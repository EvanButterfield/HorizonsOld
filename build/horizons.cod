; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG40962 DB	'-Y ', 00H
$SG40964 DB	'+X ', 00H
$SG41028 DB	'S', 080H, 0f6H, '4', 00H
$SG40479 DB	00H
	ORG $+2
$SG41067 DB	'too large', 00H
	ORG $+2
$SG41164 DB	'rb', 00H
	ORG $+1
$SG41069 DB	'too large', 00H
	ORG $+2
$SG41181 DB	'rb', 00H
	ORG $+1
$SG41072 DB	'too large', 00H
	ORG $+2
$SG41315 DB	'0', 00H, 00H, 00H
$SG41074 DB	'outofmem', 00H
	ORG $+3
$SG41592 DB	'0', 00H, 00H, 00H
$SG41127 DB	'max value > 65535', 00H
	ORG $+2
$SG41610 DB	'0', 00H, 00H, 00H
$SG41149 DB	'unknown image type', 00H
	ORG $+1
$SG41825 DB	'0', 00H, 00H, 00H
$SG41166 DB	'can''t fopen', 00H
$SG35542 DB	'rb', 00H
	ORG $+1
$SG41183 DB	'can''t fopen', 00H
	ORG $+4
$SG41248 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41249 DB	'!', 00H, '(', 00H, 'o', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'b', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'o', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '0', 00H, ')', 00H, 00H, 00H
$SG41266 DB	'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+6
$SG41265 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41277 DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '4', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, 00H, 00H
	ORG $+4
$SG41276 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41326 DB	'b', 00H, '0', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'2', 00H, '8', 00H, 00H, 00H
	ORG $+6
$SG41297 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41298 DB	'o', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+6
$SG41375 DB	'i', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'i', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H
$SG41314 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41395 DB	'typ1', 00H
	ORG $+3
$SG41325 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41396 DB	'typ1', 00H
	ORG $+3
$SG41374 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41397 DB	'typ1', 00H
	ORG $+3
$SG41376 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG41377 DB	'o', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG41398 DB	'typ1', 00H
	ORG $+3
$SG41400 DB	'OTTO', 00H
	ORG $+3
$SG41401 DB	'OTTO', 00H
	ORG $+3
$SG41402 DB	'OTTO', 00H
	ORG $+3
$SG41403 DB	'OTTO', 00H
	ORG $+3
$SG41406 DB	'true', 00H
	ORG $+3
$SG41407 DB	'true', 00H
	ORG $+3
$SG41408 DB	'true', 00H
	ORG $+3
$SG41409 DB	'true', 00H
	ORG $+3
$SG41430 DB	'ttcf', 00H
	ORG $+3
$SG41431 DB	'ttcf', 00H
	ORG $+3
$SG41432 DB	'ttcf', 00H
	ORG $+3
$SG41433 DB	'ttcf', 00H
	ORG $+3
$SG41442 DB	'ttcf', 00H
	ORG $+3
$SG41443 DB	'ttcf', 00H
	ORG $+3
$SG41444 DB	'ttcf', 00H
	ORG $+3
$SG41445 DB	'ttcf', 00H
	ORG $+3
$SG41468 DB	'SVG ', 00H
	ORG $+3
$SG41512 DB	'cmap', 00H
	ORG $+3
$SG41513 DB	'loca', 00H
	ORG $+3
$SG41514 DB	'head', 00H
	ORG $+3
$SG41515 DB	'glyf', 00H
	ORG $+3
$SG41516 DB	'hhea', 00H
	ORG $+3
$SG41517 DB	'hmtx', 00H
	ORG $+3
$SG41518 DB	'kern', 00H
	ORG $+3
$SG41519 DB	'GPOS', 00H
	ORG $+3
$SG41525 DB	'CFF ', 00H
	ORG $+3
$SG41531 DB	'maxp', 00H
	ORG $+7
$SG41637 DB	'!', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '-', 00H
	DB	'>', 00H, 'c', 00H, 'f', 00H, 'f', 00H, '.', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 00H, 00H
$SG42392 DB	'OS/2', 00H
	ORG $+3
$SG41591 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42657 DB	'x', 00H, '1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'x', 00H, '+', 00H, '1', 00H, 00H, 00H
	ORG $+4
$SG41609 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42669 DB	'x', 00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'x', 00H, '+', 00H, '1', 00H, 00H, 00H
	ORG $+4
$SG41636 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42690 DB	'b', 00H, 'o', 00H, 't', 00H, 't', 00H, 'o', 00H, 'm', 00H
	DB	'_', 00H, 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+4
$SG41824 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42788 DB	'x', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H, 00H
	ORG $+4
$SG42127 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42797 DB	'f', 00H, 'a', 00H, 'b', 00H, 's', 00H, '(', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, ')', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '1', 00H, '.', 00H, '0', 00H, '1', 00H, 'f', 00H
	DB	00H, 00H
$SG42128 DB	'o', 00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'_', 00H, 'c', 00H, 't', 00H, 'x', 00H, '.', 00H, 'n', 00H, 'u'
	DB	00H, 'm', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	'_', 00H, 'c', 00H, 't', 00H, 'x', 00H, '.', 00H, 'n', 00H, 'u'
	DB	00H, 'm', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG35579 DB	'rb', 00H
	ORG $+1
$SG42647 DB	'y', 00H, '0', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'y', 00H
	DB	'1', 00H, 00H, 00H
$SG42799 DB	's', 00H, 'y', 00H, '1', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'y', 00H, '_', 00H, 'f', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l'
	DB	00H, '-', 00H, '0', 00H, '.', 00H, '0', 00H, '1', 00H, 'f', 00H
	DB	00H, 00H
$SG42617 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42618 DB	'z', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H
	ORG $+2
$SG42661 DB	'x', 00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'x', 00H, 00H, 00H
$SG42873 DB	'z', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'n'
	DB	00H, '_', 00H, 'y', 00H, '_', 00H, 't', 00H, 'o', 00H, 'p', 00H
	DB	00H, 00H
$SG42646 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG43295 DB	'x', 00H, '+', 00H, 'g', 00H, 'w', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'p', 00H, 'w', 00H, 00H, 00H
	ORG $+4
$SG42648 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42649 DB	'e', 00H, '-', 00H, '>', 00H, 's', 00H, 'y', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'e', 00H, '-', 00H, '>', 00H, 'e'
	DB	00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG42665 DB	'x', 00H, '1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'x', 00H, 00H, 00H
$SG43297 DB	'y', 00H, '+', 00H, 'g', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'p', 00H, 'h', 00H, 00H, 00H
	ORG $+4
$SG42656 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG43426 DB	'h', 00H, '_', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '8', 00H, 00H, 00H
	ORG $+4
$SG42660 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG43428 DB	'v', 00H, '_', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '8', 00H, 00H, 00H
	ORG $+4
$SG42664 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG35406 DB	'unknown image type', 00H
	ORG $+5
$SG42668 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG35649 DB	'unknown image type', 00H
	ORG $+5
$SG42670 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42671 DB	'x', 00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'x', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '+', 00H
	DB	'1', 00H, 00H, 00H
	ORG $+6
$SG42688 DB	't', 00H, 'o', 00H, 'p', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG42791 DB	'd', 00H, 'y', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG35680 DB	'rb', 00H
	ORG $+5
$SG42676 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG35701 DB	'rb', 00H
	ORG $+5
$SG42677 DB	'x', 00H, '0', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'x', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '+', 00H
	DB	'1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, 'x', 00H, '+', 00H, '1', 00H, 00H, 00H
	ORG $+6
$SG42687 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG44115 DB	'name', 00H
	ORG $+3
$SG42689 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG44168 DB	'head', 00H
	ORG $+3
$SG42770 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42771 DB	'e', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 't', 00H, 'o'
	DB	00H, 'p', 00H, 00H, 00H
	ORG $+2
$SG42793 DB	'd', 00H, 'x', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG44170 DB	'name', 00H
	ORG $+3
$SG42777 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36175 DB	'bad code lengths', 00H
	ORG $+7
$SG42778 DB	'e', 00H, '-', 00H, '>', 00H, 's', 00H, 'y', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 'b', 00H, 'o'
	DB	00H, 't', 00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'e', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'y', 00H, '_', 00H
	DB	't', 00H, 'o', 00H, 'p', 00H, 00H, 00H
$SG36277 DB	'bad huffman code', 00H
	ORG $+7
$SG42787 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36282 DB	'bad huffman code', 00H
	ORG $+7
$SG42790 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36298 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG42792 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36304 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG42796 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36341 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG42798 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36349 DB	'bad huffman code', 00H
	ORG $+7
$SG42866 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG42867 DB	'z', 00H, '-', 00H, '>', 00H, 'd', 00H, 'i', 00H, 'r', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H
	DB	00H
	ORG $+6
$SG43484 DB	'p', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H
	DB	'[', 00H, 'i', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG36362 DB	'bad huffman code', 00H
	ORG $+7
$SG42872 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG36369 DB	'bad huffman code', 00H
	ORG $+7
$SG43294 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG37655 DB	'bad SOS component count', 00H
$SG43296 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG37668 DB	'bad SOS', 00H
$SG43425 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG37670 DB	'bad SOS', 00H
$SG43427 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG37673 DB	'bad SOS', 00H
$SG43483 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG37725 DB	'no header height', 00H
	ORG $+7
$SG43533 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG43534 DB	'p', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H
	DB	'[', 00H, 'i', 00H, '*', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, '_', 00H, 'i', 00H, 'n', 00H, '_', 00H
	DB	'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ']', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+2
$SG35424 DB	'outofmem', 00H
	ORG $+3
$SG37739 DB	'bad H', 00H
	ORG $+2
$SG37744 DB	'bad TQ', 00H
	ORG $+1
$SG46157 DB	'uri', 00H
$SG35443 DB	'outofmem', 00H
	ORG $+3
$SG37742 DB	'bad V', 00H
	ORG $+2
$SG37769 DB	'no SOI', 00H
	ORG $+1
$SG46158 DB	'/', 00H
	ORG $+2
$SG35544 DB	'can''t fopen', 00H
$SG46159 DB	'/', 00H
	ORG $+2
$SG35581 DB	'can''t fopen', 00H
$SG40904 DB	'-Y ', 00H
$SG35682 DB	'can''t fopen', 00H
$SG37751 DB	'bad H', 00H
	ORG $+6
$SG44013 DB	'W', 00H, ':', 00H, '\', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	'-', 00H, 'h', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, '\', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG44014 DB	'i', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H
	ORG $+2
$SG35866 DB	'outofmem', 00H
	ORG $+3
$SG37753 DB	'bad V', 00H
	ORG $+2
$SG37773 DB	'no SOF', 00H
	ORG $+1
$SG40907 DB	'+X ', 00H
$SG35881 DB	'unsupported', 00H
	ORG $+4
$SG35955 DB	'outofmem', 00H
	ORG $+7
$SG35970 DB	'unsupported', 00H
	ORG $+4
$SG35997 DB	'outofmem', 00H
	ORG $+7
$SG36029 DB	'outofmem', 00H
	ORG $+7
$SG37603 DB	'expected marker', 00H
$SG37727 DB	'0 width', 00H
?stbi__bmask@@3QBIB DD 00H				; stbi__bmask
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
$SG46151 DB	'count', 00H
	ORG $+6
?stbi__jbias@@3QBHB DD 00H				; stbi__jbias
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
?stbi__jpeg_dezigzag@@3QBEB DB 00H			; stbi__jpeg_dezigzag
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
$SG37606 DB	'bad DRI len', 00H
	ORG $+4
$SG37609 DB	'bad DQT type', 00H
	ORG $+3
$SG37611 DB	'bad DQT table', 00H
	ORG $+2
$SG37615 DB	'bad DHT header', 00H
	ORG $+1
$SG37627 DB	'bad COM len', 00H
	ORG $+4
$SG37628 DB	'bad APP len', 00H
	ORG $+4
$SG37636 DB	'unknown marker', 00H
	ORG $+1
$SG37657 DB	'bad SOS len', 00H
	ORG $+4
$SG37661 DB	'bad DC huff', 00H
	ORG $+4
$SG37663 DB	'bad AC huff', 00H
	ORG $+4
$SG37721 DB	'bad SOF len', 00H
	ORG $+4
$SG37723 DB	'only 8-bit', 00H
	ORG $+5
$SG37729 DB	'too large', 00H
	ORG $+6
$SG37731 DB	'too large', 00H
	ORG $+6
$SG37733 DB	'bad component count', 00H
	ORG $+4
$SG37735 DB	'bad SOF len', 00H
	ORG $+4
$SG37747 DB	'too large', 00H
	ORG $+6
$SG37755 DB	'outofmem', 00H
	ORG $+7
$SG37758 DB	'outofmem', 00H
	ORG $+7
$SG37799 DB	'bad DNL len', 00H
	ORG $+4
$SG37801 DB	'bad DNL height', 00H
	ORG $+1
$SG46149 DB	'bufferView', 00H
	ORG $+5
$SG46153 DB	'byteOffset', 00H
	ORG $+1
$SG46156 DB	'buffer', 00H
	ORG $+1
$SG46315 DB	'nodes', 00H
	ORG $+2
$SG46316 DB	'meshes', 00H
	ORG $+5
$SG46317 DB	'accessors', 00H
	ORG $+6
$SG46318 DB	'bufferViews', 00H
	ORG $+4
$SG46319 DB	'buffers', 00H
$SG46320 DB	'materials', 00H
	ORG $+2
$SG46322 DB	'mesh', 00H
	ORG $+3
$SG46323 DB	'scale', 00H
	ORG $+6
$SG46325 DB	'primitives', 00H
	ORG $+5
$SG46326 DB	'attributes', 00H
	ORG $+5
$SG46327 DB	'POSITION', 00H
	ORG $+7
$SG46328 DB	'indices', 00H
$SG46332 DB	'material', 00H
	ORG $+7
$SG46333 DB	'pbrMetallicRoughness', 00H
	ORG $+3
$SG46334 DB	'baseColorFactor', 00H
$SG46339 DB	'NORMAL', 00H
	ORG $+1
$SG46340 DB	'TEXCOORD_0', 00H
	ORG $+5
$SG46341 DB	'COLOR_0', 00H
$SG38306 DB	'bad req_comp', 00H
	ORG $+3
$SG38312 DB	'outofmem', 00H
	ORG $+7
$SG38322 DB	'outofmem', 00H
	ORG $+7
$SG38364 DB	'outofmem', 00H
	ORG $+7
$SG38373 DB	'outofmem', 00H
	ORG $+7
$SG38395 DB	'outofmem', 00H
	ORG $+7
$SG46646 DB	'.', 00H, '.', 00H, '/', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	'e', 00H, 't', 00H, 's', 00H, '/', 00H, 'R', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, 'y', 00H, 'G', 00H, 'G', 00H, '.', 00H, 't', 00H
	DB	't', 00H, 'f', 00H, 00H, 00H
	ORG $+4
$SG46647 DB	'.', 00H, '.', 00H, '/', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	'e', 00H, 't', 00H, 's', 00H, '/', 00H, 's', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 'd', 00H, '.', 00H, 'w', 00H, 'a', 00H, 'v', 00H
	DB	00H, 00H
$SG46648 DB	'../assets/test.png', 00H
	ORG $+5
$SG46649 DB	'../assets/models/scene.gltf', 00H
	ORG $+4
$SG38457 DB	'bad sizes', 00H
	ORG $+6
$SG46650 DB	'../assets/models/primitives/sphere.gltf', 00H
$SG46651 DB	'../assets/models/primitives/bean.gltf', 00H
	ORG $+2
$SG46652 DB	'.', 00H, '.', 00H, '/', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '/', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, 's', 00H, '.', 00H, 'h', 00H, 'l', 00H, 's', 00H
	DB	'l', 00H, 00H, 00H
	ORG $+6
$SG38460 DB	'bad codelengths', 00H
$SG46653 DB	'.', 00H, '.', 00H, '/', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, '/', 00H, 'u', 00H, 'i', 00H, '_', 00H, 's', 00H, 'h'
	DB	00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's', 00H, '.', 00H
	DB	'h', 00H, 'l', 00H, 's', 00H, 'l', 00H, 00H, 00H
$SG46662 DB	'HELLO, WORLD!', 00H
	ORG $+2
$SG46663 DB	'EDIT TEXT', 00H
	ORG $+6
$SG46666 DB	'HELLO, WORLD!', 00H
	ORG $+2
$SG46667 DB	'EDIT TEXT', 00H
	ORG $+6
$SG38545 DB	'output buffer limit', 00H
	ORG $+4
$SG38547 DB	'outofmem', 00H
	ORG $+7
$SG38549 DB	'outofmem', 00H
	ORG $+7
$SG38551 DB	'outofmem', 00H
	ORG $+7
?stbi__zlength_base@@3QBHB DD 03H			; stbi__zlength_base
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zlength_extra@@3QBHB DD 00H			; stbi__zlength_extra
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zdist_base@@3QBHB DD 01H				; stbi__zdist_base
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
?stbi__zdist_extra@@3QBHB DD 00H			; stbi__zdist_extra
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
$SG38579 DB	'bad huffman code', 00H
	ORG $+7
$SG38585 DB	'bad huffman code', 00H
	ORG $+7
$SG38588 DB	'bad dist', 00H
	ORG $+7
$SG38622 DB	'bad codelengths', 00H
$SG38628 DB	'bad codelengths', 00H
$SG38633 DB	'bad codelengths', 00H
$SG38635 DB	'bad codelengths', 00H
$SG38637 DB	'bad codelengths', 00H
$SG38654 DB	'zlib corrupt', 00H
	ORG $+3
$SG38656 DB	'zlib corrupt', 00H
	ORG $+3
$SG38658 DB	'read past buffer', 00H
	ORG $+7
$SG38668 DB	'bad zlib header', 00H
$SG38670 DB	'bad zlib header', 00H
$SG38672 DB	'no preset dict', 00H
	ORG $+1
$SG38674 DB	'bad compression', 00H
$SG39004 DB	'not enough pixels', 00H
	ORG $+6
?stbi__zdefault_length@@3QBEB DB 08H			; stbi__zdefault_length
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
?stbi__zdefault_distance@@3QBEB DB 05H			; stbi__zdefault_distance
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
$SG38811 DB	'bad png sig', 00H
	ORG $+4
?stbi__depth_scale_table@@3QBEB DB 00H			; stbi__depth_scale_table
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	ORG $+7
$SG39000 DB	'outofmem', 00H
	ORG $+7
$SG39002 DB	'too large', 00H
	ORG $+6
$SG39006 DB	'invalid filter', 00H
	ORG $+1
$SG39009 DB	'invalid width', 00H
	ORG $+2
$SG39102 DB	'outofmem', 00H
	ORG $+7
$SG39168 DB	'outofmem', 00H
	ORG $+7
$SG39310 DB	'multiple IHDR', 00H
	ORG $+2
$SG39312 DB	'bad IHDR len', 00H
	ORG $+3
$SG39314 DB	'too large', 00H
	ORG $+6
$SG39316 DB	'too large', 00H
	ORG $+6
$SG39318 DB	'1/2/4/8/16-bit only', 00H
	ORG $+4
$SG39320 DB	'bad ctype', 00H
	ORG $+6
$SG39322 DB	'bad ctype', 00H
	ORG $+6
$SG39326 DB	'bad ctype', 00H
	ORG $+6
$SG39328 DB	'bad comp method', 00H
$SG39330 DB	'bad filter method', 00H
	ORG $+6
$SG39332 DB	'bad interlace method', 00H
	ORG $+3
$SG39335 DB	'0-pixel image', 00H
	ORG $+2
$SG39339 DB	'too large', 00H
	ORG $+6
$SG39342 DB	'too large', 00H
	ORG $+6
$SG39345 DB	'first not IHDR', 00H
	ORG $+1
$SG39347 DB	'invalid PLTE', 00H
	ORG $+3
$SG39349 DB	'invalid PLTE', 00H
	ORG $+3
$SG39352 DB	'first not IHDR', 00H
	ORG $+1
$SG39354 DB	'tRNS after IDAT', 00H
$SG39359 DB	'tRNS before PLTE', 00H
	ORG $+7
$SG39361 DB	'bad tRNS len', 00H
	ORG $+3
$SG39363 DB	'tRNS with alpha', 00H
$SG39365 DB	'bad tRNS len', 00H
	ORG $+3
$SG39370 DB	'first not IHDR', 00H
	ORG $+1
$SG39372 DB	'no PLTE', 00H
$SG39378 DB	'outofmem', 00H
	ORG $+7
$SG39380 DB	'outofdata', 00H
	ORG $+6
$SG39383 DB	'first not IHDR', 00H
	ORG $+1
$SG39386 DB	'no IDAT', 00H
$SG39406 DB	'first not IHDR', 00H
	ORG $+1
$SG39425 DB	'bad req_comp', 00H
	ORG $+3
$SG39431 DB	'bad bits_per_channel', 00H
	ORG $+3
$SG39579 DB	'not BMP', 00H
$SG39581 DB	'bad BMP', 00H
$SG39583 DB	'unknown BMP', 00H
	ORG $+4
$SG39587 DB	'bad BMP', 00H
$SG39591 DB	'BMP RLE', 00H
$SG39593 DB	'BMP JPEG/PNG', 00H
	ORG $+3
$SG39595 DB	'bad BMP', 00H
$SG39607 DB	'bad BMP', 00H
$SG39608 DB	'bad BMP', 00H
$SG39610 DB	'bad BMP', 00H
$SG39732 DB	'too large', 00H
	ORG $+6
$SG39734 DB	'too large', 00H
	ORG $+6
$SG39741 DB	'bad offset', 00H
	ORG $+5
$SG39747 DB	'too large', 00H
	ORG $+6
$SG39749 DB	'outofmem', 00H
	ORG $+7
$SG39754 DB	'invalid', 00H
$SG39762 DB	'bad bpp', 00H
$SG39783 DB	'bad masks', 00H
	ORG $+6
$SG39786 DB	'bad masks', 00H
	ORG $+6
$SG39972 DB	'too large', 00H
	ORG $+6
$SG39974 DB	'too large', 00H
	ORG $+6
$SG39979 DB	'bad format', 00H
	ORG $+5
$SG39982 DB	'too large', 00H
	ORG $+6
$SG39984 DB	'outofmem', 00H
	ORG $+7
$SG39989 DB	'bad palette', 00H
	ORG $+4
$SG39991 DB	'outofmem', 00H
	ORG $+7
$SG39996 DB	'bad palette', 00H
	ORG $+4
$SG40141 DB	'not PSD', 00H
$SG40143 DB	'wrong version', 00H
	ORG $+2
$SG40146 DB	'wrong channel count', 00H
	ORG $+4
$SG40148 DB	'too large', 00H
	ORG $+6
$SG40150 DB	'too large', 00H
	ORG $+6
$SG40152 DB	'unsupported bit depth', 00H
	ORG $+2
$SG40154 DB	'wrong color format', 00H
	ORG $+5
$SG40156 DB	'bad compression', 00H
$SG40158 DB	'too large', 00H
	ORG $+6
$SG40162 DB	'outofmem', 00H
	ORG $+7
$SG40168 DB	'corrupt', 00H
$SG40205 DB	'S', 080H, 0f6H, '4', 00H
	ORG $+3
$SG40207 DB	'PICT', 00H
	ORG $+3
$SG40237 DB	'bad file', 00H
	ORG $+7
$SG40319 DB	'bad format', 00H
	ORG $+5
$SG40321 DB	'bad file', 00H
	ORG $+7
$SG40323 DB	'bad format', 00H
	ORG $+5
$SG40325 DB	'bad format', 00H
	ORG $+5
$SG40330 DB	'bad file', 00H
	ORG $+7
$SG40335 DB	'bad file', 00H
	ORG $+7
$SG40341 DB	'bad file', 00H
	ORG $+7
$SG40344 DB	'bad file', 00H
	ORG $+7
$SG40376 DB	'too large', 00H
	ORG $+6
$SG40378 DB	'too large', 00H
	ORG $+6
$SG40380 DB	'bad file', 00H
	ORG $+7
$SG40382 DB	'too large', 00H
	ORG $+6
$SG40384 DB	'outofmem', 00H
	ORG $+7
$SG40474 DB	'not GIF', 00H
$SG40476 DB	'not GIF', 00H
$SG40478 DB	'not GIF', 00H
$SG40481 DB	'too large', 00H
	ORG $+6
$SG40483 DB	'too large', 00H
	ORG $+6
$SG40497 DB	'outofmem', 00H
	ORG $+7
$SG40564 DB	'no clear code', 00H
	ORG $+2
$SG40568 DB	'too many codes', 00H
	ORG $+1
$SG40570 DB	'illegal code in raster', 00H
	ORG $+1
$SG40572 DB	'illegal code in raster', 00H
	ORG $+1
$SG40629 DB	'too large', 00H
	ORG $+6
$SG40632 DB	'outofmem', 00H
	ORG $+7
$SG40643 DB	'bad Image Descriptor', 00H
	ORG $+3
$SG40651 DB	'missing color table', 00H
	ORG $+4
$SG40665 DB	'unknown code', 00H
	ORG $+3
$SG40675 DB	'outofmem', 00H
	ORG $+7
$SG40729 DB	'not GIF', 00H
$SG40766 DB	'#?RADIANCE', 0aH, 00H
	ORG $+4
$SG40768 DB	'#?RGBE', 0aH, 00H
$SG40895 DB	'#?RADIANCE', 00H
	ORG $+1
$SG40896 DB	'#?RGBE', 00H
	ORG $+5
$SG40897 DB	'not HDR', 00H
$SG40900 DB	'FORMAT=32-bit_rle_rgbe', 00H
	ORG $+1
$SG40902 DB	'unsupported format', 00H
	ORG $+5
$SG40905 DB	'unsupported data layout', 00H
$SG40908 DB	'unsupported data layout', 00H
$SG40910 DB	'too large', 00H
	ORG $+6
$SG40912 DB	'too large', 00H
	ORG $+6
$SG40916 DB	'too large', 00H
	ORG $+6
$SG40918 DB	'outofmem', 00H
	ORG $+7
$SG40925 DB	'invalid decoded scanline length', 00H
$SG40928 DB	'outofmem', 00H
	ORG $+7
$SG40932 DB	'corrupt', 00H
$SG40934 DB	'corrupt', 00H
$SG40959 DB	'FORMAT=32-bit_rle_rgbe', 00H
CONST	ENDS
PUBLIC	GameUpdateAndRenderStub
PUBLIC	stbtt_BakeFontBitmap
PUBLIC	stbtt_GetBakedQuad
PUBLIC	stbtt_GetScaledFontVMetrics
PUBLIC	stbtt_PackBegin
PUBLIC	stbtt_PackEnd
PUBLIC	stbtt_PackFontRange
PUBLIC	stbtt_PackFontRanges
PUBLIC	stbtt_PackSetOversampling
PUBLIC	stbtt_PackSetSkipMissingCodepoints
PUBLIC	stbtt_GetPackedQuad
PUBLIC	stbtt_PackFontRangesGatherRects
PUBLIC	stbtt_PackFontRangesPackRects
PUBLIC	stbtt_PackFontRangesRenderIntoRects
PUBLIC	stbtt_GetNumberOfFonts
PUBLIC	stbtt_GetFontOffsetForIndex
PUBLIC	stbtt_InitFont
PUBLIC	stbtt_FindGlyphIndex
PUBLIC	stbtt_ScaleForPixelHeight
PUBLIC	stbtt_ScaleForMappingEmToPixels
PUBLIC	stbtt_GetFontVMetrics
PUBLIC	stbtt_GetFontVMetricsOS2
PUBLIC	stbtt_GetFontBoundingBox
PUBLIC	stbtt_GetCodepointHMetrics
PUBLIC	stbtt_GetCodepointKernAdvance
PUBLIC	stbtt_GetCodepointBox
PUBLIC	stbtt_GetGlyphHMetrics
PUBLIC	stbtt_GetGlyphKernAdvance
PUBLIC	stbtt_GetGlyphBox
PUBLIC	stbtt_GetKerningTableLength
PUBLIC	stbtt_GetKerningTable
PUBLIC	stbtt_IsGlyphEmpty
PUBLIC	stbtt_GetCodepointShape
PUBLIC	stbtt_GetGlyphShape
PUBLIC	stbtt_FreeShape
PUBLIC	stbtt_FindSVGDoc
PUBLIC	stbtt_GetCodepointSVG
PUBLIC	stbtt_GetGlyphSVG
PUBLIC	stbtt_FreeBitmap
PUBLIC	stbtt_GetCodepointBitmap
PUBLIC	stbtt_GetCodepointBitmapSubpixel
PUBLIC	stbtt_MakeCodepointBitmap
PUBLIC	stbtt_MakeCodepointBitmapSubpixel
PUBLIC	stbtt_MakeCodepointBitmapSubpixelPrefilter
PUBLIC	stbtt_GetCodepointBitmapBox
PUBLIC	stbtt_GetCodepointBitmapBoxSubpixel
PUBLIC	stbtt_GetGlyphBitmap
PUBLIC	stbtt_GetGlyphBitmapSubpixel
PUBLIC	stbtt_MakeGlyphBitmap
PUBLIC	stbtt_MakeGlyphBitmapSubpixel
PUBLIC	stbtt_MakeGlyphBitmapSubpixelPrefilter
PUBLIC	stbtt_GetGlyphBitmapBox
PUBLIC	stbtt_GetGlyphBitmapBoxSubpixel
PUBLIC	stbtt_Rasterize
PUBLIC	stbtt_FreeSDF
PUBLIC	stbtt_GetGlyphSDF
PUBLIC	stbtt_GetCodepointSDF
PUBLIC	stbtt_FindMatchingFont
PUBLIC	stbtt_CompareUTF8toUTF16_bigendian
PUBLIC	stbtt_GetFontNameString
PUBLIC	stbi_load_from_memory
PUBLIC	stbi_load_from_callbacks
PUBLIC	stbi_load
PUBLIC	stbi_load_from_file
PUBLIC	stbi_load_gif_from_memory
PUBLIC	stbi_load_16_from_memory
PUBLIC	stbi_load_16_from_callbacks
PUBLIC	stbi_load_16
PUBLIC	stbi_load_from_file_16
PUBLIC	stbi_loadf_from_memory
PUBLIC	stbi_loadf_from_callbacks
PUBLIC	stbi_loadf
PUBLIC	stbi_loadf_from_file
PUBLIC	stbi_hdr_to_ldr_gamma
PUBLIC	stbi_hdr_to_ldr_scale
PUBLIC	stbi_ldr_to_hdr_gamma
PUBLIC	stbi_ldr_to_hdr_scale
PUBLIC	stbi_is_hdr_from_callbacks
PUBLIC	stbi_is_hdr_from_memory
PUBLIC	stbi_is_hdr
PUBLIC	stbi_is_hdr_from_file
PUBLIC	stbi_failure_reason
PUBLIC	stbi_image_free
PUBLIC	stbi_info_from_memory
PUBLIC	stbi_info_from_callbacks
PUBLIC	stbi_is_16_bit_from_memory
PUBLIC	stbi_is_16_bit_from_callbacks
PUBLIC	stbi_info
PUBLIC	stbi_info_from_file
PUBLIC	stbi_is_16_bit
PUBLIC	stbi_is_16_bit_from_file
PUBLIC	stbi_set_unpremultiply_on_load
PUBLIC	stbi_convert_iphone_png_to_rgb
PUBLIC	stbi_set_flip_vertically_on_load
PUBLIC	stbi_convert_iphone_png_to_rgb_thread
PUBLIC	stbi_set_flip_vertically_on_load_thread
PUBLIC	stbi_zlib_decode_malloc_guesssize
PUBLIC	stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	stbi_zlib_decode_malloc
PUBLIC	stbi_zlib_decode_buffer
PUBLIC	stbi_zlib_decode_noheader_malloc
PUBLIC	stbi_zlib_decode_noheader_buffer
PUBLIC	?stbi__unpremultiply_on_load_thread@@YAXH@Z	; stbi__unpremultiply_on_load_thread
PUBLIC	?RunPlayer@@YAXPEAUentity@@M@Z			; RunPlayer
PUBLIC	?OnCollidePlayer@@YAXPEAUentity@@0@Z		; OnCollidePlayer
PUBLIC	json_parse
PUBLIC	json_parse_ex
PUBLIC	json_value_as_string
PUBLIC	json_value_as_number
PUBLIC	json_value_as_object
PUBLIC	json_value_as_array
PUBLIC	?json_hexadecimal_digit@@YAHD@Z			; json_hexadecimal_digit
PUBLIC	?json_hexadecimal_value@@YAHPEBDKPEAK@Z		; json_hexadecimal_value
PUBLIC	?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_whitespace
PUBLIC	?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_c_style_comments
PUBLIC	?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
PUBLIC	?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_value_size
PUBLIC	?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ; json_get_string_size
PUBLIC	?is_valid_unquoted_key_char@@YAHD@Z		; is_valid_unquoted_key_char
PUBLIC	?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_key_size
PUBLIC	?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_object_size
PUBLIC	?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_array_size
PUBLIC	?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_number_size
PUBLIC	?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z ; json_parse_value
PUBLIC	?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ; json_parse_string
PUBLIC	?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ; json_parse_key
PUBLIC	?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z ; json_parse_object
PUBLIC	?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z ; json_parse_array
PUBLIC	?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z ; json_parse_number
PUBLIC	?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z ; GameUpdateAndRender
PUBLIC	??_C@_08KEBCLIFP@Infinity@			; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN@				; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@34000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3eb33333
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3fd5555560000000
PUBLIC	__real@3fddb3d7
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff028f5c0000000
PUBLIC	__real@3ff921fafc8b007a
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41d80000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@42700000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@46800000
PUBLIC	__real@477fff00
PUBLIC	__real@47800000
PUBLIC	__real@497423f0
PUBLIC	__real@be4ccccd
PUBLIC	__real@be99999a
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c1d80000
PUBLIC	__xmm@00000200000002000000020000000200
PUBLIC	__xmm@00080008000800080008000800080008
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@01010000010100000101000001010000
PUBLIC	__xmm@08a914e808a914e808a914e808a914e8
PUBLIC	__xmm@11c8e09e11c8e09e11c8e09e11c8e09e
PUBLIC	__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
PUBLIC	__xmm@12d0046b12d0046b12d0046b12d0046b
PUBLIC	__xmm@166f166f166f166f166f166f166f166f
PUBLIC	__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
PUBLIC	__xmm@80808080808080808080808080808080
PUBLIC	__xmm@e09ee565e09ee565e09ee565e09ee565
PUBLIC	__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
PUBLIC	__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
PUBLIC	__xmm@f493f493f493f493f493f493f493f493
PUBLIC	__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
PUBLIC	__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
EXTRN	ldexp:PROC
EXTRN	fopen_s:PROC
EXTRN	fclose:PROC
EXTRN	feof:PROC
EXTRN	ferror:PROC
EXTRN	fgetc:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	ungetc:PROC
EXTRN	strtod:PROC
EXTRN	strtol:PROC
EXTRN	strncmp:PROC
EXTRN	_wassert:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	acos:PROC
EXTRN	ceil:PROC
EXTRN	cos:PROC
EXTRN	cosf:PROC
EXTRN	floor:PROC
EXTRN	fmod:PROC
EXTRN	pow:PROC
EXTRN	sinf:PROC
EXTRN	sqrt:PROC
EXTRN	sqrtf:PROC
EXTRN	tanf:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
_BSS	SEGMENT
?State@@3PEAUgame_state@@EA DQ 01H DUP (?)		; State
?TranState@@3PEAUtransient_state@@EA DQ 01H DUP (?)	; TranState
?Input@@3PEAUgame_input@@EA DQ 01H DUP (?)		; Input
?Platform@@3PEAUplatform_api@@EA DQ 01H DUP (?)		; Platform
?ShouldClose@@3HA DD 01H DUP (?)			; ShouldClose
_BSS	ENDS
_TLS	SEGMENT
?stbi__g_failure_reason@@3PEBDEB DQ 01H DUP (?)		; stbi__g_failure_reason
_TLS	ENDS
_BSS	SEGMENT
?stbi__vertically_flip_on_load_global@@3HA DD 01H DUP (?) ; stbi__vertically_flip_on_load_global
_BSS	ENDS
_TLS	SEGMENT
?stbi__vertically_flip_on_load_local@@3HA DD 01H DUP (?) ; stbi__vertically_flip_on_load_local
?stbi__vertically_flip_on_load_set@@3HA DD 01H DUP (?)	; stbi__vertically_flip_on_load_set
_TLS	ENDS
_BSS	SEGMENT
?stbi__unpremultiply_on_load_global@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_global
?stbi__de_iphone_flag_global@@3HA DD 01H DUP (?)	; stbi__de_iphone_flag_global
_BSS	ENDS
_TLS	SEGMENT
?stbi__unpremultiply_on_load_local@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_local
?stbi__unpremultiply_on_load_set@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_set
?stbi__de_iphone_flag_local@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag_local
?stbi__de_iphone_flag_set@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag_set
_TLS	ENDS
_BSS	SEGMENT
?YVelocity@@3MA DD 01H DUP (?)				; YVelocity
?XRotation@@3MA DD 01H DUP (?)				; XRotation
?YRotation@@3MA DD 01H DUP (?)				; YRotation
_BSS	ENDS
pdata	SEGMENT
$pdata$PushSize DD imagerel PushSize
	DD	imagerel PushSize+100
	DD	imagerel $unwind$PushSize
$pdata$?Sin@@YAMM@Z DD imagerel ?Sin@@YAMM@Z
	DD	imagerel ?Sin@@YAMM@Z+26
	DD	imagerel $unwind$?Sin@@YAMM@Z
$pdata$?Cos@@YAMM@Z DD imagerel ?Cos@@YAMM@Z
	DD	imagerel ?Cos@@YAMM@Z+26
	DD	imagerel $unwind$?Cos@@YAMM@Z
$pdata$?Tan@@YAMM@Z DD imagerel ?Tan@@YAMM@Z
	DD	imagerel ?Tan@@YAMM@Z+26
	DD	imagerel $unwind$?Tan@@YAMM@Z
$pdata$?Sqrt@@YAMM@Z DD imagerel ?Sqrt@@YAMM@Z
	DD	imagerel ?Sqrt@@YAMM@Z+26
	DD	imagerel $unwind$?Sqrt@@YAMM@Z
$pdata$?V2@@YA?ATv2@@MM@Z DD imagerel ?V2@@YA?ATv2@@MM@Z
	DD	imagerel ?V2@@YA?ATv2@@MM@Z+76
	DD	imagerel $unwind$?V2@@YA?ATv2@@MM@Z
$pdata$?V2@@YA?ATv2@@HH@Z DD imagerel ?V2@@YA?ATv2@@HH@Z
	DD	imagerel ?V2@@YA?ATv2@@HH@Z+72
	DD	imagerel $unwind$?V2@@YA?ATv2@@HH@Z
$pdata$??H@YA?ATv2@@T0@0@Z DD imagerel ??H@YA?ATv2@@T0@0@Z
	DD	imagerel ??H@YA?ATv2@@T0@0@Z+86
	DD	imagerel $unwind$??H@YA?ATv2@@T0@0@Z
$pdata$??D@YA?ATv2@@T0@0@Z DD imagerel ??D@YA?ATv2@@T0@0@Z
	DD	imagerel ??D@YA?ATv2@@T0@0@Z+86
	DD	imagerel $unwind$??D@YA?ATv2@@T0@0@Z
$pdata$??D@YA?ATv2@@T0@M@Z DD imagerel ??D@YA?ATv2@@T0@M@Z
	DD	imagerel ??D@YA?ATv2@@T0@M@Z+87
	DD	imagerel $unwind$??D@YA?ATv2@@T0@M@Z
$pdata$??X@YAAEATv2@@AEAT0@M@Z DD imagerel ??X@YAAEATv2@@AEAT0@M@Z
	DD	imagerel ??X@YAAEATv2@@AEAT0@M@Z+90
	DD	imagerel $unwind$??X@YAAEATv2@@AEAT0@M@Z
$pdata$??K@YA?ATv2@@T0@M@Z DD imagerel ??K@YA?ATv2@@T0@M@Z
	DD	imagerel ??K@YA?ATv2@@T0@M@Z+87
	DD	imagerel $unwind$??K@YA?ATv2@@T0@M@Z
$pdata$?V2MultiplyDot@@YAMTv2@@0@Z DD imagerel ?V2MultiplyDot@@YAMTv2@@0@Z
	DD	imagerel ?V2MultiplyDot@@YAMTv2@@0@Z+57
	DD	imagerel $unwind$?V2MultiplyDot@@YAMTv2@@0@Z
$pdata$?V2Length@@YAMTv2@@@Z DD imagerel ?V2Length@@YAMTv2@@@Z
	DD	imagerel ?V2Length@@YAMTv2@@@Z+75
	DD	imagerel $unwind$?V2Length@@YAMTv2@@@Z
$pdata$?V2Normalize@@YA?ATv2@@T1@@Z DD imagerel ?V2Normalize@@YA?ATv2@@T1@@Z
	DD	imagerel ?V2Normalize@@YA?ATv2@@T1@@Z+140
	DD	imagerel $unwind$?V2Normalize@@YA?ATv2@@T1@@Z
$pdata$?V3Cross@@YA?ATv3@@T1@0@Z DD imagerel ?V3Cross@@YA?ATv3@@T1@0@Z
	DD	imagerel ?V3Cross@@YA?ATv3@@T1@0@Z+225
	DD	imagerel $unwind$?V3Cross@@YA?ATv3@@T1@0@Z
$pdata$?V3@@YA?ATv3@@MMM@Z DD imagerel ?V3@@YA?ATv3@@MMM@Z
	DD	imagerel ?V3@@YA?ATv3@@MMM@Z+123
	DD	imagerel $unwind$?V3@@YA?ATv3@@MMM@Z
$pdata$?V3@@YA?ATv3@@Tv2@@M@Z DD imagerel ?V3@@YA?ATv3@@Tv2@@M@Z
	DD	imagerel ?V3@@YA?ATv3@@Tv2@@M@Z+116
	DD	imagerel $unwind$?V3@@YA?ATv3@@Tv2@@M@Z
$pdata$?V3@@YA?ATv3@@Tv4@@@Z DD imagerel ?V3@@YA?ATv3@@Tv4@@@Z
	DD	imagerel ?V3@@YA?ATv3@@Tv4@@@Z+121
	DD	imagerel $unwind$?V3@@YA?ATv3@@Tv4@@@Z
$pdata$??H@YA?ATv3@@T0@0@Z DD imagerel ??H@YA?ATv3@@T0@0@Z
	DD	imagerel ??H@YA?ATv3@@T0@0@Z+155
	DD	imagerel $unwind$??H@YA?ATv3@@T0@0@Z
$pdata$??Y@YAAEATv3@@AEAT0@T0@@Z DD imagerel ??Y@YAAEATv3@@AEAT0@T0@@Z
	DD	imagerel ??Y@YAAEATv3@@AEAT0@T0@@Z+166
	DD	imagerel $unwind$??Y@YAAEATv3@@AEAT0@T0@@Z
$pdata$??G@YA?ATv3@@T0@0@Z DD imagerel ??G@YA?ATv3@@T0@0@Z
	DD	imagerel ??G@YA?ATv3@@T0@0@Z+155
	DD	imagerel $unwind$??G@YA?ATv3@@T0@0@Z
$pdata$??D@YA?ATv3@@T0@0@Z DD imagerel ??D@YA?ATv3@@T0@0@Z
	DD	imagerel ??D@YA?ATv3@@T0@0@Z+155
	DD	imagerel $unwind$??D@YA?ATv3@@T0@0@Z
$pdata$??X@YAAEATv3@@AEAT0@T0@@Z DD imagerel ??X@YAAEATv3@@AEAT0@T0@@Z
	DD	imagerel ??X@YAAEATv3@@AEAT0@T0@@Z+166
	DD	imagerel $unwind$??X@YAAEATv3@@AEAT0@T0@@Z
$pdata$??D@YA?ATv3@@T0@M@Z DD imagerel ??D@YA?ATv3@@T0@M@Z
	DD	imagerel ??D@YA?ATv3@@T0@M@Z+145
	DD	imagerel $unwind$??D@YA?ATv3@@T0@M@Z
$pdata$?V3MultiplyDot@@YAMTv3@@0@Z DD imagerel ?V3MultiplyDot@@YAMTv3@@0@Z
	DD	imagerel ?V3MultiplyDot@@YAMTv3@@0@Z+95
	DD	imagerel $unwind$?V3MultiplyDot@@YAMTv3@@0@Z
$pdata$?V3Length@@YAMTv3@@@Z DD imagerel ?V3Length@@YAMTv3@@@Z
	DD	imagerel ?V3Length@@YAMTv3@@@Z+78
	DD	imagerel $unwind$?V3Length@@YAMTv3@@@Z
$pdata$?V3Normalize@@YA?ATv3@@T1@@Z DD imagerel ?V3Normalize@@YA?ATv3@@T1@@Z
	DD	imagerel ?V3Normalize@@YA?ATv3@@T1@@Z+233
	DD	imagerel $unwind$?V3Normalize@@YA?ATv3@@T1@@Z
$pdata$?V3EulerToRotation@@YA?ATv3@@T1@@Z DD imagerel ?V3EulerToRotation@@YA?ATv3@@T1@@Z
	DD	imagerel ?V3EulerToRotation@@YA?ATv3@@T1@@Z+356
	DD	imagerel $unwind$?V3EulerToRotation@@YA?ATv3@@T1@@Z
$pdata$?V4@@YA?ATv4@@MMMM@Z DD imagerel ?V4@@YA?ATv4@@MMMM@Z
	DD	imagerel ?V4@@YA?ATv4@@MMMM@Z+135
	DD	imagerel $unwind$?V4@@YA?ATv4@@MMMM@Z
$pdata$?V4@@YA?ATv4@@Tv3@@M@Z DD imagerel ?V4@@YA?ATv4@@Tv3@@M@Z
	DD	imagerel ?V4@@YA?ATv4@@Tv3@@M@Z+139
	DD	imagerel $unwind$?V4@@YA?ATv4@@Tv3@@M@Z
$pdata$??H@YA?ATv4@@T0@0@Z DD imagerel ??H@YA?ATv4@@T0@0@Z
	DD	imagerel ??H@YA?ATv4@@T0@0@Z+181
	DD	imagerel $unwind$??H@YA?ATv4@@T0@0@Z
$pdata$??D@YA?ATv4@@T0@0@Z DD imagerel ??D@YA?ATv4@@T0@0@Z
	DD	imagerel ??D@YA?ATv4@@T0@0@Z+181
	DD	imagerel $unwind$??D@YA?ATv4@@T0@0@Z
$pdata$??D@YA?ATv4@@T0@M@Z DD imagerel ??D@YA?ATv4@@T0@M@Z
	DD	imagerel ??D@YA?ATv4@@T0@M@Z+167
	DD	imagerel $unwind$??D@YA?ATv4@@T0@M@Z
$pdata$??X@YAAEATv4@@AEAT0@T0@@Z DD imagerel ??X@YAAEATv4@@AEAT0@T0@@Z
	DD	imagerel ??X@YAAEATv4@@AEAT0@T0@@Z+166
	DD	imagerel $unwind$??X@YAAEATv4@@AEAT0@T0@@Z
$pdata$?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z DD imagerel ?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z
	DD	imagerel ?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z+305
	DD	imagerel $unwind$?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z
$pdata$?Mat4Identity@@YA?ATmat4@@XZ DD imagerel ?Mat4Identity@@YA?ATmat4@@XZ
	DD	imagerel ?Mat4Identity@@YA?ATmat4@@XZ+233
	DD	imagerel $unwind$?Mat4Identity@@YA?ATmat4@@XZ
$pdata$?Mat4Transpose@@YAXPEATmat4@@0@Z DD imagerel ?Mat4Transpose@@YAXPEATmat4@@0@Z
	DD	imagerel ?Mat4Transpose@@YAXPEATmat4@@0@Z+481
	DD	imagerel $unwind$?Mat4Transpose@@YAXPEATmat4@@0@Z
$pdata$?Mat4Inverse@@YAXPEATmat4@@0@Z DD imagerel ?Mat4Inverse@@YAXPEATmat4@@0@Z
	DD	imagerel ?Mat4Inverse@@YAXPEATmat4@@0@Z+5335
	DD	imagerel $unwind$?Mat4Inverse@@YAXPEATmat4@@0@Z
$pdata$??D@YA?ATmat4@@T0@0@Z DD imagerel ??D@YA?ATmat4@@T0@0@Z
	DD	imagerel ??D@YA?ATmat4@@T0@0@Z+5039
	DD	imagerel $unwind$??D@YA?ATmat4@@T0@0@Z
$pdata$??D@YA?ATv4@@Tmat4@@T0@@Z DD imagerel ??D@YA?ATv4@@Tmat4@@T0@@Z
	DD	imagerel ??D@YA?ATv4@@Tmat4@@T0@@Z+851
	DD	imagerel $unwind$??D@YA?ATv4@@Tmat4@@T0@@Z
$pdata$?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z DD imagerel ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z
	DD	imagerel ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z+855
	DD	imagerel $unwind$?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z
$pdata$?RotateMat4@@YAXPEATmat4@@MTv3@@@Z DD imagerel ?RotateMat4@@YAXPEATmat4@@MTv3@@@Z
	DD	imagerel ?RotateMat4@@YAXPEATmat4@@MTv3@@@Z+3338
	DD	imagerel $unwind$?RotateMat4@@YAXPEATmat4@@MTv3@@@Z
$pdata$?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z DD imagerel ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z
	DD	imagerel ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z+434
	DD	imagerel $unwind$?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z
$pdata$?CreatePerspective@@YAXPEATmat4@@MMMM@Z DD imagerel ?CreatePerspective@@YAXPEATmat4@@MMMM@Z
	DD	imagerel ?CreatePerspective@@YAXPEATmat4@@MMMM@Z+462
	DD	imagerel $unwind$?CreatePerspective@@YAXPEATmat4@@MMMM@Z
$pdata$?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z DD imagerel ?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z
	DD	imagerel ?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z+564
	DD	imagerel $unwind$?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z
$pdata$?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z DD imagerel ?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z
	DD	imagerel ?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z+1429
	DD	imagerel $unwind$?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z
$pdata$??U@YA?AW4ui_type@@W40@0@Z DD imagerel ??U@YA?AW4ui_type@@W40@0@Z
	DD	imagerel ??U@YA?AW4ui_type@@W40@0@Z+35
	DD	imagerel $unwind$??U@YA?AW4ui_type@@W40@0@Z
$pdata$stbtt_BakeFontBitmap DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$stbtt_BakeFontBitmap
$pdata$stbtt_GetBakedQuad DD imagerel $LN5
	DD	imagerel $LN5+547
	DD	imagerel $unwind$stbtt_GetBakedQuad
$pdata$stbtt_GetScaledFontVMetrics DD imagerel $LN5
	DD	imagerel $LN5+265
	DD	imagerel $unwind$stbtt_GetScaledFontVMetrics
$pdata$stbtt_PackBegin DD imagerel $LN10
	DD	imagerel $LN10+419
	DD	imagerel $unwind$stbtt_PackBegin
$pdata$stbtt_PackEnd DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$stbtt_PackEnd
$pdata$stbtt_PackFontRange DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$stbtt_PackFontRange
$pdata$stbtt_PackFontRanges DD imagerel $LN13
	DD	imagerel $LN13+595
	DD	imagerel $unwind$stbtt_PackFontRanges
$pdata$stbtt_PackSetOversampling DD imagerel $LN7
	DD	imagerel $LN7+129
	DD	imagerel $unwind$stbtt_PackSetOversampling
$pdata$stbtt_GetPackedQuad DD imagerel $LN5
	DD	imagerel $LN5+620
	DD	imagerel $unwind$stbtt_GetPackedQuad
$pdata$stbtt_PackFontRangesGatherRects DD imagerel $LN17
	DD	imagerel $LN17+832
	DD	imagerel $unwind$stbtt_PackFontRangesGatherRects
$pdata$stbtt_PackFontRangesPackRects DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$stbtt_PackFontRangesPackRects
$pdata$stbtt_PackFontRangesRenderIntoRects DD imagerel $LN22
	DD	imagerel $LN22+2037
	DD	imagerel $unwind$stbtt_PackFontRangesRenderIntoRects
$pdata$stbtt_GetNumberOfFonts DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$stbtt_GetNumberOfFonts
$pdata$stbtt_GetFontOffsetForIndex DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$stbtt_GetFontOffsetForIndex
$pdata$stbtt_InitFont DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$stbtt_InitFont
$pdata$stbtt_FindGlyphIndex DD imagerel $LN33
	DD	imagerel $LN33+1538
	DD	imagerel $unwind$stbtt_FindGlyphIndex
$pdata$stbtt_ScaleForPixelHeight DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$stbtt_ScaleForPixelHeight
$pdata$stbtt_ScaleForMappingEmToPixels DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$stbtt_ScaleForMappingEmToPixels
$pdata$stbtt_GetFontVMetrics DD imagerel $LN6
	DD	imagerel $LN6+170
	DD	imagerel $unwind$stbtt_GetFontVMetrics
$pdata$stbtt_GetFontVMetricsOS2 DD imagerel $LN7
	DD	imagerel $LN7+210
	DD	imagerel $unwind$stbtt_GetFontVMetricsOS2
$pdata$stbtt_GetFontBoundingBox DD imagerel $LN3
	DD	imagerel $LN3+185
	DD	imagerel $unwind$stbtt_GetFontBoundingBox
$pdata$stbtt_GetCodepointHMetrics DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$stbtt_GetCodepointHMetrics
$pdata$stbtt_GetCodepointKernAdvance DD imagerel $LN4
	DD	imagerel $LN4+100
	DD	imagerel $unwind$stbtt_GetCodepointKernAdvance
$pdata$stbtt_GetCodepointBox DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$stbtt_GetCodepointBox
$pdata$stbtt_GetGlyphHMetrics DD imagerel $LN9
	DD	imagerel $LN9+357
	DD	imagerel $unwind$stbtt_GetGlyphHMetrics
$pdata$stbtt_GetGlyphKernAdvance DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$stbtt_GetGlyphKernAdvance
$pdata$stbtt_GetGlyphBox DD imagerel $LN10
	DD	imagerel $LN10+297
	DD	imagerel $unwind$stbtt_GetGlyphBox
$pdata$stbtt_GetKerningTableLength DD imagerel $LN6
	DD	imagerel $LN6+130
	DD	imagerel $unwind$stbtt_GetKerningTableLength
$pdata$stbtt_GetKerningTable DD imagerel $LN10
	DD	imagerel $LN10+349
	DD	imagerel $unwind$stbtt_GetKerningTable
$pdata$stbtt_IsGlyphEmpty DD imagerel $LN9
	DD	imagerel $LN9+185
	DD	imagerel $unwind$stbtt_IsGlyphEmpty
$pdata$stbtt_GetCodepointShape DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$stbtt_GetCodepointShape
$pdata$stbtt_GetGlyphShape DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$stbtt_GetGlyphShape
$pdata$stbtt_FreeShape DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$stbtt_FreeShape
$pdata$stbtt_FindSVGDoc DD imagerel $LN7
	DD	imagerel $LN7+200
	DD	imagerel $unwind$stbtt_FindSVGDoc
$pdata$stbtt_GetCodepointSVG DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$stbtt_GetCodepointSVG
$pdata$stbtt_GetGlyphSVG DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$stbtt_GetGlyphSVG
$pdata$stbtt_FreeBitmap DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$stbtt_FreeBitmap
$pdata$stbtt_GetCodepointBitmap DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$stbtt_GetCodepointBitmap
$pdata$stbtt_GetCodepointBitmapSubpixel DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$stbtt_GetCodepointBitmapSubpixel
$pdata$stbtt_MakeCodepointBitmap DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$stbtt_MakeCodepointBitmap
$pdata$stbtt_MakeCodepointBitmapSubpixel DD imagerel $LN3
	DD	imagerel $LN3+146
	DD	imagerel $unwind$stbtt_MakeCodepointBitmapSubpixel
$pdata$stbtt_MakeCodepointBitmapSubpixelPrefilter DD imagerel $LN3
	DD	imagerel $LN3+209
	DD	imagerel $unwind$stbtt_MakeCodepointBitmapSubpixelPrefilter
$pdata$stbtt_GetCodepointBitmapBox DD imagerel $LN3
	DD	imagerel $LN3+126
	DD	imagerel $unwind$stbtt_GetCodepointBitmapBox
$pdata$stbtt_GetCodepointBitmapBoxSubpixel DD imagerel $LN3
	DD	imagerel $LN3+150
	DD	imagerel $unwind$stbtt_GetCodepointBitmapBoxSubpixel
$pdata$stbtt_GetGlyphBitmap DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$stbtt_GetGlyphBitmap
$pdata$stbtt_GetGlyphBitmapSubpixel DD imagerel $LN12
	DD	imagerel $LN12+683
	DD	imagerel $unwind$stbtt_GetGlyphBitmapSubpixel
$pdata$stbtt_MakeGlyphBitmap DD imagerel $LN3
	DD	imagerel $LN3+124
	DD	imagerel $unwind$stbtt_MakeGlyphBitmap
$pdata$stbtt_MakeGlyphBitmapSubpixel DD imagerel $LN4
	DD	imagerel $LN4+382
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixel
$pdata$stbtt_MakeGlyphBitmapSubpixelPrefilter DD imagerel $LN5
	DD	imagerel $LN5+310
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixelPrefilter
$pdata$stbtt_GetGlyphBitmapBox DD imagerel $LN3
	DD	imagerel $LN3+126
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBox
$pdata$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel $LN13
	DD	imagerel $LN13+415
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
$pdata$stbtt_Rasterize DD imagerel $LN6
	DD	imagerel $LN6+353
	DD	imagerel $unwind$stbtt_Rasterize
$pdata$stbtt_FreeSDF DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$stbtt_FreeSDF
$pdata$stbtt_GetGlyphSDF DD imagerel $LN83
	DD	imagerel $LN83+6480
	DD	imagerel $unwind$stbtt_GetGlyphSDF
$pdata$stbtt_GetCodepointSDF DD imagerel $LN3
	DD	imagerel $LN3+147
	DD	imagerel $unwind$stbtt_GetCodepointSDF
$pdata$stbtt_FindMatchingFont DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$stbtt_FindMatchingFont
$pdata$stbtt_CompareUTF8toUTF16_bigendian DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$stbtt_CompareUTF8toUTF16_bigendian
$pdata$stbtt_GetFontNameString DD imagerel $LN8
	DD	imagerel $LN8+445
	DD	imagerel $unwind$stbtt_GetFontNameString
$pdata$?StringLength@@YAHPEAD@Z DD imagerel ?StringLength@@YAHPEAD@Z
	DD	imagerel ?StringLength@@YAHPEAD@Z+76
	DD	imagerel $unwind$?StringLength@@YAHPEAD@Z
$pdata$?CreateString@@YA?AUstring8@@PEAD@Z DD imagerel ?CreateString@@YA?AUstring8@@PEAD@Z
	DD	imagerel ?CreateString@@YA?AUstring8@@PEAD@Z+72
	DD	imagerel $unwind$?CreateString@@YA?AUstring8@@PEAD@Z
$pdata$?StringConcat@@YAXPEAUstring8@@U1@@Z DD imagerel ?StringConcat@@YAXPEAUstring8@@U1@@Z
	DD	imagerel ?StringConcat@@YAXPEAUstring8@@U1@@Z+155
	DD	imagerel $unwind$?StringConcat@@YAXPEAUstring8@@U1@@Z
$pdata$?CompareStringBinary@@YAHUstring8@@0@Z DD imagerel ?CompareStringBinary@@YAHUstring8@@0@Z
	DD	imagerel ?CompareStringBinary@@YAHUstring8@@0@Z+118
	DD	imagerel $unwind$?CompareStringBinary@@YAHUstring8@@0@Z
$pdata$?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z DD imagerel ?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z
	DD	imagerel ?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z+174
	DD	imagerel $unwind$?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z
$pdata$?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z DD imagerel ?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z
	DD	imagerel ?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z+150
	DD	imagerel $unwind$?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z
$pdata$?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z DD imagerel ?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z
	DD	imagerel ?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z+258
	DD	imagerel $unwind$?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z
$pdata$?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z DD imagerel ?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z
	DD	imagerel ?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z+855
	DD	imagerel $unwind$?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z
$pdata$?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z DD imagerel ?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z
	DD	imagerel ?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z+773
	DD	imagerel $unwind$?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z
$pdata$?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z DD imagerel ?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z
	DD	imagerel ?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z+2712
	DD	imagerel $unwind$?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z
$pdata$?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z DD imagerel ?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z
	DD	imagerel ?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z+1674
	DD	imagerel $unwind$?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z
$pdata$?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z DD imagerel ?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z
	DD	imagerel ?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z+1796
	DD	imagerel $unwind$?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z
$pdata$stbi_load_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_load_from_memory
$pdata$stbi_load_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_load_from_callbacks
$pdata$stbi_load DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$stbi_load
$pdata$stbi_load_from_file DD imagerel $LN4
	DD	imagerel $LN4+195
	DD	imagerel $unwind$stbi_load_from_file
$pdata$stbi_load_gif_from_memory DD imagerel $LN6
	DD	imagerel $LN6+315
	DD	imagerel $unwind$stbi_load_gif_from_memory
$pdata$stbi_load_16_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_load_16_from_memory
$pdata$stbi_load_16_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_load_16_from_callbacks
$pdata$stbi_load_16 DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$stbi_load_16
$pdata$stbi_load_from_file_16 DD imagerel $LN4
	DD	imagerel $LN4+195
	DD	imagerel $unwind$stbi_load_from_file_16
$pdata$stbi_loadf_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_loadf_from_memory
$pdata$stbi_loadf_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_loadf_from_callbacks
$pdata$stbi_loadf DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$stbi_loadf
$pdata$stbi_loadf_from_file DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$stbi_loadf_from_file
$pdata$stbi_is_hdr_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$stbi_is_hdr_from_callbacks
$pdata$stbi_is_hdr_from_memory DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$stbi_is_hdr_from_memory
$pdata$stbi_is_hdr DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$stbi_is_hdr
$pdata$stbi_is_hdr_from_file DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$stbi_is_hdr_from_file
$pdata$stbi_image_free DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$stbi_image_free
$pdata$stbi_info_from_memory DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$stbi_info_from_memory
$pdata$stbi_info_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$stbi_info_from_callbacks
$pdata$stbi_is_16_bit_from_memory DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$stbi_is_16_bit_from_memory
$pdata$stbi_is_16_bit_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$stbi_is_16_bit_from_callbacks
$pdata$stbi_info DD imagerel $LN4
	DD	imagerel $LN4+116
	DD	imagerel $unwind$stbi_info
$pdata$stbi_info_from_file DD imagerel $LN3
	DD	imagerel $LN3+166
	DD	imagerel $unwind$stbi_info_from_file
$pdata$stbi_is_16_bit DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$stbi_is_16_bit
$pdata$stbi_is_16_bit_from_file DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$stbi_is_16_bit_from_file
$pdata$stbi_zlib_decode_malloc_guesssize DD imagerel $LN7
	DD	imagerel $LN7+249
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize
$pdata$stbi_zlib_decode_malloc_guesssize_headerflag DD imagerel $LN7
	DD	imagerel $LN7+252
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize_headerflag
$pdata$stbi_zlib_decode_malloc DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$stbi_zlib_decode_malloc
$pdata$stbi_zlib_decode_buffer DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$stbi_zlib_decode_buffer
$pdata$stbi_zlib_decode_noheader_malloc DD imagerel $LN7
	DD	imagerel $LN7+236
	DD	imagerel $unwind$stbi_zlib_decode_noheader_malloc
$pdata$stbi_zlib_decode_noheader_buffer DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$stbi_zlib_decode_noheader_buffer
$pdata$?stbi__cpuid3@@YAHXZ DD imagerel ?stbi__cpuid3@@YAHXZ
	DD	imagerel ?stbi__cpuid3@@YAHXZ+80
	DD	imagerel $unwind$?stbi__cpuid3@@YAHXZ
$pdata$?stbi__sse2_available@@YAHXZ DD imagerel ?stbi__sse2_available@@YAHXZ
	DD	imagerel ?stbi__sse2_available@@YAHXZ+54
	DD	imagerel $unwind$?stbi__sse2_available@@YAHXZ
$pdata$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
	DD	imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z+231
	DD	imagerel $unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
$pdata$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z DD imagerel ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
	DD	imagerel ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z+147
	DD	imagerel $unwind$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
$pdata$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
	DD	imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z+184
	DD	imagerel $unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
$pdata$?stbi__stdio_read@@YAHPEAXPEADH@Z DD imagerel ?stbi__stdio_read@@YAHPEAXPEADH@Z
	DD	imagerel ?stbi__stdio_read@@YAHPEAXPEADH@Z+52
	DD	imagerel $unwind$?stbi__stdio_read@@YAHPEAXPEADH@Z
$pdata$?stbi__stdio_skip@@YAXPEAXH@Z DD imagerel ?stbi__stdio_skip@@YAXPEAXH@Z
	DD	imagerel ?stbi__stdio_skip@@YAXPEAXH@Z+73
	DD	imagerel $unwind$?stbi__stdio_skip@@YAXPEAXH@Z
$pdata$?stbi__stdio_eof@@YAHPEAX@Z DD imagerel ?stbi__stdio_eof@@YAHPEAX@Z
	DD	imagerel ?stbi__stdio_eof@@YAHPEAX@Z+64
	DD	imagerel $unwind$?stbi__stdio_eof@@YAHPEAX@Z
$pdata$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z DD imagerel ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
	DD	imagerel ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z+41
	DD	imagerel $unwind$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
$pdata$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z+117
	DD	imagerel $unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+172
	DD	imagerel $unwind$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z+122
	DD	imagerel $unwind$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+94
	DD	imagerel $unwind$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z+64
	DD	imagerel $unwind$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__png_is16@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__png_is16@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__png_is16@@YAHPEAUstbi__context@@@Z+76
	DD	imagerel $unwind$?stbi__png_is16@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+4551
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z+249
	DD	imagerel $unwind$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+402
	DD	imagerel $unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+2643
	DD	imagerel $unwind$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z+612
	DD	imagerel $unwind$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z+71
	DD	imagerel $unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2963
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
$pdata$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z+327
	DD	imagerel $unwind$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__psd_is16@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__psd_is16@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__psd_is16@@YAHPEAUstbi__context@@@Z+194
	DD	imagerel $unwind$?stbi__psd_is16@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z+87
	DD	imagerel $unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+2389
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z+561
	DD	imagerel $unwind$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+689
	DD	imagerel $unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z+642
	DD	imagerel $unwind$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+317
	DD	imagerel $unwind$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z DD imagerel ?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z
	DD	imagerel ?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z+1008
	DD	imagerel $unwind$?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z
$pdata$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z+54
	DD	imagerel $unwind$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z+91
	DD	imagerel $unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+661
	DD	imagerel $unwind$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z+379
	DD	imagerel $unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z+46
	DD	imagerel $unwind$?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__malloc@@YAPEAX_K@Z DD imagerel ?stbi__malloc@@YAPEAX_K@Z
	DD	imagerel ?stbi__malloc@@YAPEAX_K@Z+24
	DD	imagerel $unwind$?stbi__malloc@@YAPEAX_K@Z
$pdata$?stbi__addsizes_valid@@YAHHH@Z DD imagerel ?stbi__addsizes_valid@@YAHHH@Z
	DD	imagerel ?stbi__addsizes_valid@@YAHHH@Z+62
	DD	imagerel $unwind$?stbi__addsizes_valid@@YAHHH@Z
$pdata$?stbi__mul2sizes_valid@@YAHHH@Z DD imagerel ?stbi__mul2sizes_valid@@YAHHH@Z
	DD	imagerel ?stbi__mul2sizes_valid@@YAHHH@Z+84
	DD	imagerel $unwind$?stbi__mul2sizes_valid@@YAHHH@Z
$pdata$?stbi__mad2sizes_valid@@YAHHHH@Z DD imagerel ?stbi__mad2sizes_valid@@YAHHHH@Z
	DD	imagerel ?stbi__mad2sizes_valid@@YAHHHH@Z+85
	DD	imagerel $unwind$?stbi__mad2sizes_valid@@YAHHHH@Z
$pdata$?stbi__mad3sizes_valid@@YAHHHHH@Z DD imagerel ?stbi__mad3sizes_valid@@YAHHHHH@Z
	DD	imagerel ?stbi__mad3sizes_valid@@YAHHHHH@Z+119
	DD	imagerel $unwind$?stbi__mad3sizes_valid@@YAHHHHH@Z
$pdata$?stbi__mad4sizes_valid@@YAHHHHHH@Z DD imagerel ?stbi__mad4sizes_valid@@YAHHHHHH@Z
	DD	imagerel ?stbi__mad4sizes_valid@@YAHHHHHH@Z+153
	DD	imagerel $unwind$?stbi__mad4sizes_valid@@YAHHHHHH@Z
$pdata$?stbi__malloc_mad2@@YAPEAXHHH@Z DD imagerel ?stbi__malloc_mad2@@YAPEAXHHH@Z
	DD	imagerel ?stbi__malloc_mad2@@YAPEAXHHH@Z+71
	DD	imagerel $unwind$?stbi__malloc_mad2@@YAPEAXHHH@Z
$pdata$?stbi__malloc_mad3@@YAPEAXHHHH@Z DD imagerel ?stbi__malloc_mad3@@YAPEAXHHHH@Z
	DD	imagerel ?stbi__malloc_mad3@@YAPEAXHHHH@Z+86
	DD	imagerel $unwind$?stbi__malloc_mad3@@YAPEAXHHHH@Z
$pdata$?stbi__malloc_mad4@@YAPEAXHHHHH@Z DD imagerel ?stbi__malloc_mad4@@YAPEAXHHHHH@Z
	DD	imagerel ?stbi__malloc_mad4@@YAPEAXHHHHH@Z+99
	DD	imagerel $unwind$?stbi__malloc_mad4@@YAPEAXHHHHH@Z
$pdata$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z DD imagerel ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z
	DD	imagerel ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z+466
	DD	imagerel $unwind$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z
$pdata$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+549
	DD	imagerel $unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
$pdata$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+817
	DD	imagerel $unwind$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
$pdata$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z DD imagerel ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
	DD	imagerel ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z+195
	DD	imagerel $unwind$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
$pdata$?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z DD imagerel ?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z
	DD	imagerel ?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z+210
	DD	imagerel $unwind$?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z
$pdata$?stbi__vertical_flip@@YAXPEAXHHH@Z DD imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+405
	DD	imagerel $unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z
$pdata$?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z DD imagerel ?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z
	DD	imagerel ?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z+133
	DD	imagerel $unwind$?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z
$pdata$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+437
	DD	imagerel $unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z+443
	DD	imagerel $unwind$?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z DD imagerel ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z
	DD	imagerel ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z+194
	DD	imagerel $unwind$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z
$pdata$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
	DD	imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z+57
	DD	imagerel $unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
$pdata$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z+354
	DD	imagerel $unwind$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__get8@@YAEPEAUstbi__context@@@Z DD imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z+169
	DD	imagerel $unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z
$pdata$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z+117
	DD	imagerel $unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__skip@@YAXPEAUstbi__context@@H@Z DD imagerel ?stbi__skip@@YAXPEAUstbi__context@@H@Z
	DD	imagerel ?stbi__skip@@YAXPEAUstbi__context@@H@Z+205
	DD	imagerel $unwind$?stbi__skip@@YAXPEAUstbi__context@@H@Z
$pdata$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z+343
	DD	imagerel $unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
$pdata$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z+63
	DD	imagerel $unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z+57
	DD	imagerel $unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z
$pdata$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z+55
	DD	imagerel $unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z+57
	DD	imagerel $unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z
$pdata$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+2632
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
$pdata$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+2684
	DD	imagerel $unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
$pdata$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+648
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
$pdata$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z+367
	DD	imagerel $unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
$pdata$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z+264
	DD	imagerel $unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z+645
	DD	imagerel $unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
$pdata$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z+219
	DD	imagerel $unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z+174
	DD	imagerel $unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z+110
	DD	imagerel $unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+738
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
$pdata$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+403
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
$pdata$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z+1618
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
$pdata$?stbi__idct_block@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z+2715
	DD	imagerel $unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z
$pdata$?stbi__idct_simd@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_simd@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_simd@@YAXPEAEHQEAF@Z+11018
	DD	imagerel $unwind$?stbi__idct_simd@@YAXPEAEHQEAF@Z
$pdata$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+137
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z+237
	DD	imagerel $unwind$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z+3156
	DD	imagerel $unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z DD imagerel ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z
	DD	imagerel ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z+86
	DD	imagerel $unwind$?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z
$pdata$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+457
	DD	imagerel $unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z+1716
	DD	imagerel $unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+812
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+352
	DD	imagerel $unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
$pdata$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+2318
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+345
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z+487
	DD	imagerel $unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+110
	DD	imagerel $unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z+474
	DD	imagerel $unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z+383
	DD	imagerel $unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+1637
	DD	imagerel $unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z+131
	DD	imagerel $unwind$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
$pdata$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+451
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
$pdata$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+1986
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
$pdata$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z+137
	DD	imagerel $unwind$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z+38
	DD	imagerel $unwind$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__blinn_8x8@@YAEEE@Z DD imagerel ?stbi__blinn_8x8@@YAEEE@Z
	DD	imagerel ?stbi__blinn_8x8@@YAEEE@Z+54
	DD	imagerel $unwind$?stbi__blinn_8x8@@YAEEE@Z
$pdata$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+4514
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
$pdata$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z DD imagerel ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z
	DD	imagerel ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z+172
	DD	imagerel $unwind$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z
$pdata$?stbi__bit_reverse@@YAHHH@Z DD imagerel ?stbi__bit_reverse@@YAHHH@Z
	DD	imagerel ?stbi__bit_reverse@@YAHHH@Z+55
	DD	imagerel $unwind$?stbi__bit_reverse@@YAHHH@Z
$pdata$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+898
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
$pdata$?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z+52
	DD	imagerel $unwind$?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z DD imagerel ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z+77
	DD	imagerel $unwind$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
$pdata$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z DD imagerel ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z+142
	DD	imagerel $unwind$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
$pdata$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z+143
	DD	imagerel $unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
$pdata$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+290
	DD	imagerel $unwind$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
$pdata$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+193
	DD	imagerel $unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
$pdata$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+324
	DD	imagerel $unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
$pdata$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z+707
	DD	imagerel $unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+786
	DD	imagerel $unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+499
	DD	imagerel $unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z+178
	DD	imagerel $unwind$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z+296
	DD	imagerel $unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
$pdata$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z DD imagerel ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
	DD	imagerel ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z+108
	DD	imagerel $unwind$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
$pdata$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
	DD	imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z+47
	DD	imagerel $unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
$pdata$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z+95
	DD	imagerel $unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__paeth@@YAHHHH@Z DD imagerel ?stbi__paeth@@YAHHHH@Z
	DD	imagerel ?stbi__paeth@@YAHHHH@Z+153
	DD	imagerel $unwind$?stbi__paeth@@YAHHHH@Z
$pdata$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
	DD	imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z+6196
	DD	imagerel $unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
$pdata$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1260
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
$pdata$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z DD imagerel ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
	DD	imagerel ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z+422
	DD	imagerel $unwind$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
$pdata$?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z DD imagerel ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z
	DD	imagerel ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z+429
	DD	imagerel $unwind$?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z
$pdata$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
	DD	imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z+562
	DD	imagerel $unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
$pdata$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+778
	DD	imagerel $unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
$pdata$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
	DD	imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z+3426
	DD	imagerel $unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
$pdata$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z+578
	DD	imagerel $unwind$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z DD imagerel ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z
	DD	imagerel ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z+150
	DD	imagerel $unwind$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z
$pdata$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z+180
	DD	imagerel $unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__high_bit@@YAHI@Z DD imagerel ?stbi__high_bit@@YAHI@Z
	DD	imagerel ?stbi__high_bit@@YAHI@Z+169
	DD	imagerel $unwind$?stbi__high_bit@@YAHI@Z
$pdata$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+1359
	DD	imagerel $unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
$pdata$?stbi__tga_get_comp@@YAHHHPEAH@Z DD imagerel ?stbi__tga_get_comp@@YAHHHPEAH@Z
	DD	imagerel ?stbi__tga_get_comp@@YAHHHPEAH@Z+144
	DD	imagerel $unwind$?stbi__tga_get_comp@@YAHHHPEAH@Z
$pdata$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z DD imagerel ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
	DD	imagerel ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z+197
	DD	imagerel $unwind$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
$pdata$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z+318
	DD	imagerel $unwind$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
$pdata$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z+88
	DD	imagerel $unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
$pdata$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+108
	DD	imagerel $unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
	DD	imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z+169
	DD	imagerel $unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
$pdata$?stbi__copyval@@YAXHPEAEPEBE@Z DD imagerel ?stbi__copyval@@YAXHPEAEPEBE@Z
	DD	imagerel ?stbi__copyval@@YAXHPEAEPEBE@Z+108
	DD	imagerel $unwind$?stbi__copyval@@YAXHPEAEPEBE@Z
$pdata$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
	DD	imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z+1593
	DD	imagerel $unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
$pdata$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z+152
	DD	imagerel $unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+235
	DD	imagerel $unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
$pdata$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+524
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
$pdata$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z+180
	DD	imagerel $unwind$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
	DD	imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z+662
	DD	imagerel $unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
$pdata$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
	DD	imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z+1097
	DD	imagerel $unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
$pdata$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z DD imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
	DD	imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z+2506
	DD	imagerel $unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
$pdata$?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z DD imagerel ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z
	DD	imagerel ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z+155
	DD	imagerel $unwind$?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z
$pdata$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z+109
	DD	imagerel $unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
$pdata$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z+179
	DD	imagerel $unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
$pdata$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z
	DD	imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z+608
	DD	imagerel $unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z
$pdata$?stbi__pnm_isspace@@YAHD@Z DD imagerel ?stbi__pnm_isspace@@YAHD@Z
	DD	imagerel ?stbi__pnm_isspace@@YAHD@Z+92
	DD	imagerel $unwind$?stbi__pnm_isspace@@YAHD@Z
$pdata$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z+162
	DD	imagerel $unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
$pdata$?stbi__pnm_isdigit@@YAHD@Z DD imagerel ?stbi__pnm_isdigit@@YAHD@Z
	DD	imagerel ?stbi__pnm_isdigit@@YAHD@Z+52
	DD	imagerel $unwind$?stbi__pnm_isdigit@@YAHD@Z
$pdata$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z+102
	DD	imagerel $unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
$pdata$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z+380
	DD	imagerel $unwind$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__is_16_main@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z+79
	DD	imagerel $unwind$?stbi__is_16_main@@YAHPEAUstbi__context@@@Z
$pdata$?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z DD imagerel ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z+82
	DD	imagerel $unwind$?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z
$pdata$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z+121
	DD	imagerel $unwind$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
$pdata$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z+42
	DD	imagerel $unwind$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
$pdata$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z+139
	DD	imagerel $unwind$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
$pdata$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z DD imagerel ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
	DD	imagerel ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z+117
	DD	imagerel $unwind$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
$pdata$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z DD imagerel ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
	DD	imagerel ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z+236
	DD	imagerel $unwind$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
$pdata$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+248
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+288
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
$pdata$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+162
	DD	imagerel $unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$pdata$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
	DD	imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z+368
	DD	imagerel $unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
$pdata$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
	DD	imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z+170
	DD	imagerel $unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
$pdata$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z+41
	DD	imagerel $unwind$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
$pdata$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z+322
	DD	imagerel $unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
$pdata$?stbtt__find_table@@YAIPEAEIPEBD@Z DD imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z
	DD	imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z+349
	DD	imagerel $unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z
$pdata$?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z DD imagerel ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z
	DD	imagerel ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z+366
	DD	imagerel $unwind$?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z
$pdata$?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z DD imagerel ?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z
	DD	imagerel ?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z+283
	DD	imagerel $unwind$?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z
$pdata$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
	DD	imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z+485
	DD	imagerel $unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
$pdata$?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z DD imagerel ?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z
	DD	imagerel ?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z+137
	DD	imagerel $unwind$?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z
$pdata$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
	DD	imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z+2243
	DD	imagerel $unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
$pdata$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z+392
	DD	imagerel $unwind$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
$pdata$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
	DD	imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z+387
	DD	imagerel $unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
$pdata$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+416
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$pdata$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+4987
	DD	imagerel $unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
$pdata$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+250
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$pdata$?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z DD imagerel ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z
	DD	imagerel ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z+130
	DD	imagerel $unwind$?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z
$pdata$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
	DD	imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z+214
	DD	imagerel $unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
$pdata$?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z DD imagerel ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z
	DD	imagerel ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z+148
	DD	imagerel $unwind$?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z
$pdata$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
	DD	imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z+244
	DD	imagerel $unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
$pdata$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z+303
	DD	imagerel $unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
$pdata$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z+559
	DD	imagerel $unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
$pdata$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
	DD	imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z+5116
	DD	imagerel $unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
$pdata$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+405
	DD	imagerel $unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
$pdata$?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z DD imagerel ?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z
	DD	imagerel ?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z+313
	DD	imagerel $unwind$?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z
$pdata$?stbtt__GetCoverageIndex@@YAHPEAEH@Z DD imagerel ?stbtt__GetCoverageIndex@@YAHPEAEH@Z
	DD	imagerel ?stbtt__GetCoverageIndex@@YAHPEAEH@Z+553
	DD	imagerel $unwind$?stbtt__GetCoverageIndex@@YAHPEAEH@Z
$pdata$?stbtt__GetGlyphClass@@YAHPEAEH@Z DD imagerel ?stbtt__GetGlyphClass@@YAHPEAEH@Z
	DD	imagerel ?stbtt__GetGlyphClass@@YAHPEAEH@Z+472
	DD	imagerel $unwind$?stbtt__GetGlyphClass@@YAHPEAEH@Z
$pdata$?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z DD imagerel ?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z
	DD	imagerel ?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z+1552
	DD	imagerel $unwind$?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z
$pdata$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
	DD	imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z+299
	DD	imagerel $unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
$pdata$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+75
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$pdata$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
	DD	imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z+439
	DD	imagerel $unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
$pdata$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+1085
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
$pdata$?stbtt__sized_trapezoid_area@@YAMMMM@Z DD imagerel ?stbtt__sized_trapezoid_area@@YAMMMM@Z
	DD	imagerel ?stbtt__sized_trapezoid_area@@YAMMMM@Z+137
	DD	imagerel $unwind$?stbtt__sized_trapezoid_area@@YAMMMM@Z
$pdata$?stbtt__position_trapezoid_area@@YAMMMMMM@Z DD imagerel ?stbtt__position_trapezoid_area@@YAMMMMMM@Z
	DD	imagerel ?stbtt__position_trapezoid_area@@YAMMMMMM@Z+71
	DD	imagerel $unwind$?stbtt__position_trapezoid_area@@YAMMMMMM@Z
$pdata$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+4042
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$pdata$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1305
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+340
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+1114
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z+46
	DD	imagerel $unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+988
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+637
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$pdata$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1345
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$pdata$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+1479
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$pdata$?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z DD imagerel ?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z
	DD	imagerel ?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z+933
	DD	imagerel $unwind$?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z
$pdata$?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z DD imagerel ?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z
	DD	imagerel ?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z+384
	DD	imagerel $unwind$?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z
$pdata$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+1098
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$pdata$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+1221
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$pdata$?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z DD imagerel ?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z
	DD	imagerel ?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z+1800
	DD	imagerel $unwind$?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z
$pdata$?equal@@YAHPEAM0@Z DD imagerel ?equal@@YAHPEAM0@Z
	DD	imagerel ?equal@@YAHPEAM0@Z+122
	DD	imagerel $unwind$?equal@@YAHPEAM0@Z
$pdata$?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z+2325
	DD	imagerel $unwind$?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z
$pdata$?stbtt__cuberoot@@YAMM@Z DD imagerel ?stbtt__cuberoot@@YAMM@Z
	DD	imagerel ?stbtt__cuberoot@@YAMM@Z+93
	DD	imagerel $unwind$?stbtt__cuberoot@@YAMM@Z
$pdata$?stbtt__solve_cubic@@YAHMMMPEAM@Z DD imagerel ?stbtt__solve_cubic@@YAHMMMPEAM@Z
	DD	imagerel ?stbtt__solve_cubic@@YAHMMMPEAM@Z+769
	DD	imagerel $unwind$?stbtt__solve_cubic@@YAHMMMPEAM@Z
$pdata$?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z DD imagerel ?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z
	DD	imagerel ?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z+1079
	DD	imagerel $unwind$?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z
$pdata$?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z DD imagerel ?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z
	DD	imagerel ?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z+80
	DD	imagerel $unwind$?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z
$pdata$?stbtt__matchpair@@YAHPEAEI0HHH@Z DD imagerel ?stbtt__matchpair@@YAHPEAEI0HHH@Z
	DD	imagerel ?stbtt__matchpair@@YAHPEAEI0HHH@Z+874
	DD	imagerel $unwind$?stbtt__matchpair@@YAHPEAEI0HHH@Z
$pdata$?stbtt__matches@@YAHPEAEI0H@Z DD imagerel ?stbtt__matches@@YAHPEAEI0H@Z
	DD	imagerel ?stbtt__matches@@YAHPEAEI0H@Z+561
	DD	imagerel $unwind$?stbtt__matches@@YAHPEAEI0H@Z
$pdata$?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z DD imagerel ?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z
	DD	imagerel ?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z+111
	DD	imagerel $unwind$?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z
$pdata$?RunPlayer@@YAXPEAUentity@@M@Z DD imagerel $LN12
	DD	imagerel $LN12+1866
	DD	imagerel $unwind$?RunPlayer@@YAXPEAUentity@@M@Z
$pdata$?OnCollidePlayer@@YAXPEAUentity@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?OnCollidePlayer@@YAXPEAUentity@@0@Z
$pdata$?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z DD imagerel ?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z
	DD	imagerel ?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z+159
	DD	imagerel $unwind$?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$json_parse DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$json_parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$json_parse_ex DD imagerel $LN15
	DD	imagerel $LN15+826
	DD	imagerel $unwind$json_parse_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_hexadecimal_value@@YAHPEBDKPEAK@Z DD imagerel $LN9
	DD	imagerel $LN9+180
	DD	imagerel $unwind$?json_hexadecimal_value@@YAHPEBDKPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z DD imagerel $LN21
	DD	imagerel $LN21+288
	DD	imagerel $unwind$?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z DD imagerel $LN19
	DD	imagerel $LN19+599
	DD	imagerel $unwind$?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z DD imagerel $LN15
	DD	imagerel $LN15+269
	DD	imagerel $unwind$?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z DD imagerel $LN45
	DD	imagerel $LN45+1562
	DD	imagerel $unwind$?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z DD imagerel $LN57
	DD	imagerel $LN57+1688
	DD	imagerel $unwind$?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_valid_unquoted_key_char@@YAHD@Z DD imagerel $LN8
	DD	imagerel $LN8+102
	DD	imagerel $unwind$?is_valid_unquoted_key_char@@YAHD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z DD imagerel $LN13
	DD	imagerel $LN13+407
	DD	imagerel $unwind$?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z DD imagerel $LN33
	DD	imagerel $LN33+972
	DD	imagerel $unwind$?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z DD imagerel $LN17
	DD	imagerel $LN17+525
	DD	imagerel $unwind$?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z DD imagerel $LN70
	DD	imagerel $LN70+2393
	DD	imagerel $unwind$?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z DD imagerel $LN36
	DD	imagerel $LN36+1778
	DD	imagerel $unwind$?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z DD imagerel $LN36
	DD	imagerel $LN36+1736
	DD	imagerel $unwind$?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z DD imagerel $LN10
	DD	imagerel $LN10+369
	DD	imagerel $unwind$?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z DD imagerel $LN23
	DD	imagerel $LN23+1139
	DD	imagerel $unwind$?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z DD imagerel $LN15
	DD	imagerel $LN15+632
	DD	imagerel $unwind$?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z DD imagerel $LN46
	DD	imagerel $LN46+1163
	DD	imagerel $unwind$?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z DD imagerel ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z
	DD	imagerel ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z+218
	DD	imagerel $unwind$?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z
$pdata$?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z DD imagerel ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z
	DD	imagerel ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z+96
	DD	imagerel $unwind$?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z
$pdata$?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z DD imagerel ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z
	DD	imagerel ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z+99
	DD	imagerel $unwind$?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z
$pdata$?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z DD imagerel ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z
	DD	imagerel ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z+132
	DD	imagerel $unwind$?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z
$pdata$?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z DD imagerel ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z
	DD	imagerel ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z+169
	DD	imagerel $unwind$?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z
$pdata$?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z DD imagerel ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z
	DD	imagerel ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z+1715
	DD	imagerel $unwind$?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z
$pdata$?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z DD imagerel ?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z
	DD	imagerel ?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z+5529
	DD	imagerel $unwind$?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z
$pdata$?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z DD imagerel ?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z
	DD	imagerel ?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z+466
	DD	imagerel $unwind$?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z
$pdata$?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z DD imagerel ?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z
	DD	imagerel ?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z+1826
	DD	imagerel $unwind$?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z
$pdata$?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z DD imagerel ?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z
	DD	imagerel ?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z+158
	DD	imagerel $unwind$?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z
$pdata$?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z DD imagerel ?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z
	DD	imagerel ?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z+191
	DD	imagerel $unwind$?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z
$pdata$?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z DD imagerel ?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z
	DD	imagerel ?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z+617
	DD	imagerel $unwind$?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z
$pdata$?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z DD imagerel ?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z
	DD	imagerel ?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z+50
	DD	imagerel $unwind$?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z
$pdata$?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z DD imagerel ?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z
	DD	imagerel ?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z+50
	DD	imagerel $unwind$?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z
$pdata$?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z DD imagerel ?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z
	DD	imagerel ?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z+53
	DD	imagerel $unwind$?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z
$pdata$?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z DD imagerel ?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z
	DD	imagerel ?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z+442
	DD	imagerel $unwind$?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z
$pdata$?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z DD imagerel $LN72
	DD	imagerel $LN72+8146
	DD	imagerel $unwind$?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z
pdata	ENDS
;	COMDAT __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
CONST	SEGMENT
__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e DB '~', 0faH, '~', 0faH, '~', 0faH
	DB	'~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH
CONST	ENDS
;	COMDAT __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
CONST	SEGMENT
__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d DB 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH
	DB	0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H
CONST	ENDS
;	COMDAT __xmm@f493f493f493f493f493f493f493f493
CONST	SEGMENT
__xmm@f493f493f493f493f493f493f493f493 DB 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
	DB	093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
CONST	ENDS
;	COMDAT __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
CONST	SEGMENT
__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9 DB 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H
	DB	01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH
CONST	ENDS
;	COMDAT __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
CONST	SEGMENT
__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0 DB 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H
	DB	0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H
CONST	ENDS
;	COMDAT __xmm@e09ee565e09ee565e09ee565e09ee565
CONST	SEGMENT
__xmm@e09ee565e09ee565e09ee565e09ee565 DB 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H
	DB	09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H
CONST	ENDS
;	COMDAT __xmm@80808080808080808080808080808080
CONST	SEGMENT
__xmm@80808080808080808080808080808080 DB 080H, 080H, 080H, 080H, 080H, 080H
	DB	080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
CONST	SEGMENT
__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a DB 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
	DB	'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
CONST	ENDS
;	COMDAT __xmm@166f166f166f166f166f166f166f166f
CONST	SEGMENT
__xmm@166f166f166f166f166f166f166f166f DB 'o', 016H, 'o', 016H, 'o', 016H
	DB	'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H
CONST	ENDS
;	COMDAT __xmm@12d0046b12d0046b12d0046b12d0046b
CONST	SEGMENT
__xmm@12d0046b12d0046b12d0046b12d0046b DB 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H
	DB	012H, 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H, 012H
CONST	ENDS
;	COMDAT __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
CONST	SEGMENT
__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3 DB 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H
	DB	0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
CONST	SEGMENT
__xmm@11c8e09e11c8e09e11c8e09e11c8e09e DB 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H
	DB	0c8H, 011H, 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@08a914e808a914e808a914e808a914e8
CONST	SEGMENT
__xmm@08a914e808a914e808a914e808a914e8 DB 0e8H, 014H, 0a9H, 08H, 0e8H, 014H
	DB	0a9H, 08H, 0e8H, 014H, 0a9H, 08H, 0e8H, 014H, 0a9H, 08H
CONST	ENDS
;	COMDAT __xmm@01010000010100000101000001010000
CONST	SEGMENT
__xmm@01010000010100000101000001010000 DB 00H, 00H, 01H, 01H, 00H, 00H, 01H
	DB	01H, 00H, 00H, 01H, 01H, 00H, 00H, 01H, 01H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00080008000800080008000800080008
CONST	SEGMENT
__xmm@00080008000800080008000800080008 DB 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
CONST	ENDS
;	COMDAT __xmm@00000200000002000000020000000200
CONST	SEGMENT
__xmm@00000200000002000000020000000200 DB 00H, 02H, 00H, 00H, 00H, 02H, 00H
	DB	00H, 00H, 02H, 00H, 00H, 00H, 02H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c1d80000
CONST	SEGMENT
__real@c1d80000 DD 0c1d80000r			; -27
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@be4ccccd
CONST	SEGMENT
__real@be4ccccd DD 0be4ccccdr			; -0.2
CONST	ENDS
;	COMDAT __real@497423f0
CONST	SEGMENT
__real@497423f0 DD 0497423f0r			; 999999
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@46800000
CONST	SEGMENT
__real@46800000 DD 046800000r			; 16384
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41d80000
CONST	SEGMENT
__real@41d80000 DD 041d80000r			; 27
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fafc8b007a
CONST	SEGMENT
__real@3ff921fafc8b007a DQ 03ff921fafc8b007ar	; 1.5708
CONST	ENDS
;	COMDAT __real@3ff028f5c0000000
CONST	SEGMENT
__real@3ff028f5c0000000 DQ 03ff028f5c0000000r	; 1.01
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fddb3d7
CONST	SEGMENT
__real@3fddb3d7 DD 03fddb3d7r			; 1.73205
CONST	ENDS
;	COMDAT __real@3fd5555560000000
CONST	SEGMENT
__real@3fd5555560000000 DQ 03fd5555560000000r	; 0.333333
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@34000000
CONST	SEGMENT
__real@34000000 DD 034000000r			; 1.19209e-07
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEBCLIFP@Infinity@
CONST	SEGMENT
??_C@_08KEBCLIFP@Infinity@ DB 'Infinity', 00H		; `string'
CONST	ENDS
;	COMDAT ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
_DATA	SEGMENT
?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H ; `stbi__shiftsigned'::`2'::shift_table
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	04H
	DD	06H
	DD	00H
_DATA	ENDS
;	COMDAT ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
_DATA	SEGMENT
?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H	; `stbi__shiftsigned'::`2'::mul_table
	DD	0ffH
	DD	055H
	DD	049H
	DD	011H
	DD	021H
	DD	041H
	DD	081H
	DD	01H
_DATA	ENDS
;	COMDAT ?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
_DATA	SEGMENT
?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA DB 'X'
	DB	'XXX PNG chunk not known', 00H		; `stbi__parse_png_file'::`151'::invalid_chunk
_DATA	ENDS
;	COMDAT ?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB
CONST	SEGMENT
?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB DB 089H ; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
CONST	ENDS
;	COMDAT ?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB
CONST	SEGMENT
?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
CONST	ENDS
;	COMDAT ?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 052H ; `stbi__process_frame_header'::`22'::rgb
	DB	047H
	DB	042H
CONST	ENDS
;	COMDAT ?tag@?DE@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?tag@?DE@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 041H ; `stbi__process_marker'::`52'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
CONST	ENDS
;	COMDAT ?tag@?CL@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?tag@?CL@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 04aH ; `stbi__process_marker'::`43'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A DQ FLAT:?stbi__stdio_read@@YAHPEAXPEADH@Z ; stbi__stdio_callbacks
	DQ	FLAT:?stbi__stdio_skip@@YAXPEAXH@Z
	DQ	FLAT:?stbi__stdio_eof@@YAHPEAX@Z
?stbi__l2h_gamma@@3MA DD 0400ccccdr		; 2.2	; stbi__l2h_gamma
?stbi__l2h_scale@@3MA DD 03f800000r		; 1	; stbi__l2h_scale
?stbi__h2l_gamma_i@@3MA DD 03ee8ba2er		; 0.454545 ; stbi__h2l_gamma_i
?stbi__h2l_scale_i@@3MA DD 03f800000r		; 1	; stbi__h2l_scale_i
?first_row_filter@@3PAEA DB 00H				; first_row_filter
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+3
?GlobalSensitivity@@3MA DD 042480000r		; 50	; GlobalSensitivity
?GlobalMaxPitch@@3MA DD 042b20000r		; 89	; GlobalMaxPitch
?GlobalMinPitch@@3MA DD 0c2b20000r		; -89	; GlobalMinPitch
?GlobalSpeed@@3MA DD 041400000r			; 12	; GlobalSpeed
?Gravity@@3MA DD 0c26b70a4r			; -58.86 ; Gravity
?JumpHeight@@3MA DD 040600000r			; 3.5	; JumpHeight
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z DD 021501H
	DD	0110115H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	018H
	DW	08a3H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z DD 042019H
	DD	013010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_valid_unquoted_key_char@@YAHD@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?json_hexadecimal_value@@YAHPEBDKPEAK@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$json_parse_ex DD 021b01H
	DD	017011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$json_parse DD 010e01H
	DD	0620eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z
	DD	026H
	DD	01fb8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z
	DD	026H
	DD	01a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z
	DD	02eH
	DD	024fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z
	DD	01fH
	DD	0abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z
	DD	027H
	DD	0708H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z
	DD	027H
	DD	01b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z
	DD	022H
	DD	0157fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RunPlayer@@YAXPEAUentity@@M@Z
	DD	01eH
	DD	0730H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z
	DD	027H
	DD	08fdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	022H
	DD	04b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	022H
	DD	0437H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	01cH
	DD	0440H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	019H
	DD	0140H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	026H
	DD	0500H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
	DD	021H
	DD	01363H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	021H
	DD	01361H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
	DD	024H
	DD	0621H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
	DD	020H
	DD	0d49H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	027H
	DD	04d2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	017H
	DD	02f9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	021H
	DD	0369H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	025H
	DD	0118aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
	DD	01aH
	DD	069cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
	DD	016H
	DD	0c3cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__idct_block@@YAXPEAEHQEAF@Z
	DD	01fH
	DD	0a83H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
	DD	022H
	DD	0150H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z
	DD	025H
	DD	01a6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	025H
	DD	01a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__vertical_flip@@YAXPEAXHHH@Z
	DD	026H
	DD	017bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z
	DD	02dH
	DD	03d6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	02cH
	DD	0124H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	022H
	DD	0270H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	025H
	DD	0219H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	025H
	DD	093dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	022H
	DD	0e7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	025H
	DD	011afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__cpuid3@@YAHXZ
	DD	010H
	DD	03dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_noheader_buffer
	DD	02aH
	DD	09cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_noheader_malloc
	DD	025H
	DD	0d4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_buffer
	DD	02aH
	DD	09cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag
	DD	02aH
	DD	0e4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_malloc_guesssize
	DD	02aH
	DD	0e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_16_bit_from_file
	DD	016H
	DD	067H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_file
	DD	025H
	DD	08eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_16_bit_from_callbacks
	DD	01bH
	DD	047H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_16_bit_from_memory
	DD	01aH
	DD	046H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_callbacks
	DD	025H
	DD	069H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_memory
	DD	024H
	DD	068H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_file
	DD	016H
	DD	067H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_memory
	DD	01aH
	DD	046H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_callbacks
	DD	01bH
	DD	047H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_file
	DD	025H
	DD	06cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_callbacks
	DD	025H
	DD	074H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_memory
	DD	024H
	DD	073H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_file_16
	DD	025H
	DD	0abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_16_from_callbacks
	DD	025H
	DD	074H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_16_from_memory
	DD	024H
	DD	073H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_gif_from_memory
	DD	024H
	DD	0123H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_file
	DD	025H
	DD	0abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_callbacks
	DD	025H
	DD	074H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_memory
	DD	024H
	DD	073H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z
	DD	028H
	DD	06eaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z
	DD	027H
	DD	0670H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z
	DD	027H
	DD	0a7eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z
	DD	028H
	DD	02ebH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z
	DD	027H
	DD	033dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z
	DD	01dH
	DD	0e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbtt_GetGlyphSDF
	DD	026H
	DD	01938H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z
	DD	027H
	DD	057bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z
	DD	02aH
	DD	021aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreatePerspective@@YAXPEATmat4@@MMMM@Z
	DD	02aH
	DD	01b7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z
	DD	01dH
	DD	0198H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?RotateMat4@@YAXPEATmat4@@MTv3@@@Z
	DD	023H
	DD	0cf0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z
	DD	01dH
	DD	033dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv4@@Tmat4@@T0@@Z
	DD	01fH
	DD	033fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATmat4@@T0@0@Z
	DD	01fH
	DD	0139bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Mat4Inverse@@YAXPEATmat4@@0@Z
	DD	018H
	DD	014c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Mat4Transpose@@YAXPEATmat4@@0@Z
	DD	01aH
	DD	01cdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Mat4Identity@@YA?ATmat4@@XZ
	DD	015H
	DD	0d5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z
	DD	01aH
	DD	011dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??X@YAAEATv4@@AEAT0@T0@@Z
	DD	01aH
	DD	092H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv4@@T0@M@Z
	DD	020H
	DD	093H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv4@@T0@0@Z
	DD	01fH
	DD	0a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??H@YA?ATv4@@T0@0@Z
	DD	01fH
	DD	0a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V4@@YA?ATv4@@Tv3@@M@Z
	DD	020H
	DD	077H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V4@@YA?ATv4@@MMMM@Z
	DD	027H
	DD	073H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V3EulerToRotation@@YA?ATv3@@T1@@Z
	DD	01dH
	DD	014dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V3Normalize@@YA?ATv3@@T1@@Z
	DD	01dH
	DD	0cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv3@@T0@M@Z
	DD	020H
	DD	07dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??X@YAAEATv3@@AEAT0@T0@@Z
	DD	01aH
	DD	092H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv3@@T0@0@Z
	DD	01fH
	DD	087H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??G@YA?ATv3@@T0@0@Z
	DD	01fH
	DD	087H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??Y@YAAEATv3@@AEAT0@T0@@Z
	DD	01aH
	DD	092H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??H@YA?ATv3@@T0@0@Z
	DD	01fH
	DD	087H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V3@@YA?ATv3@@Tv4@@@Z
	DD	01aH
	DD	065H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V3@@YA?ATv3@@Tv2@@M@Z
	DD	020H
	DD	060H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V3@@YA?ATv3@@MMM@Z
	DD	027H
	DD	067H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V3Cross@@YA?ATv3@@T1@0@Z
	DD	01fH
	DD	0cdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V2Normalize@@YA?ATv2@@T1@@Z
	DD	013H
	DD	07aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??K@YA?ATv2@@T0@M@Z
	DD	019H
	DD	045H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??X@YAAEATv2@@AEAT0@M@Z
	DD	019H
	DD	048H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv2@@T0@M@Z
	DD	019H
	DD	045H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??D@YA?ATv2@@T0@0@Z
	DD	018H
	DD	044H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??H@YA?ATv2@@T0@0@Z
	DD	018H
	DD	044H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V2@@YA?ATv2@@HH@Z
	DD	016H
	DD	036H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?V2@@YA?ATv2@@MM@Z
	DD	01aH
	DD	03aH
voltbl	ENDS
xdata	SEGMENT
$unwind$PushSize DD 010e01H
	DD	0220eH
$unwind$?Sin@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?Cos@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?Tan@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?Sqrt@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?V2@@YA?ATv2@@MM@Z DD 011f19H
	DD	02210H
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$?V2@@YA?ATv2@@HH@Z DD 011b19H
	DD	0220cH
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$??H@YA?ATv2@@T0@0@Z DD 011d19H
	DD	0220eH
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$??D@YA?ATv2@@T0@0@Z DD 011d19H
	DD	0220eH
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$??D@YA?ATv2@@T0@M@Z DD 011e19H
	DD	0220fH
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$??X@YAAEATv2@@AEAT0@M@Z DD 011e19H
	DD	0620fH
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$??K@YA?ATv2@@T0@M@Z DD 011e19H
	DD	0220fH
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$?V2MultiplyDot@@YAMTv2@@0@Z DD 010e01H
	DD	0220eH
$unwind$?V2Length@@YAMTv2@@@Z DD 010901H
	DD	06209H
$unwind$?V2Normalize@@YA?ATv2@@T1@@Z DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$?V3Cross@@YA?ATv3@@T1@0@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?V3@@YA?ATv3@@MMM@Z DD 032c19H
	DD	07019421dH
	DD	06018H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?V3@@YA?ATv3@@Tv2@@M@Z DD 032519H
	DD	070124216H
	DD	06011H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?V3@@YA?ATv3@@Tv4@@@Z DD 031f19H
	DD	0700c4210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??H@YA?ATv3@@T0@0@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??Y@YAAEATv3@@AEAT0@T0@@Z DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$??G@YA?ATv3@@T0@0@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??D@YA?ATv3@@T0@0@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??X@YAAEATv3@@AEAT0@T0@@Z DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$??D@YA?ATv3@@T0@M@Z DD 032519H
	DD	070124216H
	DD	06011H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?V3MultiplyDot@@YAMTv3@@0@Z DD 010e01H
	DD	0220eH
$unwind$?V3Length@@YAMTv3@@@Z DD 030b01H
	DD	07007820bH
	DD	06006H
$unwind$?V3Normalize@@YA?ATv3@@T1@@Z DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$?V3EulerToRotation@@YA?ATv3@@T1@@Z DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?V4@@YA?ATv4@@MMMM@Z DD 032c19H
	DD	07019421dH
	DD	06018H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?V4@@YA?ATv4@@Tv3@@M@Z DD 032519H
	DD	070124216H
	DD	06011H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??H@YA?ATv4@@T0@0@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??D@YA?ATv4@@T0@0@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??D@YA?ATv4@@T0@M@Z DD 032519H
	DD	070124216H
	DD	06011H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$??X@YAAEATv4@@AEAT0@T0@@Z DD 031f19H
	DD	0700ce210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z DD 031f19H
	DD	0700c6210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$?Mat4Identity@@YA?ATmat4@@XZ DD 031a19H
	DD	07007a20bH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?Mat4Transpose@@YAXPEATmat4@@0@Z DD 031f19H
	DD	0700ca210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?Mat4Inverse@@YAXPEATmat4@@0@Z DD 011d19H
	DD	0820eH
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$??D@YA?ATmat4@@T0@0@Z DD 032419H
	DD	07011a215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$??D@YA?ATv4@@Tmat4@@T0@@Z DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z DD 042519H
	DD	0390113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?RotateMat4@@YAXPEATmat4@@MTv3@@@Z DD 042b19H
	DD	09d0119H
	DD	060117012H
	DD	imagerel __GSHandlerCheck
	DD	04d0H
$unwind$?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z DD 042519H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$?CreatePerspective@@YAXPEATmat4@@MMMM@Z DD 042f19H
	DD	0110120H
	DD	060187019H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z DD 043219H
	DD	01f0120H
	DD	060187019H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z DD 042f19H
	DD	04d011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0250H
$unwind$??U@YA?AW4ui_type@@W40@0@Z DD 010c01H
	DD	0220cH
$unwind$stbtt_BakeFontBitmap DD 011801H
	DD	0a218H
$unwind$stbtt_GetBakedQuad DD 011701H
	DD	08217H
$unwind$stbtt_GetScaledFontVMetrics DD 021b01H
	DD	01d011bH
$unwind$stbtt_PackBegin DD 021901H
	DD	070159219H
$unwind$stbtt_PackEnd DD 010901H
	DD	04209H
$unwind$stbtt_PackFontRange DD 011901H
	DD	0c219H
$unwind$stbtt_PackFontRanges DD 021b01H
	DD	01f011bH
$unwind$stbtt_PackSetOversampling DD 011201H
	DD	04212H
$unwind$stbtt_GetPackedQuad DD 011701H
	DD	08217H
$unwind$stbtt_PackFontRangesGatherRects DD 021b01H
	DD	013011bH
$unwind$stbtt_PackFontRangesPackRects DD 011301H
	DD	04213H
$unwind$stbtt_PackFontRangesRenderIntoRects DD 041d01H
	DD	01b011dH
	DD	060157016H
$unwind$stbtt_GetNumberOfFonts DD 010901H
	DD	04209H
$unwind$stbtt_GetFontOffsetForIndex DD 010d01H
	DD	0420dH
$unwind$stbtt_InitFont DD 011301H
	DD	04213H
$unwind$stbtt_FindGlyphIndex DD 021001H
	DD	0130110H
$unwind$stbtt_ScaleForPixelHeight DD 010f01H
	DD	0620fH
$unwind$stbtt_ScaleForMappingEmToPixels DD 010f01H
	DD	0620fH
$unwind$stbtt_GetFontVMetrics DD 011801H
	DD	04218H
$unwind$stbtt_GetFontVMetricsOS2 DD 011801H
	DD	06218H
$unwind$stbtt_GetFontBoundingBox DD 011801H
	DD	04218H
$unwind$stbtt_GetCodepointHMetrics DD 011701H
	DD	04217H
$unwind$stbtt_GetCodepointKernAdvance DD 011201H
	DD	06212H
$unwind$stbtt_GetCodepointBox DD 011701H
	DD	06217H
$unwind$stbtt_GetGlyphHMetrics DD 011701H
	DD	06217H
$unwind$stbtt_GetGlyphKernAdvance DD 011201H
	DD	06212H
$unwind$stbtt_GetGlyphBox DD 011701H
	DD	08217H
$unwind$stbtt_GetKerningTableLength DD 010901H
	DD	06209H
$unwind$stbtt_GetKerningTable DD 011301H
	DD	06213H
$unwind$stbtt_IsGlyphEmpty DD 010d01H
	DD	0820dH
$unwind$stbtt_GetCodepointShape DD 011201H
	DD	04212H
$unwind$stbtt_GetGlyphShape DD 011201H
	DD	04212H
$unwind$stbtt_FreeShape DD 010e01H
	DD	0420eH
$unwind$stbtt_FindSVGDoc DD 010d01H
	DD	0a20dH
$unwind$stbtt_GetCodepointSVG DD 011201H
	DD	04212H
$unwind$stbtt_GetGlyphSVG DD 011201H
	DD	08212H
$unwind$stbtt_FreeBitmap DD 010e01H
	DD	0420eH
$unwind$stbtt_GetCodepointBitmap DD 011a01H
	DD	0a21aH
$unwind$stbtt_GetCodepointBitmapSubpixel DD 011b01H
	DD	0a21bH
$unwind$stbtt_MakeCodepointBitmap DD 011801H
	DD	0a218H
$unwind$stbtt_MakeCodepointBitmapSubpixel DD 011801H
	DD	0a218H
$unwind$stbtt_MakeCodepointBitmapSubpixelPrefilter DD 011801H
	DD	0e218H
$unwind$stbtt_GetCodepointBitmapBox DD 011901H
	DD	0a219H
$unwind$stbtt_GetCodepointBitmapBoxSubpixel DD 011901H
	DD	0a219H
$unwind$stbtt_GetGlyphBitmap DD 011a01H
	DD	0a21aH
$unwind$stbtt_GetGlyphBitmapSubpixel DD 021e01H
	DD	015011eH
$unwind$stbtt_MakeGlyphBitmap DD 011801H
	DD	0a218H
$unwind$stbtt_MakeGlyphBitmapSubpixel DD 021b01H
	DD	013011bH
$unwind$stbtt_MakeGlyphBitmapSubpixelPrefilter DD 011801H
	DD	0a218H
$unwind$stbtt_GetGlyphBitmapBox DD 011901H
	DD	0a219H
$unwind$stbtt_GetGlyphBitmapBoxSubpixel DD 011901H
	DD	08219H
$unwind$stbtt_Rasterize DD 021c01H
	DD	011011cH
$unwind$stbtt_FreeSDF DD 010e01H
	DD	0420eH
$unwind$stbtt_GetGlyphSDF DD 022e19H
	DD	03f011cH
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$stbtt_GetCodepointSDF DD 011901H
	DD	0a219H
$unwind$stbtt_FindMatchingFont DD 011301H
	DD	04213H
$unwind$stbtt_CompareUTF8toUTF16_bigendian DD 011701H
	DD	04217H
$unwind$stbtt_GetFontNameString DD 011801H
	DD	0a218H
$unwind$?StringLength@@YAHPEAD@Z DD 010901H
	DD	02209H
$unwind$?CreateString@@YA?AUstring8@@PEAD@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
$unwind$?StringConcat@@YAXPEAUstring8@@U1@@Z DD 010e01H
	DD	0220eH
$unwind$?CompareStringBinary@@YAHUstring8@@0@Z DD 010e01H
	DD	0220eH
$unwind$?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z DD 010e01H
	DD	0620eH
$unwind$?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z DD 021601H
	DD	060157016H
$unwind$?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z DD 042f19H
	DD	065011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0310H
$unwind$?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z DD 043019H
	DD	019011eH
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z DD 042f19H
	DD	0cb011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0640H
$unwind$?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z DD 042f19H
	DD	039011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z DD 043019H
	DD	079011eH
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	03b0H
$unwind$stbi_load_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load DD 011801H
	DD	0a218H
$unwind$stbi_load_from_file DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_load_gif_from_memory DD 022c19H
	DD	029011aH
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_load_16_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_16_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_16 DD 011801H
	DD	0a218H
$unwind$stbi_load_from_file_16 DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_loadf_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_loadf_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_loadf DD 011801H
	DD	0a218H
$unwind$stbi_loadf_from_file DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_is_hdr_from_callbacks DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_hdr_from_memory DD 022219H
	DD	0230110H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_hdr DD 010901H
	DD	06209H
$unwind$stbi_is_hdr_from_file DD 021e19H
	DD	025010cH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_image_free DD 010901H
	DD	04209H
$unwind$stbi_info_from_memory DD 022c19H
	DD	023011aH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_info_from_callbacks DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_16_bit_from_memory DD 022219H
	DD	0230110H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_16_bit_from_callbacks DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_info DD 011801H
	DD	06218H
$unwind$stbi_info_from_file DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_is_16_bit DD 010901H
	DD	06209H
$unwind$stbi_is_16_bit_from_file DD 021e19H
	DD	025010cH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_zlib_decode_malloc_guesssize DD 023219H
	DD	020b0120H
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_malloc_guesssize_headerflag DD 023219H
	DD	020b0120H
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_malloc DD 011201H
	DD	04212H
$unwind$stbi_zlib_decode_buffer DD 023219H
	DD	02090120H
	DD	imagerel __GSHandlerCheck
	DD	01030H
$unwind$stbi_zlib_decode_noheader_malloc DD 022d19H
	DD	020b011bH
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_noheader_buffer DD 023219H
	DD	02090120H
	DD	imagerel __GSHandlerCheck
	DD	01030H
$unwind$?stbi__cpuid3@@YAHXZ DD 021519H
	DD	030023206H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?stbi__sse2_available@@YAHXZ DD 010401H
	DD	06204H
$unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z DD 011301H
	DD	02213H
$unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD 031501H
	DD	070116215H
	DD	06010H
$unwind$?stbi__stdio_read@@YAHPEAXPEADH@Z DD 011301H
	DD	04213H
$unwind$?stbi__stdio_skip@@YAXPEAXH@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__stdio_eof@@YAHPEAX@Z DD 010901H
	DD	06209H
$unwind$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z DD 010e01H
	DD	0420eH
$unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0a218H
$unwind$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0c218H
$unwind$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	0a218H
$unwind$?stbi__png_is16@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	0a209H
$unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 022d19H
	DD	0ab011bH
	DD	imagerel __GSHandlerCheck
	DD	0540H
$unwind$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 031c01H
	DD	020011cH
	DD	07015H
$unwind$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	0a218H
$unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 021b01H
	DD	01f011bH
$unwind$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__psd_is16@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 022d19H
	DD	09d011bH
	DD	imagerel __GSHandlerCheck
	DD	04d0H
$unwind$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z DD 022d19H
	DD	089011bH
	DD	imagerel __GSHandlerCheck
	DD	0430H
$unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 021901H
	DD	07015d219H
$unwind$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z DD 012719H
	DD	0e218H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 033419H
	DD	011180122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	088b0H
$unwind$?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z DD 043519H
	DD	0111f0123H
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	088e0H
$unwind$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0a218H
$unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__malloc@@YAPEAX_K@Z DD 010901H
	DD	04209H
$unwind$?stbi__addsizes_valid@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$?stbi__mul2sizes_valid@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$?stbi__mad2sizes_valid@@YAHHHH@Z DD 011101H
	DD	06211H
$unwind$?stbi__mad3sizes_valid@@YAHHHHH@Z DD 011601H
	DD	06216H
$unwind$?stbi__mad4sizes_valid@@YAHHHHHH@Z DD 011601H
	DD	06216H
$unwind$?stbi__malloc_mad2@@YAPEAXHHH@Z DD 011101H
	DD	04211H
$unwind$?stbi__malloc_mad3@@YAPEAXHHHH@Z DD 011601H
	DD	04216H
$unwind$?stbi__malloc_mad4@@YAPEAXHHHHH@Z DD 011601H
	DD	06216H
$unwind$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z DD 011701H
	DD	0a217H
$unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 021901H
	DD	070159219H
$unwind$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z DD 042e19H
	DD	010b011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0840H
$unwind$?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z DD 011701H
	DD	06217H
$unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z DD 011801H
	DD	06218H
$unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__skip@@YAXPEAUstbi__context@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD 031501H
	DD	070116215H
	DD	06010H
$unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 011701H
	DD	0c217H
$unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD 011701H
	DD	0c217H
$unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 020f01H
	DD	0700b720fH
$unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD 010e01H
	DD	0a20eH
$unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD 021901H
	DD	070159219H
$unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD 021901H
	DD	070157219H
$unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD 021b01H
	DD	011011bH
$unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z DD 022719H
	DD	0390115H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?stbi__idct_simd@@YAXPEAEHQEAF@Z DD 021b01H
	DD	036b011bH
$unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	02209H
$unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z DD 010e01H
	DD	0220eH
$unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD 022219H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD 011201H
	DD	06212H
$unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0c20dH
$unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD 021b01H
	DD	063011bH
$unwind$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD 011801H
	DD	04218H
$unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 021b01H
	DD	08d011bH
$unwind$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__blinn_8x8@@YAEEE@Z DD 010c01H
	DD	0220cH
$unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 022d19H
	DD	03d011bH
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__bit_reverse@@YAHHH@Z DD 010c01H
	DD	0420cH
$unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 032919H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	02209H
$unwind$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD 011301H
	DD	08213H
$unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD 031f19H
	DD	0148010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0a30H
$unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD 030b01H
	DD	07007620bH
	DD	06006H
$unwind$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z DD 011801H
	DD	04218H
$unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__paeth@@YAHHHH@Z DD 011101H
	DD	02211H
$unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD 041d01H
	DD	019011dH
	DD	060157016H
$unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 042f19H
	DD	021011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z DD 011301H
	DD	04213H
$unwind$?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z DD 011301H
	DD	04213H
$unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD 011801H
	DD	0a218H
$unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD 032819H
	DD	09c0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	04d0H
$unwind$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	08218H
$unwind$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__high_bit@@YAHI@Z DD 010801H
	DD	02208H
$unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD 010e01H
	DD	0c20eH
$unwind$?stbi__tga_get_comp@@YAHHHPEAH@Z DD 011101H
	DD	02211H
$unwind$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z DD 011301H
	DD	06213H
$unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD 011201H
	DD	06212H
$unwind$?stbi__copyval@@YAXHPEAEPEBE@Z DD 011201H
	DD	02212H
$unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD 022c19H
	DD	01b011aH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD 011801H
	DD	06218H
$unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 011801H
	DD	06218H
$unwind$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD 021101H
	DD	0110111H
$unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z DD 041d01H
	DD	015011dH
	DD	060157016H
$unwind$?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z DD 011301H
	DD	06213H
$unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD 011301H
	DD	06213H
$unwind$?stbi__pnm_isspace@@YAHD@Z DD 010801H
	DD	02208H
$unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0420eH
$unwind$?stbi__pnm_isdigit@@YAHD@Z DD 010801H
	DD	02208H
$unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__is_16_main@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	04209H
$unwind$?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z DD 010901H
	DD	02209H
$unwind$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z DD 010d01H
	DD	0420dH
$unwind$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z DD 031501H
	DD	070116215H
	DD	06010H
$unwind$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 010901H
	DD	06209H
$unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD 010901H
	DD	06209H
$unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD 031501H
	DD	07011e215H
	DD	06010H
$unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD 031901H
	DD	07015c219H
	DD	06014H
$unwind$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z DD 010901H
	DD	04209H
$unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD 031501H
	DD	07011a215H
	DD	06010H
$unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z DD 011201H
	DD	06212H
$unwind$?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z DD 010901H
	DD	04209H
$unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD 041801H
	DD	0190118H
	DD	060107011H
$unwind$?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z DD 010901H
	DD	06209H
$unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD 041801H
	DD	04b0118H
	DD	060107011H
$unwind$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD 011701H
	DD	0e217H
$unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 011701H
	DD	0a217H
$unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 042919H
	DD	02f0117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 011701H
	DD	06217H
$unwind$?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z DD 010901H
	DD	08209H
$unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD 011501H
	DD	0a215H
$unwind$?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z DD 011501H
	DD	08215H
$unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD 011b01H
	DD	0a21bH
$unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD 041801H
	DD	0110118H
	DD	060107011H
$unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD 041801H
	DD	01d0118H
	DD	060107011H
$unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD 042919H
	DD	05b0117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 021501H
	DD	0130115H
$unwind$?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z DD 011201H
	DD	08212H
$unwind$?stbtt__GetCoverageIndex@@YAHPEAEH@Z DD 021001H
	DD	0110110H
$unwind$?stbtt__GetGlyphClass@@YAHPEAEH@Z DD 010d01H
	DD	0e20dH
$unwind$?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z DD 021501H
	DD	0210115H
$unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD 011301H
	DD	08213H
$unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 010e01H
	DD	0620eH
$unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD 011901H
	DD	08219H
$unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 011801H
	DD	04218H
$unwind$?stbtt__sized_trapezoid_area@@YAMMMM@Z DD 011601H
	DD	04216H
$unwind$?stbtt__position_trapezoid_area@@YAMMMMMM@Z DD 011c01H
	DD	0421cH
$unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 021b01H
	DD	01d011bH
$unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 032e19H
	DD	05c011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 031e19H
	DD	0700ba20fH
	DD	0600aH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 042419H
	DD	0130112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD 010d01H
	DD	0420dH
$unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021b01H
	DD	013011bH
$unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 011a01H
	DD	0c21aH
$unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 021d01H
	DD	01b011dH
$unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 042301H
	DD	0a6823H
	DD	017011bH
$unwind$?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z DD 031c01H
	DD	024011cH
	DD	07015H
$unwind$?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z DD 011301H
	DD	02213H
$unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 022719H
	DD	070149218H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 022719H
	DD	070149218H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z DD 021b01H
	DD	011011bH
$unwind$?equal@@YAHPEAM0@Z DD 010e01H
	DD	0220eH
$unwind$?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z DD 022f19H
	DD	023011dH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$?stbtt__cuberoot@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?stbtt__solve_cubic@@YAHMMMPEAM@Z DD 011b01H
	DD	0a21bH
$unwind$?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z DD 011701H
	DD	0c217H
$unwind$?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z DD 011701H
	DD	06217H
$unwind$?stbtt__matchpair@@YAHPEAEI0HHH@Z DD 011701H
	DD	0c217H
$unwind$?stbtt__matches@@YAHPEAEI0H@Z DD 011701H
	DD	0a217H
$unwind$?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z DD 011301H
	DD	06213H
$unwind$?RunPlayer@@YAXPEAUentity@@M@Z DD 042619H
	DD	04f0114H
	DD	0600c700dH
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$?OnCollidePlayer@@YAXPEAUentity@@0@Z DD 010e01H
	DD	0220eH
$unwind$?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z DD 031501H
	DD	070118215H
	DD	06010H
$unwind$?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z DD 031001H
	DD	0700ce210H
	DD	0600bH
$unwind$?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z DD 010d01H
	DD	0220dH
$unwind$?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z DD 031001H
	DD	0700c8210H
	DD	0600bH
$unwind$?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z DD 031501H
	DD	070118215H
	DD	06010H
$unwind$?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z DD 011201H
	DD	08212H
$unwind$?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z DD 041d01H
	DD	059011dH
	DD	060157016H
$unwind$?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z DD 042a19H
	DD	01050118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0810H
$unwind$?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z DD 042f19H
	DD	01d011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z DD 042f19H
	DD	0125011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0910H
$unwind$?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z DD 031501H
	DD	070118215H
	DD	06010H
$unwind$?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z DD 043619H
	DD	081710124H
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	040b70H
$unwind$?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z DD 010801H
	DD	02208H
$unwind$?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z DD 010801H
	DD	02208H
$unwind$?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z DD 010801H
	DD	02208H
$unwind$?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z DD 042e19H
	DD	02b011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z DD 042e19H
	DD	01f9011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0fb0H
xdata	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
UIIndex$1 = 96
ZIndex$2 = 100
UI$3 = 104
EntityIndex$4 = 112
UIIndex$5 = 116
UIIndex$6 = 120
UIIndex$7 = 124
EntityIndex$8 = 128
Hovered$9 = 132
AlreadyHovered$10 = 136
Selected$11 = 140
UI$12 = 144
UI$13 = 152
Player$14 = 160
UI$15 = 168
UI$16 = 176
tv512 = 184
Type$17 = 188
Length$18 = 192
tv857 = 196
Type$19 = 200
tv867 = 204
tv884 = 208
tv932 = 212
tv953 = 216
UI$20 = 224
Entity$21 = 232
Entity$22 = 240
Length$23 = 248
Aspect$24 = 252
Thickness$25 = 256
Height$26 = 260
Width$27 = 264
Data$28 = 268
FrameArenaSize$29 = 272
Y$30 = 280
tv128 = 288
tv80 = 296
$T31 = 304
$T32 = 320
$T33 = 336
$T34 = 352
$T35 = 368
$T36 = 384
$T37 = 400
$T38 = 416
$T39 = 432
$T40 = 448
$T41 = 464
$T42 = 480
$T43 = 496
$T44 = 512
$T45 = 528
$T46 = 544
$T47 = 560
$T48 = 576
$T49 = 592
$T50 = 608
$T51 = 624
$T52 = 640
$T53 = 656
$T54 = 672
$T55 = 688
$T56 = 704
$T57 = 720
$T58 = 736
$T59 = 752
$T60 = 768
$T61 = 792
$T62 = 808
$T63 = 824
$T64 = 840
$T65 = 856
$T66 = 872
$T67 = 888
$T68 = 904
$T69 = 920
$T70 = 936
$T71 = 952
$T72 = 968
$T73 = 984
$T74 = 1008
$T75 = 1072
$T76 = 1136
$T77 = 1200
$T78 = 1264
$T79 = 1328
$T80 = 2120
Position$81 = 2912
$T82 = 2920
Scale$83 = 2928
$T84 = 2936
$T85 = 2952
$T86 = 2968
$T87 = 2984
$T88 = 3000
$T89 = 3008
Position$90 = 3016
$T91 = 3024
$T92 = 3040
$T93 = 3056
$T94 = 3072
$T95 = 3088
$T96 = 3104
$T97 = 3120
$T98 = 3136
$T99 = 3152
$T100 = 3168
$T101 = 3184
$T102 = 3200
$T103 = 3216
$T104 = 3232
$T105 = 3248
$T106 = 3264
$T107 = 3280
$T108 = 3296
Scale$109 = 3312
Image$110 = 3320
$T111 = 3336
Light$112 = 3360
Projection$113 = 3424
$T114 = 3488
$T115 = 3552
View$116 = 3616
$T117 = 3680
UI$118 = 3744
Indices$119 = 3920
Vertices$120 = 3952
__$ArrayPad$ = 4016
WindowFlags$ = 4064
WindowDimension$ = 4072
Memory$ = 4080
GameInput$ = 4088
DeltaTime$ = 4096
?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z PROC ; GameUpdateAndRender

; 273  : {

$LN72:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 0f
	00 00		 sub	 rsp, 4040		; 00000fc8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	0f 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 274  :     Input = GameInput;

  0002e	48 8b 84 24 f8
	0f 00 00	 mov	 rax, QWORD PTR GameInput$[rsp]
  00036	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?Input@@3PEAUgame_input@@EA, rax

; 275  :     
; 276  :     State = (game_state *)Memory->PermanentStorage;

  0003d	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  00045	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00049	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?State@@3PEAUgame_state@@EA, rax

; 277  :     TranState = (transient_state *)Memory->TransientStorage;

  00050	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  00058	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0005c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?TranState@@3PEAUtransient_state@@EA, rax

; 278  :     
; 279  :     State->Time += DeltaTime;

  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0006a	f3 0f 10 80 f0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+240]
  00072	f3 0f 58 84 24
	00 10 00 00	 addss	 xmm0, DWORD PTR DeltaTime$[rsp]
  0007b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00082	f3 0f 11 80 f0
	00 00 00	 movss	 DWORD PTR [rax+240], xmm0

; 280  :     
; 281  :     Platform = &Memory->Platform;

  0008a	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  00092	48 83 c0 20	 add	 rax, 32			; 00000020H
  00096	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?Platform@@3PEAUplatform_api@@EA, rax

; 282  :     
; 283  :     //
; 284  :     // NOTE(evan): Initialization
; 285  :     //
; 286  :     if(!TranState->IsInitialized)

  0009d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  000a4	83 38 00	 cmp	 DWORD PTR [rax], 0
  000a7	0f 85 29 0e 00
	00		 jne	 $LN20@GameUpdate

; 287  :     {
; 288  :         memory_index FrameArenaSize = Memory->PermanentStorageSize/2;

  000ad	33 d2		 xor	 edx, edx
  000af	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  000b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ba	b9 02 00 00 00	 mov	 ecx, 2
  000bf	48 f7 f1	 div	 rcx
  000c2	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR FrameArenaSize$29[rsp], rax

; 289  :         
; 290  :         InitializeArena(&State->WorldArena, (u8 *)Memory->PermanentStorage + sizeof(game_state),

  000ca	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 2d 80 1a 00
	00		 sub	 rax, 6784		; 00001a80H
  000db	48 8b 8c 24 f0
	0f 00 00	 mov	 rcx, QWORD PTR Memory$[rsp]
  000e3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000e7	48 81 c1 80 1a
	00 00		 add	 rcx, 6784		; 00001a80H
  000ee	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?State@@3PEAUgame_state@@EA
  000f5	48 81 c2 20 01
	00 00		 add	 rdx, 288		; 00000120H
  000fc	48 89 94 24 28
	01 00 00	 mov	 QWORD PTR tv80[rsp], rdx
  00104	4c 8b c0	 mov	 r8, rax
  00107	48 8b d1	 mov	 rdx, rcx
  0010a	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  00112	48 8b c8	 mov	 rcx, rax
  00115	e8 00 00 00 00	 call	 InitializeArena

; 291  :                         Memory->PermanentStorageSize - sizeof(game_state));
; 292  :         InitializeArena(&TranState->FrameArena, (u8 *)Memory->TransientStorage + sizeof(transient_state), FrameArenaSize);

  0011a	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  00122	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00126	48 05 d0 6c 00
	00		 add	 rax, 27856		; 00006cd0H
  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00133	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00137	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR FrameArenaSize$29[rsp]
  0013f	48 8b d0	 mov	 rdx, rax
  00142	e8 00 00 00 00	 call	 InitializeArena

; 293  :         InitializeArena(&TranState->TranArena, (u8 *)Memory->TransientStorage + sizeof(transient_state) + FrameArenaSize,

  00147	48 8b 84 24 f0
	0f 00 00	 mov	 rax, QWORD PTR Memory$[rsp]
  0014f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00153	48 2d d0 6c 00
	00		 sub	 rax, 27856		; 00006cd0H
  00159	48 2b 84 24 10
	01 00 00	 sub	 rax, QWORD PTR FrameArenaSize$29[rsp]
  00161	48 8b 8c 24 f0
	0f 00 00	 mov	 rcx, QWORD PTR Memory$[rsp]
  00169	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0016d	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR FrameArenaSize$29[rsp]
  00175	48 8d 8c 11 d0
	6c 00 00	 lea	 rcx, QWORD PTR [rcx+rdx+27856]
  0017d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00184	48 83 c2 08	 add	 rdx, 8
  00188	48 89 94 24 20
	01 00 00	 mov	 QWORD PTR tv128[rsp], rdx
  00190	4c 8b c0	 mov	 r8, rax
  00193	48 8b d1	 mov	 rdx, rcx
  00196	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv128[rsp]
  0019e	48 8b c8	 mov	 rcx, rax
  001a1	e8 00 00 00 00	 call	 InitializeArena

; 294  :                         Memory->TransientStorageSize - sizeof(transient_state) - FrameArenaSize);
; 295  :         InitializeArena(&State->EntityArena,

  001a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  001ad	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  001b3	ba 00 6c 00 00	 mov	 edx, 27648		; 00006c00H
  001b8	48 8b c8	 mov	 rcx, rax
  001bb	e8 00 00 00 00	 call	 PushSize
  001c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  001c7	48 81 c1 58 04
	00 00		 add	 rcx, 1112		; 00000458H
  001ce	41 b8 00 6c 00
	00		 mov	 r8d, 27648		; 00006c00H
  001d4	48 8b d0	 mov	 rdx, rax
  001d7	e8 00 00 00 00	 call	 InitializeArena

; 296  :                         (u8 *)PushArray(&State->WorldArena, entity, MAX_ENTITY_COUNT),
; 297  :                         sizeof(entity)*MAX_ENTITY_COUNT);
; 298  :         
; 299  :         Platform->ZeroMemory(TranState->Entities, sizeof(entity *)*MAX_ENTITY_COUNT);

  001dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  001e3	48 05 c8 00 00
	00		 add	 rax, 200		; 000000c8H
  001e9	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  001f8	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]

; 300  :         
; 301  :         {
; 302  :             u32 Data[1] =
; 303  :             {
; 304  :                 0xFFFFFFFF

  001fe	c7 84 24 0c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR Data$28[rsp], -1 ; ffffffffH

; 305  :             };
; 306  :             u32 Width = 1;

  00209	c7 84 24 08 01
	00 00 01 00 00
	00		 mov	 DWORD PTR Width$27[rsp], 1

; 307  :             u32 Height = 1;

  00214	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR Height$26[rsp], 1

; 308  :             State->BasicTexture = Platform->CreateTexture(Data, Width, Height);

  0021f	44 8b 84 24 04
	01 00 00	 mov	 r8d, DWORD PTR Height$26[rsp]
  00227	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR Width$27[rsp]
  0022e	48 8d 8c 24 0c
	01 00 00	 lea	 rcx, QWORD PTR Data$28[rsp]
  00236	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0023d	ff 50 40	 call	 QWORD PTR [rax+64]
  00240	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00247	48 89 81 08 01
	00 00		 mov	 QWORD PTR [rcx+264], rax

; 309  :             
; 310  :             ui_vertex Vertices[4] =
; 311  :             {
; 312  :                 { { +1.0f, +1.0f }, { 1.0f, 1.0f } }, // Top right

  0024e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00256	f3 0f 11 84 24
	70 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp], xmm0
  0025f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00267	f3 0f 11 84 24
	74 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+4], xmm0
  00270	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00278	f3 0f 11 84 24
	78 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+8], xmm0
  00281	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00289	f3 0f 11 84 24
	7c 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+12], xmm0

; 313  :                 { { +1.0f, -1.0f }, { 1.0f, 0.0f } }, // Bottom right

  00292	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0029a	f3 0f 11 84 24
	80 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+16], xmm0
  002a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002ab	f3 0f 11 84 24
	84 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+20], xmm0
  002b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002bc	f3 0f 11 84 24
	88 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+24], xmm0
  002c5	0f 57 c0	 xorps	 xmm0, xmm0
  002c8	f3 0f 11 84 24
	8c 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+28], xmm0

; 314  :                 { { -1.0f, -1.0f }, { 0.0f, 0.0f } }, // Bottom left

  002d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002d9	f3 0f 11 84 24
	90 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+32], xmm0
  002e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002ea	f3 0f 11 84 24
	94 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+36], xmm0
  002f3	0f 57 c0	 xorps	 xmm0, xmm0
  002f6	f3 0f 11 84 24
	98 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+40], xmm0
  002ff	0f 57 c0	 xorps	 xmm0, xmm0
  00302	f3 0f 11 84 24
	9c 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+44], xmm0

; 315  :                 { { -1.0f, +1.0f }, { 0.0f, 1.0f } }  // Top left

  0030b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00313	f3 0f 11 84 24
	a0 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+48], xmm0
  0031c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00324	f3 0f 11 84 24
	a4 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+52], xmm0
  0032d	0f 57 c0	 xorps	 xmm0, xmm0
  00330	f3 0f 11 84 24
	a8 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+56], xmm0
  00339	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00341	f3 0f 11 84 24
	ac 0f 00 00	 movss	 DWORD PTR Vertices$120[rsp+60], xmm0

; 316  :             };
; 317  :             
; 318  :             u32 Indices[6] =
; 319  :             {
; 320  :                 0, 1, 3,

  0034a	c7 84 24 50 0f
	00 00 00 00 00
	00		 mov	 DWORD PTR Indices$119[rsp], 0
  00355	c7 84 24 54 0f
	00 00 01 00 00
	00		 mov	 DWORD PTR Indices$119[rsp+4], 1
  00360	c7 84 24 58 0f
	00 00 03 00 00
	00		 mov	 DWORD PTR Indices$119[rsp+8], 3

; 321  :                 1, 2, 3

  0036b	c7 84 24 5c 0f
	00 00 01 00 00
	00		 mov	 DWORD PTR Indices$119[rsp+12], 1
  00376	c7 84 24 60 0f
	00 00 02 00 00
	00		 mov	 DWORD PTR Indices$119[rsp+16], 2
  00381	c7 84 24 64 0f
	00 00 03 00 00
	00		 mov	 DWORD PTR Indices$119[rsp+20], 3

; 322  :             };
; 323  :             State->Quad = Platform->CreateMesh(Vertices, ArrayCount(Vertices),

  0038c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00394	41 b9 06 00 00
	00		 mov	 r9d, 6
  0039a	4c 8d 84 24 50
	0f 00 00	 lea	 r8, QWORD PTR Indices$119[rsp]
  003a2	ba 04 00 00 00	 mov	 edx, 4
  003a7	48 8d 8c 24 70
	0f 00 00	 lea	 rcx, QWORD PTR Vertices$120[rsp]
  003af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  003b6	ff 50 30	 call	 QWORD PTR [rax+48]
  003b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  003c0	48 89 81 00 01
	00 00		 mov	 QWORD PTR [rcx+256], rax

; 324  :                                                Indices, ArrayCount(Indices), true);
; 325  :         }
; 326  :         
; 327  :         State->Font = LoadFont(L"../assets/RandyGG.ttf", &TranState->TranArena, 32.0f);

  003c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  003ce	48 83 c0 08	 add	 rax, 8
  003d2	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@42000000
  003da	4c 8b c0	 mov	 r8, rax
  003dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46646
  003e4	48 8d 8c 24 48
	08 00 00	 lea	 rcx, QWORD PTR $T80[rsp]
  003ec	e8 00 00 00 00	 call	 ?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z ; LoadFont
  003f1	48 8d 8c 24 30
	05 00 00	 lea	 rcx, QWORD PTR $T79[rsp]
  003f9	48 8b f9	 mov	 rdi, rcx
  003fc	48 8b f0	 mov	 rsi, rax
  003ff	b9 18 03 00 00	 mov	 ecx, 792		; 00000318H
  00404	f3 a4		 rep movsb
  00406	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0040d	48 8d 8c 24 30
	05 00 00	 lea	 rcx, QWORD PTR $T79[rsp]
  00415	48 8d b8 40 01
	00 00		 lea	 rdi, QWORD PTR [rax+320]
  0041c	48 8b f1	 mov	 rsi, rcx
  0041f	b9 18 03 00 00	 mov	 ecx, 792		; 00000318H
  00424	f3 a4		 rep movsb

; 328  :         
; 329  :         // NOTE(evan): Sounds
; 330  :         *GetSoundAsset(SID_EXPLOSION) = Platform->CreateSound(L"../assets/sound.wav", 0.5f, &State->WorldArena);

  00426	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0042d	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00433	4c 8b c8	 mov	 r9, rax
  00436	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  0043e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46647
  00445	48 8d 8c 24 d8
	03 00 00	 lea	 rcx, QWORD PTR $T73[rsp]
  0044d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00454	ff 50 58	 call	 QWORD PTR [rax+88]
  00457	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR $T60[rsp]
  0045f	48 8b f9	 mov	 rdi, rcx
  00462	48 8b f0	 mov	 rsi, rax
  00465	b9 18 00 00 00	 mov	 ecx, 24
  0046a	f3 a4		 rep movsb
  0046c	b9 01 00 00 00	 mov	 ecx, 1
  00471	e8 00 00 00 00	 call	 ?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z ; GetSoundAsset
  00476	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR $T60[rsp]
  0047e	48 8b f8	 mov	 rdi, rax
  00481	48 8b f1	 mov	 rsi, rcx
  00484	b9 18 00 00 00	 mov	 ecx, 24
  00489	f3 a4		 rep movsb

; 331  :         
; 332  :         // NOTE(evan): Images
; 333  :         *GetImageAsset(IID_SMILE) = CreateImage("../assets/test.png", &State->WorldArena);

  0048b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00492	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00498	4c 8b c0	 mov	 r8, rax
  0049b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46648
  004a2	48 8d 8c 24 c8
	03 00 00	 lea	 rcx, QWORD PTR $T72[rsp]
  004aa	e8 00 00 00 00	 call	 ?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z ; CreateImage
  004af	48 8d 8c 24 08
	0d 00 00	 lea	 rcx, QWORD PTR $T111[rsp]
  004b7	48 8b f9	 mov	 rdi, rcx
  004ba	48 8b f0	 mov	 rsi, rax
  004bd	b9 10 00 00 00	 mov	 ecx, 16
  004c2	f3 a4		 rep movsb
  004c4	b9 01 00 00 00	 mov	 ecx, 1
  004c9	e8 00 00 00 00	 call	 ?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z ; GetImageAsset
  004ce	48 8d 8c 24 08
	0d 00 00	 lea	 rcx, QWORD PTR $T111[rsp]
  004d6	48 8b f8	 mov	 rdi, rax
  004d9	48 8b f1	 mov	 rsi, rcx
  004dc	b9 10 00 00 00	 mov	 ecx, 16
  004e1	f3 a4		 rep movsb

; 334  :         
; 335  :         // NOTE(evan): Models
; 336  :         *GetModelAsset(MID_SCENE) = LoadGLTF("../assets/models/scene.gltf", &State->WorldArena);

  004e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  004ea	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  004f0	4c 8b c0	 mov	 r8, rax
  004f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46649
  004fa	48 8d 8c 24 b8
	03 00 00	 lea	 rcx, QWORD PTR $T71[rsp]
  00502	e8 00 00 00 00	 call	 ?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z ; LoadGLTF
  00507	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR $T47[rsp]
  0050f	48 8b f9	 mov	 rdi, rcx
  00512	48 8b f0	 mov	 rsi, rax
  00515	b9 10 00 00 00	 mov	 ecx, 16
  0051a	f3 a4		 rep movsb
  0051c	b9 03 00 00 00	 mov	 ecx, 3
  00521	e8 00 00 00 00	 call	 ?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z ; GetModelAsset
  00526	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR $T47[rsp]
  0052e	48 8b f8	 mov	 rdi, rax
  00531	48 8b f1	 mov	 rsi, rcx
  00534	b9 10 00 00 00	 mov	 ecx, 16
  00539	f3 a4		 rep movsb

; 337  :         *GetModelAsset(MID_SPHERE) = LoadGLTF("../assets/models/primitives/sphere.gltf", &State->WorldArena);

  0053b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00542	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00548	4c 8b c0	 mov	 r8, rax
  0054b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46650
  00552	48 8d 8c 24 a8
	03 00 00	 lea	 rcx, QWORD PTR $T70[rsp]
  0055a	e8 00 00 00 00	 call	 ?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z ; LoadGLTF
  0055f	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  00567	48 8b f9	 mov	 rdi, rcx
  0056a	48 8b f0	 mov	 rsi, rax
  0056d	b9 10 00 00 00	 mov	 ecx, 16
  00572	f3 a4		 rep movsb
  00574	b9 02 00 00 00	 mov	 ecx, 2
  00579	e8 00 00 00 00	 call	 ?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z ; GetModelAsset
  0057e	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  00586	48 8b f8	 mov	 rdi, rax
  00589	48 8b f1	 mov	 rsi, rcx
  0058c	b9 10 00 00 00	 mov	 ecx, 16
  00591	f3 a4		 rep movsb

; 338  :         *GetModelAsset(MID_BEAN) = LoadGLTF("../assets/models/primitives/bean.gltf", &State->WorldArena);

  00593	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0059a	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  005a0	4c 8b c0	 mov	 r8, rax
  005a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46651
  005aa	48 8d 8c 24 98
	03 00 00	 lea	 rcx, QWORD PTR $T69[rsp]
  005b2	e8 00 00 00 00	 call	 ?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z ; LoadGLTF
  005b7	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  005bf	48 8b f9	 mov	 rdi, rcx
  005c2	48 8b f0	 mov	 rsi, rax
  005c5	b9 10 00 00 00	 mov	 ecx, 16
  005ca	f3 a4		 rep movsb
  005cc	b9 01 00 00 00	 mov	 ecx, 1
  005d1	e8 00 00 00 00	 call	 ?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z ; GetModelAsset
  005d6	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  005de	48 8b f8	 mov	 rdi, rax
  005e1	48 8b f1	 mov	 rsi, rcx
  005e4	b9 10 00 00 00	 mov	 ecx, 16
  005e9	f3 a4		 rep movsb

; 339  :         
; 340  :         CreateEntity(0, false, {}, MID_SCENE, {}, V3(1.0f, 1.0f, 1.0f), {});

  005eb	48 8d 84 24 c0
	0c 00 00	 lea	 rax, QWORD PTR $T106[rsp]
  005f3	48 8b f8	 mov	 rdi, rax
  005f6	33 c0		 xor	 eax, eax
  005f8	b9 0c 00 00 00	 mov	 ecx, 12
  005fd	f3 aa		 rep stosb
  005ff	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00607	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  0060f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00617	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR $T57[rsp]
  0061f	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00624	48 8d 8c 24 b0
	0c 00 00	 lea	 rcx, QWORD PTR $T105[rsp]
  0062c	48 8b f9	 mov	 rdi, rcx
  0062f	48 8b f0	 mov	 rsi, rax
  00632	b9 0c 00 00 00	 mov	 ecx, 12
  00637	f3 a4		 rep movsb
  00639	48 8d 84 24 d0
	0c 00 00	 lea	 rax, QWORD PTR $T107[rsp]
  00641	48 8b f8	 mov	 rdi, rax
  00644	33 c0		 xor	 eax, eax
  00646	b9 0c 00 00 00	 mov	 ecx, 12
  0064b	f3 aa		 rep stosb
  0064d	48 8d 84 24 a0
	0d 00 00	 lea	 rax, QWORD PTR $T114[rsp]
  00655	48 8b f8	 mov	 rdi, rax
  00658	33 c0		 xor	 eax, eax
  0065a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0065f	f3 aa		 rep stosb
  00661	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR $T41[rsp]
  00669	48 8d 8c 24 c0
	0c 00 00	 lea	 rcx, QWORD PTR $T106[rsp]
  00671	48 8b f8	 mov	 rdi, rax
  00674	48 8b f1	 mov	 rsi, rcx
  00677	b9 0c 00 00 00	 mov	 ecx, 12
  0067c	f3 a4		 rep movsb
  0067e	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR $T42[rsp]
  00686	48 8d 8c 24 b0
	0c 00 00	 lea	 rcx, QWORD PTR $T105[rsp]
  0068e	48 8b f8	 mov	 rdi, rax
  00691	48 8b f1	 mov	 rsi, rcx
  00694	b9 0c 00 00 00	 mov	 ecx, 12
  00699	f3 a4		 rep movsb
  0069b	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR $T43[rsp]
  006a3	48 8d 8c 24 d0
	0c 00 00	 lea	 rcx, QWORD PTR $T107[rsp]
  006ab	48 8b f8	 mov	 rdi, rax
  006ae	48 8b f1	 mov	 rsi, rcx
  006b1	b9 0c 00 00 00	 mov	 ecx, 12
  006b6	f3 a4		 rep movsb
  006b8	48 8d 84 24 f0
	04 00 00	 lea	 rax, QWORD PTR $T78[rsp]
  006c0	48 8d 8c 24 a0
	0d 00 00	 lea	 rcx, QWORD PTR $T114[rsp]
  006c8	48 8b f8	 mov	 rdi, rax
  006cb	48 8b f1	 mov	 rsi, rcx
  006ce	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  006d3	f3 a4		 rep movsb
  006d5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  006de	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  006e7	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR $T41[rsp]
  006ef	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  006f4	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR $T42[rsp]
  006fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00701	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR $T43[rsp]
  00709	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0070e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00714	4c 8d 84 24 f0
	04 00 00	 lea	 r8, QWORD PTR $T78[rsp]
  0071c	33 d2		 xor	 edx, edx
  0071e	33 c9		 xor	 ecx, ecx
  00720	e8 00 00 00 00	 call	 ?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z ; CreateEntity

; 341  :         entity *Player = CreateEntity(0, false, {}, MID_NONE, V3(0.0f, 10.0f, 0.0f), V3(1.0f, 1.0f, 1.0f), {}, RunPlayer);

  00725	48 8d 84 24 a0
	0c 00 00	 lea	 rax, QWORD PTR $T104[rsp]
  0072d	48 8b f8	 mov	 rdi, rax
  00730	33 c0		 xor	 eax, eax
  00732	b9 0c 00 00 00	 mov	 ecx, 12
  00737	f3 aa		 rep stosb
  00739	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00741	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00749	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00751	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR $T58[rsp]
  00759	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  0075e	48 8d 8c 24 90
	0c 00 00	 lea	 rcx, QWORD PTR $T103[rsp]
  00766	48 8b f9	 mov	 rdi, rcx
  00769	48 8b f0	 mov	 rsi, rax
  0076c	b9 0c 00 00 00	 mov	 ecx, 12
  00771	f3 a4		 rep movsb
  00773	0f 57 db	 xorps	 xmm3, xmm3
  00776	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@41200000
  0077e	0f 57 c9	 xorps	 xmm1, xmm1
  00781	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR $T59[rsp]
  00789	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  0078e	48 8d 8c 24 80
	0c 00 00	 lea	 rcx, QWORD PTR $T102[rsp]
  00796	48 8b f9	 mov	 rdi, rcx
  00799	48 8b f0	 mov	 rsi, rax
  0079c	b9 0c 00 00 00	 mov	 ecx, 12
  007a1	f3 a4		 rep movsb
  007a3	48 8d 84 24 60
	0e 00 00	 lea	 rax, QWORD PTR $T117[rsp]
  007ab	48 8b f8	 mov	 rdi, rax
  007ae	33 c0		 xor	 eax, eax
  007b0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  007b5	f3 aa		 rep stosb
  007b7	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR $T32[rsp]
  007bf	48 8d 8c 24 a0
	0c 00 00	 lea	 rcx, QWORD PTR $T104[rsp]
  007c7	48 8b f8	 mov	 rdi, rax
  007ca	48 8b f1	 mov	 rsi, rcx
  007cd	b9 0c 00 00 00	 mov	 ecx, 12
  007d2	f3 a4		 rep movsb
  007d4	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR $T33[rsp]
  007dc	48 8d 8c 24 90
	0c 00 00	 lea	 rcx, QWORD PTR $T103[rsp]
  007e4	48 8b f8	 mov	 rdi, rax
  007e7	48 8b f1	 mov	 rsi, rcx
  007ea	b9 0c 00 00 00	 mov	 ecx, 12
  007ef	f3 a4		 rep movsb
  007f1	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR $T34[rsp]
  007f9	48 8d 8c 24 80
	0c 00 00	 lea	 rcx, QWORD PTR $T102[rsp]
  00801	48 8b f8	 mov	 rdi, rax
  00804	48 8b f1	 mov	 rsi, rcx
  00807	b9 0c 00 00 00	 mov	 ecx, 12
  0080c	f3 a4		 rep movsb
  0080e	48 8d 84 24 b0
	04 00 00	 lea	 rax, QWORD PTR $T77[rsp]
  00816	48 8d 8c 24 60
	0e 00 00	 lea	 rcx, QWORD PTR $T117[rsp]
  0081e	48 8b f8	 mov	 rdi, rax
  00821	48 8b f1	 mov	 rsi, rcx
  00824	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00829	f3 a4		 rep movsb
  0082b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00834	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?RunPlayer@@YAXPEAUentity@@M@Z ; RunPlayer
  0083b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00840	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR $T32[rsp]
  00848	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0084d	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR $T33[rsp]
  00855	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0085a	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR $T34[rsp]
  00862	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00867	45 33 c9	 xor	 r9d, r9d
  0086a	4c 8d 84 24 b0
	04 00 00	 lea	 r8, QWORD PTR $T77[rsp]
  00872	33 d2		 xor	 edx, edx
  00874	33 c9		 xor	 ecx, ecx
  00876	e8 00 00 00 00	 call	 ?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z ; CreateEntity
  0087b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR Player$14[rsp], rax

; 342  :         CreateEntity(Player, false, {}, MID_BEAN, V3(0.0f, 0.0f, 0.0f), V3(1.0f, 1.0f, 1.0f), {}, 0, OnCollidePlayer);

  00883	48 8d 84 24 70
	0c 00 00	 lea	 rax, QWORD PTR $T101[rsp]
  0088b	48 8b f8	 mov	 rdi, rax
  0088e	33 c0		 xor	 eax, eax
  00890	b9 0c 00 00 00	 mov	 ecx, 12
  00895	f3 aa		 rep stosb
  00897	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0089f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  008a7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  008af	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR $T54[rsp]
  008b7	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  008bc	48 8d 8c 24 60
	0c 00 00	 lea	 rcx, QWORD PTR $T100[rsp]
  008c4	48 8b f9	 mov	 rdi, rcx
  008c7	48 8b f0	 mov	 rsi, rax
  008ca	b9 0c 00 00 00	 mov	 ecx, 12
  008cf	f3 a4		 rep movsb
  008d1	0f 57 db	 xorps	 xmm3, xmm3
  008d4	0f 57 d2	 xorps	 xmm2, xmm2
  008d7	0f 57 c9	 xorps	 xmm1, xmm1
  008da	48 8d 8c 24 18
	03 00 00	 lea	 rcx, QWORD PTR $T61[rsp]
  008e2	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  008e7	48 8d 8c 24 50
	0c 00 00	 lea	 rcx, QWORD PTR $T99[rsp]
  008ef	48 8b f9	 mov	 rdi, rcx
  008f2	48 8b f0	 mov	 rsi, rax
  008f5	b9 0c 00 00 00	 mov	 ecx, 12
  008fa	f3 a4		 rep movsb
  008fc	48 8d 84 24 e0
	0d 00 00	 lea	 rax, QWORD PTR $T115[rsp]
  00904	48 8b f8	 mov	 rdi, rax
  00907	33 c0		 xor	 eax, eax
  00909	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0090e	f3 aa		 rep stosb
  00910	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR $T38[rsp]
  00918	48 8d 8c 24 70
	0c 00 00	 lea	 rcx, QWORD PTR $T101[rsp]
  00920	48 8b f8	 mov	 rdi, rax
  00923	48 8b f1	 mov	 rsi, rcx
  00926	b9 0c 00 00 00	 mov	 ecx, 12
  0092b	f3 a4		 rep movsb
  0092d	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR $T39[rsp]
  00935	48 8d 8c 24 60
	0c 00 00	 lea	 rcx, QWORD PTR $T100[rsp]
  0093d	48 8b f8	 mov	 rdi, rax
  00940	48 8b f1	 mov	 rsi, rcx
  00943	b9 0c 00 00 00	 mov	 ecx, 12
  00948	f3 a4		 rep movsb
  0094a	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR $T40[rsp]
  00952	48 8d 8c 24 50
	0c 00 00	 lea	 rcx, QWORD PTR $T99[rsp]
  0095a	48 8b f8	 mov	 rdi, rax
  0095d	48 8b f1	 mov	 rsi, rcx
  00960	b9 0c 00 00 00	 mov	 ecx, 12
  00965	f3 a4		 rep movsb
  00967	48 8d 84 24 70
	04 00 00	 lea	 rax, QWORD PTR $T76[rsp]
  0096f	48 8d 8c 24 e0
	0d 00 00	 lea	 rcx, QWORD PTR $T115[rsp]
  00977	48 8b f8	 mov	 rdi, rax
  0097a	48 8b f1	 mov	 rsi, rcx
  0097d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00982	f3 a4		 rep movsb
  00984	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?OnCollidePlayer@@YAXPEAUentity@@0@Z ; OnCollidePlayer
  0098b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00990	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00999	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR $T38[rsp]
  009a1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  009a6	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR $T39[rsp]
  009ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  009b3	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR $T40[rsp]
  009bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009c0	41 b9 01 00 00
	00		 mov	 r9d, 1
  009c6	4c 8d 84 24 70
	04 00 00	 lea	 r8, QWORD PTR $T76[rsp]
  009ce	33 d2		 xor	 edx, edx
  009d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Player$14[rsp]
  009d8	e8 00 00 00 00	 call	 ?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z ; CreateEntity

; 343  :         
; 344  :         InitializeCamera(&Player->Camera, Player->Position, Player->Position, Player->Position, 60, 0.01f, 100.0f);

  009dd	48 8d 84 24 00
	02 00 00	 lea	 rax, QWORD PTR $T44[rsp]
  009e5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Player$14[rsp]
  009ed	48 8b f8	 mov	 rdi, rax
  009f0	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  009f4	b9 0c 00 00 00	 mov	 ecx, 12
  009f9	f3 a4		 rep movsb
  009fb	48 8d 84 24 10
	02 00 00	 lea	 rax, QWORD PTR $T45[rsp]
  00a03	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Player$14[rsp]
  00a0b	48 8b f8	 mov	 rdi, rax
  00a0e	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00a12	b9 0c 00 00 00	 mov	 ecx, 12
  00a17	f3 a4		 rep movsb
  00a19	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR $T31[rsp]
  00a21	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR Player$14[rsp]
  00a29	48 8b f8	 mov	 rdi, rax
  00a2c	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00a30	b9 0c 00 00 00	 mov	 ecx, 12
  00a35	f3 a4		 rep movsb
  00a37	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Player$14[rsp]
  00a3f	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00a45	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00a4d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00a53	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  00a5b	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00a61	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42700000
  00a69	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00a6f	4c 8d 8c 24 00
	02 00 00	 lea	 r9, QWORD PTR $T44[rsp]
  00a77	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR $T45[rsp]
  00a7f	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR $T31[rsp]
  00a87	48 8b c8	 mov	 rcx, rax
  00a8a	e8 00 00 00 00	 call	 ?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z ; InitializeCamera

; 345  :         State->Camera = &Player->Camera;

  00a8f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR Player$14[rsp]
  00a97	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  00a9d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00aa4	48 89 81 f8 00
	00 00		 mov	 QWORD PTR [rcx+248], rax

; 346  :         
; 347  :         State->DirLight.Direction = V3(-0.2f, -1.0f, -0.3f);

  00aab	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@be99999a
  00ab3	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@bf800000
  00abb	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@be4ccccd
  00ac3	48 8d 8c 24 28
	03 00 00	 lea	 rcx, QWORD PTR $T62[rsp]
  00acb	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00ad0	48 8d 8c 24 e0
	0b 00 00	 lea	 rcx, QWORD PTR $T92[rsp]
  00ad8	48 8b f9	 mov	 rdi, rcx
  00adb	48 8b f0	 mov	 rsi, rax
  00ade	b9 0c 00 00 00	 mov	 ecx, 12
  00ae3	f3 a4		 rep movsb
  00ae5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00aec	48 8d 8c 24 e0
	0b 00 00	 lea	 rcx, QWORD PTR $T92[rsp]
  00af4	48 8d b8 b4 00
	00 00		 lea	 rdi, QWORD PTR [rax+180]
  00afb	48 8b f1	 mov	 rsi, rcx
  00afe	b9 0c 00 00 00	 mov	 ecx, 12
  00b03	f3 a4		 rep movsb

; 348  :         State->DirLight.Ambient = V3(0.1f, 0.1f, 0.1f);

  00b05	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  00b0d	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00b15	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3dcccccd
  00b1d	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR $T63[rsp]
  00b25	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00b2a	48 8d 8c 24 d0
	0b 00 00	 lea	 rcx, QWORD PTR $T91[rsp]
  00b32	48 8b f9	 mov	 rdi, rcx
  00b35	48 8b f0	 mov	 rsi, rax
  00b38	b9 0c 00 00 00	 mov	 ecx, 12
  00b3d	f3 a4		 rep movsb
  00b3f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00b46	48 8d 8c 24 d0
	0b 00 00	 lea	 rcx, QWORD PTR $T91[rsp]
  00b4e	48 8d b8 c4 00
	00 00		 lea	 rdi, QWORD PTR [rax+196]
  00b55	48 8b f1	 mov	 rsi, rcx
  00b58	b9 0c 00 00 00	 mov	 ecx, 12
  00b5d	f3 a4		 rep movsb

; 349  :         State->DirLight.Diffuse = V3(0.3f, 0.3f, 0.3f);

  00b5f	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3e99999a
  00b67	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3e99999a
  00b6f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3e99999a
  00b77	48 8d 8c 24 48
	03 00 00	 lea	 rcx, QWORD PTR $T64[rsp]
  00b7f	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00b84	48 8d 8c 24 e0
	0c 00 00	 lea	 rcx, QWORD PTR $T108[rsp]
  00b8c	48 8b f9	 mov	 rdi, rcx
  00b8f	48 8b f0	 mov	 rsi, rax
  00b92	b9 0c 00 00 00	 mov	 ecx, 12
  00b97	f3 a4		 rep movsb
  00b99	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00ba0	48 8d 8c 24 e0
	0c 00 00	 lea	 rcx, QWORD PTR $T108[rsp]
  00ba8	48 8d b8 d4 00
	00 00		 lea	 rdi, QWORD PTR [rax+212]
  00baf	48 8b f1	 mov	 rsi, rcx
  00bb2	b9 0c 00 00 00	 mov	 ecx, 12
  00bb7	f3 a4		 rep movsb

; 350  :         
; 351  :         {
; 352  :             point_light Light;
; 353  :             Light.Position = V3(0.0f, 3.0f, 0.0f);

  00bb9	0f 57 db	 xorps	 xmm3, xmm3
  00bbc	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40400000
  00bc4	0f 57 c9	 xorps	 xmm1, xmm1
  00bc7	48 8d 8c 24 58
	03 00 00	 lea	 rcx, QWORD PTR $T65[rsp]
  00bcf	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00bd4	48 8d 8c 24 40
	0c 00 00	 lea	 rcx, QWORD PTR $T98[rsp]
  00bdc	48 8b f9	 mov	 rdi, rcx
  00bdf	48 8b f0	 mov	 rsi, rax
  00be2	b9 0c 00 00 00	 mov	 ecx, 12
  00be7	f3 a4		 rep movsb
  00be9	48 8d 84 24 20
	0d 00 00	 lea	 rax, QWORD PTR Light$112[rsp]
  00bf1	48 8d 8c 24 40
	0c 00 00	 lea	 rcx, QWORD PTR $T98[rsp]
  00bf9	48 8b f8	 mov	 rdi, rax
  00bfc	48 8b f1	 mov	 rsi, rcx
  00bff	b9 0c 00 00 00	 mov	 ecx, 12
  00c04	f3 a4		 rep movsb

; 354  :             Light.Constant = 0.1f;

  00c06	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00c0e	f3 0f 11 84 24
	30 0d 00 00	 movss	 DWORD PTR Light$112[rsp+16], xmm0

; 355  :             Light.Linear = 0.9f;

  00c17	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00c1f	f3 0f 11 84 24
	34 0d 00 00	 movss	 DWORD PTR Light$112[rsp+20], xmm0

; 356  :             Light.Quadratic = 0.08f;

  00c28	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3da3d70a
  00c30	f3 0f 11 84 24
	38 0d 00 00	 movss	 DWORD PTR Light$112[rsp+24], xmm0

; 357  :             Light.Ambient = V3(0.1f, 0.1f, 0.1f);

  00c39	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  00c41	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00c49	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3dcccccd
  00c51	48 8d 8c 24 68
	03 00 00	 lea	 rcx, QWORD PTR $T66[rsp]
  00c59	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00c5e	48 8d 8c 24 30
	0c 00 00	 lea	 rcx, QWORD PTR $T97[rsp]
  00c66	48 8b f9	 mov	 rdi, rcx
  00c69	48 8b f0	 mov	 rsi, rax
  00c6c	b9 0c 00 00 00	 mov	 ecx, 12
  00c71	f3 a4		 rep movsb
  00c73	48 8d 84 24 40
	0d 00 00	 lea	 rax, QWORD PTR Light$112[rsp+32]
  00c7b	48 8d 8c 24 30
	0c 00 00	 lea	 rcx, QWORD PTR $T97[rsp]
  00c83	48 8b f8	 mov	 rdi, rax
  00c86	48 8b f1	 mov	 rsi, rcx
  00c89	b9 0c 00 00 00	 mov	 ecx, 12
  00c8e	f3 a4		 rep movsb

; 358  :             Light.Diffuse = V3(0.8f, 0.8f, 0.8f);

  00c90	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f4ccccd
  00c98	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f4ccccd
  00ca0	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f4ccccd
  00ca8	48 8d 8c 24 78
	03 00 00	 lea	 rcx, QWORD PTR $T67[rsp]
  00cb0	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00cb5	48 8d 8c 24 20
	0c 00 00	 lea	 rcx, QWORD PTR $T96[rsp]
  00cbd	48 8b f9	 mov	 rdi, rcx
  00cc0	48 8b f0	 mov	 rsi, rax
  00cc3	b9 0c 00 00 00	 mov	 ecx, 12
  00cc8	f3 a4		 rep movsb
  00cca	48 8d 84 24 50
	0d 00 00	 lea	 rax, QWORD PTR Light$112[rsp+48]
  00cd2	48 8d 8c 24 20
	0c 00 00	 lea	 rcx, QWORD PTR $T96[rsp]
  00cda	48 8b f8	 mov	 rdi, rax
  00cdd	48 8b f1	 mov	 rsi, rcx
  00ce0	b9 0c 00 00 00	 mov	 ecx, 12
  00ce5	f3 a4		 rep movsb

; 359  :             State->PointLight = CreateEntity(0, true, Light, MID_SPHERE,

  00ce7	0f 57 db	 xorps	 xmm3, xmm3
  00cea	0f 57 d2	 xorps	 xmm2, xmm2
  00ced	0f 57 c9	 xorps	 xmm1, xmm1
  00cf0	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR $T68[rsp]
  00cf8	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00cfd	48 8d 8c 24 10
	0c 00 00	 lea	 rcx, QWORD PTR $T95[rsp]
  00d05	48 8b f9	 mov	 rdi, rcx
  00d08	48 8b f0	 mov	 rsi, rax
  00d0b	b9 0c 00 00 00	 mov	 ecx, 12
  00d10	f3 a4		 rep movsb
  00d12	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00d1a	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00d22	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00d2a	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR $T55[rsp]
  00d32	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00d37	48 8d 8c 24 00
	0c 00 00	 lea	 rcx, QWORD PTR $T94[rsp]
  00d3f	48 8b f9	 mov	 rdi, rcx
  00d42	48 8b f0	 mov	 rsi, rax
  00d45	b9 0c 00 00 00	 mov	 ecx, 12
  00d4a	f3 a4		 rep movsb
  00d4c	0f 57 db	 xorps	 xmm3, xmm3
  00d4f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40400000
  00d57	0f 57 c9	 xorps	 xmm1, xmm1
  00d5a	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR $T56[rsp]
  00d62	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00d67	48 8d 8c 24 f0
	0b 00 00	 lea	 rcx, QWORD PTR $T93[rsp]
  00d6f	48 8b f9	 mov	 rdi, rcx
  00d72	48 8b f0	 mov	 rsi, rax
  00d75	b9 0c 00 00 00	 mov	 ecx, 12
  00d7a	f3 a4		 rep movsb
  00d7c	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR $T35[rsp]
  00d84	48 8d 8c 24 10
	0c 00 00	 lea	 rcx, QWORD PTR $T95[rsp]
  00d8c	48 8b f8	 mov	 rdi, rax
  00d8f	48 8b f1	 mov	 rsi, rcx
  00d92	b9 0c 00 00 00	 mov	 ecx, 12
  00d97	f3 a4		 rep movsb
  00d99	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR $T36[rsp]
  00da1	48 8d 8c 24 00
	0c 00 00	 lea	 rcx, QWORD PTR $T94[rsp]
  00da9	48 8b f8	 mov	 rdi, rax
  00dac	48 8b f1	 mov	 rsi, rcx
  00daf	b9 0c 00 00 00	 mov	 ecx, 12
  00db4	f3 a4		 rep movsb
  00db6	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR $T37[rsp]
  00dbe	48 8d 8c 24 f0
	0b 00 00	 lea	 rcx, QWORD PTR $T93[rsp]
  00dc6	48 8b f8	 mov	 rdi, rax
  00dc9	48 8b f1	 mov	 rsi, rcx
  00dcc	b9 0c 00 00 00	 mov	 ecx, 12
  00dd1	f3 a4		 rep movsb
  00dd3	48 8d 84 24 30
	04 00 00	 lea	 rax, QWORD PTR $T75[rsp]
  00ddb	48 8d 8c 24 20
	0d 00 00	 lea	 rcx, QWORD PTR Light$112[rsp]
  00de3	48 8b f8	 mov	 rdi, rax
  00de6	48 8b f1	 mov	 rsi, rcx
  00de9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00dee	f3 a4		 rep movsb
  00df0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00df9	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00e02	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR $T35[rsp]
  00e0a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00e0f	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR $T36[rsp]
  00e17	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00e1c	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR $T37[rsp]
  00e24	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e29	41 b9 02 00 00
	00		 mov	 r9d, 2
  00e2f	4c 8d 84 24 30
	04 00 00	 lea	 r8, QWORD PTR $T75[rsp]
  00e37	ba 01 00 00 00	 mov	 edx, 1
  00e3c	33 c9		 xor	 ecx, ecx
  00e3e	e8 00 00 00 00	 call	 ?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z ; CreateEntity
  00e43	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00e4a	48 89 81 e8 00
	00 00		 mov	 QWORD PTR [rcx+232], rax

; 360  :                                              V3(0.0f, 3.0f, 0.0f), V3(1.0f, 1.0f, 1.0f), V3(0.0f, 0.0f, 0.0f));
; 361  :         }
; 362  :         
; 363  :         State->BasicShader = Platform->CreateShader(L"../code/shaders.hlsl", false);

  00e51	33 d2		 xor	 edx, edx
  00e53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46652
  00e5a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00e61	ff 50 48	 call	 QWORD PTR [rax+72]
  00e64	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00e6b	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 364  :         State->UIShader = Platform->CreateShader(L"../code/ui_shaders.hlsl", true);

  00e72	ba 01 00 00 00	 mov	 edx, 1
  00e77	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46653
  00e7e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00e85	ff 50 48	 call	 QWORD PTR [rax+72]
  00e88	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00e8f	48 89 81 18 01
	00 00		 mov	 QWORD PTR [rcx+280], rax

; 365  :         
; 366  :         State->DevMode = false;

  00e96	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00e9d	c7 80 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+312], 0

; 367  :         State->SelectedUI = -1;

  00ea7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00eae	c7 80 70 1a 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+6768], -1

; 368  :         State->EditorMode = EDITOR_MODE_NONE;

  00eb8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00ebf	c7 80 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+316], 0

; 369  :         
; 370  :         TranState->IsInitialized = true;

  00ec9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00ed0	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN20@GameUpdate:

; 371  :     }
; 372  :     //
; 373  :     //
; 374  :     //
; 375  :     State->WindowDimension = WindowDimension;

  00ed6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00edd	48 8b 8c 24 e8
	0f 00 00	 mov	 rcx, QWORD PTR WindowDimension$[rsp]
  00ee5	48 89 88 ac 00
	00 00		 mov	 QWORD PTR [rax+172], rcx

; 376  :     
; 377  :     for(s32 EntityIndex = 0;

  00eec	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR EntityIndex$4[rsp], 0
  00ef4	eb 0a		 jmp	 SHORT $LN4@GameUpdate
$LN2@GameUpdate:

; 379  :         ++EntityIndex)

  00ef6	8b 44 24 70	 mov	 eax, DWORD PTR EntityIndex$4[rsp]
  00efa	ff c0		 inc	 eax
  00efc	89 44 24 70	 mov	 DWORD PTR EntityIndex$4[rsp], eax
$LN4@GameUpdate:

; 378  :         EntityIndex < TranState->EntityCount;

  00f00	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00f07	8b 80 c8 6c 00
	00		 mov	 eax, DWORD PTR [rax+27848]
  00f0d	39 44 24 70	 cmp	 DWORD PTR EntityIndex$4[rsp], eax
  00f11	7d 5b		 jge	 SHORT $LN3@GameUpdate

; 380  :     {
; 381  :         entity *Entity = &TranState->Entities[EntityIndex];

  00f13	48 63 44 24 70	 movsxd	 rax, DWORD PTR EntityIndex$4[rsp]
  00f18	48 69 c0 d8 00
	00 00		 imul	 rax, rax, 216		; 000000d8H
  00f1f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00f26	48 8d 84 01 c8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+200]
  00f2e	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR Entity$21[rsp], rax

; 382  :         if(Entity && Entity->RunEntity)

  00f36	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR Entity$21[rsp], 0
  00f3f	74 2b		 je	 SHORT $LN21@GameUpdate
  00f41	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Entity$21[rsp]
  00f49	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00f4e	74 1c		 je	 SHORT $LN21@GameUpdate

; 383  :         {
; 384  :             Entity->RunEntity(Entity, DeltaTime);

  00f50	f3 0f 10 8c 24
	00 10 00 00	 movss	 xmm1, DWORD PTR DeltaTime$[rsp]
  00f59	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Entity$21[rsp]
  00f61	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Entity$21[rsp]
  00f69	ff 50 08	 call	 QWORD PTR [rax+8]
$LN21@GameUpdate:

; 385  :         }
; 386  :     }

  00f6c	eb 88		 jmp	 SHORT $LN2@GameUpdate
$LN3@GameUpdate:

; 387  :     
; 388  :     if(Input->Keyboard.Space && !State->LastInput.Keyboard.Space &&

  00f6e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00f75	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00f79	74 59		 je	 SHORT $LN22@GameUpdate
  00f7b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00f82	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00f86	75 4c		 jne	 SHORT $LN22@GameUpdate
  00f88	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00f8f	83 b8 3c 01 00
	00 00		 cmp	 DWORD PTR [rax+316], 0
  00f96	75 3c		 jne	 SHORT $LN22@GameUpdate

; 389  :        State->EditorMode == EDITOR_MODE_NONE)
; 390  :     {
; 391  :         State->DevMode = !State->DevMode;

  00f98	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00f9f	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  00fa6	75 0d		 jne	 SHORT $LN60@GameUpdate
  00fa8	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv512[rsp], 1
  00fb3	eb 0b		 jmp	 SHORT $LN61@GameUpdate
$LN60@GameUpdate:
  00fb5	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv512[rsp], 0
$LN61@GameUpdate:
  00fc0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00fc7	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv512[rsp]
  00fce	89 88 38 01 00
	00		 mov	 DWORD PTR [rax+312], ecx
$LN22@GameUpdate:

; 392  :     }
; 393  :     
; 394  :     if(Input->Keyboard.AltF4 || (WindowFlags & WINDOW_FLAGS_CLOSED))

  00fd4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00fdb	83 78 54 00	 cmp	 DWORD PTR [rax+84], 0
  00fdf	75 0e		 jne	 SHORT $LN24@GameUpdate
  00fe1	8b 84 24 e0 0f
	00 00		 mov	 eax, DWORD PTR WindowFlags$[rsp]
  00fe8	83 e0 01	 and	 eax, 1
  00feb	85 c0		 test	 eax, eax
  00fed	74 0a		 je	 SHORT $LN23@GameUpdate
$LN24@GameUpdate:

; 395  :     {
; 396  :         ShouldClose = true;

  00fef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ShouldClose@@3HA, 1
$LN23@GameUpdate:

; 397  :     }
; 398  :     
; 399  :     if(State->DevMode && State->EditorMode == EDITOR_MODE_NONE &&
; 400  :        Input->Keyboard.One && !State->LastInput.Keyboard.One)

  00ff9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01000	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  01007	0f 84 30 01 00
	00		 je	 $LN25@GameUpdate
  0100d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01014	83 b8 3c 01 00
	00 00		 cmp	 DWORD PTR [rax+316], 0
  0101b	0f 85 1c 01 00
	00		 jne	 $LN25@GameUpdate
  01021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01028	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  0102c	0f 84 0b 01 00
	00		 je	 $LN25@GameUpdate
  01032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01039	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  0103d	0f 85 fa 00 00
	00		 jne	 $LN25@GameUpdate

; 401  :     {
; 402  :         for(s32 UIIndex = 0;

  01043	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR UIIndex$5[rsp], 0
  0104b	eb 0a		 jmp	 SHORT $LN7@GameUpdate
$LN5@GameUpdate:

; 404  :             ++UIIndex)

  0104d	8b 44 24 74	 mov	 eax, DWORD PTR UIIndex$5[rsp]
  01051	ff c0		 inc	 eax
  01053	89 44 24 74	 mov	 DWORD PTR UIIndex$5[rsp], eax
$LN7@GameUpdate:

; 403  :             UIIndex < MAX_UI_COUNT;

  01057	83 7c 24 74 20	 cmp	 DWORD PTR UIIndex$5[rsp], 32 ; 00000020H
  0105c	0f 8d db 00 00
	00		 jge	 $LN6@GameUpdate

; 405  :         {
; 406  :             ui_element *UI = &State->UIElements[UIIndex];

  01062	48 63 44 24 74	 movsxd	 rax, DWORD PTR UIIndex$5[rsp]
  01067	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  0106e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  01075	48 8d 84 01 70
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1136]
  0107d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR UI$13[rsp], rax

; 407  :             
; 408  :             if(UI->IsActive)

  01085	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR UI$13[rsp]
  0108d	83 38 00	 cmp	 DWORD PTR [rax], 0
  01090	74 02		 je	 SHORT $LN26@GameUpdate

; 409  :             {
; 410  :                 continue;

  01092	eb b9		 jmp	 SHORT $LN5@GameUpdate
$LN26@GameUpdate:

; 411  :             }
; 412  :             
; 413  :             UI->IsActive = true;

  01094	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR UI$13[rsp]
  0109c	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 414  :             UI->Image = GetImageAsset(IID_SMILE);

  010a2	b9 01 00 00 00	 mov	 ecx, 1
  010a7	e8 00 00 00 00	 call	 ?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z ; GetImageAsset
  010ac	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR UI$13[rsp]
  010b4	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 415  :             UI->Position.x = (f32)Input->Mouse.X;

  010b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  010bf	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  010c4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR UI$13[rsp]
  010cc	f3 0f 11 80 90
	00 00 00	 movss	 DWORD PTR [rax+144], xmm0

; 416  :             UI->Position.y = (f32)Input->Mouse.Y;

  010d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  010db	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  010e0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR UI$13[rsp]
  010e8	f3 0f 11 80 94
	00 00 00	 movss	 DWORD PTR [rax+148], xmm0

; 417  :             UI->Scale = V2(0.25f, 0.25f);

  010f0	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3e800000
  010f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  01100	e8 00 00 00 00	 call	 ?V2@@YA?ATv2@@MM@Z	; V2
  01105	48 89 84 24 c0
	0b 00 00	 mov	 QWORD PTR $T89[rsp], rax
  0110d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR UI$13[rsp]
  01115	48 8b 8c 24 c0
	0b 00 00	 mov	 rcx, QWORD PTR $T89[rsp]
  0111d	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 418  :             UI->Type = UI_NONE;

  01124	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR UI$13[rsp]
  0112c	c7 80 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+168], 0

; 419  :             
; 420  :             break;

  01136	eb 05		 jmp	 SHORT $LN6@GameUpdate

; 421  :         }

  01138	e9 10 ff ff ff	 jmp	 $LN5@GameUpdate
$LN6@GameUpdate:
$LN25@GameUpdate:

; 422  :     }
; 423  :     
; 424  :     if(State->DevMode && State->EditorMode == EDITOR_MODE_NONE &&
; 425  :        Input->Keyboard.Two && !State->LastInput.Keyboard.Two)

  0113d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01144	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  0114b	0f 84 17 01 00
	00		 je	 $LN27@GameUpdate
  01151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01158	83 b8 3c 01 00
	00 00		 cmp	 DWORD PTR [rax+316], 0
  0115f	0f 85 03 01 00
	00		 jne	 $LN27@GameUpdate
  01165	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0116c	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  01170	0f 84 f2 00 00
	00		 je	 $LN27@GameUpdate
  01176	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0117d	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  01181	0f 85 e1 00 00
	00		 jne	 $LN27@GameUpdate

; 426  :     {
; 427  :         for(s32 UIIndex = 0;

  01187	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR UIIndex$6[rsp], 0
  0118f	eb 0a		 jmp	 SHORT $LN10@GameUpdate
$LN8@GameUpdate:

; 429  :             ++UIIndex)

  01191	8b 44 24 78	 mov	 eax, DWORD PTR UIIndex$6[rsp]
  01195	ff c0		 inc	 eax
  01197	89 44 24 78	 mov	 DWORD PTR UIIndex$6[rsp], eax
$LN10@GameUpdate:

; 428  :             UIIndex < MAX_UI_COUNT;

  0119b	83 7c 24 78 20	 cmp	 DWORD PTR UIIndex$6[rsp], 32 ; 00000020H
  011a0	0f 8d c2 00 00
	00		 jge	 $LN9@GameUpdate

; 430  :         {
; 431  :             ui_element *UI = &State->UIElements[UIIndex];

  011a6	48 63 44 24 78	 movsxd	 rax, DWORD PTR UIIndex$6[rsp]
  011ab	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  011b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  011b9	48 8d 84 01 70
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1136]
  011c1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR UI$15[rsp], rax

; 432  :             
; 433  :             if(UI->IsActive)

  011c9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR UI$15[rsp]
  011d1	83 38 00	 cmp	 DWORD PTR [rax], 0
  011d4	74 02		 je	 SHORT $LN28@GameUpdate

; 434  :             {
; 435  :                 continue;

  011d6	eb b9		 jmp	 SHORT $LN8@GameUpdate
$LN28@GameUpdate:

; 436  :             }
; 437  :             
; 438  :             UI->IsActive = true;

  011d8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR UI$15[rsp]
  011e0	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 439  :             Platform->CopyMemory(UI->String, "EDIT TEXT", StringLength("HELLO, WORLD!"));

  011e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46662
  011ed	e8 00 00 00 00	 call	 ?StringLength@@YAHPEAD@Z ; StringLength
  011f2	48 98		 cdqe
  011f4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR UI$15[rsp]
  011fc	48 83 c1 10	 add	 rcx, 16
  01200	4c 8b c0	 mov	 r8, rax
  01203	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46663
  0120a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  01211	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 440  :             UI->Position.x = (f32)Input->Mouse.X;

  01217	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0121e	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  01223	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR UI$15[rsp]
  0122b	f3 0f 11 80 90
	00 00 00	 movss	 DWORD PTR [rax+144], xmm0

; 441  :             UI->Position.y = (f32)Input->Mouse.Y;

  01233	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0123a	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  0123f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR UI$15[rsp]
  01247	f3 0f 11 80 94
	00 00 00	 movss	 DWORD PTR [rax+148], xmm0

; 442  :             UI->Type = UI_STRING;

  0124f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR UI$15[rsp]
  01257	c7 80 a8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+168], 1

; 443  :             
; 444  :             break;

  01261	eb 05		 jmp	 SHORT $LN9@GameUpdate

; 445  :         }

  01263	e9 29 ff ff ff	 jmp	 $LN8@GameUpdate
$LN9@GameUpdate:
$LN27@GameUpdate:

; 446  :     }
; 447  :     
; 448  :     if(State->DevMode && State->EditorMode == EDITOR_MODE_NONE &&
; 449  :        Input->Keyboard.Three && !State->LastInput.Keyboard.Three)

  01268	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0126f	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  01276	0f 84 85 01 00
	00		 je	 $LN29@GameUpdate
  0127c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01283	83 b8 3c 01 00
	00 00		 cmp	 DWORD PTR [rax+316], 0
  0128a	0f 85 71 01 00
	00		 jne	 $LN29@GameUpdate
  01290	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01297	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0129b	0f 84 60 01 00
	00		 je	 $LN29@GameUpdate
  012a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  012a8	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  012ac	0f 85 4f 01 00
	00		 jne	 $LN29@GameUpdate

; 450  :     {
; 451  :         for(s32 UIIndex = 0;

  012b2	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR UIIndex$7[rsp], 0
  012ba	eb 0a		 jmp	 SHORT $LN13@GameUpdate
$LN11@GameUpdate:

; 453  :             ++UIIndex)

  012bc	8b 44 24 7c	 mov	 eax, DWORD PTR UIIndex$7[rsp]
  012c0	ff c0		 inc	 eax
  012c2	89 44 24 7c	 mov	 DWORD PTR UIIndex$7[rsp], eax
$LN13@GameUpdate:

; 452  :             UIIndex < MAX_UI_COUNT;

  012c6	83 7c 24 7c 20	 cmp	 DWORD PTR UIIndex$7[rsp], 32 ; 00000020H
  012cb	0f 8d 30 01 00
	00		 jge	 $LN12@GameUpdate

; 454  :         {
; 455  :             ui_element *UI = &State->UIElements[UIIndex];

  012d1	48 63 44 24 7c	 movsxd	 rax, DWORD PTR UIIndex$7[rsp]
  012d6	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  012dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  012e4	48 8d 84 01 70
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1136]
  012ec	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR UI$12[rsp], rax

; 456  :             
; 457  :             if(UI->IsActive)

  012f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  012fc	83 38 00	 cmp	 DWORD PTR [rax], 0
  012ff	74 02		 je	 SHORT $LN30@GameUpdate

; 458  :             {
; 459  :                 continue;

  01301	eb b9		 jmp	 SHORT $LN11@GameUpdate
$LN30@GameUpdate:

; 460  :             }
; 461  :             
; 462  :             UI->IsActive = true;

  01303	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  0130b	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 463  :             Platform->CopyMemory(UI->String, "EDIT TEXT", StringLength("HELLO, WORLD!"));

  01311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG46666
  01318	e8 00 00 00 00	 call	 ?StringLength@@YAHPEAD@Z ; StringLength
  0131d	48 98		 cdqe
  0131f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR UI$12[rsp]
  01327	48 83 c1 10	 add	 rcx, 16
  0132b	4c 8b c0	 mov	 r8, rax
  0132e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46667
  01335	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0133c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 464  :             UI->Position.x = (f32)Input->Mouse.X;

  01342	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01349	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  0134e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  01356	f3 0f 11 80 90
	00 00 00	 movss	 DWORD PTR [rax+144], xmm0

; 465  :             UI->Position.y = (f32)Input->Mouse.Y;

  0135e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01365	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  0136a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  01372	f3 0f 11 80 94
	00 00 00	 movss	 DWORD PTR [rax+148], xmm0

; 466  :             UI->Scale = v2{ 30.0f, 30.0f };

  0137a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41f00000
  01382	f3 0f 11 84 24
	68 0b 00 00	 movss	 DWORD PTR $T82[rsp], xmm0
  0138b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41f00000
  01393	f3 0f 11 84 24
	6c 0b 00 00	 movss	 DWORD PTR $T82[rsp+4], xmm0
  0139c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  013a4	48 8b 8c 24 68
	0b 00 00	 mov	 rcx, QWORD PTR $T82[rsp]
  013ac	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 467  :             UI->Thickness = 2.0f;

  013b3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  013bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  013c3	f3 0f 11 80 a0
	00 00 00	 movss	 DWORD PTR [rax+160], xmm0

; 468  :             UI->Toggled = false;

  013cb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR UI$12[rsp]
  013d3	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+164], 0

; 469  :             UI->Type = UI_STRING|UI_TOGGLE;

  013dd	ba 02 00 00 00	 mov	 edx, 2
  013e2	b9 01 00 00 00	 mov	 ecx, 1
  013e7	e8 00 00 00 00	 call	 ??U@YA?AW4ui_type@@W40@0@Z ; operator|
  013ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR UI$12[rsp]
  013f4	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 470  :             
; 471  :             break;

  013fa	eb 05		 jmp	 SHORT $LN12@GameUpdate

; 472  :         }

  013fc	e9 bb fe ff ff	 jmp	 $LN11@GameUpdate
$LN12@GameUpdate:
$LN29@GameUpdate:

; 473  :     }
; 474  :     
; 475  :     if(State->DevMode && State->SelectedUI >= 0)

  01401	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01408	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  0140f	0f 84 b3 01 00
	00		 je	 $LN31@GameUpdate
  01415	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0141c	83 b8 70 1a 00
	00 00		 cmp	 DWORD PTR [rax+6768], 0
  01423	0f 8c 9f 01 00
	00		 jl	 $LN31@GameUpdate

; 476  :     {
; 477  :         ui_element *UI = &State->UIElements[State->SelectedUI];

  01429	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01430	48 63 80 70 1a
	00 00		 movsxd	 rax, DWORD PTR [rax+6768]
  01437	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  0143e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  01445	48 8d 84 01 70
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1136]
  0144d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR UI$16[rsp], rax

; 478  :         
; 479  :         v2 Position = UI->Position;

  01455	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR UI$16[rsp]
  0145d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  01464	48 89 84 24 c8
	0b 00 00	 mov	 QWORD PTR Position$90[rsp], rax

; 480  :         v2 Scale = UI->Scale;

  0146c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR UI$16[rsp]
  01474	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0147b	48 89 84 24 f0
	0c 00 00	 mov	 QWORD PTR Scale$109[rsp], rax

; 481  :         ui_type Type = UI->Type;

  01483	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR UI$16[rsp]
  0148b	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  01491	89 84 24 bc 00
	00 00		 mov	 DWORD PTR Type$17[rsp], eax

; 482  :         
; 483  :         if(Input->Keyboard.Escape)

  01498	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0149f	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  014a3	74 68		 je	 SHORT $LN33@GameUpdate

; 484  :         {
; 485  :             if(State->EditorMode == EDITOR_MODE_UI_MOVE)

  014a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  014ac	83 b8 3c 01 00
	00 01		 cmp	 DWORD PTR [rax+316], 1
  014b3	75 1d		 jne	 SHORT $LN34@GameUpdate

; 486  :             {
; 487  :                 UI->Position = State->OriginalUIPosition;

  014b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  014bc	48 8b 80 74 1a
	00 00		 mov	 rax, QWORD PTR [rax+6772]
  014c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR UI$16[rsp]
  014cb	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
$LN34@GameUpdate:

; 488  :             }
; 489  :             
; 490  :             if(Type & UI_STRING && UI->String[0] == 0)

  014d2	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR Type$17[rsp]
  014d9	83 e0 01	 and	 eax, 1
  014dc	85 c0		 test	 eax, eax
  014de	74 1c		 je	 SHORT $LN35@GameUpdate
  014e0	b8 01 00 00 00	 mov	 eax, 1
  014e5	48 6b c0 00	 imul	 rax, rax, 0
  014e9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR UI$16[rsp]
  014f1	0f be 44 01 10	 movsx	 eax, BYTE PTR [rcx+rax+16]
  014f6	85 c0		 test	 eax, eax
  014f8	75 02		 jne	 SHORT $LN35@GameUpdate

; 491  :             {
; 492  :                 // NOTE(evan): Can't have an empty string taking up precious UI space
; 493  :             }

  014fa	eb 11		 jmp	 SHORT $LN36@GameUpdate
$LN35@GameUpdate:

; 494  :             else
; 495  :             {
; 496  :                 State->EditorMode = EDITOR_MODE_NONE;

  014fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01503	c7 80 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+316], 0
$LN36@GameUpdate:
$LN33@GameUpdate:

; 497  :             }
; 498  :         }
; 499  :         
; 500  :         if(Input->Keyboard.M && State->EditorMode == EDITOR_MODE_NONE)

  0150d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01514	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  01518	74 37		 je	 SHORT $LN37@GameUpdate
  0151a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01521	83 b8 3c 01 00
	00 00		 cmp	 DWORD PTR [rax+316], 0
  01528	75 27		 jne	 SHORT $LN37@GameUpdate

; 501  :         {
; 502  :             State->OriginalUIPosition = Position;

  0152a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01531	48 8b 8c 24 c8
	0b 00 00	 mov	 rcx, QWORD PTR Position$90[rsp]
  01539	48 89 88 74 1a
	00 00		 mov	 QWORD PTR [rax+6772], rcx

; 503  :             State->EditorMode = EDITOR_MODE_UI_MOVE;

  01540	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01547	c7 80 3c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+316], 1
$LN37@GameUpdate:

; 504  :         }
; 505  :         
; 506  :         if(Input->Keyboard.E &&
; 507  :            State->EditorMode == EDITOR_MODE_NONE &&

  01551	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01558	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  0155c	74 3c		 je	 SHORT $LN38@GameUpdate
  0155e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01565	83 b8 3c 01 00
	00 00		 cmp	 DWORD PTR [rax+316], 0
  0156c	75 2c		 jne	 SHORT $LN38@GameUpdate
  0156e	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR Type$17[rsp]
  01575	83 e0 01	 and	 eax, 1
  01578	85 c0		 test	 eax, eax
  0157a	74 1e		 je	 SHORT $LN38@GameUpdate

; 508  :            (Type & UI_STRING))
; 509  :         {
; 510  :             Input->Keyboard.HasChar = false;

  0157c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01583	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 511  :             State->EditorMode = EDITOR_MODE_UI_EDIT;

  01589	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01590	c7 80 3c 01 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+316], 2
$LN38@GameUpdate:

; 512  :         }
; 513  :         
; 514  :         if(Input->Keyboard.Delete)

  0159a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  015a1	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  015a5	74 1f		 je	 SHORT $LN39@GameUpdate

; 515  :         {
; 516  :             UI->IsActive = false;

  015a7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR UI$16[rsp]
  015af	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 517  :             State->SelectedUI = -1;

  015b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  015bc	c7 80 70 1a 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+6768], -1
$LN39@GameUpdate:

; 518  :         }
; 519  :     }

  015c6	eb 21		 jmp	 SHORT $LN32@GameUpdate
$LN31@GameUpdate:

; 520  :     else if(State->SelectedUI <= 0)

  015c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  015cf	83 b8 70 1a 00
	00 00		 cmp	 DWORD PTR [rax+6768], 0
  015d6	7f 11		 jg	 SHORT $LN40@GameUpdate

; 521  :     {
; 522  :         State->EditorMode = EDITOR_MODE_NONE;

  015d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  015df	c7 80 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+316], 0
$LN40@GameUpdate:
$LN32@GameUpdate:

; 523  :     }
; 524  :     
; 525  :     if(State->DevMode && State->EditorMode == EDITOR_MODE_UI_MOVE)

  015e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  015f0	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  015f7	74 5d		 je	 SHORT $LN41@GameUpdate
  015f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01600	83 b8 3c 01 00
	00 01		 cmp	 DWORD PTR [rax+316], 1
  01607	75 4d		 jne	 SHORT $LN41@GameUpdate

; 526  :     {
; 527  :         State->UIElements[State->SelectedUI].Position = V2(Input->Mouse.X, Input->Mouse.Y);

  01609	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01610	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  01613	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0161a	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  0161d	e8 00 00 00 00	 call	 ?V2@@YA?ATv2@@HH@Z	; V2
  01622	48 89 84 24 b8
	0b 00 00	 mov	 QWORD PTR $T88[rsp], rax
  0162a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01631	48 63 80 70 1a
	00 00		 movsxd	 rax, DWORD PTR [rax+6768]
  01638	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  0163f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  01646	48 8b 94 24 b8
	0b 00 00	 mov	 rdx, QWORD PTR $T88[rsp]
  0164e	48 89 94 01 00
	05 00 00	 mov	 QWORD PTR [rcx+rax+1280], rdx
$LN41@GameUpdate:

; 528  :     }
; 529  :     
; 530  :     if(State->DevMode && State->EditorMode == EDITOR_MODE_UI_EDIT)

  01656	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0165d	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  01664	0f 84 f6 00 00
	00		 je	 $LN42@GameUpdate
  0166a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01671	83 b8 3c 01 00
	00 02		 cmp	 DWORD PTR [rax+316], 2
  01678	0f 85 e2 00 00
	00		 jne	 $LN42@GameUpdate

; 531  :     {
; 532  :         ui_element *UI = &State->UIElements[State->SelectedUI];

  0167e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01685	48 63 80 70 1a
	00 00		 movsxd	 rax, DWORD PTR [rax+6768]
  0168c	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  01693	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  0169a	48 8d 84 01 70
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1136]
  016a2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR UI$20[rsp], rax

; 533  :         
; 534  :         if(Input->Keyboard.HasChar)

  016aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  016b1	83 38 00	 cmp	 DWORD PTR [rax], 0
  016b4	74 5d		 je	 SHORT $LN43@GameUpdate

; 535  :         {
; 536  :             s32 Length = StringLength(UI->String);

  016b6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR UI$20[rsp]
  016be	48 83 c0 10	 add	 rax, 16
  016c2	48 8b c8	 mov	 rcx, rax
  016c5	e8 00 00 00 00	 call	 ?StringLength@@YAHPEAD@Z ; StringLength
  016ca	89 84 24 c0 00
	00 00		 mov	 DWORD PTR Length$18[rsp], eax

; 537  :             UI->String[Length] = Input->Keyboard.InputChar;

  016d1	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR Length$18[rsp]
  016d9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR UI$20[rsp]
  016e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?Input@@3PEAUgame_input@@EA
  016e8	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  016ec	88 54 01 10	 mov	 BYTE PTR [rcx+rax+16], dl

; 538  :             UI->String[Length + 1] = 0;

  016f0	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR Length$18[rsp]
  016f7	ff c0		 inc	 eax
  016f9	48 98		 cdqe
  016fb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR UI$20[rsp]
  01703	c6 44 01 10 00	 mov	 BYTE PTR [rcx+rax+16], 0

; 539  :             
; 540  :             int Y = 0;

  01708	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR Y$30[rsp], 0
$LN43@GameUpdate:

; 541  :         }
; 542  :         
; 543  :         if(Input->Keyboard.Backspace && !State->LastInput.Keyboard.Backspace)

  01713	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0171a	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0171e	74 40		 je	 SHORT $LN44@GameUpdate
  01720	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01727	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0172b	75 33		 jne	 SHORT $LN44@GameUpdate

; 544  :         {
; 545  :             s32 Length = StringLength(UI->String);

  0172d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR UI$20[rsp]
  01735	48 83 c0 10	 add	 rax, 16
  01739	48 8b c8	 mov	 rcx, rax
  0173c	e8 00 00 00 00	 call	 ?StringLength@@YAHPEAD@Z ; StringLength
  01741	89 84 24 f8 00
	00 00		 mov	 DWORD PTR Length$23[rsp], eax

; 546  :             UI->String[Length - 1] = 0;

  01748	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR Length$23[rsp]
  0174f	ff c8		 dec	 eax
  01751	48 98		 cdqe
  01753	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR UI$20[rsp]
  0175b	c6 44 01 10 00	 mov	 BYTE PTR [rcx+rax+16], 0
$LN44@GameUpdate:
$LN42@GameUpdate:

; 547  :         }
; 548  :     }
; 549  :     
; 550  :     //
; 551  :     // NOTE(evan): Rendering
; 552  :     //
; 553  :     {
; 554  :         f32 Aspect = (f32)WindowDimension.Width / (f32)WindowDimension.Height;

  01760	8b 84 24 e8 0f
	00 00		 mov	 eax, DWORD PTR WindowDimension$[rsp]
  01767	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  0176c	8b 84 24 ec 0f
	00 00		 mov	 eax, DWORD PTR WindowDimension$[rsp+4]
  01773	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  01778	f3 0f 5e c1	 divss	 xmm0, xmm1
  0177c	f3 0f 11 84 24
	fc 00 00 00	 movss	 DWORD PTR Aspect$24[rsp], xmm0

; 555  :         mat4 Projection;
; 556  :         CreatePerspective(&Projection, Aspect, State->Camera->FOV*DEG_TO_RAD,

  01785	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0178c	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  01793	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  0179a	48 8b 89 f8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+248]
  017a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?State@@3PEAUgame_state@@EA
  017a8	48 8b 92 f8 00
	00 00		 mov	 rdx, QWORD PTR [rdx+248]
  017af	f3 0f 10 42 30	 movss	 xmm0, DWORD PTR [rdx+48]
  017b4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  017bc	f3 0f 10 48 38	 movss	 xmm1, DWORD PTR [rax+56]
  017c1	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  017c7	f3 0f 10 59 34	 movss	 xmm3, DWORD PTR [rcx+52]
  017cc	0f 28 d0	 movaps	 xmm2, xmm0
  017cf	f3 0f 10 8c 24
	fc 00 00 00	 movss	 xmm1, DWORD PTR Aspect$24[rsp]
  017d8	48 8d 8c 24 60
	0d 00 00	 lea	 rcx, QWORD PTR Projection$113[rsp]
  017e0	e8 00 00 00 00	 call	 ?CreatePerspective@@YAXPEATmat4@@MMMM@Z ; CreatePerspective

; 557  :                           State->Camera->Near, State->Camera->Far);
; 558  :         mat4 View;
; 559  :         GetCameraView(State->Camera, &View);

  017e5	48 8d 94 24 20
	0e 00 00	 lea	 rdx, QWORD PTR View$116[rsp]
  017ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  017f4	48 8b 88 f8 00
	00 00		 mov	 rcx, QWORD PTR [rax+248]
  017fb	e8 00 00 00 00	 call	 ?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z ; GetCameraView

; 560  :         
; 561  :         for(s32 EntityIndex = 0;

  01800	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR EntityIndex$8[rsp], 0
  0180b	eb 10		 jmp	 SHORT $LN16@GameUpdate
$LN14@GameUpdate:

; 563  :             ++EntityIndex)

  0180d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR EntityIndex$8[rsp]
  01814	ff c0		 inc	 eax
  01816	89 84 24 80 00
	00 00		 mov	 DWORD PTR EntityIndex$8[rsp], eax
$LN16@GameUpdate:

; 562  :             EntityIndex < TranState->EntityCount;

  0181d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  01824	8b 80 c8 6c 00
	00		 mov	 eax, DWORD PTR [rax+27848]
  0182a	39 84 24 80 00
	00 00		 cmp	 DWORD PTR EntityIndex$8[rsp], eax
  01831	0f 8d d0 00 00
	00		 jge	 $LN15@GameUpdate

; 564  :         {
; 565  :             entity *Entity = &TranState->Entities[EntityIndex];

  01837	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR EntityIndex$8[rsp]
  0183f	48 69 c0 d8 00
	00 00		 imul	 rax, rax, 216		; 000000d8H
  01846	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  0184d	48 8d 84 01 c8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+200]
  01855	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR Entity$22[rsp], rax

; 566  :             if(Entity)

  0185d	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR Entity$22[rsp], 0
  01866	0f 84 96 00 00
	00		 je	 $LN45@GameUpdate

; 567  :             {
; 568  :                 if(Entity->Model)

  0186c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR Entity$22[rsp]
  01874	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0187c	0f 84 80 00 00
	00		 je	 $LN46@GameUpdate

; 569  :                 {
; 570  :                     RenderEntity(Entity, Entity->Parent, State->BasicTexture, State->BasicShader,

  01882	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01889	48 8b 80 e8 00
	00 00		 mov	 rax, QWORD PTR [rax+232]
  01890	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR $T74[rsp]
  01898	48 8b f9	 mov	 rdi, rcx
  0189b	48 8d 70 4c	 lea	 rsi, QWORD PTR [rax+76]
  0189f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  018a4	f3 a4		 rep movsb
  018a6	48 8d 84 24 20
	0e 00 00	 lea	 rax, QWORD PTR View$116[rsp]
  018ae	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  018b3	48 8d 84 24 60
	0d 00 00	 lea	 rax, QWORD PTR Projection$113[rsp]
  018bb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  018c0	48 8d 84 24 f0
	03 00 00	 lea	 rax, QWORD PTR $T74[rsp]
  018c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  018d4	4c 8b 88 10 01
	00 00		 mov	 r9, QWORD PTR [rax+272]
  018db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  018e2	4c 8b 80 08 01
	00 00		 mov	 r8, QWORD PTR [rax+264]
  018e9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR Entity$22[rsp]
  018f1	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  018f5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Entity$22[rsp]
  018fd	e8 00 00 00 00	 call	 ?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z ; RenderEntity
$LN46@GameUpdate:
$LN45@GameUpdate:

; 571  :                                  State->PointLight->Light, &Projection, &View);
; 572  :                 }
; 573  :             }
; 574  :         }

  01902	e9 06 ff ff ff	 jmp	 $LN14@GameUpdate
$LN15@GameUpdate:

; 575  :         
; 576  :         CreateOrthographic(&Projection,

  01907	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0190e	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  01915	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  0191c	48 8b 89 f8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+248]
  01923	8b 94 24 ec 0f
	00 00		 mov	 edx, DWORD PTR WindowDimension$[rsp+4]
  0192a	f3 48 0f 2a c2	 cvtsi2ss xmm0, rdx
  0192f	8b 94 24 e8 0f
	00 00		 mov	 edx, DWORD PTR WindowDimension$[rsp]
  01936	f3 48 0f 2a ca	 cvtsi2ss xmm1, rdx
  0193b	f3 0f 10 50 38	 movss	 xmm2, DWORD PTR [rax+56]
  01940	f3 0f 11 54 24
	30		 movss	 DWORD PTR [rsp+48], xmm2
  01946	f3 0f 10 51 34	 movss	 xmm2, DWORD PTR [rcx+52]
  0194b	f3 0f 11 54 24
	28		 movss	 DWORD PTR [rsp+40], xmm2
  01951	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  01957	0f 57 db	 xorps	 xmm3, xmm3
  0195a	0f 28 d1	 movaps	 xmm2, xmm1
  0195d	0f 57 c9	 xorps	 xmm1, xmm1
  01960	48 8d 8c 24 60
	0d 00 00	 lea	 rcx, QWORD PTR Projection$113[rsp]
  01968	e8 00 00 00 00	 call	 ?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z ; CreateOrthographic

; 577  :                            0.0f, (f32)WindowDimension.Width,
; 578  :                            0.0f, (f32)WindowDimension.Height,
; 579  :                            State->Camera->Near, State->Camera->Far);
; 580  :         
; 581  :         b32 AlreadyHovered = false;

  0196d	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR AlreadyHovered$10[rsp], 0

; 582  :         f32 ZIndex = 0.0f;

  01978	0f 57 c0	 xorps	 xmm0, xmm0
  0197b	f3 0f 11 44 24
	64		 movss	 DWORD PTR ZIndex$2[rsp], xmm0

; 583  :         for(s32 UIIndex = MAX_UI_COUNT - 1;

  01981	c7 44 24 60 1f
	00 00 00	 mov	 DWORD PTR UIIndex$1[rsp], 31
  01989	eb 0a		 jmp	 SHORT $LN19@GameUpdate
$LN17@GameUpdate:

; 585  :             --UIIndex)

  0198b	8b 44 24 60	 mov	 eax, DWORD PTR UIIndex$1[rsp]
  0198f	ff c8		 dec	 eax
  01991	89 44 24 60	 mov	 DWORD PTR UIIndex$1[rsp], eax
$LN19@GameUpdate:

; 584  :             UIIndex >= 0;

  01995	83 7c 24 60 00	 cmp	 DWORD PTR UIIndex$1[rsp], 0
  0199a	0f 8c 68 05 00
	00		 jl	 $LN18@GameUpdate

; 586  :         {
; 587  :             ui_element *UI = &State->UIElements[UIIndex];

  019a0	48 63 44 24 60	 movsxd	 rax, DWORD PTR UIIndex$1[rsp]
  019a5	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  019ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  019b3	48 8d 84 01 70
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1136]
  019bb	48 89 44 24 68	 mov	 QWORD PTR UI$3[rsp], rax

; 588  :             
; 589  :             if(!UI->IsActive)

  019c0	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  019c5	83 38 00	 cmp	 DWORD PTR [rax], 0
  019c8	75 02		 jne	 SHORT $LN47@GameUpdate

; 590  :             {
; 591  :                 continue;

  019ca	eb bf		 jmp	 SHORT $LN17@GameUpdate
$LN47@GameUpdate:

; 592  :             }
; 593  :             
; 594  :             loaded_image Image = *UI->Image;

  019cc	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  019d1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  019d5	48 8d 8c 24 f8
	0c 00 00	 lea	 rcx, QWORD PTR Image$110[rsp]
  019dd	48 8b f9	 mov	 rdi, rcx
  019e0	48 8b f0	 mov	 rsi, rax
  019e3	b9 10 00 00 00	 mov	 ecx, 16
  019e8	f3 a4		 rep movsb

; 595  :             v2 Position = UI->Position;

  019ea	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  019ef	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  019f6	48 89 84 24 60
	0b 00 00	 mov	 QWORD PTR Position$81[rsp], rax

; 596  :             v2 Scale = UI->Scale;

  019fe	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  01a03	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  01a0a	48 89 84 24 70
	0b 00 00	 mov	 QWORD PTR Scale$83[rsp], rax

; 597  :             f32 Thickness = UI->Thickness;

  01a12	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  01a17	f3 0f 10 80 a0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+160]
  01a1f	f3 0f 11 84 24
	00 01 00 00	 movss	 DWORD PTR Thickness$25[rsp], xmm0

; 598  :             ui_type Type = UI->Type;

  01a28	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  01a2d	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  01a33	89 84 24 c8 00
	00 00		 mov	 DWORD PTR Type$19[rsp], eax

; 599  :             
; 600  :             b32 Selected = UIIndex == State->SelectedUI;

  01a3a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01a41	8b 80 70 1a 00
	00		 mov	 eax, DWORD PTR [rax+6768]
  01a47	39 44 24 60	 cmp	 DWORD PTR UIIndex$1[rsp], eax
  01a4b	75 0d		 jne	 SHORT $LN62@GameUpdate
  01a4d	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv857[rsp], 1
  01a58	eb 0b		 jmp	 SHORT $LN63@GameUpdate
$LN62@GameUpdate:
  01a5a	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv857[rsp], 0
$LN63@GameUpdate:
  01a65	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv857[rsp]
  01a6c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR Selected$11[rsp], eax

; 601  :             
; 602  :             b32 Hovered = false;

  01a73	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Hovered$9[rsp], 0

; 603  :             
; 604  :             // TODO(evan): Make this not stupud
; 605  :             if(Type & UI_STRING)

  01a7e	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR Type$19[rsp]
  01a85	83 e0 01	 and	 eax, 1
  01a88	85 c0		 test	 eax, eax
  01a8a	0f 84 8e 02 00
	00		 je	 $LN48@GameUpdate

; 606  :             {
; 607  :                 if(Type & UI_TOGGLE)

  01a90	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR Type$19[rsp]
  01a97	83 e0 02	 and	 eax, 2
  01a9a	85 c0		 test	 eax, eax
  01a9c	0f 84 84 01 00
	00		 je	 $LN50@GameUpdate

; 608  :                 {
; 609  :                     Hovered = UIToggle(Position, Scale, Thickness, UI->String, &State->Font,

  01aa2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR AlreadyHovered$10[rsp], 0
  01aaa	75 0d		 jne	 SHORT $LN64@GameUpdate
  01aac	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv867[rsp], 1
  01ab7	eb 0b		 jmp	 SHORT $LN65@GameUpdate
$LN64@GameUpdate:
  01ab9	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv867[rsp], 0
$LN65@GameUpdate:
  01ac4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01acc	f3 0f 11 84 24
	78 0b 00 00	 movss	 DWORD PTR $T84[rsp], xmm0
  01ad5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01add	f3 0f 11 84 24
	7c 0b 00 00	 movss	 DWORD PTR $T84[rsp+4], xmm0
  01ae6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01aee	f3 0f 11 84 24
	80 0b 00 00	 movss	 DWORD PTR $T84[rsp+8], xmm0
  01af7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01aff	f3 0f 11 84 24
	84 0b 00 00	 movss	 DWORD PTR $T84[rsp+12], xmm0
  01b08	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01b10	f3 0f 11 84 24
	88 0b 00 00	 movss	 DWORD PTR $T85[rsp], xmm0
  01b19	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01b21	f3 0f 11 84 24
	8c 0b 00 00	 movss	 DWORD PTR $T85[rsp+4], xmm0
  01b2a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01b32	f3 0f 11 84 24
	90 0b 00 00	 movss	 DWORD PTR $T85[rsp+8], xmm0
  01b3b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01b43	f3 0f 11 84 24
	94 0b 00 00	 movss	 DWORD PTR $T85[rsp+12], xmm0
  01b4c	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR $T46[rsp]
  01b54	48 8d 8c 24 78
	0b 00 00	 lea	 rcx, QWORD PTR $T84[rsp]
  01b5c	48 8b f8	 mov	 rdi, rax
  01b5f	48 8b f1	 mov	 rsi, rcx
  01b62	b9 10 00 00 00	 mov	 ecx, 16
  01b67	f3 a4		 rep movsb
  01b69	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR $T49[rsp]
  01b71	48 8d 8c 24 88
	0b 00 00	 lea	 rcx, QWORD PTR $T85[rsp]
  01b79	48 8b f8	 mov	 rdi, rax
  01b7c	48 8b f1	 mov	 rsi, rcx
  01b7f	b9 10 00 00 00	 mov	 ecx, 16
  01b84	f3 a4		 rep movsb
  01b86	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01b8d	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  01b93	48 8b 4c 24 68	 mov	 rcx, QWORD PTR UI$3[rsp]
  01b98	48 83 c1 10	 add	 rcx, 16
  01b9c	48 8b 54 24 68	 mov	 rdx, QWORD PTR UI$3[rsp]
  01ba1	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [rdx+164]
  01ba7	89 54 24 58	 mov	 DWORD PTR [rsp+88], edx
  01bab	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR Selected$11[rsp]
  01bb2	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  01bb6	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR tv867[rsp]
  01bbd	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  01bc1	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR ZIndex$2[rsp]
  01bc7	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  01bcd	48 8d 94 24 60
	0d 00 00	 lea	 rdx, QWORD PTR Projection$113[rsp]
  01bd5	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  01bda	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR $T46[rsp]
  01be2	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  01be7	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR $T49[rsp]
  01bef	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  01bf4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bf9	4c 8b c9	 mov	 r9, rcx
  01bfc	f3 0f 10 94 24
	00 01 00 00	 movss	 xmm2, DWORD PTR Thickness$25[rsp]
  01c05	48 8b 94 24 70
	0b 00 00	 mov	 rdx, QWORD PTR Scale$83[rsp]
  01c0d	48 8b 8c 24 60
	0b 00 00	 mov	 rcx, QWORD PTR Position$81[rsp]
  01c15	e8 00 00 00 00	 call	 ?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z ; UIToggle
  01c1a	89 84 24 84 00
	00 00		 mov	 DWORD PTR Hovered$9[rsp], eax

; 610  :                                        COLOR_WHITE, COLOR_WHITE, &Projection, ZIndex,
; 611  :                                        !AlreadyHovered, Selected, UI->Toggled);
; 612  :                 }

  01c21	e9 f3 00 00 00	 jmp	 $LN51@GameUpdate
$LN50@GameUpdate:

; 613  :                 else
; 614  :                 {
; 615  :                     Hovered = UIString(Position, UI->String, &State->Font, COLOR_WHITE, &Projection, ZIndex,

  01c26	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR AlreadyHovered$10[rsp], 0
  01c2e	75 0d		 jne	 SHORT $LN66@GameUpdate
  01c30	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv884[rsp], 1
  01c3b	eb 0b		 jmp	 SHORT $LN67@GameUpdate
$LN66@GameUpdate:
  01c3d	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv884[rsp], 0
$LN67@GameUpdate:
  01c48	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01c50	f3 0f 11 84 24
	98 0b 00 00	 movss	 DWORD PTR $T86[rsp], xmm0
  01c59	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01c61	f3 0f 11 84 24
	9c 0b 00 00	 movss	 DWORD PTR $T86[rsp+4], xmm0
  01c6a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01c72	f3 0f 11 84 24
	a0 0b 00 00	 movss	 DWORD PTR $T86[rsp+8], xmm0
  01c7b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01c83	f3 0f 11 84 24
	a4 0b 00 00	 movss	 DWORD PTR $T86[rsp+12], xmm0
  01c8c	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR $T53[rsp]
  01c94	48 8d 8c 24 98
	0b 00 00	 lea	 rcx, QWORD PTR $T86[rsp]
  01c9c	48 8b f8	 mov	 rdi, rax
  01c9f	48 8b f1	 mov	 rsi, rcx
  01ca2	b9 10 00 00 00	 mov	 ecx, 16
  01ca7	f3 a4		 rep movsb
  01ca9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01cb0	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  01cb6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR UI$3[rsp]
  01cbb	48 83 c1 10	 add	 rcx, 16
  01cbf	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01cc8	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR Selected$11[rsp]
  01ccf	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  01cd3	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR tv884[rsp]
  01cda	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  01cde	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR ZIndex$2[rsp]
  01ce4	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  01cea	48 8d 94 24 60
	0d 00 00	 lea	 rdx, QWORD PTR Projection$113[rsp]
  01cf2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01cf7	4c 8d 8c 24 90
	02 00 00	 lea	 r9, QWORD PTR $T53[rsp]
  01cff	4c 8b c0	 mov	 r8, rax
  01d02	48 8b d1	 mov	 rdx, rcx
  01d05	48 8b 8c 24 60
	0b 00 00	 mov	 rcx, QWORD PTR Position$81[rsp]
  01d0d	e8 00 00 00 00	 call	 ?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z ; UIString
  01d12	89 84 24 84 00
	00 00		 mov	 DWORD PTR Hovered$9[rsp], eax
$LN51@GameUpdate:

; 616  :                                        !AlreadyHovered, Selected, 0);
; 617  :                 }
; 618  :             }

  01d19	e9 16 01 00 00	 jmp	 $LN49@GameUpdate
$LN48@GameUpdate:

; 619  :             else
; 620  :             {
; 621  :                 Hovered = UIImage(Image, Position, Scale, COLOR_WHITE, &Projection, ZIndex,

  01d1e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR AlreadyHovered$10[rsp], 0
  01d26	75 0d		 jne	 SHORT $LN68@GameUpdate
  01d28	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv932[rsp], 1
  01d33	eb 0b		 jmp	 SHORT $LN69@GameUpdate
$LN68@GameUpdate:
  01d35	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv932[rsp], 0
$LN69@GameUpdate:
  01d40	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01d48	f3 0f 11 84 24
	a8 0b 00 00	 movss	 DWORD PTR $T87[rsp], xmm0
  01d51	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01d59	f3 0f 11 84 24
	ac 0b 00 00	 movss	 DWORD PTR $T87[rsp+4], xmm0
  01d62	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01d6a	f3 0f 11 84 24
	b0 0b 00 00	 movss	 DWORD PTR $T87[rsp+8], xmm0
  01d73	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01d7b	f3 0f 11 84 24
	b4 0b 00 00	 movss	 DWORD PTR $T87[rsp+12], xmm0
  01d84	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR $T52[rsp]
  01d8c	48 8d 8c 24 a8
	0b 00 00	 lea	 rcx, QWORD PTR $T87[rsp]
  01d94	48 8b f8	 mov	 rdi, rax
  01d97	48 8b f1	 mov	 rsi, rcx
  01d9a	b9 10 00 00 00	 mov	 ecx, 16
  01d9f	f3 a4		 rep movsb
  01da1	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR $T51[rsp]
  01da9	48 8d 8c 24 f8
	0c 00 00	 lea	 rcx, QWORD PTR Image$110[rsp]
  01db1	48 8b f8	 mov	 rdi, rax
  01db4	48 8b f1	 mov	 rsi, rcx
  01db7	b9 10 00 00 00	 mov	 ecx, 16
  01dbc	f3 a4		 rep movsb
  01dbe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01dc5	48 8b 80 00 01
	00 00		 mov	 rax, QWORD PTR [rax+256]
  01dcc	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01dd1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR [rsp+64], 1
  01dd9	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR Selected$11[rsp]
  01de0	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  01de4	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv932[rsp]
  01deb	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01def	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR ZIndex$2[rsp]
  01df5	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  01dfb	48 8d 84 24 60
	0d 00 00	 lea	 rax, QWORD PTR Projection$113[rsp]
  01e03	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e08	4c 8d 8c 24 80
	02 00 00	 lea	 r9, QWORD PTR $T52[rsp]
  01e10	4c 8b 84 24 70
	0b 00 00	 mov	 r8, QWORD PTR Scale$83[rsp]
  01e18	48 8b 94 24 60
	0b 00 00	 mov	 rdx, QWORD PTR Position$81[rsp]
  01e20	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR $T51[rsp]
  01e28	e8 00 00 00 00	 call	 ?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z ; UIImage
  01e2d	89 84 24 84 00
	00 00		 mov	 DWORD PTR Hovered$9[rsp], eax
$LN49@GameUpdate:

; 622  :                                   !AlreadyHovered, Selected, true);
; 623  :             }
; 624  :             
; 625  :             if(Hovered)

  01e34	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR Hovered$9[rsp], 0
  01e3c	0f 84 ad 00 00
	00		 je	 $LN52@GameUpdate

; 626  :             {
; 627  :                 AlreadyHovered = true;

  01e42	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR AlreadyHovered$10[rsp], 1

; 628  :                 
; 629  :                 if(Input->Mouse.LButton && !State->LastInput.Mouse.LButton && !State->DevMode)

  01e4d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01e54	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01e58	74 55		 je	 SHORT $LN53@GameUpdate
  01e5a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01e61	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01e65	75 48		 jne	 SHORT $LN53@GameUpdate
  01e67	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01e6e	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  01e75	75 38		 jne	 SHORT $LN53@GameUpdate

; 630  :                 {
; 631  :                     UI->Toggled = !UI->Toggled;

  01e77	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  01e7c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [rax+164], 0
  01e83	75 0d		 jne	 SHORT $LN70@GameUpdate
  01e85	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv953[rsp], 1
  01e90	eb 0b		 jmp	 SHORT $LN71@GameUpdate
$LN70@GameUpdate:
  01e92	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv953[rsp], 0
$LN71@GameUpdate:
  01e9d	48 8b 44 24 68	 mov	 rax, QWORD PTR UI$3[rsp]
  01ea2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv953[rsp]
  01ea9	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx
$LN53@GameUpdate:

; 632  :                 }
; 633  :                 
; 634  :                 if(Input->Mouse.LButton && State->DevMode)

  01eaf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01eb6	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01eba	74 2c		 je	 SHORT $LN54@GameUpdate
  01ebc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01ec3	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  01eca	74 1c		 je	 SHORT $LN54@GameUpdate

; 635  :                 {
; 636  :                     Selected = true;

  01ecc	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR Selected$11[rsp], 1

; 637  :                     State->SelectedUI = UIIndex;

  01ed7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01ede	8b 4c 24 60	 mov	 ecx, DWORD PTR UIIndex$1[rsp]
  01ee2	89 88 70 1a 00
	00		 mov	 DWORD PTR [rax+6768], ecx
$LN54@GameUpdate:

; 638  :                 }
; 639  :                 
; 640  :                 if(Input->Mouse.RButton)

  01ee8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
$LN52@GameUpdate:

; 641  :                 {
; 642  :                 }
; 643  :             }
; 644  :             
; 645  :             ZIndex += 0.001f;

  01eef	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR ZIndex$2[rsp]
  01ef5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3a83126f
  01efd	f3 0f 11 44 24
	64		 movss	 DWORD PTR ZIndex$2[rsp], xmm0

; 646  :         }

  01f03	e9 83 fa ff ff	 jmp	 $LN17@GameUpdate
$LN18@GameUpdate:

; 647  :         
; 648  :         if(Input->Mouse.LButton && !State->LastInput.Mouse.LButton)

  01f08	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01f0f	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01f13	74 79		 je	 SHORT $LN56@GameUpdate
  01f15	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01f1c	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01f20	75 6c		 jne	 SHORT $LN56@GameUpdate

; 649  :         {
; 650  :             ui_element UI = State->UIElements[State->SelectedUI];

  01f22	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01f29	48 63 80 70 1a
	00 00		 movsxd	 rax, DWORD PTR [rax+6768]
  01f30	48 69 c0 b0 00
	00 00		 imul	 rax, rax, 176		; 000000b0H
  01f37	48 8d 8c 24 a0
	0e 00 00	 lea	 rcx, QWORD PTR UI$118[rsp]
  01f3f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?State@@3PEAUgame_state@@EA
  01f46	48 8b f9	 mov	 rdi, rcx
  01f49	48 8d b4 02 70
	04 00 00	 lea	 rsi, QWORD PTR [rdx+rax+1136]
  01f51	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  01f56	f3 a4		 rep movsb

; 651  :             if((UI.Type & UI_STRING) && UI.String[0] == 0)

  01f58	8b 84 24 48 0f
	00 00		 mov	 eax, DWORD PTR UI$118[rsp+168]
  01f5f	83 e0 01	 and	 eax, 1
  01f62	85 c0		 test	 eax, eax
  01f64	74 17		 je	 SHORT $LN57@GameUpdate
  01f66	b8 01 00 00 00	 mov	 eax, 1
  01f6b	48 6b c0 00	 imul	 rax, rax, 0
  01f6f	0f be 84 04 b0
	0e 00 00	 movsx	 eax, BYTE PTR UI$118[rsp+rax+16]
  01f77	85 c0		 test	 eax, eax
  01f79	75 02		 jne	 SHORT $LN57@GameUpdate

; 652  :             {
; 653  :                 // NOTE(evan): Can't have an empty string taking up precious UI space
; 654  :             }

  01f7b	eb 11		 jmp	 SHORT $LN58@GameUpdate
$LN57@GameUpdate:

; 655  :             else
; 656  :             {
; 657  :                 State->SelectedUI = -1;

  01f7d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  01f84	c7 80 70 1a 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+6768], -1
$LN58@GameUpdate:
$LN56@GameUpdate:

; 658  :             }
; 659  :         }
; 660  :     }
; 661  :     //
; 662  :     //
; 663  :     //
; 664  :     
; 665  :     State->LastInput = *Input;

  01f8e	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?State@@3PEAUgame_state@@EA
  01f95	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?Input@@3PEAUgame_input@@EA
  01f9c	b9 ac 00 00 00	 mov	 ecx, 172		; 000000acH
  01fa1	f3 a4		 rep movsb

; 666  :     TranState->FrameArena.Used = 0;

  01fa3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  01faa	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 667  :     
; 668  :     return(ShouldClose);

  01fb2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?ShouldClose@@3HA

; 669  : }

  01fb8	48 8b 8c 24 b0
	0f 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01fc0	48 33 cc	 xor	 rcx, rsp
  01fc3	e8 00 00 00 00	 call	 __security_check_cookie
  01fc8	48 81 c4 c8 0f
	00 00		 add	 rsp, 4040		; 00000fc8H
  01fcf	5f		 pop	 rdi
  01fd0	5e		 pop	 rsi
  01fd1	c3		 ret	 0
?GameUpdateAndRender@@YAHW4window_flags@@Uwindow_dimension@@PEAUgame_memory@@PEAUgame_input@@M@Z ENDP ; GameUpdateAndRender
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Entity$ = 32
$T1 = 256
__$ArrayPad$ = 320
Parent$ = 368
HasPointLight$ = 376
Light$ = 384
MID$ = 392
Position$ = 400
Scale$ = 408
Rotation$ = 416
RunEntity$ = 424
OnCollideEntity$ = 432
?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z PROC ; CreateEntity

; 240  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 241  :     entity Entity;
; 242  :     
; 243  :     Entity.RunEntity = RunEntity;

  0002e	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR RunEntity$[rsp]
  00036	48 89 44 24 28	 mov	 QWORD PTR Entity$[rsp+8], rax

; 244  :     Entity.OnCollideEntity = OnCollideEntity;

  0003b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR OnCollideEntity$[rsp]
  00043	48 89 44 24 30	 mov	 QWORD PTR Entity$[rsp+16], rax

; 245  :     
; 246  :     Entity.Position = Position;

  00048	48 8d 44 24 38	 lea	 rax, QWORD PTR Entity$[rsp+24]
  0004d	48 8b f8	 mov	 rdi, rax
  00050	48 8b b4 24 90
	01 00 00	 mov	 rsi, QWORD PTR Position$[rsp]
  00058	b9 0c 00 00 00	 mov	 ecx, 12
  0005d	f3 a4		 rep movsb

; 247  :     Entity.Scale = Scale;

  0005f	48 8d 44 24 44	 lea	 rax, QWORD PTR Entity$[rsp+36]
  00064	48 8b f8	 mov	 rdi, rax
  00067	48 8b b4 24 98
	01 00 00	 mov	 rsi, QWORD PTR Scale$[rsp]
  0006f	b9 0c 00 00 00	 mov	 ecx, 12
  00074	f3 a4		 rep movsb

; 248  :     Entity.Rotation = Rotation;

  00076	48 8d 44 24 50	 lea	 rax, QWORD PTR Entity$[rsp+48]
  0007b	48 8b f8	 mov	 rdi, rax
  0007e	48 8b b4 24 a0
	01 00 00	 mov	 rsi, QWORD PTR Rotation$[rsp]
  00086	b9 0c 00 00 00	 mov	 ecx, 12
  0008b	f3 a4		 rep movsb

; 249  :     
; 250  :     Entity.HasPointLight = HasPointLight;

  0008d	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR HasPointLight$[rsp]
  00094	89 44 24 68	 mov	 DWORD PTR Entity$[rsp+72], eax

; 251  :     Entity.Light = Light;

  00098	48 8d 44 24 6c	 lea	 rax, QWORD PTR Entity$[rsp+76]
  0009d	48 8b f8	 mov	 rdi, rax
  000a0	48 8b b4 24 80
	01 00 00	 mov	 rsi, QWORD PTR Light$[rsp]
  000a8	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000ad	f3 a4		 rep movsb

; 252  :     
; 253  :     if(MID)

  000af	83 bc 24 88 01
	00 00 00	 cmp	 DWORD PTR MID$[rsp], 0
  000b7	74 16		 je	 SHORT $LN2@CreateEnti

; 254  :     {
; 255  :         Entity.Model = GetModelAsset(MID);

  000b9	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR MID$[rsp]
  000c0	e8 00 00 00 00	 call	 ?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z ; GetModelAsset
  000c5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR Entity$[rsp+144], rax

; 256  :     }

  000cd	eb 0c		 jmp	 SHORT $LN3@CreateEnti
$LN2@CreateEnti:

; 257  :     else
; 258  :     {
; 259  :         Entity.Model = 0;

  000cf	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR Entity$[rsp+144], 0
$LN3@CreateEnti:

; 260  :     }
; 261  :     
; 262  :     Entity.Camera = {};

  000db	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR $T1[rsp]
  000e3	48 8b f8	 mov	 rdi, rax
  000e6	33 c0		 xor	 eax, eax
  000e8	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000ed	f3 aa		 rep stosb
  000ef	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR Entity$[rsp+152]
  000f7	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  000ff	48 8b f8	 mov	 rdi, rax
  00102	48 8b f1	 mov	 rsi, rcx
  00105	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0010a	f3 a4		 rep movsb

; 263  :     
; 264  :     Entity.Parent = Parent;

  0010c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR Parent$[rsp]
  00114	48 89 44 24 60	 mov	 QWORD PTR Entity$[rsp+64], rax

; 265  :     
; 266  :     Entity.Index = TranState->EntityCount;

  00119	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00120	8b 80 c8 6c 00
	00		 mov	 eax, DWORD PTR [rax+27848]
  00126	89 44 24 20	 mov	 DWORD PTR Entity$[rsp], eax

; 267  :     TranState->Entities[TranState->EntityCount++] = Entity;

  0012a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00131	48 63 80 c8 6c
	00 00		 movsxd	 rax, DWORD PTR [rax+27848]
  00138	48 69 c0 d8 00
	00 00		 imul	 rax, rax, 216		; 000000d8H
  0013f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00146	48 8d 54 24 20	 lea	 rdx, QWORD PTR Entity$[rsp]
  0014b	48 8d bc 01 c8
	00 00 00	 lea	 rdi, QWORD PTR [rcx+rax+200]
  00153	48 8b f2	 mov	 rsi, rdx
  00156	b9 d8 00 00 00	 mov	 ecx, 216		; 000000d8H
  0015b	f3 a4		 rep movsb
  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00164	8b 80 c8 6c 00
	00		 mov	 eax, DWORD PTR [rax+27848]
  0016a	ff c0		 inc	 eax
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00173	89 81 c8 6c 00
	00		 mov	 DWORD PTR [rcx+27848], eax

; 268  :     
; 269  :     return(&TranState->Entities[TranState->EntityCount - 1]);

  00179	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00180	8b 80 c8 6c 00
	00		 mov	 eax, DWORD PTR [rax+27848]
  00186	ff c8		 dec	 eax
  00188	48 98		 cdqe
  0018a	48 69 c0 d8 00
	00 00		 imul	 rax, rax, 216		; 000000d8H
  00191	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00198	48 8d 84 01 c8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+200]

; 270  : }

  001a0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a8	48 33 cc	 xor	 rcx, rsp
  001ab	e8 00 00 00 00	 call	 __security_check_cookie
  001b0	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  001b7	5f		 pop	 rdi
  001b8	5e		 pop	 rsi
  001b9	c3		 ret	 0
?CreateEntity@@YAPEAUentity@@PEAU1@HUpoint_light@@W4model_asset_id@@Tv3@@33P6AX0M@ZP6AX00@Z@Z ENDP ; CreateEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Result$ = 0
ID$ = 32
?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z PROC ; GetModelAsset

; 228  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 229  :     loaded_model *Result = 0;

  00008	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 230  :     Result = &TranState->Assets.Models[ID];

  00010	48 63 44 24 20	 movsxd	 rax, DWORD PTR ID$[rsp]
  00015	48 6b c0 10	 imul	 rax, rax, 16
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00020	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  00028	48 89 04 24	 mov	 QWORD PTR Result$[rsp], rax

; 231  :     
; 232  :     return(Result);

  0002c	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 233  : }

  00030	48 83 c4 18	 add	 rsp, 24
  00034	c3		 ret	 0
?GetModelAsset@@YAPEAUloaded_model@@W4model_asset_id@@@Z ENDP ; GetModelAsset
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Result$ = 0
ID$ = 32
?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z PROC ; GetImageAsset

; 219  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 220  :     loaded_image*Result = 0;

  00008	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 221  :     Result = &TranState->Assets.Images[ID];

  00010	48 63 44 24 20	 movsxd	 rax, DWORD PTR ID$[rsp]
  00015	48 6b c0 10	 imul	 rax, rax, 16
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00020	48 8d 44 01 68	 lea	 rax, QWORD PTR [rcx+rax+104]
  00025	48 89 04 24	 mov	 QWORD PTR Result$[rsp], rax

; 222  :     
; 223  :     return(Result);

  00029	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 224  : }

  0002d	48 83 c4 18	 add	 rsp, 24
  00031	c3		 ret	 0
?GetImageAsset@@YAPEAUloaded_image@@W4image_asset_id@@@Z ENDP ; GetImageAsset
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Result$ = 0
ID$ = 32
?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z PROC ; GetSoundAsset

; 210  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 211  :     loaded_sound *Result = 0;

  00008	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 212  :     Result = &TranState->Assets.Sounds[ID];

  00010	48 63 44 24 20	 movsxd	 rax, DWORD PTR ID$[rsp]
  00015	48 6b c0 18	 imul	 rax, rax, 24
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00020	48 8d 44 01 38	 lea	 rax, QWORD PTR [rcx+rax+56]
  00025	48 89 04 24	 mov	 QWORD PTR Result$[rsp], rax

; 213  :     
; 214  :     return(Result);

  00029	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 215  : }

  0002d	48 83 c4 18	 add	 rsp, 24
  00031	c3		 ret	 0
?GetSoundAsset@@YAPEAUloaded_sound@@W4sound_asset_id@@@Z ENDP ; GetSoundAsset
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Alpha$1 = 80
Y$2 = 84
X$3 = 88
Source$ = 96
Dest$4 = 104
DestRow$ = 112
Texture$ = 120
$T5 = 128
File$ = 152
$T6 = 176
Result$ = 208
CData$ = 1008
TempBitmap$ = 2928
__$ArrayPad$ = 265072
$T7 = 265120
Path$ = 265128
Arena$ = 265136
FontHeight$ = 265144
?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z PROC	; LoadFont

; 161  : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	b8 88 0b 04 00	 mov	 eax, 265096		; 00040b88H
  0001c	e8 00 00 00 00	 call	 __chkstk
  00021	48 2b e0	 sub	 rsp, rax
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 84 24 70
	0b 04 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 162  :     file_contents File = ReadFile16(Path, Arena);

  00036	4c 8b 84 24 b0
	0b 04 00	 mov	 r8, QWORD PTR Arena$[rsp]
  0003e	48 8b 94 24 a8
	0b 04 00	 mov	 rdx, QWORD PTR Path$[rsp]
  00046	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  0004e	e8 00 00 00 00	 call	 ?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z ; ReadFile16
  00053	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  0005b	48 8b f9	 mov	 rdi, rcx
  0005e	48 8b f0	 mov	 rsi, rax
  00061	b9 18 00 00 00	 mov	 ecx, 24
  00066	f3 a4		 rep movsb
  00068	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR File$[rsp]
  00070	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00078	48 8b f8	 mov	 rdi, rax
  0007b	48 8b f1	 mov	 rsi, rcx
  0007e	b9 18 00 00 00	 mov	 ecx, 24
  00083	f3 a4		 rep movsb

; 163  :     
; 164  : #define TEMP_WIDTH 512
; 165  : #define TEMP_HEIGHT 512
; 166  :     u8 TempBitmap[TEMP_WIDTH*TEMP_HEIGHT];
; 167  :     stbtt_bakedchar CData[96]; // ' ' through '~' is 95 glyphs
; 168  :     
; 169  :     stbtt_BakeFontBitmap((u8 *)File.Data, 0, FontHeight, TempBitmap, TEMP_WIDTH, TEMP_HEIGHT, ' ', 96, CData);

  00085	48 8d 84 24 f0
	03 00 00	 lea	 rax, QWORD PTR CData$[rsp]
  0008d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00092	c7 44 24 38 60
	00 00 00	 mov	 DWORD PTR [rsp+56], 96	; 00000060H
  0009a	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR [rsp+48], 32	; 00000020H
  000a2	c7 44 24 28 00
	02 00 00	 mov	 DWORD PTR [rsp+40], 512	; 00000200H
  000aa	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  000b2	4c 8d 8c 24 70
	0b 00 00	 lea	 r9, QWORD PTR TempBitmap$[rsp]
  000ba	f3 0f 10 94 24
	b8 0b 04 00	 movss	 xmm2, DWORD PTR FontHeight$[rsp]
  000c3	33 d2		 xor	 edx, edx
  000c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR File$[rsp+8]
  000cd	e8 00 00 00 00	 call	 stbtt_BakeFontBitmap

; 170  :     
; 171  :     u32 *Texture = PushArray(Arena, u32, TEMP_WIDTH*TEMP_HEIGHT);

  000d2	ba 00 00 10 00	 mov	 edx, 1048576		; 00100000H
  000d7	48 8b 8c 24 b0
	0b 04 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  000df	e8 00 00 00 00	 call	 PushSize
  000e4	48 89 44 24 78	 mov	 QWORD PTR Texture$[rsp], rax

; 172  :     
; 173  :     u8 *Source = TempBitmap;

  000e9	48 8d 84 24 70
	0b 00 00	 lea	 rax, QWORD PTR TempBitmap$[rsp]
  000f1	48 89 44 24 60	 mov	 QWORD PTR Source$[rsp], rax

; 174  :     u8 *DestRow = (u8 *)Texture;

  000f6	48 8b 44 24 78	 mov	 rax, QWORD PTR Texture$[rsp]
  000fb	48 89 44 24 70	 mov	 QWORD PTR DestRow$[rsp], rax

; 175  :     for(s32 Y = 0;

  00100	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR Y$2[rsp], 0
  00108	eb 0a		 jmp	 SHORT $LN4@LoadFont
$LN2@LoadFont:

; 177  :         ++Y)

  0010a	8b 44 24 54	 mov	 eax, DWORD PTR Y$2[rsp]
  0010e	ff c0		 inc	 eax
  00110	89 44 24 54	 mov	 DWORD PTR Y$2[rsp], eax
$LN4@LoadFont:

; 176  :         Y < TEMP_HEIGHT;

  00114	81 7c 24 54 00
	02 00 00	 cmp	 DWORD PTR Y$2[rsp], 512	; 00000200H
  0011c	0f 8d 84 00 00
	00		 jge	 $LN3@LoadFont

; 178  :     {
; 179  :         u32 *Dest = (u32 *)DestRow;

  00122	48 8b 44 24 70	 mov	 rax, QWORD PTR DestRow$[rsp]
  00127	48 89 44 24 68	 mov	 QWORD PTR Dest$4[rsp], rax

; 180  :         for(s32 X = 0;

  0012c	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR X$3[rsp], 0
  00134	eb 0a		 jmp	 SHORT $LN7@LoadFont
$LN5@LoadFont:

; 182  :             ++X)

  00136	8b 44 24 58	 mov	 eax, DWORD PTR X$3[rsp]
  0013a	ff c0		 inc	 eax
  0013c	89 44 24 58	 mov	 DWORD PTR X$3[rsp], eax
$LN7@LoadFont:

; 181  :             X < TEMP_WIDTH;

  00140	81 7c 24 58 00
	02 00 00	 cmp	 DWORD PTR X$3[rsp], 512	; 00000200H
  00148	7d 47		 jge	 SHORT $LN6@LoadFont

; 183  :         {
; 184  :             u8 Alpha = *Source++;

  0014a	48 8b 44 24 60	 mov	 rax, QWORD PTR Source$[rsp]
  0014f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00152	88 44 24 50	 mov	 BYTE PTR Alpha$1[rsp], al
  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR Source$[rsp]
  0015b	48 ff c0	 inc	 rax
  0015e	48 89 44 24 60	 mov	 QWORD PTR Source$[rsp], rax

; 185  :             *Dest++ = ((Alpha << 24) |

  00163	0f b6 44 24 50	 movzx	 eax, BYTE PTR Alpha$1[rsp]
  00168	c1 e0 18	 shl	 eax, 24
  0016b	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  00170	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  00175	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  0017a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR Dest$4[rsp]
  0017f	89 01		 mov	 DWORD PTR [rcx], eax
  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR Dest$4[rsp]
  00186	48 83 c0 04	 add	 rax, 4
  0018a	48 89 44 24 68	 mov	 QWORD PTR Dest$4[rsp], rax

; 186  :                        (255 << 16)   |
; 187  :                        (255 << 8)    |
; 188  :                        (255 << 0));
; 189  :         }

  0018f	eb a5		 jmp	 SHORT $LN5@LoadFont
$LN6@LoadFont:

; 190  :         
; 191  :         DestRow += TEMP_WIDTH*sizeof(u32);

  00191	48 8b 44 24 70	 mov	 rax, QWORD PTR DestRow$[rsp]
  00196	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0019c	48 89 44 24 70	 mov	 QWORD PTR DestRow$[rsp], rax

; 192  :     }

  001a1	e9 64 ff ff ff	 jmp	 $LN2@LoadFont
$LN3@LoadFont:

; 193  :     
; 194  :     font Result;
; 195  :     Result.CData = PushArray(Arena, stbtt_bakedchar, TEMP_WIDTH*TEMP_HEIGHT);

  001a6	ba 00 00 50 00	 mov	 edx, 5242880		; 00500000H
  001ab	48 8b 8c 24 b0
	0b 04 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  001b3	e8 00 00 00 00	 call	 PushSize
  001b8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR Result$[rsp], rax

; 196  :     Platform->CopyMemory(Result.CData, CData, TEMP_WIDTH*TEMP_HEIGHT);

  001c0	41 b8 00 00 04
	00		 mov	 r8d, 262144		; 00040000H
  001c6	48 8d 94 24 f0
	03 00 00	 lea	 rdx, QWORD PTR CData$[rsp]
  001ce	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  001d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  001dd	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 197  :     Result.Width = TEMP_WIDTH;

  001e3	c7 84 24 d8 00
	00 00 00 02 00
	00		 mov	 DWORD PTR Result$[rsp+8], 512 ; 00000200H

; 198  :     Result.Height = TEMP_HEIGHT;

  001ee	c7 84 24 dc 00
	00 00 00 02 00
	00		 mov	 DWORD PTR Result$[rsp+12], 512 ; 00000200H

; 199  :     Result.Image = Platform->CreateTexture(Texture, TEMP_WIDTH, TEMP_HEIGHT);

  001f9	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  001ff	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00204	48 8b 4c 24 78	 mov	 rcx, QWORD PTR Texture$[rsp]
  00209	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00210	ff 50 40	 call	 QWORD PTR [rax+64]
  00213	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR Result$[rsp+16], rax

; 200  :     Result.CharacterHeight = FontHeight;

  0021b	f3 0f 10 84 24
	b8 0b 04 00	 movss	 xmm0, DWORD PTR FontHeight$[rsp]
  00224	f3 0f 11 84 24
	e0 03 00 00	 movss	 DWORD PTR Result$[rsp+784], xmm0

; 201  :     
; 202  : #undef TEMP_WIDTH
; 203  : #undef TEMP_HEIGHT
; 204  :     
; 205  :     return(Result);

  0022d	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  00235	48 8b bc 24 a0
	0b 04 00	 mov	 rdi, QWORD PTR $T7[rsp]
  0023d	48 8b f0	 mov	 rsi, rax
  00240	b9 18 03 00 00	 mov	 ecx, 792		; 00000318H
  00245	f3 a4		 rep movsb
  00247	48 8b 84 24 a0
	0b 04 00	 mov	 rax, QWORD PTR $T7[rsp]

; 206  : }

  0024f	48 8b 8c 24 70
	0b 04 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00257	48 33 cc	 xor	 rcx, rsp
  0025a	e8 00 00 00 00	 call	 __security_check_cookie
  0025f	48 81 c4 88 0b
	04 00		 add	 rsp, 265096		; 00040b88H
  00266	5f		 pop	 rdi
  00267	5e		 pop	 rsi
  00268	c3		 ret	 0
?LoadFont@@YA?AUfont@@PEA_WPEAUmemory_arena@@M@Z ENDP	; LoadFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Height$ = 48
Width$ = 52
TextureData$ = 56
Channels$ = 64
Result$ = 72
__$ArrayPad$ = 88
$T1 = 128
ImagePath$ = 136
Arena$ = 144
?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z PROC ; CreateImage

; 145  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 146  :     s32 Width, Height, Channels;
; 147  :     u32 *TextureData = (u32 *)stbi_load(ImagePath, &Width, &Height, &Channels, 4);

  00024	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0002c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR Channels$[rsp]
  00031	4c 8d 44 24 30	 lea	 r8, QWORD PTR Height$[rsp]
  00036	48 8d 54 24 34	 lea	 rdx, QWORD PTR Width$[rsp]
  0003b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ImagePath$[rsp]
  00043	e8 00 00 00 00	 call	 stbi_load
  00048	48 89 44 24 38	 mov	 QWORD PTR TextureData$[rsp], rax

; 148  :     
; 149  :     loaded_image Result;
; 150  :     Result.Size.Width = (f32)Width;

  0004d	f3 0f 2a 44 24
	34		 cvtsi2ss xmm0, DWORD PTR Width$[rsp]
  00053	f3 0f 11 44 24
	50		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 151  :     Result.Size.Height = (f32)Height;

  00059	f3 0f 2a 44 24
	30		 cvtsi2ss xmm0, DWORD PTR Height$[rsp]
  0005f	f3 0f 11 44 24
	54		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 152  :     Result.Platform = Platform->CreateTexture(TextureData, Width, Height);

  00065	44 8b 44 24 30	 mov	 r8d, DWORD PTR Height$[rsp]
  0006a	8b 54 24 34	 mov	 edx, DWORD PTR Width$[rsp]
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR TextureData$[rsp]
  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0007a	ff 50 40	 call	 QWORD PTR [rax+64]
  0007d	48 89 44 24 48	 mov	 QWORD PTR Result$[rsp], rax

; 153  :     
; 154  :     stbi_image_free(TextureData);

  00082	48 8b 4c 24 38	 mov	 rcx, QWORD PTR TextureData$[rsp]
  00087	e8 00 00 00 00	 call	 stbi_image_free

; 155  :     
; 156  :     return(Result);

  0008c	48 8d 44 24 48	 lea	 rax, QWORD PTR Result$[rsp]
  00091	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR $T1[rsp]
  00099	48 8b f0	 mov	 rsi, rax
  0009c	b9 10 00 00 00	 mov	 ecx, 16
  000a1	f3 a4		 rep movsb
  000a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]

; 157  : }

  000ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b0	48 33 cc	 xor	 rcx, rsp
  000b3	e8 00 00 00 00	 call	 __security_check_cookie
  000b8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000bc	5f		 pop	 rdi
  000bd	5e		 pop	 rsi
  000be	c3		 ret	 0
?CreateImage@@YA?AUloaded_image@@PEADPEAUmemory_arena@@@Z ENDP ; CreateImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Result$ = 32
$T1 = 96
FileName$ = 104
FileArena$ = 112
?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z PROC ; ReadFile16

; 132  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 133  :     file_contents Result = {0};

  00015	48 8d 44 24 20	 lea	 rax, QWORD PTR Result$[rsp]
  0001a	48 8b f8	 mov	 rdi, rax
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 18 00 00 00	 mov	 ecx, 24
  00024	f3 aa		 rep stosb

; 134  :     
; 135  :     Result.Handle = Platform->OpenFile(FileName, FILE_OPEN_READ);

  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR FileName$[rsp]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00037	ff 10		 call	 QWORD PTR [rax]
  00039	48 89 44 24 20	 mov	 QWORD PTR Result$[rsp], rax

; 136  :     Result.Size = Platform->GetFileSize(Result.Handle);

  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Result$[rsp]
  00043	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0004a	ff 50 10	 call	 QWORD PTR [rax+16]
  0004d	89 44 24 30	 mov	 DWORD PTR Result$[rsp+16], eax

; 137  :     Result.Data = PushSize(FileArena, Result.Size);

  00051	8b 44 24 30	 mov	 eax, DWORD PTR Result$[rsp+16]
  00055	8b d0		 mov	 edx, eax
  00057	48 8b 4c 24 70	 mov	 rcx, QWORD PTR FileArena$[rsp]
  0005c	e8 00 00 00 00	 call	 PushSize
  00061	48 89 44 24 28	 mov	 QWORD PTR Result$[rsp+8], rax

; 138  :     Platform->ReadEntireFile(Result.Handle, Result.Size, Result.Data);

  00066	4c 8b 44 24 28	 mov	 r8, QWORD PTR Result$[rsp+8]
  0006b	8b 54 24 30	 mov	 edx, DWORD PTR Result$[rsp+16]
  0006f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Result$[rsp]
  00074	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0007b	ff 50 18	 call	 QWORD PTR [rax+24]

; 139  :     
; 140  :     return(Result);

  0007e	48 8d 44 24 20	 lea	 rax, QWORD PTR Result$[rsp]
  00083	48 8b 7c 24 60	 mov	 rdi, QWORD PTR $T1[rsp]
  00088	48 8b f0	 mov	 rsi, rax
  0008b	b9 18 00 00 00	 mov	 ecx, 24
  00090	f3 a4		 rep movsb
  00092	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]

; 141  : }

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	5f		 pop	 rdi
  0009c	5e		 pop	 rsi
  0009d	c3		 ret	 0
?ReadFile16@@YA?AUfile_contents@@PEA_WPEAUmemory_arena@@@Z ENDP ; ReadFile16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
MeshIndex$1 = 48
Mesh$2 = 56
Model$ = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
$T7 = 144
$T8 = 160
$T9 = 176
$T10 = 192
$T11 = 208
$T12 = 224
$T13 = 240
$T14 = 256
$T15 = 272
$T16 = 288
$T17 = 304
$T18 = 368
$T19 = 432
$T20 = 496
$T21 = 560
$T22 = 624
$T23 = 688
$T24 = 752
$T25 = 792
$T26 = 856
$T27 = 920
$T28 = 984
$T29 = 1048
TempScale$ = 1112
TempPosition$ = 1128
$T30 = 1144
TempRotation$ = 1160
$T31 = 1176
$T32 = 1192
Transform$33 = 1216
M4Normal$34 = 1280
NormalMat$35 = 1344
$T36 = 1384
EntityTransformMat$37 = 1424
ParentTransformMat$38 = 1488
PrevM$ = 1552
$T39 = 1616
$T40 = 1680
$T41 = 1744
$T42 = 1808
$T43 = 1872
M$44 = 1936
Constants$45 = 2000
__$ArrayPad$ = 2320
Entity$ = 2368
Parent$ = 2376
Texture$ = 2384
Shader$ = 2392
PointLight$ = 2400
Projection$ = 2408
View$ = 2416
?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z PROC ; RenderEntity

; 70   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 28 09
	00 00		 sub	 rsp, 2344		; 00000928H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 10
	09 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 71   :     loaded_model Model = *Entity->Model;

  0002f	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  00037	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0003e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR Model$[rsp]
  00043	48 8b f9	 mov	 rdi, rcx
  00046	48 8b f0	 mov	 rsi, rax
  00049	b9 10 00 00 00	 mov	 ecx, 16
  0004e	f3 a4		 rep movsb

; 72   :     
; 73   :     v3 TempPosition = Entity->Position;

  00050	48 8d 84 24 68
	04 00 00	 lea	 rax, QWORD PTR TempPosition$[rsp]
  00058	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  00060	48 8b f8	 mov	 rdi, rax
  00063	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00067	b9 0c 00 00 00	 mov	 ecx, 12
  0006c	f3 a4		 rep movsb

; 74   :     v3 TempScale = Entity->Scale;

  0006e	48 8d 84 24 58
	04 00 00	 lea	 rax, QWORD PTR TempScale$[rsp]
  00076	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  0007e	48 8b f8	 mov	 rdi, rax
  00081	48 8d 71 24	 lea	 rsi, QWORD PTR [rcx+36]
  00085	b9 0c 00 00 00	 mov	 ecx, 12
  0008a	f3 a4		 rep movsb

; 75   :     v3 TempRotation = Entity->Rotation;

  0008c	48 8d 84 24 88
	04 00 00	 lea	 rax, QWORD PTR TempRotation$[rsp]
  00094	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  0009c	48 8b f8	 mov	 rdi, rax
  0009f	48 8d 71 30	 lea	 rsi, QWORD PTR [rcx+48]
  000a3	b9 0c 00 00 00	 mov	 ecx, 12
  000a8	f3 a4		 rep movsb

; 76   :     
; 77   :     mat4 PrevM = *View * *Projection;

  000aa	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR $T22[rsp]
  000b2	48 8b f8	 mov	 rdi, rax
  000b5	48 8b b4 24 68
	09 00 00	 mov	 rsi, QWORD PTR Projection$[rsp]
  000bd	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000c2	f3 a4		 rep movsb
  000c4	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR $T17[rsp]
  000cc	48 8b f8	 mov	 rdi, rax
  000cf	48 8b b4 24 70
	09 00 00	 mov	 rsi, QWORD PTR View$[rsp]
  000d7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000dc	f3 a4		 rep movsb
  000de	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR $T22[rsp]
  000e6	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR $T17[rsp]
  000ee	48 8d 8c 24 18
	03 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  000f6	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  000fb	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00103	48 8b f9	 mov	 rdi, rcx
  00106	48 8b f0	 mov	 rsi, rax
  00109	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0010e	f3 a4		 rep movsb
  00110	48 8d 84 24 10
	06 00 00	 lea	 rax, QWORD PTR PrevM$[rsp]
  00118	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00120	48 8b f8	 mov	 rdi, rax
  00123	48 8b f1	 mov	 rsi, rcx
  00126	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0012b	f3 a4		 rep movsb

; 78   :     
; 79   :     for(u32 MeshIndex = 0;

  0012d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR MeshIndex$1[rsp], 0
  00135	eb 0a		 jmp	 SHORT $LN4@RenderEnti
$LN2@RenderEnti:

; 81   :         ++MeshIndex)

  00137	8b 44 24 30	 mov	 eax, DWORD PTR MeshIndex$1[rsp]
  0013b	ff c0		 inc	 eax
  0013d	89 44 24 30	 mov	 DWORD PTR MeshIndex$1[rsp], eax
$LN4@RenderEnti:

; 80   :         MeshIndex < Model.MeshCount;

  00141	8b 44 24 48	 mov	 eax, DWORD PTR Model$[rsp+8]
  00145	39 44 24 30	 cmp	 DWORD PTR MeshIndex$1[rsp], eax
  00149	0f 83 b9 05 00
	00		 jae	 $LN3@RenderEnti

; 82   :     {
; 83   :         mesh *Mesh = &Model.Meshes[MeshIndex];

  0014f	8b 44 24 30	 mov	 eax, DWORD PTR MeshIndex$1[rsp]
  00153	48 6b c0 70	 imul	 rax, rax, 112		; 00000070H
  00157	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Model$[rsp]
  0015c	48 03 c8	 add	 rcx, rax
  0015f	48 8b c1	 mov	 rax, rcx
  00162	48 89 44 24 38	 mov	 QWORD PTR Mesh$2[rsp], rax

; 84   :         
; 85   :         mat4 EntityTransformMat = Mat4Identity();

  00167	48 8d 8c 24 58
	03 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  0016f	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  00174	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  0017c	48 8b f9	 mov	 rdi, rcx
  0017f	48 8b f0	 mov	 rsi, rax
  00182	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00187	f3 a4		 rep movsb
  00189	48 8d 84 24 90
	05 00 00	 lea	 rax, QWORD PTR EntityTransformMat$37[rsp]
  00191	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  00199	48 8b f8	 mov	 rdi, rax
  0019c	48 8b f1	 mov	 rsi, rcx
  0019f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a4	f3 a4		 rep movsb

; 86   :         TempPosition += Mesh->RelPosition;

  001a6	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  001ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Mesh$2[rsp]
  001b0	48 8b f8	 mov	 rdi, rax
  001b3	48 8d 71 10	 lea	 rsi, QWORD PTR [rcx+16]
  001b7	b9 0c 00 00 00	 mov	 ecx, 12
  001bc	f3 a4		 rep movsb
  001be	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  001c3	48 8d 8c 24 68
	04 00 00	 lea	 rcx, QWORD PTR TempPosition$[rsp]
  001cb	e8 00 00 00 00	 call	 ??Y@YAAEATv3@@AEAT0@T0@@Z ; operator+=

; 87   :         TempScale *= Mesh->RelScale;

  001d0	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  001d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Mesh$2[rsp]
  001da	48 8b f8	 mov	 rdi, rax
  001dd	48 8d 71 1c	 lea	 rsi, QWORD PTR [rcx+28]
  001e1	b9 0c 00 00 00	 mov	 ecx, 12
  001e6	f3 a4		 rep movsb
  001e8	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T4[rsp]
  001ed	48 8d 8c 24 58
	04 00 00	 lea	 rcx, QWORD PTR TempScale$[rsp]
  001f5	e8 00 00 00 00	 call	 ??X@YAAEATv3@@AEAT0@T0@@Z ; operator*=

; 88   :         CalculateTransform(&EntityTransformMat, TempPosition, TempScale, TempRotation);

  001fa	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  00202	48 8d 8c 24 88
	04 00 00	 lea	 rcx, QWORD PTR TempRotation$[rsp]
  0020a	48 8b f8	 mov	 rdi, rax
  0020d	48 8b f1	 mov	 rsi, rcx
  00210	b9 0c 00 00 00	 mov	 ecx, 12
  00215	f3 a4		 rep movsb
  00217	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  0021f	48 8d 8c 24 58
	04 00 00	 lea	 rcx, QWORD PTR TempScale$[rsp]
  00227	48 8b f8	 mov	 rdi, rax
  0022a	48 8b f1	 mov	 rsi, rcx
  0022d	b9 0c 00 00 00	 mov	 ecx, 12
  00232	f3 a4		 rep movsb
  00234	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  0023c	48 8d 8c 24 68
	04 00 00	 lea	 rcx, QWORD PTR TempPosition$[rsp]
  00244	48 8b f8	 mov	 rdi, rax
  00247	48 8b f1	 mov	 rsi, rcx
  0024a	b9 0c 00 00 00	 mov	 ecx, 12
  0024f	f3 a4		 rep movsb
  00251	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR $T6[rsp]
  00259	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR $T7[rsp]
  00261	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  00269	48 8d 8c 24 90
	05 00 00	 lea	 rcx, QWORD PTR EntityTransformMat$37[rsp]
  00271	e8 00 00 00 00	 call	 ?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z ; CalculateTransform

; 89   :         
; 90   :         mat4 ParentTransformMat = Mat4Identity();

  00276	48 8d 8c 24 98
	03 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  0027e	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  00283	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  0028b	48 8b f9	 mov	 rdi, rcx
  0028e	48 8b f0	 mov	 rsi, rax
  00291	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00296	f3 a4		 rep movsb
  00298	48 8d 84 24 d0
	05 00 00	 lea	 rax, QWORD PTR ParentTransformMat$38[rsp]
  002a0	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  002a8	48 8b f8	 mov	 rdi, rax
  002ab	48 8b f1	 mov	 rsi, rcx
  002ae	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002b3	f3 a4		 rep movsb

; 91   :         if(Parent)

  002b5	48 83 bc 24 48
	09 00 00 00	 cmp	 QWORD PTR Parent$[rsp], 0
  002be	74 79		 je	 SHORT $LN5@RenderEnti

; 92   :         {
; 93   :             CalculateTransform(&ParentTransformMat, Parent->Position, Parent->Scale, Parent->Rotation);

  002c0	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  002c8	48 8b 8c 24 48
	09 00 00	 mov	 rcx, QWORD PTR Parent$[rsp]
  002d0	48 8b f8	 mov	 rdi, rax
  002d3	48 8d 71 30	 lea	 rsi, QWORD PTR [rcx+48]
  002d7	b9 0c 00 00 00	 mov	 ecx, 12
  002dc	f3 a4		 rep movsb
  002de	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  002e6	48 8b 8c 24 48
	09 00 00	 mov	 rcx, QWORD PTR Parent$[rsp]
  002ee	48 8b f8	 mov	 rdi, rax
  002f1	48 8d 71 24	 lea	 rsi, QWORD PTR [rcx+36]
  002f5	b9 0c 00 00 00	 mov	 ecx, 12
  002fa	f3 a4		 rep movsb
  002fc	48 8d 44 24 70	 lea	 rax, QWORD PTR $T5[rsp]
  00301	48 8b 8c 24 48
	09 00 00	 mov	 rcx, QWORD PTR Parent$[rsp]
  00309	48 8b f8	 mov	 rdi, rax
  0030c	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00310	b9 0c 00 00 00	 mov	 ecx, 12
  00315	f3 a4		 rep movsb
  00317	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR $T9[rsp]
  0031f	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR $T10[rsp]
  00327	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T5[rsp]
  0032c	48 8d 8c 24 d0
	05 00 00	 lea	 rcx, QWORD PTR ParentTransformMat$38[rsp]
  00334	e8 00 00 00 00	 call	 ?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z ; CalculateTransform
$LN5@RenderEnti:

; 94   :         }
; 95   :         
; 96   :         mat4 Transform = EntityTransformMat;

  00339	48 8d 84 24 c0
	04 00 00	 lea	 rax, QWORD PTR Transform$33[rsp]
  00341	48 8d 8c 24 90
	05 00 00	 lea	 rcx, QWORD PTR EntityTransformMat$37[rsp]
  00349	48 8b f8	 mov	 rdi, rax
  0034c	48 8b f1	 mov	 rsi, rcx
  0034f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00354	f3 a4		 rep movsb

; 97   :         if(Parent)

  00356	48 83 bc 24 48
	09 00 00 00	 cmp	 QWORD PTR Parent$[rsp], 0
  0035f	0f 84 89 00 00
	00		 je	 $LN6@RenderEnti

; 98   :         {
; 99   :             Transform = Transform*ParentTransformMat;

  00365	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR $T23[rsp]
  0036d	48 8d 8c 24 d0
	05 00 00	 lea	 rcx, QWORD PTR ParentTransformMat$38[rsp]
  00375	48 8b f8	 mov	 rdi, rax
  00378	48 8b f1	 mov	 rsi, rcx
  0037b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00380	f3 a4		 rep movsb
  00382	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR $T21[rsp]
  0038a	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR Transform$33[rsp]
  00392	48 8b f8	 mov	 rdi, rax
  00395	48 8b f1	 mov	 rsi, rcx
  00398	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0039d	f3 a4		 rep movsb
  0039f	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR $T23[rsp]
  003a7	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR $T21[rsp]
  003af	48 8d 8c 24 d8
	03 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  003b7	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  003bc	48 8d 8c 24 10
	07 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  003c4	48 8b f9	 mov	 rdi, rcx
  003c7	48 8b f0	 mov	 rsi, rax
  003ca	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  003cf	f3 a4		 rep movsb
  003d1	48 8d 84 24 c0
	04 00 00	 lea	 rax, QWORD PTR Transform$33[rsp]
  003d9	48 8d 8c 24 10
	07 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  003e1	48 8b f8	 mov	 rdi, rax
  003e4	48 8b f1	 mov	 rsi, rcx
  003e7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  003ec	f3 a4		 rep movsb
$LN6@RenderEnti:

; 100  :         }
; 101  :         
; 102  :         mat4 M4Normal;
; 103  :         Mat4Inverse(&M4Normal, &Transform);

  003ee	48 8d 94 24 c0
	04 00 00	 lea	 rdx, QWORD PTR Transform$33[rsp]
  003f6	48 8d 8c 24 00
	05 00 00	 lea	 rcx, QWORD PTR M4Normal$34[rsp]
  003fe	e8 00 00 00 00	 call	 ?Mat4Inverse@@YAXPEATmat4@@0@Z ; Mat4Inverse

; 104  :         Mat4Transpose(&M4Normal, &M4Normal);

  00403	48 8d 94 24 00
	05 00 00	 lea	 rdx, QWORD PTR M4Normal$34[rsp]
  0040b	48 8d 8c 24 00
	05 00 00	 lea	 rcx, QWORD PTR M4Normal$34[rsp]
  00413	e8 00 00 00 00	 call	 ?Mat4Transpose@@YAXPEATmat4@@0@Z ; Mat4Transpose

; 105  :         
; 106  :         mat3 NormalMat = Mat3FromMat4(&M4Normal);

  00418	48 8d 94 24 00
	05 00 00	 lea	 rdx, QWORD PTR M4Normal$34[rsp]
  00420	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  00428	e8 00 00 00 00	 call	 ?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z ; Mat3FromMat4
  0042d	48 8d 8c 24 68
	05 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  00435	48 8b f9	 mov	 rdi, rcx
  00438	48 8b f0	 mov	 rsi, rax
  0043b	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00440	f3 a4		 rep movsb
  00442	48 8d 84 24 40
	05 00 00	 lea	 rax, QWORD PTR NormalMat$35[rsp]
  0044a	48 8d 8c 24 68
	05 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  00452	48 8b f8	 mov	 rdi, rax
  00455	48 8b f1	 mov	 rsi, rcx
  00458	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0045d	f3 a4		 rep movsb

; 107  :         
; 108  :         mat4 M = Transform*PrevM;

  0045f	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR $T20[rsp]
  00467	48 8d 8c 24 10
	06 00 00	 lea	 rcx, QWORD PTR PrevM$[rsp]
  0046f	48 8b f8	 mov	 rdi, rax
  00472	48 8b f1	 mov	 rsi, rcx
  00475	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0047a	f3 a4		 rep movsb
  0047c	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR $T19[rsp]
  00484	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR Transform$33[rsp]
  0048c	48 8b f8	 mov	 rdi, rax
  0048f	48 8b f1	 mov	 rsi, rcx
  00492	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00497	f3 a4		 rep movsb
  00499	4c 8d 84 24 f0
	01 00 00	 lea	 r8, QWORD PTR $T20[rsp]
  004a1	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR $T19[rsp]
  004a9	48 8d 8c 24 18
	04 00 00	 lea	 rcx, QWORD PTR $T29[rsp]
  004b1	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  004b6	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  004be	48 8b f9	 mov	 rdi, rcx
  004c1	48 8b f0	 mov	 rsi, rax
  004c4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004c9	f3 a4		 rep movsb
  004cb	48 8d 84 24 90
	07 00 00	 lea	 rax, QWORD PTR M$44[rsp]
  004d3	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  004db	48 8b f8	 mov	 rdi, rax
  004de	48 8b f1	 mov	 rsi, rcx
  004e1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004e6	f3 a4		 rep movsb

; 109  :         shader_constants Constants;
; 110  :         Constants.Material = Mesh->Material;

  004e8	48 8d 84 24 d0
	07 00 00	 lea	 rax, QWORD PTR Constants$45[rsp]
  004f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR Mesh$2[rsp]
  004f5	48 8b f8	 mov	 rdi, rax
  004f8	48 8d 71 5c	 lea	 rsi, QWORD PTR [rcx+92]
  004fc	b9 10 00 00 00	 mov	 ecx, 16
  00501	f3 a4		 rep movsb

; 111  :         Constants.DirLight = State->DirLight;

  00503	48 8d 84 24 e0
	07 00 00	 lea	 rax, QWORD PTR Constants$45[rsp+16]
  0050b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00512	48 8b f8	 mov	 rdi, rax
  00515	48 8d b1 b4 00
	00 00		 lea	 rsi, QWORD PTR [rcx+180]
  0051c	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00521	f3 a4		 rep movsb

; 112  :         Constants.PointLight = PointLight;

  00523	48 8d 84 24 10
	08 00 00	 lea	 rax, QWORD PTR Constants$45[rsp+64]
  0052b	48 8b f8	 mov	 rdi, rax
  0052e	48 8b b4 24 60
	09 00 00	 mov	 rsi, QWORD PTR PointLight$[rsp]
  00536	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0053b	f3 a4		 rep movsb

; 113  :         Constants.CameraPosition = V3(PrevM*V4(State->Camera->Position, 1.0f));

  0053d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00544	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0054b	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  00553	48 8b f9	 mov	 rdi, rcx
  00556	48 8b f0	 mov	 rsi, rax
  00559	b9 0c 00 00 00	 mov	 ecx, 12
  0055e	f3 a4		 rep movsb
  00560	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00568	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T11[rsp]
  00570	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00578	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@Tv3@@M@Z	; V4
  0057d	48 8d 8c 24 a8
	04 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  00585	48 8b f9	 mov	 rdi, rcx
  00588	48 8b f0	 mov	 rsi, rax
  0058b	b9 10 00 00 00	 mov	 ecx, 16
  00590	f3 a4		 rep movsb
  00592	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  0059a	48 8d 8c 24 a8
	04 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  005a2	48 8b f8	 mov	 rdi, rax
  005a5	48 8b f1	 mov	 rsi, rcx
  005a8	b9 10 00 00 00	 mov	 ecx, 16
  005ad	f3 a4		 rep movsb
  005af	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR $T18[rsp]
  005b7	48 8d 8c 24 10
	06 00 00	 lea	 rcx, QWORD PTR PrevM$[rsp]
  005bf	48 8b f8	 mov	 rdi, rax
  005c2	48 8b f1	 mov	 rsi, rcx
  005c5	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  005ca	f3 a4		 rep movsb
  005cc	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR $T12[rsp]
  005d4	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR $T18[rsp]
  005dc	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  005e4	e8 00 00 00 00	 call	 ??D@YA?ATv4@@Tmat4@@T0@@Z ; operator*
  005e9	48 8d 8c 24 98
	04 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  005f1	48 8b f9	 mov	 rdi, rcx
  005f4	48 8b f0	 mov	 rsi, rax
  005f7	b9 10 00 00 00	 mov	 ecx, 16
  005fc	f3 a4		 rep movsb
  005fe	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T13[rsp]
  00606	48 8d 8c 24 98
	04 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0060e	48 8b f8	 mov	 rdi, rax
  00611	48 8b f1	 mov	 rsi, rcx
  00614	b9 10 00 00 00	 mov	 ecx, 16
  00619	f3 a4		 rep movsb
  0061b	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  00623	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  0062b	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@Tv4@@@Z	; V3
  00630	48 8d 8c 24 78
	04 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00638	48 8b f9	 mov	 rdi, rcx
  0063b	48 8b f0	 mov	 rsi, rax
  0063e	b9 0c 00 00 00	 mov	 ecx, 12
  00643	f3 a4		 rep movsb
  00645	48 8d 84 24 50
	08 00 00	 lea	 rax, QWORD PTR Constants$45[rsp+128]
  0064d	48 8d 8c 24 78
	04 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00655	48 8b f8	 mov	 rdi, rax
  00658	48 8b f1	 mov	 rsi, rcx
  0065b	b9 0c 00 00 00	 mov	 ecx, 12
  00660	f3 a4		 rep movsb

; 114  :         Constants.Time = State->Time;

  00662	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00669	f3 0f 10 80 f0
	00 00 00	 movss	 xmm0, DWORD PTR [rax+240]
  00671	f3 0f 11 84 24
	5c 08 00 00	 movss	 DWORD PTR Constants$45[rsp+140], xmm0

; 115  :         Constants.M = M;

  0067a	48 8d 84 24 60
	08 00 00	 lea	 rax, QWORD PTR Constants$45[rsp+144]
  00682	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR M$44[rsp]
  0068a	48 8b f8	 mov	 rdi, rax
  0068d	48 8b f1	 mov	 rsi, rcx
  00690	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00695	f3 a4		 rep movsb

; 116  :         Constants.TransformMat = Transform;

  00697	48 8d 84 24 a0
	08 00 00	 lea	 rax, QWORD PTR Constants$45[rsp+208]
  0069f	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR Transform$33[rsp]
  006a7	48 8b f8	 mov	 rdi, rax
  006aa	48 8b f1	 mov	 rsi, rcx
  006ad	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  006b2	f3 a4		 rep movsb

; 117  :         Constants.NormalMat = NormalMat;

  006b4	48 8d 84 24 e0
	08 00 00	 lea	 rax, QWORD PTR Constants$45[rsp+272]
  006bc	48 8d 8c 24 40
	05 00 00	 lea	 rcx, QWORD PTR NormalMat$35[rsp]
  006c4	48 8b f8	 mov	 rdi, rax
  006c7	48 8b f1	 mov	 rsi, rcx
  006ca	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  006cf	f3 a4		 rep movsb

; 118  :         
; 119  :         Platform->RenderMesh(Mesh->Platform, Texture, Shader, &Constants, false);

  006d1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  006d9	4c 8d 8c 24 d0
	07 00 00	 lea	 r9, QWORD PTR Constants$45[rsp]
  006e1	4c 8b 84 24 58
	09 00 00	 mov	 r8, QWORD PTR Shader$[rsp]
  006e9	48 8b 94 24 50
	09 00 00	 mov	 rdx, QWORD PTR Texture$[rsp]
  006f1	48 8b 44 24 38	 mov	 rax, QWORD PTR Mesh$2[rsp]
  006f6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00700	ff 50 50	 call	 QWORD PTR [rax+80]

; 120  :     }

  00703	e9 2f fa ff ff	 jmp	 $LN2@RenderEnti
$LN3@RenderEnti:

; 121  : }

  00708	48 8b 8c 24 10
	09 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00710	48 33 cc	 xor	 rcx, rsp
  00713	e8 00 00 00 00	 call	 __security_check_cookie
  00718	48 81 c4 28 09
	00 00		 add	 rsp, 2344		; 00000928H
  0071f	5f		 pop	 rdi
  00720	5e		 pop	 rsi
  00721	c3		 ret	 0
?RenderEntity@@YAXPEAUentity@@0PEAX1Upoint_light@@PEATmat4@@3@Z ENDP ; RenderEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
$T8 = 144
RotationRadians$ = 160
$T9 = 176
$T10 = 192
__$ArrayPad$ = 208
Result$ = 256
Position$ = 264
Scale$ = 272
Rotation$ = 280
?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z PROC	; CalculateTransform

; 54   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 55   :     TranslateMat4(Result, Position);

  0002f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00034	48 8b f8	 mov	 rdi, rax
  00037	48 8b b4 24 08
	01 00 00	 mov	 rsi, QWORD PTR Position$[rsp]
  0003f	b9 0c 00 00 00	 mov	 ecx, 12
  00044	f3 a4		 rep movsb
  00046	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0004b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00053	e8 00 00 00 00	 call	 ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z ; TranslateMat4

; 56   :     v3 RotationRadians = Rotation*DEG_TO_RAD;

  00058	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0005d	48 8b f8	 mov	 rdi, rax
  00060	48 8b b4 24 18
	01 00 00	 mov	 rsi, QWORD PTR Rotation$[rsp]
  00068	b9 0c 00 00 00	 mov	 ecx, 12
  0006d	f3 a4		 rep movsb
  0006f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3c8efa35
  00077	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  0007c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00084	e8 00 00 00 00	 call	 ??D@YA?ATv3@@T0@M@Z	; operator*
  00089	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00091	48 8b f9	 mov	 rdi, rcx
  00094	48 8b f0	 mov	 rsi, rax
  00097	b9 0c 00 00 00	 mov	 ecx, 12
  0009c	f3 a4		 rep movsb
  0009e	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR RotationRadians$[rsp]
  000a6	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  000ae	48 8b f8	 mov	 rdi, rax
  000b1	48 8b f1	 mov	 rsi, rcx
  000b4	b9 0c 00 00 00	 mov	 ecx, 12
  000b9	f3 a4		 rep movsb

; 57   :     if(RotationRadians.x || RotationRadians.y || RotationRadians.z)

  000bb	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp]
  000c4	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000cb	7a 2e		 jp	 SHORT $LN3@CalculateT
  000cd	75 2c		 jne	 SHORT $LN3@CalculateT
  000cf	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+4]
  000d8	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000df	7a 1a		 jp	 SHORT $LN3@CalculateT
  000e1	75 18		 jne	 SHORT $LN3@CalculateT
  000e3	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+8]
  000ec	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000f3	7a 06		 jp	 SHORT $LN5@CalculateT
  000f5	0f 84 94 00 00
	00		 je	 $LN2@CalculateT
$LN5@CalculateT:
$LN3@CalculateT:

; 58   :     {
; 59   :         RotateMat4(Result,

  000fb	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  00100	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  00108	48 8b f8	 mov	 rdi, rax
  0010b	48 8b f1	 mov	 rsi, rcx
  0010e	b9 0c 00 00 00	 mov	 ecx, 12
  00113	f3 a4		 rep movsb
  00115	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  0011a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00122	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  00127	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  0012f	48 8b f9	 mov	 rdi, rcx
  00132	48 8b f0	 mov	 rsi, rax
  00135	b9 0c 00 00 00	 mov	 ecx, 12
  0013a	f3 a4		 rep movsb
  0013c	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  00141	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00149	48 8b f8	 mov	 rdi, rax
  0014c	48 8b f1	 mov	 rsi, rcx
  0014f	b9 0c 00 00 00	 mov	 ecx, 12
  00154	f3 a4		 rep movsb
  00156	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  0015b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  00163	48 8b f8	 mov	 rdi, rax
  00166	48 8b f1	 mov	 rsi, rcx
  00169	b9 0c 00 00 00	 mov	 ecx, 12
  0016e	f3 a4		 rep movsb
  00170	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  00175	e8 00 00 00 00	 call	 ?V3Length@@YAMTv3@@@Z	; V3Length
  0017a	4c 8d 44 24 60	 lea	 r8, QWORD PTR $T5[rsp]
  0017f	0f 28 c8	 movaps	 xmm1, xmm0
  00182	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  0018a	e8 00 00 00 00	 call	 ?RotateMat4@@YAXPEATmat4@@MTv3@@@Z ; RotateMat4
$LN2@CalculateT:

; 60   :                    V3Length(RotationRadians),
; 61   :                    V3Normalize(RotationRadians));
; 62   :     }
; 63   :     ScaleMat4(Result, Scale);

  0018f	48 8d 44 24 70	 lea	 rax, QWORD PTR $T6[rsp]
  00194	48 8b f8	 mov	 rdi, rax
  00197	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR Scale$[rsp]
  0019f	b9 0c 00 00 00	 mov	 ecx, 12
  001a4	f3 a4		 rep movsb
  001a6	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T6[rsp]
  001ab	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  001b3	e8 00 00 00 00	 call	 ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z ; ScaleMat4

; 64   : }

  001b8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c0	48 33 cc	 xor	 rcx, rsp
  001c3	e8 00 00 00 00	 call	 __security_check_cookie
  001c8	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  001cf	5f		 pop	 rdi
  001d0	5e		 pop	 rsi
  001d1	c3		 ret	 0
?CalculateTransform@@YAXPEATmat4@@Tv3@@11@Z ENDP	; CalculateTransform
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
Mesh$1 = 112
VertexIndex$2 = 120
IndIndex$3 = 124
VertexIndex$4 = 128
VertexIndex$5 = 132
VertexIndex$6 = 136
Binary$ = 144
Count$7 = 152
Count$8 = 156
VertexIndex$9 = 160
Primitive$10 = 168
Object$ = 176
RealMeshIndex$11 = 184
ByteOffset$12 = 188
ByteOffset$13 = 192
ByteOffset$14 = 196
ByteOffset$15 = 200
Count$16 = 204
Count$17 = 208
ByteOffset$18 = 212
Buffers$ = 216
BufferViews$ = 224
Accessors$ = 232
Attributes$19 = 240
BaseColorArray$20 = 248
PrimitiveElement$21 = 256
NodeElement$ = 264
MeshIndex$22 = 272
RealIndex$23 = 276
Index$24 = 280
A$25 = 284
B$26 = 288
G$27 = 292
R$28 = 296
Count$29 = 300
ScaleArray$30 = 304
Result$ = 312
FileString$ = 328
Node$31 = 336
ScaleElement$32 = 344
Materials$ = 352
PathString$33 = 360
Meshes$ = 376
MeshArrayElement$34 = 384
MeshObject$35 = 392
PrimitivesElement$36 = 400
Primitives$37 = 408
Root$ = 416
Positions$38 = 424
Indices$39 = 432
MaterialElement$40 = 440
Material$41 = 448
PBRMetallicRoughnessElement$42 = 456
PBRMetallicRoughness$43 = 464
AttributesElement$44 = 472
Normals$45 = 480
tv1083 = 488
UVs$46 = 496
Colors$47 = 504
tv1161 = 512
Nodes$ = 520
BaseColorArrayElement$48 = 528
$T49 = 544
Contents$50 = 560
FileContents$ = 584
$T51 = 608
$T52 = 624
$T53 = 640
$T54 = 656
$T55 = 672
$T56 = 688
$T57 = 704
$T58 = 720
$T59 = 736
$T60 = 752
$T61 = 768
$T62 = 784
$T63 = 800
$T64 = 816
$T65 = 832
$T66 = 848
$T67 = 864
$T68 = 880
$T69 = 896
$T70 = 912
$T71 = 928
$T72 = 944
$T73 = 960
$T74 = 976
$T75 = 992
$T76 = 1008
$T77 = 1024
$T78 = 1040
$T79 = 1056
$T80 = 1072
$T81 = 1088
$T82 = 1104
$T83 = 1120
$T84 = 1136
$T85 = 1152
$T86 = 1168
$T87 = 1184
$T88 = 1200
$T89 = 1216
$T90 = 1232
$T91 = 1248
$T92 = 1264
Contents$93 = 1288
$T94 = 1312
$T95 = 1336
$T96 = 1360
Contents$97 = 1384
$T98 = 1408
Contents$99 = 1432
$T100 = 1456
Contents$101 = 1480
$T102 = 1504
$T103 = 1520
$T104 = 1536
$T105 = 1552
$T106 = 1568
$T107 = 1584
$T108 = 1600
$T109 = 1616
$T110 = 1632
$T111 = 1648
$T112 = 1664
$T113 = 1680
$T114 = 1696
$T115 = 1712
$T116 = 1728
$T117 = 1744
$T118 = 1760
$T119 = 1776
$T120 = 1792
$T121 = 1808
$T122 = 1824
$T123 = 1840
$T124 = 1864
$T125 = 1888
$T126 = 1912
$T127 = 1936
$T128 = 1960
Scale$129 = 1984
$T130 = 2000
Position$131 = 2016
$T132 = 2032
$T133 = 2048
__$ArrayPad$ = 2064
$T134 = 2112
Path$ = 2120
Arena$ = 2128
?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z PROC ; LoadGLTF

; 193  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 28 08
	00 00		 sub	 rsp, 2088		; 00000828H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 10
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 194  :     /*
; 195  : GLTF Spec:
; 196  : 
; 197  : Coordinate System:
; 198  : The units for all linear distances are meters.
; 199  : All angles are in radians.
; 200  : Positive rotation is counterclockwise.
; 201  : 
; 202  : Component Types:
; 203  : 5120: BYTE
; 204  : 5121: UNSIGNED_BYTE
; 205  : 5122: SHORT
; 206  : 5123: UNSIGNED_SHORT
; 207  : 5125: UNSIGNED_INT
; 208  : 5126: FLOAT
; 209  : */
; 210  :     
; 211  :     // TODO(evan): Different nodes can access the same mesh
; 212  :     // this would be a good optimization to make later
; 213  :     
; 214  :     loaded_model Result = {0};

  0002a	48 8d 84 24 38
	01 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  00032	48 8b f8	 mov	 rdi, rax
  00035	33 c0		 xor	 eax, eax
  00037	b9 10 00 00 00	 mov	 ecx, 16
  0003c	f3 aa		 rep stosb

; 215  :     
; 216  :     file_contents FileContents = ReadFile8(Path, &TranState->FrameArena);

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00045	48 83 c0 20	 add	 rax, 32			; 00000020H
  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b 94 24 48
	08 00 00	 mov	 rdx, QWORD PTR Path$[rsp]
  00054	48 8d 8c 24 30
	07 00 00	 lea	 rcx, QWORD PTR $T123[rsp]
  0005c	e8 00 00 00 00	 call	 ?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z ; ReadFile8
  00061	48 8d 8c 24 38
	05 00 00	 lea	 rcx, QWORD PTR $T95[rsp]
  00069	48 8b f9	 mov	 rdi, rcx
  0006c	48 8b f0	 mov	 rsi, rax
  0006f	b9 18 00 00 00	 mov	 ecx, 24
  00074	f3 a4		 rep movsb
  00076	48 8d 84 24 48
	02 00 00	 lea	 rax, QWORD PTR FileContents$[rsp]
  0007e	48 8d 8c 24 38
	05 00 00	 lea	 rcx, QWORD PTR $T95[rsp]
  00086	48 8b f8	 mov	 rdi, rax
  00089	48 8b f1	 mov	 rsi, rcx
  0008c	b9 18 00 00 00	 mov	 ecx, 24
  00091	f3 a4		 rep movsb

; 217  :     char *FileString = (char *)FileContents.Data;

  00093	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR FileContents$[rsp+8]
  0009b	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR FileString$[rsp], rax

; 218  :     
; 219  :     json_value_s *Root = json_parse(FileString, StringLength(FileString));

  000a3	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR FileString$[rsp]
  000ab	e8 00 00 00 00	 call	 ?StringLength@@YAHPEAD@Z ; StringLength
  000b0	48 98		 cdqe
  000b2	48 8b d0	 mov	 rdx, rax
  000b5	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR FileString$[rsp]
  000bd	e8 00 00 00 00	 call	 json_parse
  000c2	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR Root$[rsp], rax

; 220  :     json_object_s *Object = (json_object_s *)Root->payload;

  000ca	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR Root$[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR Object$[rsp], rax

; 221  :     
; 222  :     json_array_s *Nodes = GrabJSONArray(CreateString("nodes"), Object);

  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46315
  000e4	48 8d 8c 24 e0
	06 00 00	 lea	 rcx, QWORD PTR $T118[rsp]
  000ec	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  000f1	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR $T51[rsp]
  000f9	48 8b f9	 mov	 rdi, rcx
  000fc	48 8b f0	 mov	 rsi, rax
  000ff	b9 10 00 00 00	 mov	 ecx, 16
  00104	f3 a4		 rep movsb
  00106	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR $T52[rsp]
  0010e	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR $T51[rsp]
  00116	48 8b f8	 mov	 rdi, rax
  00119	48 8b f1	 mov	 rsi, rcx
  0011c	b9 10 00 00 00	 mov	 ecx, 16
  00121	f3 a4		 rep movsb
  00123	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Object$[rsp]
  0012b	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR $T52[rsp]
  00133	e8 00 00 00 00	 call	 ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ; GrabJSONArray
  00138	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR Nodes$[rsp], rax

; 223  :     json_array_s *Meshes = GrabJSONArray(CreateString("meshes"), Object);

  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46316
  00147	48 8d 8c 24 f0
	06 00 00	 lea	 rcx, QWORD PTR $T119[rsp]
  0014f	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00154	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR $T53[rsp]
  0015c	48 8b f9	 mov	 rdi, rcx
  0015f	48 8b f0	 mov	 rsi, rax
  00162	b9 10 00 00 00	 mov	 ecx, 16
  00167	f3 a4		 rep movsb
  00169	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR $T54[rsp]
  00171	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR $T53[rsp]
  00179	48 8b f8	 mov	 rdi, rax
  0017c	48 8b f1	 mov	 rsi, rcx
  0017f	b9 10 00 00 00	 mov	 ecx, 16
  00184	f3 a4		 rep movsb
  00186	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Object$[rsp]
  0018e	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR $T54[rsp]
  00196	e8 00 00 00 00	 call	 ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ; GrabJSONArray
  0019b	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR Meshes$[rsp], rax

; 224  :     json_array_s *Accessors = GrabJSONArray(CreateString("accessors"), Object);

  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46317
  001aa	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T117[rsp]
  001b2	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  001b7	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR $T55[rsp]
  001bf	48 8b f9	 mov	 rdi, rcx
  001c2	48 8b f0	 mov	 rsi, rax
  001c5	b9 10 00 00 00	 mov	 ecx, 16
  001ca	f3 a4		 rep movsb
  001cc	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR $T56[rsp]
  001d4	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR $T55[rsp]
  001dc	48 8b f8	 mov	 rdi, rax
  001df	48 8b f1	 mov	 rsi, rcx
  001e2	b9 10 00 00 00	 mov	 ecx, 16
  001e7	f3 a4		 rep movsb
  001e9	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Object$[rsp]
  001f1	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR $T56[rsp]
  001f9	e8 00 00 00 00	 call	 ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ; GrabJSONArray
  001fe	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR Accessors$[rsp], rax

; 225  :     json_array_s *BufferViews = GrabJSONArray(CreateString("bufferViews"), Object);

  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46318
  0020d	48 8d 8c 24 10
	07 00 00	 lea	 rcx, QWORD PTR $T121[rsp]
  00215	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0021a	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR $T57[rsp]
  00222	48 8b f9	 mov	 rdi, rcx
  00225	48 8b f0	 mov	 rsi, rax
  00228	b9 10 00 00 00	 mov	 ecx, 16
  0022d	f3 a4		 rep movsb
  0022f	48 8d 84 24 d0
	02 00 00	 lea	 rax, QWORD PTR $T58[rsp]
  00237	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR $T57[rsp]
  0023f	48 8b f8	 mov	 rdi, rax
  00242	48 8b f1	 mov	 rsi, rcx
  00245	b9 10 00 00 00	 mov	 ecx, 16
  0024a	f3 a4		 rep movsb
  0024c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Object$[rsp]
  00254	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR $T58[rsp]
  0025c	e8 00 00 00 00	 call	 ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ; GrabJSONArray
  00261	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR BufferViews$[rsp], rax

; 226  :     json_array_s *Buffers = GrabJSONArray(CreateString("buffers"), Object);

  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46319
  00270	48 8d 8c 24 20
	07 00 00	 lea	 rcx, QWORD PTR $T122[rsp]
  00278	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0027d	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR $T59[rsp]
  00285	48 8b f9	 mov	 rdi, rcx
  00288	48 8b f0	 mov	 rsi, rax
  0028b	b9 10 00 00 00	 mov	 ecx, 16
  00290	f3 a4		 rep movsb
  00292	48 8d 84 24 f0
	02 00 00	 lea	 rax, QWORD PTR $T60[rsp]
  0029a	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR $T59[rsp]
  002a2	48 8b f8	 mov	 rdi, rax
  002a5	48 8b f1	 mov	 rsi, rcx
  002a8	b9 10 00 00 00	 mov	 ecx, 16
  002ad	f3 a4		 rep movsb
  002af	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Object$[rsp]
  002b7	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR $T60[rsp]
  002bf	e8 00 00 00 00	 call	 ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ; GrabJSONArray
  002c4	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR Buffers$[rsp], rax

; 227  :     json_array_s *Materials = GrabJSONArray(CreateString("materials"), Object);

  002cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46320
  002d3	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR $T102[rsp]
  002db	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  002e0	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR $T61[rsp]
  002e8	48 8b f9	 mov	 rdi, rcx
  002eb	48 8b f0	 mov	 rsi, rax
  002ee	b9 10 00 00 00	 mov	 ecx, 16
  002f3	f3 a4		 rep movsb
  002f5	48 8d 84 24 10
	03 00 00	 lea	 rax, QWORD PTR $T62[rsp]
  002fd	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR $T61[rsp]
  00305	48 8b f8	 mov	 rdi, rax
  00308	48 8b f1	 mov	 rsi, rcx
  0030b	b9 10 00 00 00	 mov	 ecx, 16
  00310	f3 a4		 rep movsb
  00312	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR Object$[rsp]
  0031a	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR $T62[rsp]
  00322	e8 00 00 00 00	 call	 ?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ; GrabJSONArray
  00327	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR Materials$[rsp], rax

; 228  :     
; 229  :     u8 *Binary = 0;

  0032f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR Binary$[rsp], 0

; 230  :     
; 231  :     json_array_element_s *NodeElement = Nodes->start;

  0033b	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR Nodes$[rsp]
  00343	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00346	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR NodeElement$[rsp], rax
$LN2@LoadGLTF:

; 232  :     while(true)

  0034e	33 c0		 xor	 eax, eax
  00350	83 f8 01	 cmp	 eax, 1
  00353	0f 84 f2 11 00
	00		 je	 $LN3@LoadGLTF

; 233  :     {
; 234  :         json_object_s *Node = (json_object_s *)NodeElement->value->payload;

  00359	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR NodeElement$[rsp]
  00361	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00364	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00367	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR Node$31[rsp], rax

; 235  :         
; 236  :         f32 RealMeshIndex = 0;

  0036f	0f 57 c0	 xorps	 xmm0, xmm0
  00372	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR RealMeshIndex$11[rsp], xmm0

; 237  :         Assert(GrabNumberFromJSONObject(CreateString("mesh"), Node, &RealMeshIndex) == GLTF_RESULT_SUCCESS);

  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46322
  00382	48 8d 8c 24 f0
	05 00 00	 lea	 rcx, QWORD PTR $T103[rsp]
  0038a	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0038f	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR $T63[rsp]
  00397	48 8b f9	 mov	 rdi, rcx
  0039a	48 8b f0	 mov	 rsi, rax
  0039d	b9 10 00 00 00	 mov	 ecx, 16
  003a2	f3 a4		 rep movsb
  003a4	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR $T64[rsp]
  003ac	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR $T63[rsp]
  003b4	48 8b f8	 mov	 rdi, rax
  003b7	48 8b f1	 mov	 rsi, rcx
  003ba	b9 10 00 00 00	 mov	 ecx, 16
  003bf	f3 a4		 rep movsb
  003c1	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR RealMeshIndex$11[rsp]
  003c9	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR Node$31[rsp]
  003d1	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR $T64[rsp]
  003d9	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  003de	85 c0		 test	 eax, eax
  003e0	74 0b		 je	 SHORT $LN24@LoadGLTF
  003e2	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN24@LoadGLTF:

; 238  :         s32 MeshIndex = (s32)RealMeshIndex;

  003ed	f3 0f 2c 84 24
	b8 00 00 00	 cvttss2si eax, DWORD PTR RealMeshIndex$11[rsp]
  003f6	89 84 24 10 01
	00 00		 mov	 DWORD PTR MeshIndex$22[rsp], eax

; 239  :         
; 240  :         // NOTE(evan): Scale
; 241  :         v3 Scale = { 1.0f, 1.0f, 1.0f };

  003fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00405	f3 0f 11 84 24
	c0 07 00 00	 movss	 DWORD PTR Scale$129[rsp], xmm0
  0040e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00416	f3 0f 11 84 24
	c4 07 00 00	 movss	 DWORD PTR Scale$129[rsp+4], xmm0
  0041f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00427	f3 0f 11 84 24
	c8 07 00 00	 movss	 DWORD PTR Scale$129[rsp+8], xmm0

; 242  :         {
; 243  :             json_object_element_s *ScaleElement = FindJSONObjectElement(CreateString("scale"), Node);

  00430	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46323
  00437	48 8d 8c 24 00
	07 00 00	 lea	 rcx, QWORD PTR $T120[rsp]
  0043f	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00444	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR $T65[rsp]
  0044c	48 8b f9	 mov	 rdi, rcx
  0044f	48 8b f0	 mov	 rsi, rax
  00452	b9 10 00 00 00	 mov	 ecx, 16
  00457	f3 a4		 rep movsb
  00459	48 8d 84 24 50
	03 00 00	 lea	 rax, QWORD PTR $T66[rsp]
  00461	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR $T65[rsp]
  00469	48 8b f8	 mov	 rdi, rax
  0046c	48 8b f1	 mov	 rsi, rcx
  0046f	b9 10 00 00 00	 mov	 ecx, 16
  00474	f3 a4		 rep movsb
  00476	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR Node$31[rsp]
  0047e	48 8d 8c 24 50
	03 00 00	 lea	 rcx, QWORD PTR $T66[rsp]
  00486	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  0048b	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR ScaleElement$32[rsp], rax

; 244  :             if(ScaleElement)

  00493	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR ScaleElement$32[rsp], 0
  0049c	74 64		 je	 SHORT $LN25@LoadGLTF

; 245  :             {
; 246  :                 json_array_s *ScaleArray = json_value_as_array(ScaleElement->value);

  0049e	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR ScaleElement$32[rsp]
  004a6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004aa	e8 00 00 00 00	 call	 json_value_as_array
  004af	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR ScaleArray$30[rsp], rax

; 247  :                 
; 248  :                 GrabNumberFromJSONArray(0, ScaleArray, &Scale.x);

  004b7	4c 8d 84 24 c0
	07 00 00	 lea	 r8, QWORD PTR Scale$129[rsp]
  004bf	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ScaleArray$30[rsp]
  004c7	33 c9		 xor	 ecx, ecx
  004c9	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray

; 249  :                 GrabNumberFromJSONArray(1, ScaleArray, &Scale.y);

  004ce	4c 8d 84 24 c4
	07 00 00	 lea	 r8, QWORD PTR Scale$129[rsp+4]
  004d6	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ScaleArray$30[rsp]
  004de	b9 01 00 00 00	 mov	 ecx, 1
  004e3	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray

; 250  :                 GrabNumberFromJSONArray(2, ScaleArray, &Scale.z);

  004e8	4c 8d 84 24 c8
	07 00 00	 lea	 r8, QWORD PTR Scale$129[rsp+8]
  004f0	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR ScaleArray$30[rsp]
  004f8	b9 02 00 00 00	 mov	 ecx, 2
  004fd	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray
$LN25@LoadGLTF:

; 251  :             }
; 252  :         }
; 253  :         
; 254  :         json_array_element_s *MeshArrayElement = GrabJSONArrayElementIndexed(MeshIndex, Meshes);

  00502	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR Meshes$[rsp]
  0050a	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR MeshIndex$22[rsp]
  00511	e8 00 00 00 00	 call	 ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z ; GrabJSONArrayElementIndexed
  00516	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR MeshArrayElement$34[rsp], rax

; 255  :         json_object_s *MeshObject = json_value_as_object(MeshArrayElement->value);

  0051e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR MeshArrayElement$34[rsp]
  00526	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00529	e8 00 00 00 00	 call	 json_value_as_object
  0052e	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR MeshObject$35[rsp], rax

; 256  :         
; 257  :         json_object_element_s *PrimitivesElement = FindJSONObjectElement(CreateString("primitives"), MeshObject);

  00536	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46325
  0053d	48 8d 8c 24 00
	06 00 00	 lea	 rcx, QWORD PTR $T104[rsp]
  00545	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0054a	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR $T67[rsp]
  00552	48 8b f9	 mov	 rdi, rcx
  00555	48 8b f0	 mov	 rsi, rax
  00558	b9 10 00 00 00	 mov	 ecx, 16
  0055d	f3 a4		 rep movsb
  0055f	48 8d 84 24 70
	03 00 00	 lea	 rax, QWORD PTR $T68[rsp]
  00567	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR $T67[rsp]
  0056f	48 8b f8	 mov	 rdi, rax
  00572	48 8b f1	 mov	 rsi, rcx
  00575	b9 10 00 00 00	 mov	 ecx, 16
  0057a	f3 a4		 rep movsb
  0057c	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR MeshObject$35[rsp]
  00584	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR $T68[rsp]
  0058c	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  00591	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR PrimitivesElement$36[rsp], rax

; 258  :         json_array_s *Primitives = json_value_as_array(PrimitivesElement->value);

  00599	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR PrimitivesElement$36[rsp]
  005a1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005a5	e8 00 00 00 00	 call	 json_value_as_array
  005aa	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR Primitives$37[rsp], rax

; 259  :         json_array_element_s *PrimitiveElement = Primitives->start;

  005b2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR Primitives$37[rsp]
  005ba	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005bd	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR PrimitiveElement$21[rsp], rax

; 260  :         
; 261  :         Result.Meshes = PushStruct(Arena, mesh);

  005c5	ba 70 00 00 00	 mov	 edx, 112		; 00000070H
  005ca	48 8b 8c 24 50
	08 00 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  005d2	e8 00 00 00 00	 call	 PushSize
  005d7	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR Result$[rsp], rax

; 262  :         mesh *Mesh = Result.Meshes;

  005df	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR Result$[rsp]
  005e7	48 89 44 24 70	 mov	 QWORD PTR Mesh$1[rsp], rax

; 263  :         Result.MeshCount = 1;

  005ec	c7 84 24 40 01
	00 00 01 00 00
	00		 mov	 DWORD PTR Result$[rsp+8], 1
$LN4@LoadGLTF:

; 264  :         while(true)

  005f7	33 c0		 xor	 eax, eax
  005f9	83 f8 01	 cmp	 eax, 1
  005fc	0f 84 1f 0f 00
	00		 je	 $LN5@LoadGLTF

; 265  :         {
; 266  :             Mesh->RelScale = Scale;

  00602	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  00607	48 8d 8c 24 c0
	07 00 00	 lea	 rcx, QWORD PTR Scale$129[rsp]
  0060f	48 8d 78 1c	 lea	 rdi, QWORD PTR [rax+28]
  00613	48 8b f1	 mov	 rsi, rcx
  00616	b9 0c 00 00 00	 mov	 ecx, 12
  0061b	f3 a4		 rep movsb

; 267  :             
; 268  :             json_object_s *Primitive = (json_object_s *)PrimitiveElement->value->payload;

  0061d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR PrimitiveElement$21[rsp]
  00625	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00628	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0062b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR Primitive$10[rsp], rax

; 269  :             
; 270  :             json_object_element_s *AttributesElement = FindJSONObjectElement(CreateString("attributes"), Primitive);

  00633	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46326
  0063a	48 8d 8c 24 10
	06 00 00	 lea	 rcx, QWORD PTR $T105[rsp]
  00642	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00647	48 8d 8c 24 80
	03 00 00	 lea	 rcx, QWORD PTR $T69[rsp]
  0064f	48 8b f9	 mov	 rdi, rcx
  00652	48 8b f0	 mov	 rsi, rax
  00655	b9 10 00 00 00	 mov	 ecx, 16
  0065a	f3 a4		 rep movsb
  0065c	48 8d 84 24 90
	03 00 00	 lea	 rax, QWORD PTR $T70[rsp]
  00664	48 8d 8c 24 80
	03 00 00	 lea	 rcx, QWORD PTR $T69[rsp]
  0066c	48 8b f8	 mov	 rdi, rax
  0066f	48 8b f1	 mov	 rsi, rcx
  00672	b9 10 00 00 00	 mov	 ecx, 16
  00677	f3 a4		 rep movsb
  00679	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR Primitive$10[rsp]
  00681	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR $T70[rsp]
  00689	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  0068e	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR AttributesElement$44[rsp], rax

; 271  :             json_object_s *Attributes = json_value_as_object(AttributesElement->value);

  00696	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR AttributesElement$44[rsp]
  0069e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006a2	e8 00 00 00 00	 call	 json_value_as_object
  006a7	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR Attributes$19[rsp], rax

; 272  :             
; 273  :             string8 PathString = CreateString(Path);

  006af	48 8b 94 24 48
	08 00 00	 mov	 rdx, QWORD PTR Path$[rsp]
  006b7	48 8d 8c 24 20
	06 00 00	 lea	 rcx, QWORD PTR $T106[rsp]
  006bf	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  006c4	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR $T71[rsp]
  006cc	48 8b f9	 mov	 rdi, rcx
  006cf	48 8b f0	 mov	 rsi, rax
  006d2	b9 10 00 00 00	 mov	 ecx, 16
  006d7	f3 a4		 rep movsb
  006d9	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR PathString$33[rsp]
  006e1	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR $T71[rsp]
  006e9	48 8b f8	 mov	 rdi, rax
  006ec	48 8b f1	 mov	 rsi, rcx
  006ef	b9 10 00 00 00	 mov	 ecx, 16
  006f4	f3 a4		 rep movsb

; 274  :             
; 275  :             //
; 276  :             // NOTE(evan): Positions
; 277  :             //
; 278  :             {
; 279  :                 u32 ByteOffset = 0;

  006f6	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ByteOffset$12[rsp], 0

; 280  :                 u32 Count = 0;

  00701	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Count$7[rsp], 0

; 281  :                 file_contents Contents = GetGLTFBinaryInfo(Binary, &ByteOffset, &Count, CreateString("POSITION"), true,

  0070c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46327
  00713	48 8d 8c 24 30
	06 00 00	 lea	 rcx, QWORD PTR $T107[rsp]
  0071b	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00720	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR $T72[rsp]
  00728	48 8b f9	 mov	 rdi, rcx
  0072b	48 8b f0	 mov	 rsi, rax
  0072e	b9 10 00 00 00	 mov	 ecx, 16
  00733	f3 a4		 rep movsb
  00735	48 8d 84 24 c0
	03 00 00	 lea	 rax, QWORD PTR $T73[rsp]
  0073d	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR PathString$33[rsp]
  00745	48 8b f8	 mov	 rdi, rax
  00748	48 8b f1	 mov	 rsi, rcx
  0074b	b9 10 00 00 00	 mov	 ecx, 16
  00750	f3 a4		 rep movsb
  00752	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00759	48 83 c0 20	 add	 rax, 32			; 00000020H
  0075d	48 8d 8c 24 d0
	03 00 00	 lea	 rcx, QWORD PTR $T74[rsp]
  00765	48 8d 94 24 b0
	03 00 00	 lea	 rdx, QWORD PTR $T72[rsp]
  0076d	48 8b f9	 mov	 rdi, rcx
  00770	48 8b f2	 mov	 rsi, rdx
  00773	b9 10 00 00 00	 mov	 ecx, 16
  00778	f3 a4		 rep movsb
  0077a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Buffers$[rsp]
  00782	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00787	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BufferViews$[rsp]
  0078f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00794	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Accessors$[rsp]
  0079c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007a1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR Primitive$10[rsp]
  007a9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007ae	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Attributes$19[rsp]
  007b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007bb	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR $T73[rsp]
  007c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007c8	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  007cd	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  007d5	48 8d 84 24 d0
	03 00 00	 lea	 rax, QWORD PTR $T74[rsp]
  007dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007e2	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR Count$7[rsp]
  007ea	4c 8d 84 24 bc
	00 00 00	 lea	 r8, QWORD PTR ByteOffset$12[rsp]
  007f2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Binary$[rsp]
  007fa	48 8d 8c 24 48
	07 00 00	 lea	 rcx, QWORD PTR $T124[rsp]
  00802	e8 00 00 00 00	 call	 ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z ; GetGLTFBinaryInfo
  00807	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR $T92[rsp]
  0080f	48 8b f9	 mov	 rdi, rcx
  00812	48 8b f0	 mov	 rsi, rax
  00815	b9 18 00 00 00	 mov	 ecx, 24
  0081a	f3 a4		 rep movsb
  0081c	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR Contents$50[rsp]
  00824	48 8d 8c 24 f0
	04 00 00	 lea	 rcx, QWORD PTR $T92[rsp]
  0082c	48 8b f8	 mov	 rdi, rax
  0082f	48 8b f1	 mov	 rsi, rcx
  00832	b9 18 00 00 00	 mov	 ecx, 24
  00837	f3 a4		 rep movsb

; 282  :                                                            &TranState->FrameArena, PathString,
; 283  :                                                            Attributes, Primitive, Accessors, BufferViews, Buffers);
; 284  :                 Binary = (u8 *)Contents.Data;

  00839	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR Contents$50[rsp+8]
  00841	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR Binary$[rsp], rax

; 285  :                 
; 286  :                 v3 *Positions = (v3 *)(Binary + ByteOffset);

  00849	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR ByteOffset$12[rsp]
  00850	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Binary$[rsp]
  00858	48 03 c8	 add	 rcx, rax
  0085b	48 8b c1	 mov	 rax, rcx
  0085e	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR Positions$38[rsp], rax

; 287  :                 
; 288  :                 Mesh->Vertices = PushArray(Arena, vertex, Count);

  00866	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR Count$7[rsp]
  0086d	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00871	48 8b d0	 mov	 rdx, rax
  00874	48 8b 8c 24 50
	08 00 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  0087c	e8 00 00 00 00	 call	 PushSize
  00881	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Mesh$1[rsp]
  00886	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 289  :                 Mesh->VertexCount = Count;

  0088a	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  0088f	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR Count$7[rsp]
  00896	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 290  :                 
; 291  :                 for(u32 VertexIndex = 0;

  00899	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR VertexIndex$2[rsp], 0
  008a1	eb 0a		 jmp	 SHORT $LN8@LoadGLTF
$LN6@LoadGLTF:

; 293  :                     ++VertexIndex)

  008a3	8b 44 24 78	 mov	 eax, DWORD PTR VertexIndex$2[rsp]
  008a7	ff c0		 inc	 eax
  008a9	89 44 24 78	 mov	 DWORD PTR VertexIndex$2[rsp], eax
$LN8@LoadGLTF:

; 292  :                     VertexIndex < Count;

  008ad	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR Count$7[rsp]
  008b4	39 44 24 78	 cmp	 DWORD PTR VertexIndex$2[rsp], eax
  008b8	73 4f		 jae	 SHORT $LN7@LoadGLTF

; 294  :                 {
; 295  :                     v3 Position = Positions[VertexIndex];

  008ba	8b 44 24 78	 mov	 eax, DWORD PTR VertexIndex$2[rsp]
  008be	48 6b c0 0c	 imul	 rax, rax, 12
  008c2	48 8d 8c 24 e0
	07 00 00	 lea	 rcx, QWORD PTR Position$131[rsp]
  008ca	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR Positions$38[rsp]
  008d2	48 8b f9	 mov	 rdi, rcx
  008d5	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  008d9	b9 0c 00 00 00	 mov	 ecx, 12
  008de	f3 a4		 rep movsb

; 296  :                     Mesh->Vertices[VertexIndex].Position = Position;

  008e0	8b 44 24 78	 mov	 eax, DWORD PTR VertexIndex$2[rsp]
  008e4	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  008e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Mesh$1[rsp]
  008ed	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  008f1	48 8d 94 24 e0
	07 00 00	 lea	 rdx, QWORD PTR Position$131[rsp]
  008f9	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  008fd	48 8b f2	 mov	 rsi, rdx
  00900	b9 0c 00 00 00	 mov	 ecx, 12
  00905	f3 a4		 rep movsb

; 297  :                 }

  00907	eb 9a		 jmp	 SHORT $LN6@LoadGLTF
$LN7@LoadGLTF:

; 298  :                 
; 299  :                 Platform->CloseFile(Contents.Handle);

  00909	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR Contents$50[rsp]
  00911	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00918	ff 50 28	 call	 QWORD PTR [rax+40]

; 300  :             }
; 301  :             
; 302  :             //
; 303  :             // NOTE(evan): Indices
; 304  :             //
; 305  :             {
; 306  :                 u32 ByteOffset = 0;

  0091b	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ByteOffset$13[rsp], 0

; 307  :                 u32 Count = 0;

  00926	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Count$8[rsp], 0

; 308  :                 file_contents Contents = GetGLTFBinaryInfo(Binary, &ByteOffset, &Count, CreateString("indices"), false,

  00931	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46328
  00938	48 8d 8c 24 40
	06 00 00	 lea	 rcx, QWORD PTR $T108[rsp]
  00940	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00945	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR $T75[rsp]
  0094d	48 8b f9	 mov	 rdi, rcx
  00950	48 8b f0	 mov	 rsi, rax
  00953	b9 10 00 00 00	 mov	 ecx, 16
  00958	f3 a4		 rep movsb
  0095a	48 8d 84 24 f0
	03 00 00	 lea	 rax, QWORD PTR $T76[rsp]
  00962	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR PathString$33[rsp]
  0096a	48 8b f8	 mov	 rdi, rax
  0096d	48 8b f1	 mov	 rsi, rcx
  00970	b9 10 00 00 00	 mov	 ecx, 16
  00975	f3 a4		 rep movsb
  00977	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  0097e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00982	48 8d 8c 24 00
	04 00 00	 lea	 rcx, QWORD PTR $T77[rsp]
  0098a	48 8d 94 24 e0
	03 00 00	 lea	 rdx, QWORD PTR $T75[rsp]
  00992	48 8b f9	 mov	 rdi, rcx
  00995	48 8b f2	 mov	 rsi, rdx
  00998	b9 10 00 00 00	 mov	 ecx, 16
  0099d	f3 a4		 rep movsb
  0099f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Buffers$[rsp]
  009a7	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  009ac	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BufferViews$[rsp]
  009b4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009b9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Accessors$[rsp]
  009c1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  009c6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR Primitive$10[rsp]
  009ce	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009d3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Attributes$19[rsp]
  009db	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  009e0	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR $T76[rsp]
  009e8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009ed	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  009f2	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  009fa	48 8d 84 24 00
	04 00 00	 lea	 rax, QWORD PTR $T77[rsp]
  00a02	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a07	4c 8d 8c 24 9c
	00 00 00	 lea	 r9, QWORD PTR Count$8[rsp]
  00a0f	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR ByteOffset$13[rsp]
  00a17	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Binary$[rsp]
  00a1f	48 8d 8c 24 60
	07 00 00	 lea	 rcx, QWORD PTR $T125[rsp]
  00a27	e8 00 00 00 00	 call	 ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z ; GetGLTFBinaryInfo
  00a2c	48 8d 8c 24 20
	05 00 00	 lea	 rcx, QWORD PTR $T94[rsp]
  00a34	48 8b f9	 mov	 rdi, rcx
  00a37	48 8b f0	 mov	 rsi, rax
  00a3a	b9 18 00 00 00	 mov	 ecx, 24
  00a3f	f3 a4		 rep movsb
  00a41	48 8d 84 24 08
	05 00 00	 lea	 rax, QWORD PTR Contents$93[rsp]
  00a49	48 8d 8c 24 20
	05 00 00	 lea	 rcx, QWORD PTR $T94[rsp]
  00a51	48 8b f8	 mov	 rdi, rax
  00a54	48 8b f1	 mov	 rsi, rcx
  00a57	b9 18 00 00 00	 mov	 ecx, 24
  00a5c	f3 a4		 rep movsb

; 309  :                                                            &TranState->FrameArena, PathString,
; 310  :                                                            Attributes, Primitive, Accessors, BufferViews, Buffers);
; 311  :                 
; 312  :                 u16 *Indices = (u16 *)(Binary + ByteOffset);

  00a5e	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ByteOffset$13[rsp]
  00a65	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Binary$[rsp]
  00a6d	48 03 c8	 add	 rcx, rax
  00a70	48 8b c1	 mov	 rax, rcx
  00a73	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR Indices$39[rsp], rax

; 313  :                 Mesh->Indices = PushArray(Arena, u32, Count);

  00a7b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR Count$8[rsp]
  00a82	48 c1 e0 02	 shl	 rax, 2
  00a86	48 8b d0	 mov	 rdx, rax
  00a89	48 8b 8c 24 50
	08 00 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  00a91	e8 00 00 00 00	 call	 PushSize
  00a96	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Mesh$1[rsp]
  00a9b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 314  :                 Mesh->IndexCount = Count;

  00a9f	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  00aa4	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR Count$8[rsp]
  00aab	89 48 58	 mov	 DWORD PTR [rax+88], ecx

; 315  :                 for(u32 IndIndex = 0;

  00aae	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR IndIndex$3[rsp], 0
  00ab6	eb 0a		 jmp	 SHORT $LN11@LoadGLTF
$LN9@LoadGLTF:

; 317  :                     ++IndIndex)

  00ab8	8b 44 24 7c	 mov	 eax, DWORD PTR IndIndex$3[rsp]
  00abc	ff c0		 inc	 eax
  00abe	89 44 24 7c	 mov	 DWORD PTR IndIndex$3[rsp], eax
$LN11@LoadGLTF:

; 316  :                     IndIndex < Count;

  00ac2	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR Count$8[rsp]
  00ac9	39 44 24 7c	 cmp	 DWORD PTR IndIndex$3[rsp], eax
  00acd	73 22		 jae	 SHORT $LN10@LoadGLTF

; 318  :                 {
; 319  :                     Mesh->Indices[IndIndex] = (u32)(Indices[IndIndex]);

  00acf	8b 44 24 7c	 mov	 eax, DWORD PTR IndIndex$3[rsp]
  00ad3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR Indices$39[rsp]
  00adb	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00adf	8b 4c 24 7c	 mov	 ecx, DWORD PTR IndIndex$3[rsp]
  00ae3	48 8b 54 24 70	 mov	 rdx, QWORD PTR Mesh$1[rsp]
  00ae8	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00aec	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 320  :                 }

  00aef	eb c7		 jmp	 SHORT $LN9@LoadGLTF
$LN10@LoadGLTF:

; 321  :                 
; 322  :                 Platform->CloseFile(Contents.Handle);

  00af1	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR Contents$93[rsp]
  00af9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00b00	ff 50 28	 call	 QWORD PTR [rax+40]

; 323  :             }
; 324  :             
; 325  :             //
; 326  :             // NOTE(evan): Material
; 327  :             //
; 328  :             if(Materials)

  00b03	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR Materials$[rsp], 0
  00b0c	0f 84 b8 02 00
	00		 je	 $LN26@LoadGLTF

; 329  :             {
; 330  :                 f32 RealIndex;
; 331  :                 Assert(GrabNumberFromJSONObject(CreateString("material"), Primitive, &RealIndex) == GLTF_RESULT_SUCCESS);

  00b12	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46332
  00b19	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T113[rsp]
  00b21	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00b26	48 8d 8c 24 10
	04 00 00	 lea	 rcx, QWORD PTR $T78[rsp]
  00b2e	48 8b f9	 mov	 rdi, rcx
  00b31	48 8b f0	 mov	 rsi, rax
  00b34	b9 10 00 00 00	 mov	 ecx, 16
  00b39	f3 a4		 rep movsb
  00b3b	48 8d 84 24 20
	04 00 00	 lea	 rax, QWORD PTR $T79[rsp]
  00b43	48 8d 8c 24 10
	04 00 00	 lea	 rcx, QWORD PTR $T78[rsp]
  00b4b	48 8b f8	 mov	 rdi, rax
  00b4e	48 8b f1	 mov	 rsi, rcx
  00b51	b9 10 00 00 00	 mov	 ecx, 16
  00b56	f3 a4		 rep movsb
  00b58	4c 8d 84 24 14
	01 00 00	 lea	 r8, QWORD PTR RealIndex$23[rsp]
  00b60	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR Primitive$10[rsp]
  00b68	48 8d 8c 24 20
	04 00 00	 lea	 rcx, QWORD PTR $T79[rsp]
  00b70	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  00b75	85 c0		 test	 eax, eax
  00b77	74 0b		 je	 SHORT $LN28@LoadGLTF
  00b79	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN28@LoadGLTF:

; 332  :                 s32 Index = (s32)RealIndex;

  00b84	f3 0f 2c 84 24
	14 01 00 00	 cvttss2si eax, DWORD PTR RealIndex$23[rsp]
  00b8d	89 84 24 18 01
	00 00		 mov	 DWORD PTR Index$24[rsp], eax

; 333  :                 
; 334  :                 json_array_element_s *MaterialElement = GrabJSONArrayElementIndexed(Index, Materials);

  00b94	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR Materials$[rsp]
  00b9c	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR Index$24[rsp]
  00ba3	e8 00 00 00 00	 call	 ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z ; GrabJSONArrayElementIndexed
  00ba8	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR MaterialElement$40[rsp], rax

; 335  :                 json_object_s *Material = json_value_as_object(MaterialElement->value);

  00bb0	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR MaterialElement$40[rsp]
  00bb8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00bbb	e8 00 00 00 00	 call	 json_value_as_object
  00bc0	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR Material$41[rsp], rax

; 336  :                 
; 337  :                 json_object_element_s *PBRMetallicRoughnessElement =

  00bc8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46333
  00bcf	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T109[rsp]
  00bd7	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00bdc	48 8d 8c 24 30
	04 00 00	 lea	 rcx, QWORD PTR $T80[rsp]
  00be4	48 8b f9	 mov	 rdi, rcx
  00be7	48 8b f0	 mov	 rsi, rax
  00bea	b9 10 00 00 00	 mov	 ecx, 16
  00bef	f3 a4		 rep movsb
  00bf1	48 8d 84 24 40
	04 00 00	 lea	 rax, QWORD PTR $T81[rsp]
  00bf9	48 8d 8c 24 30
	04 00 00	 lea	 rcx, QWORD PTR $T80[rsp]
  00c01	48 8b f8	 mov	 rdi, rax
  00c04	48 8b f1	 mov	 rsi, rcx
  00c07	b9 10 00 00 00	 mov	 ecx, 16
  00c0c	f3 a4		 rep movsb
  00c0e	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR Material$41[rsp]
  00c16	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR $T81[rsp]
  00c1e	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  00c23	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR PBRMetallicRoughnessElement$42[rsp], rax

; 338  :                     FindJSONObjectElement(CreateString("pbrMetallicRoughness"), Material);
; 339  :                 json_object_s *PBRMetallicRoughness = json_value_as_object(PBRMetallicRoughnessElement->value);

  00c2b	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR PBRMetallicRoughnessElement$42[rsp]
  00c33	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00c37	e8 00 00 00 00	 call	 json_value_as_object
  00c3c	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR PBRMetallicRoughness$43[rsp], rax

; 340  :                 
; 341  :                 json_object_element_s *BaseColorArrayElement = FindJSONObjectElement(CreateString("baseColorFactor"), PBRMetallicRoughness);

  00c44	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46334
  00c4b	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR $T110[rsp]
  00c53	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00c58	48 8d 8c 24 50
	04 00 00	 lea	 rcx, QWORD PTR $T82[rsp]
  00c60	48 8b f9	 mov	 rdi, rcx
  00c63	48 8b f0	 mov	 rsi, rax
  00c66	b9 10 00 00 00	 mov	 ecx, 16
  00c6b	f3 a4		 rep movsb
  00c6d	48 8d 84 24 60
	04 00 00	 lea	 rax, QWORD PTR $T83[rsp]
  00c75	48 8d 8c 24 50
	04 00 00	 lea	 rcx, QWORD PTR $T82[rsp]
  00c7d	48 8b f8	 mov	 rdi, rax
  00c80	48 8b f1	 mov	 rsi, rcx
  00c83	b9 10 00 00 00	 mov	 ecx, 16
  00c88	f3 a4		 rep movsb
  00c8a	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR PBRMetallicRoughness$43[rsp]
  00c92	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR $T83[rsp]
  00c9a	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  00c9f	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR BaseColorArrayElement$48[rsp], rax

; 342  :                 json_array_s *BaseColorArray = json_value_as_array(BaseColorArrayElement->value);

  00ca7	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR BaseColorArrayElement$48[rsp]
  00caf	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00cb3	e8 00 00 00 00	 call	 json_value_as_array
  00cb8	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR BaseColorArray$20[rsp], rax

; 343  :                 
; 344  :                 f32 R, G, B, A;
; 345  :                 Assert(GrabNumberFromJSONArray(0, BaseColorArray, &R) == GLTF_RESULT_SUCCESS);

  00cc0	4c 8d 84 24 28
	01 00 00	 lea	 r8, QWORD PTR R$28[rsp]
  00cc8	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR BaseColorArray$20[rsp]
  00cd0	33 c9		 xor	 ecx, ecx
  00cd2	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray
  00cd7	85 c0		 test	 eax, eax
  00cd9	74 0b		 je	 SHORT $LN29@LoadGLTF
  00cdb	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN29@LoadGLTF:

; 346  :                 Assert(GrabNumberFromJSONArray(1, BaseColorArray, &G) == GLTF_RESULT_SUCCESS);

  00ce6	4c 8d 84 24 24
	01 00 00	 lea	 r8, QWORD PTR G$27[rsp]
  00cee	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR BaseColorArray$20[rsp]
  00cf6	b9 01 00 00 00	 mov	 ecx, 1
  00cfb	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray
  00d00	85 c0		 test	 eax, eax
  00d02	74 0b		 je	 SHORT $LN30@LoadGLTF
  00d04	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN30@LoadGLTF:

; 347  :                 Assert(GrabNumberFromJSONArray(2, BaseColorArray, &B) == GLTF_RESULT_SUCCESS);

  00d0f	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR B$26[rsp]
  00d17	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR BaseColorArray$20[rsp]
  00d1f	b9 02 00 00 00	 mov	 ecx, 2
  00d24	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray
  00d29	85 c0		 test	 eax, eax
  00d2b	74 0b		 je	 SHORT $LN31@LoadGLTF
  00d2d	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN31@LoadGLTF:

; 348  :                 Assert(GrabNumberFromJSONArray(3, BaseColorArray, &A) == GLTF_RESULT_SUCCESS);

  00d38	4c 8d 84 24 1c
	01 00 00	 lea	 r8, QWORD PTR A$25[rsp]
  00d40	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR BaseColorArray$20[rsp]
  00d48	b9 03 00 00 00	 mov	 ecx, 3
  00d4d	e8 00 00 00 00	 call	 ?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ; GrabNumberFromJSONArray
  00d52	85 c0		 test	 eax, eax
  00d54	74 0b		 je	 SHORT $LN32@LoadGLTF
  00d56	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN32@LoadGLTF:

; 349  :                 Mesh->Material.BaseColor = V4(R, G, B, A);

  00d61	f3 0f 10 84 24
	1c 01 00 00	 movss	 xmm0, DWORD PTR A$25[rsp]
  00d6a	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00d70	f3 0f 10 9c 24
	20 01 00 00	 movss	 xmm3, DWORD PTR B$26[rsp]
  00d79	f3 0f 10 94 24
	24 01 00 00	 movss	 xmm2, DWORD PTR G$27[rsp]
  00d82	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR R$28[rsp]
  00d8b	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR $T111[rsp]
  00d93	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  00d98	48 8d 8c 24 f0
	07 00 00	 lea	 rcx, QWORD PTR $T132[rsp]
  00da0	48 8b f9	 mov	 rdi, rcx
  00da3	48 8b f0	 mov	 rsi, rax
  00da6	b9 10 00 00 00	 mov	 ecx, 16
  00dab	f3 a4		 rep movsb
  00dad	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  00db2	48 8d 8c 24 f0
	07 00 00	 lea	 rcx, QWORD PTR $T132[rsp]
  00dba	48 8d 78 5c	 lea	 rdi, QWORD PTR [rax+92]
  00dbe	48 8b f1	 mov	 rsi, rcx
  00dc1	b9 10 00 00 00	 mov	 ecx, 16
  00dc6	f3 a4		 rep movsb

; 350  :             }

  00dc8	eb 5f		 jmp	 SHORT $LN27@LoadGLTF
$LN26@LoadGLTF:

; 351  :             else
; 352  :             {
; 353  :                 Mesh->Material.BaseColor = COLOR_WHITE;

  00dca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00dd2	f3 0f 11 84 24
	d0 07 00 00	 movss	 DWORD PTR $T130[rsp], xmm0
  00ddb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00de3	f3 0f 11 84 24
	d4 07 00 00	 movss	 DWORD PTR $T130[rsp+4], xmm0
  00dec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00df4	f3 0f 11 84 24
	d8 07 00 00	 movss	 DWORD PTR $T130[rsp+8], xmm0
  00dfd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e05	f3 0f 11 84 24
	dc 07 00 00	 movss	 DWORD PTR $T130[rsp+12], xmm0
  00e0e	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  00e13	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR $T130[rsp]
  00e1b	48 8d 78 5c	 lea	 rdi, QWORD PTR [rax+92]
  00e1f	48 8b f1	 mov	 rsi, rcx
  00e22	b9 10 00 00 00	 mov	 ecx, 16
  00e27	f3 a4		 rep movsb
$LN27@LoadGLTF:

; 354  :             }
; 355  :             
; 356  :             //
; 357  :             // NOTE(evan): Normals
; 358  :             //
; 359  :             {
; 360  :                 u32 ByteOffset = 0;

  00e29	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ByteOffset$14[rsp], 0

; 361  :                 u32 Count = 0;

  00e34	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR Count$29[rsp], 0

; 362  :                 file_contents Contents = GetGLTFBinaryInfo(Binary, &ByteOffset, &Count, CreateString("NORMAL"), true,

  00e3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46339
  00e46	48 8d 8c 24 80
	06 00 00	 lea	 rcx, QWORD PTR $T112[rsp]
  00e4e	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00e53	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR $T84[rsp]
  00e5b	48 8b f9	 mov	 rdi, rcx
  00e5e	48 8b f0	 mov	 rsi, rax
  00e61	b9 10 00 00 00	 mov	 ecx, 16
  00e66	f3 a4		 rep movsb
  00e68	48 8d 84 24 80
	04 00 00	 lea	 rax, QWORD PTR $T85[rsp]
  00e70	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR PathString$33[rsp]
  00e78	48 8b f8	 mov	 rdi, rax
  00e7b	48 8b f1	 mov	 rsi, rcx
  00e7e	b9 10 00 00 00	 mov	 ecx, 16
  00e83	f3 a4		 rep movsb
  00e85	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  00e8c	48 83 c0 20	 add	 rax, 32			; 00000020H
  00e90	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR $T86[rsp]
  00e98	48 8d 94 24 70
	04 00 00	 lea	 rdx, QWORD PTR $T84[rsp]
  00ea0	48 8b f9	 mov	 rdi, rcx
  00ea3	48 8b f2	 mov	 rsi, rdx
  00ea6	b9 10 00 00 00	 mov	 ecx, 16
  00eab	f3 a4		 rep movsb
  00ead	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Buffers$[rsp]
  00eb5	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00eba	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BufferViews$[rsp]
  00ec2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ec7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Accessors$[rsp]
  00ecf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00ed4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR Primitive$10[rsp]
  00edc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ee1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Attributes$19[rsp]
  00ee9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00eee	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR $T85[rsp]
  00ef6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00efb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00f00	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00f08	48 8d 84 24 90
	04 00 00	 lea	 rax, QWORD PTR $T86[rsp]
  00f10	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f15	4c 8d 8c 24 2c
	01 00 00	 lea	 r9, QWORD PTR Count$29[rsp]
  00f1d	4c 8d 84 24 c4
	00 00 00	 lea	 r8, QWORD PTR ByteOffset$14[rsp]
  00f25	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Binary$[rsp]
  00f2d	48 8d 8c 24 78
	07 00 00	 lea	 rcx, QWORD PTR $T126[rsp]
  00f35	e8 00 00 00 00	 call	 ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z ; GetGLTFBinaryInfo
  00f3a	48 8d 8c 24 50
	05 00 00	 lea	 rcx, QWORD PTR $T96[rsp]
  00f42	48 8b f9	 mov	 rdi, rcx
  00f45	48 8b f0	 mov	 rsi, rax
  00f48	b9 18 00 00 00	 mov	 ecx, 24
  00f4d	f3 a4		 rep movsb
  00f4f	48 8d 84 24 68
	05 00 00	 lea	 rax, QWORD PTR Contents$97[rsp]
  00f57	48 8d 8c 24 50
	05 00 00	 lea	 rcx, QWORD PTR $T96[rsp]
  00f5f	48 8b f8	 mov	 rdi, rax
  00f62	48 8b f1	 mov	 rsi, rcx
  00f65	b9 18 00 00 00	 mov	 ecx, 24
  00f6a	f3 a4		 rep movsb

; 363  :                                                            &TranState->FrameArena, PathString,
; 364  :                                                            Attributes, Primitive, Accessors, BufferViews, Buffers);
; 365  :                 
; 366  :                 v3 *Normals = (v3 *)(Binary + ByteOffset);

  00f6c	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR ByteOffset$14[rsp]
  00f73	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Binary$[rsp]
  00f7b	48 03 c8	 add	 rcx, rax
  00f7e	48 8b c1	 mov	 rax, rcx
  00f81	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR Normals$45[rsp], rax

; 367  :                 
; 368  :                 for(u32 VertexIndex = 0;

  00f89	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR VertexIndex$4[rsp], 0
  00f94	eb 10		 jmp	 SHORT $LN14@LoadGLTF
$LN12@LoadGLTF:

; 370  :                     ++VertexIndex)

  00f96	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$4[rsp]
  00f9d	ff c0		 inc	 eax
  00f9f	89 84 24 80 00
	00 00		 mov	 DWORD PTR VertexIndex$4[rsp], eax
$LN14@LoadGLTF:

; 369  :                     VertexIndex < Mesh->VertexCount;

  00fa6	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  00fab	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00fae	39 84 24 80 00
	00 00		 cmp	 DWORD PTR VertexIndex$4[rsp], eax
  00fb5	73 49		 jae	 SHORT $LN13@LoadGLTF

; 371  :                 {
; 372  :                     Mesh->Vertices[VertexIndex].Normal = Normals[VertexIndex];

  00fb7	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$4[rsp]
  00fbe	48 6b c0 0c	 imul	 rax, rax, 12
  00fc2	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR VertexIndex$4[rsp]
  00fc9	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  00fcd	48 8b 54 24 70	 mov	 rdx, QWORD PTR Mesh$1[rsp]
  00fd2	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00fd6	48 8b bc 24 e0
	01 00 00	 mov	 rdi, QWORD PTR Normals$45[rsp]
  00fde	48 89 bc 24 e8
	01 00 00	 mov	 QWORD PTR tv1083[rsp], rdi
  00fe6	48 8d 7c 0a 14	 lea	 rdi, QWORD PTR [rdx+rcx+20]
  00feb	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR tv1083[rsp]
  00ff3	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00ff7	b9 0c 00 00 00	 mov	 ecx, 12
  00ffc	f3 a4		 rep movsb

; 373  :                 }

  00ffe	eb 96		 jmp	 SHORT $LN12@LoadGLTF
$LN13@LoadGLTF:

; 374  :                 
; 375  :                 Platform->CloseFile(Contents.Handle);

  01000	48 8b 8c 24 68
	05 00 00	 mov	 rcx, QWORD PTR Contents$97[rsp]
  01008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0100f	ff 50 28	 call	 QWORD PTR [rax+40]

; 376  :             }
; 377  :             
; 378  :             //
; 379  :             // NOTE(evan): UVs
; 380  :             //
; 381  :             {
; 382  :                 u32 ByteOffset = 0;

  01012	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ByteOffset$15[rsp], 0

; 383  :                 u32 Count = 0;

  0101d	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Count$16[rsp], 0

; 384  :                 file_contents Contents = GetGLTFBinaryInfo(Binary, &ByteOffset, &Count, CreateString("TEXCOORD_0"), true,

  01028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46340
  0102f	48 8d 8c 24 c0
	06 00 00	 lea	 rcx, QWORD PTR $T116[rsp]
  01037	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0103c	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR $T87[rsp]
  01044	48 8b f9	 mov	 rdi, rcx
  01047	48 8b f0	 mov	 rsi, rax
  0104a	b9 10 00 00 00	 mov	 ecx, 16
  0104f	f3 a4		 rep movsb
  01051	48 8d 84 24 b0
	04 00 00	 lea	 rax, QWORD PTR $T88[rsp]
  01059	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR PathString$33[rsp]
  01061	48 8b f8	 mov	 rdi, rax
  01064	48 8b f1	 mov	 rsi, rcx
  01067	b9 10 00 00 00	 mov	 ecx, 16
  0106c	f3 a4		 rep movsb
  0106e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  01075	48 83 c0 20	 add	 rax, 32			; 00000020H
  01079	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR $T89[rsp]
  01081	48 8d 94 24 a0
	04 00 00	 lea	 rdx, QWORD PTR $T87[rsp]
  01089	48 8b f9	 mov	 rdi, rcx
  0108c	48 8b f2	 mov	 rsi, rdx
  0108f	b9 10 00 00 00	 mov	 ecx, 16
  01094	f3 a4		 rep movsb
  01096	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Buffers$[rsp]
  0109e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  010a3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BufferViews$[rsp]
  010ab	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  010b0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Accessors$[rsp]
  010b8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  010bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR Primitive$10[rsp]
  010c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010ca	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Attributes$19[rsp]
  010d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  010d7	48 8d 8c 24 b0
	04 00 00	 lea	 rcx, QWORD PTR $T88[rsp]
  010df	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  010e4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  010e9	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  010f1	48 8d 84 24 c0
	04 00 00	 lea	 rax, QWORD PTR $T89[rsp]
  010f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010fe	4c 8d 8c 24 cc
	00 00 00	 lea	 r9, QWORD PTR Count$16[rsp]
  01106	4c 8d 84 24 c8
	00 00 00	 lea	 r8, QWORD PTR ByteOffset$15[rsp]
  0110e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Binary$[rsp]
  01116	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR $T127[rsp]
  0111e	e8 00 00 00 00	 call	 ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z ; GetGLTFBinaryInfo
  01123	48 8d 8c 24 80
	05 00 00	 lea	 rcx, QWORD PTR $T98[rsp]
  0112b	48 8b f9	 mov	 rdi, rcx
  0112e	48 8b f0	 mov	 rsi, rax
  01131	b9 18 00 00 00	 mov	 ecx, 24
  01136	f3 a4		 rep movsb
  01138	48 8d 84 24 98
	05 00 00	 lea	 rax, QWORD PTR Contents$99[rsp]
  01140	48 8d 8c 24 80
	05 00 00	 lea	 rcx, QWORD PTR $T98[rsp]
  01148	48 8b f8	 mov	 rdi, rax
  0114b	48 8b f1	 mov	 rsi, rcx
  0114e	b9 18 00 00 00	 mov	 ecx, 24
  01153	f3 a4		 rep movsb

; 385  :                                                            &TranState->FrameArena, PathString,
; 386  :                                                            Attributes, Primitive, Accessors, BufferViews, Buffers);
; 387  :                 
; 388  :                 v2 *UVs = (v2 *)(Binary + ByteOffset);

  01155	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR ByteOffset$15[rsp]
  0115c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Binary$[rsp]
  01164	48 03 c8	 add	 rcx, rax
  01167	48 8b c1	 mov	 rax, rcx
  0116a	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR UVs$46[rsp], rax

; 389  :                 
; 390  :                 for(u32 VertexIndex = 0;

  01172	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR VertexIndex$5[rsp], 0
  0117d	eb 10		 jmp	 SHORT $LN17@LoadGLTF
$LN15@LoadGLTF:

; 392  :                     ++VertexIndex)

  0117f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$5[rsp]
  01186	ff c0		 inc	 eax
  01188	89 84 24 84 00
	00 00		 mov	 DWORD PTR VertexIndex$5[rsp], eax
$LN17@LoadGLTF:

; 391  :                     VertexIndex < Count;

  0118f	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR Count$16[rsp]
  01196	39 84 24 84 00
	00 00		 cmp	 DWORD PTR VertexIndex$5[rsp], eax
  0119d	73 2e		 jae	 SHORT $LN16@LoadGLTF

; 393  :                 {
; 394  :                     Mesh->Vertices[VertexIndex].UV = UVs[VertexIndex];

  0119f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$5[rsp]
  011a6	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR UVs$46[rsp]
  011ae	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  011b2	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR VertexIndex$5[rsp]
  011b9	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  011bd	48 8b 54 24 70	 mov	 rdx, QWORD PTR Mesh$1[rsp]
  011c2	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  011c6	48 89 44 0a 0c	 mov	 QWORD PTR [rdx+rcx+12], rax

; 395  :                 }

  011cb	eb b2		 jmp	 SHORT $LN15@LoadGLTF
$LN16@LoadGLTF:

; 396  :                 
; 397  :                 Platform->CloseFile(Contents.Handle);

  011cd	48 8b 8c 24 98
	05 00 00	 mov	 rcx, QWORD PTR Contents$99[rsp]
  011d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  011dc	ff 50 28	 call	 QWORD PTR [rax+40]

; 398  :             }
; 399  :             
; 400  :             //
; 401  :             // NOTE(evan): Vertex Colors
; 402  :             //
; 403  :             {
; 404  :                 u32 ByteOffset = 0;

  011df	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ByteOffset$18[rsp], 0

; 405  :                 u32 Count = 0;

  011ea	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Count$17[rsp], 0

; 406  :                 file_contents Contents = GetGLTFBinaryInfo(Binary, &ByteOffset, &Count, CreateString("COLOR_0"), true,

  011f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46341
  011fc	48 8d 8c 24 a0
	06 00 00	 lea	 rcx, QWORD PTR $T114[rsp]
  01204	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  01209	48 8d 8c 24 d0
	04 00 00	 lea	 rcx, QWORD PTR $T90[rsp]
  01211	48 8b f9	 mov	 rdi, rcx
  01214	48 8b f0	 mov	 rsi, rax
  01217	b9 10 00 00 00	 mov	 ecx, 16
  0121c	f3 a4		 rep movsb
  0121e	48 8d 84 24 e0
	04 00 00	 lea	 rax, QWORD PTR $T91[rsp]
  01226	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR PathString$33[rsp]
  0122e	48 8b f8	 mov	 rdi, rax
  01231	48 8b f1	 mov	 rsi, rcx
  01234	b9 10 00 00 00	 mov	 ecx, 16
  01239	f3 a4		 rep movsb
  0123b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?TranState@@3PEAUtransient_state@@EA
  01242	48 83 c0 20	 add	 rax, 32			; 00000020H
  01246	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  0124e	48 8d 94 24 d0
	04 00 00	 lea	 rdx, QWORD PTR $T90[rsp]
  01256	48 8b f9	 mov	 rdi, rcx
  01259	48 8b f2	 mov	 rsi, rdx
  0125c	b9 10 00 00 00	 mov	 ecx, 16
  01261	f3 a4		 rep movsb
  01263	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR Buffers$[rsp]
  0126b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01270	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR BufferViews$[rsp]
  01278	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0127d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Accessors$[rsp]
  01285	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0128a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR Primitive$10[rsp]
  01292	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01297	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Attributes$19[rsp]
  0129f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  012a4	48 8d 8c 24 e0
	04 00 00	 lea	 rcx, QWORD PTR $T91[rsp]
  012ac	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012b1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  012b6	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  012be	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR $T49[rsp]
  012c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012cb	4c 8d 8c 24 d0
	00 00 00	 lea	 r9, QWORD PTR Count$17[rsp]
  012d3	4c 8d 84 24 d4
	00 00 00	 lea	 r8, QWORD PTR ByteOffset$18[rsp]
  012db	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR Binary$[rsp]
  012e3	48 8d 8c 24 a8
	07 00 00	 lea	 rcx, QWORD PTR $T128[rsp]
  012eb	e8 00 00 00 00	 call	 ?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z ; GetGLTFBinaryInfo
  012f0	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR $T100[rsp]
  012f8	48 8b f9	 mov	 rdi, rcx
  012fb	48 8b f0	 mov	 rsi, rax
  012fe	b9 18 00 00 00	 mov	 ecx, 24
  01303	f3 a4		 rep movsb
  01305	48 8d 84 24 c8
	05 00 00	 lea	 rax, QWORD PTR Contents$101[rsp]
  0130d	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR $T100[rsp]
  01315	48 8b f8	 mov	 rdi, rax
  01318	48 8b f1	 mov	 rsi, rcx
  0131b	b9 18 00 00 00	 mov	 ecx, 24
  01320	f3 a4		 rep movsb

; 407  :                                                            &TranState->FrameArena, PathString,
; 408  :                                                            Attributes, Primitive, Accessors, BufferViews, Buffers);
; 409  :                 
; 410  :                 if(Count)

  01322	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR Count$17[rsp], 0
  0132a	0f 84 ab 00 00
	00		 je	 $LN33@LoadGLTF

; 411  :                 {
; 412  :                     v4 *Colors = (v4 *)(Binary + ByteOffset);

  01330	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR ByteOffset$18[rsp]
  01337	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR Binary$[rsp]
  0133f	48 03 c8	 add	 rcx, rax
  01342	48 8b c1	 mov	 rax, rcx
  01345	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR Colors$47[rsp], rax

; 413  :                     
; 414  :                     for(u32 VertexIndex = 0;

  0134d	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR VertexIndex$6[rsp], 0
  01358	eb 10		 jmp	 SHORT $LN20@LoadGLTF
$LN18@LoadGLTF:

; 416  :                         ++VertexIndex)

  0135a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$6[rsp]
  01361	ff c0		 inc	 eax
  01363	89 84 24 88 00
	00 00		 mov	 DWORD PTR VertexIndex$6[rsp], eax
$LN20@LoadGLTF:

; 415  :                         VertexIndex < Mesh->VertexCount;

  0136a	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  0136f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01372	39 84 24 88 00
	00 00		 cmp	 DWORD PTR VertexIndex$6[rsp], eax
  01379	73 49		 jae	 SHORT $LN19@LoadGLTF

; 417  :                     {
; 418  :                         Mesh->Vertices[VertexIndex].Color = Colors[VertexIndex];

  0137b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$6[rsp]
  01382	48 6b c0 10	 imul	 rax, rax, 16
  01386	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR VertexIndex$6[rsp]
  0138d	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  01391	48 8b 54 24 70	 mov	 rdx, QWORD PTR Mesh$1[rsp]
  01396	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  0139a	48 8b bc 24 f8
	01 00 00	 mov	 rdi, QWORD PTR Colors$47[rsp]
  013a2	48 89 bc 24 00
	02 00 00	 mov	 QWORD PTR tv1161[rsp], rdi
  013aa	48 8d 7c 0a 20	 lea	 rdi, QWORD PTR [rdx+rcx+32]
  013af	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR tv1161[rsp]
  013b7	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  013bb	b9 10 00 00 00	 mov	 ecx, 16
  013c0	f3 a4		 rep movsb

; 419  :                     }

  013c2	eb 96		 jmp	 SHORT $LN18@LoadGLTF
$LN19@LoadGLTF:

; 420  :                     
; 421  :                     Platform->CloseFile(Contents.Handle);

  013c4	48 8b 8c 24 c8
	05 00 00	 mov	 rcx, QWORD PTR Contents$101[rsp]
  013cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  013d3	ff 50 28	 call	 QWORD PTR [rax+40]

; 422  :                 }

  013d6	e9 a6 00 00 00	 jmp	 $LN34@LoadGLTF
$LN33@LoadGLTF:

; 423  :                 else
; 424  :                 {
; 425  :                     for(u32 VertexIndex = 0;

  013db	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR VertexIndex$9[rsp], 0
  013e6	eb 10		 jmp	 SHORT $LN23@LoadGLTF
$LN21@LoadGLTF:

; 427  :                         ++VertexIndex)

  013e8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$9[rsp]
  013ef	ff c0		 inc	 eax
  013f1	89 84 24 a0 00
	00 00		 mov	 DWORD PTR VertexIndex$9[rsp], eax
$LN23@LoadGLTF:

; 426  :                         VertexIndex < Mesh->VertexCount;

  013f8	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  013fd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01400	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR VertexIndex$9[rsp], eax
  01407	73 78		 jae	 SHORT $LN22@LoadGLTF

; 428  :                     {
; 429  :                         Mesh->Vertices[VertexIndex].Color = V4(1.0f, 1.0f, 1.0f, 1.0f);

  01409	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01411	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  01417	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0141f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  01427	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0142f	48 8d 8c 24 b0
	06 00 00	 lea	 rcx, QWORD PTR $T115[rsp]
  01437	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  0143c	48 8d 8c 24 00
	08 00 00	 lea	 rcx, QWORD PTR $T133[rsp]
  01444	48 8b f9	 mov	 rdi, rcx
  01447	48 8b f0	 mov	 rsi, rax
  0144a	b9 10 00 00 00	 mov	 ecx, 16
  0144f	f3 a4		 rep movsb
  01451	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR VertexIndex$9[rsp]
  01458	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  0145c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Mesh$1[rsp]
  01461	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  01465	48 8d 94 24 00
	08 00 00	 lea	 rdx, QWORD PTR $T133[rsp]
  0146d	48 8d 7c 01 20	 lea	 rdi, QWORD PTR [rcx+rax+32]
  01472	48 8b f2	 mov	 rsi, rdx
  01475	b9 10 00 00 00	 mov	 ecx, 16
  0147a	f3 a4		 rep movsb

; 430  :                     }

  0147c	e9 67 ff ff ff	 jmp	 $LN21@LoadGLTF
$LN22@LoadGLTF:
$LN34@LoadGLTF:

; 431  :                 }
; 432  :             }
; 433  :             
; 434  :             Mesh->Platform = Platform->CreateMesh(Mesh->Vertices, Mesh->VertexCount, Mesh->Indices, Mesh->IndexCount, false);

  01481	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  01489	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  0148e	44 8b 48 58	 mov	 r9d, DWORD PTR [rax+88]
  01492	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  01497	4c 8b 40 50	 mov	 r8, QWORD PTR [rax+80]
  0149b	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  014a0	8b 50 48	 mov	 edx, DWORD PTR [rax+72]
  014a3	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  014a8	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  014ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  014b3	ff 50 30	 call	 QWORD PTR [rax+48]
  014b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Mesh$1[rsp]
  014bb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 435  :             
; 436  :             if(PrimitiveElement->next == 0)

  014be	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR PrimitiveElement$21[rsp]
  014c6	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  014cb	75 02		 jne	 SHORT $LN35@LoadGLTF

; 437  :             {
; 438  :                 break;

  014cd	eb 52		 jmp	 SHORT $LN5@LoadGLTF
$LN35@LoadGLTF:

; 439  :             }
; 440  :             
; 441  :             PrimitiveElement = PrimitiveElement->next;

  014cf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR PrimitiveElement$21[rsp]
  014d7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  014db	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR PrimitiveElement$21[rsp], rax

; 442  :             Mesh->Next = PushStruct(Arena, mesh);

  014e3	ba 70 00 00 00	 mov	 edx, 112		; 00000070H
  014e8	48 8b 8c 24 50
	08 00 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  014f0	e8 00 00 00 00	 call	 PushSize
  014f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Mesh$1[rsp]
  014fa	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 443  :             Mesh = Mesh->Next;

  014fe	48 8b 44 24 70	 mov	 rax, QWORD PTR Mesh$1[rsp]
  01503	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01507	48 89 44 24 70	 mov	 QWORD PTR Mesh$1[rsp], rax

; 444  :             ++Result.MeshCount;

  0150c	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR Result$[rsp+8]
  01513	ff c0		 inc	 eax
  01515	89 84 24 40 01
	00 00		 mov	 DWORD PTR Result$[rsp+8], eax

; 445  :         }

  0151c	e9 d6 f0 ff ff	 jmp	 $LN4@LoadGLTF
$LN5@LoadGLTF:

; 446  :         
; 447  :         if(NodeElement->next == 0)

  01521	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR NodeElement$[rsp]
  01529	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0152e	75 02		 jne	 SHORT $LN36@LoadGLTF

; 448  :         {
; 449  :             break;

  01530	eb 19		 jmp	 SHORT $LN3@LoadGLTF
$LN36@LoadGLTF:

; 450  :         }
; 451  :         NodeElement = NodeElement->next;

  01532	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR NodeElement$[rsp]
  0153a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0153e	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR NodeElement$[rsp], rax

; 452  :     }

  01546	e9 03 ee ff ff	 jmp	 $LN2@LoadGLTF
$LN3@LoadGLTF:

; 453  :     
; 454  :     Platform->CloseFile(FileContents.Handle);

  0154b	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR FileContents$[rsp]
  01553	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0155a	ff 50 28	 call	 QWORD PTR [rax+40]

; 455  :     
; 456  :     return(Result);

  0155d	48 8d 84 24 38
	01 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  01565	48 8b bc 24 40
	08 00 00	 mov	 rdi, QWORD PTR $T134[rsp]
  0156d	48 8b f0	 mov	 rsi, rax
  01570	b9 10 00 00 00	 mov	 ecx, 16
  01575	f3 a4		 rep movsb
  01577	48 8b 84 24 40
	08 00 00	 mov	 rax, QWORD PTR $T134[rsp]

; 457  : }

  0157f	48 8b 8c 24 10
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01587	48 33 cc	 xor	 rcx, rsp
  0158a	e8 00 00 00 00	 call	 __security_check_cookie
  0158f	48 81 c4 28 08
	00 00		 add	 rsp, 2088		; 00000828H
  01596	5f		 pop	 rdi
  01597	5e		 pop	 rsi
  01598	c3		 ret	 0
?LoadGLTF@@YA?AUloaded_model@@PEADPEAUmemory_arena@@@Z ENDP ; LoadGLTF
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
RealIndex$1 = 32
RealIndex$2 = 36
Index$ = 40
RealBufferViewIndex$ = 44
RealCount$ = 48
RealByteOffset$ = 52
RealBufferIndex$3 = 56
BufferViewIndex$ = 60
BufferIndex$4 = 64
Accessor$ = 72
BufferView$ = 80
Result$ = 88
BinPathString$5 = 112
AccessorElement$ = 128
BufferViewElement$ = 136
BufferElement$6 = 144
Buffer$7 = 152
BinNameElement$8 = 160
BinNameJSONString$9 = 168
BinPath$10 = 176
BinName$11 = 184
$T12 = 208
$T13 = 224
$T14 = 240
$T15 = 256
$T16 = 272
$T17 = 288
$T18 = 304
$T19 = 320
$T20 = 336
$T21 = 352
$T22 = 368
$T23 = 384
$T24 = 400
$T25 = 416
$T26 = 432
$T27 = 448
$T28 = 464
$T29 = 480
$T30 = 496
$T31 = 512
$T32 = 536
$T33 = 552
$T34 = 568
$T35 = 584
$T36 = 600
$T37 = 616
$T38 = 632
$T39 = 648
$T40 = 664
$T41 = 680
$T42 = 736
Binary$ = 744
ByteOffset$ = 752
Count$ = 760
Name$ = 768
IsAttribute$ = 776
Arena$ = 784
GLTFPath$ = 792
Attributes$ = 800
Primitive$ = 808
Accessors$ = 816
BufferViews$ = 824
Buffers$ = 832
?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z PROC ; GetGLTFBinaryInfo

; 111  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H

; 112  :     file_contents Result = {0};

  0001d	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  00022	48 8b f8	 mov	 rdi, rax
  00025	33 c0		 xor	 eax, eax
  00027	b9 18 00 00 00	 mov	 ecx, 24
  0002c	f3 aa		 rep stosb

; 113  :     
; 114  :     s32 Index;
; 115  :     json_object_s *Accessor;
; 116  :     if(IsAttribute)

  0002e	83 bc 24 08 03
	00 00 00	 cmp	 DWORD PTR IsAttribute$[rsp], 0
  00036	74 72		 je	 SHORT $LN2@GetGLTFBin

; 117  :     {
; 118  :         f32 RealIndex = 0;

  00038	0f 57 c0	 xorps	 xmm0, xmm0
  0003b	f3 0f 11 44 24
	20		 movss	 DWORD PTR RealIndex$1[rsp], xmm0

; 119  :         if(GrabNumberFromJSONObject(Name, Attributes, &RealIndex) == GLTF_RESULT_DOES_NOT_EXIST)

  00041	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR $T30[rsp]
  00049	48 8b f8	 mov	 rdi, rax
  0004c	48 8b b4 24 00
	03 00 00	 mov	 rsi, QWORD PTR Name$[rsp]
  00054	b9 10 00 00 00	 mov	 ecx, 16
  00059	f3 a4		 rep movsb
  0005b	4c 8d 44 24 20	 lea	 r8, QWORD PTR RealIndex$1[rsp]
  00060	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR Attributes$[rsp]
  00068	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00070	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  00075	83 f8 01	 cmp	 eax, 1
  00078	75 24		 jne	 SHORT $LN4@GetGLTFBin

; 120  :         {
; 121  :             return(Result);

  0007a	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  0007f	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  00087	48 8b f0	 mov	 rsi, rax
  0008a	b9 18 00 00 00	 mov	 ecx, 24
  0008f	f3 a4		 rep movsb
  00091	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
  00099	e9 0b 06 00 00	 jmp	 $LN1@GetGLTFBin
$LN4@GetGLTFBin:

; 122  :         }
; 123  :         
; 124  :         Index = (s32)RealIndex;

  0009e	f3 0f 2c 44 24
	20		 cvttss2si eax, DWORD PTR RealIndex$1[rsp]
  000a4	89 44 24 28	 mov	 DWORD PTR Index$[rsp], eax

; 125  :     }

  000a8	eb 70		 jmp	 SHORT $LN3@GetGLTFBin
$LN2@GetGLTFBin:

; 126  :     else
; 127  :     {
; 128  :         f32 RealIndex = 0;

  000aa	0f 57 c0	 xorps	 xmm0, xmm0
  000ad	f3 0f 11 44 24
	24		 movss	 DWORD PTR RealIndex$2[rsp], xmm0

; 129  :         if(GrabNumberFromJSONObject(Name, Primitive, &RealIndex) == GLTF_RESULT_DOES_NOT_EXIST)

  000b3	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  000bb	48 8b f8	 mov	 rdi, rax
  000be	48 8b b4 24 00
	03 00 00	 mov	 rsi, QWORD PTR Name$[rsp]
  000c6	b9 10 00 00 00	 mov	 ecx, 16
  000cb	f3 a4		 rep movsb
  000cd	4c 8d 44 24 24	 lea	 r8, QWORD PTR RealIndex$2[rsp]
  000d2	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR Primitive$[rsp]
  000da	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  000e2	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  000e7	83 f8 01	 cmp	 eax, 1
  000ea	75 24		 jne	 SHORT $LN5@GetGLTFBin

; 130  :         {
; 131  :             return(Result);

  000ec	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  000f1	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  000f9	48 8b f0	 mov	 rsi, rax
  000fc	b9 18 00 00 00	 mov	 ecx, 24
  00101	f3 a4		 rep movsb
  00103	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
  0010b	e9 99 05 00 00	 jmp	 $LN1@GetGLTFBin
$LN5@GetGLTFBin:

; 132  :         }
; 133  :         
; 134  :         Index = (s32)RealIndex;

  00110	f3 0f 2c 44 24
	24		 cvttss2si eax, DWORD PTR RealIndex$2[rsp]
  00116	89 44 24 28	 mov	 DWORD PTR Index$[rsp], eax
$LN3@GetGLTFBin:

; 135  :     }
; 136  :     
; 137  :     json_array_element_s *AccessorElement = GrabJSONArrayElementIndexed(Index, Accessors);

  0011a	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR Accessors$[rsp]
  00122	8b 4c 24 28	 mov	 ecx, DWORD PTR Index$[rsp]
  00126	e8 00 00 00 00	 call	 ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z ; GrabJSONArrayElementIndexed
  0012b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR AccessorElement$[rsp], rax

; 138  :     Accessor = json_value_as_object(AccessorElement->value);

  00133	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR AccessorElement$[rsp]
  0013b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0013e	e8 00 00 00 00	 call	 json_value_as_object
  00143	48 89 44 24 48	 mov	 QWORD PTR Accessor$[rsp], rax

; 139  :     
; 140  :     f32 RealBufferViewIndex = 0;

  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 11 44 24
	2c		 movss	 DWORD PTR RealBufferViewIndex$[rsp], xmm0

; 141  :     if(GrabNumberFromJSONObject(CreateString("bufferView"), Accessor, &RealBufferViewIndex) == GLTF_RESULT_DOES_NOT_EXIST)

  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46149
  00158	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  00160	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00165	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  0016d	48 8b f9	 mov	 rdi, rcx
  00170	48 8b f0	 mov	 rsi, rax
  00173	b9 10 00 00 00	 mov	 ecx, 16
  00178	f3 a4		 rep movsb
  0017a	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T14[rsp]
  00182	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  0018a	48 8b f8	 mov	 rdi, rax
  0018d	48 8b f1	 mov	 rsi, rcx
  00190	b9 10 00 00 00	 mov	 ecx, 16
  00195	f3 a4		 rep movsb
  00197	4c 8d 44 24 2c	 lea	 r8, QWORD PTR RealBufferViewIndex$[rsp]
  0019c	48 8b 54 24 48	 mov	 rdx, QWORD PTR Accessor$[rsp]
  001a1	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  001a9	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  001ae	83 f8 01	 cmp	 eax, 1
  001b1	75 24		 jne	 SHORT $LN6@GetGLTFBin

; 142  :     {
; 143  :         return(Result);

  001b3	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  001b8	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  001c0	48 8b f0	 mov	 rsi, rax
  001c3	b9 18 00 00 00	 mov	 ecx, 24
  001c8	f3 a4		 rep movsb
  001ca	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
  001d2	e9 d2 04 00 00	 jmp	 $LN1@GetGLTFBin
$LN6@GetGLTFBin:

; 144  :     }
; 145  :     s32 BufferViewIndex = (s32)RealBufferViewIndex;

  001d7	f3 0f 2c 44 24
	2c		 cvttss2si eax, DWORD PTR RealBufferViewIndex$[rsp]
  001dd	89 44 24 3c	 mov	 DWORD PTR BufferViewIndex$[rsp], eax

; 146  :     
; 147  :     f32 RealCount = 0;

  001e1	0f 57 c0	 xorps	 xmm0, xmm0
  001e4	f3 0f 11 44 24
	30		 movss	 DWORD PTR RealCount$[rsp], xmm0

; 148  :     if(GrabNumberFromJSONObject(CreateString("count"), Accessor, &RealCount) == GLTF_RESULT_DOES_NOT_EXIST)

  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46151
  001f1	48 8d 8c 24 18
	02 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  001f9	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  001fe	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00206	48 8b f9	 mov	 rdi, rcx
  00209	48 8b f0	 mov	 rsi, rax
  0020c	b9 10 00 00 00	 mov	 ecx, 16
  00211	f3 a4		 rep movsb
  00213	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR $T16[rsp]
  0021b	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00223	48 8b f8	 mov	 rdi, rax
  00226	48 8b f1	 mov	 rsi, rcx
  00229	b9 10 00 00 00	 mov	 ecx, 16
  0022e	f3 a4		 rep movsb
  00230	4c 8d 44 24 30	 lea	 r8, QWORD PTR RealCount$[rsp]
  00235	48 8b 54 24 48	 mov	 rdx, QWORD PTR Accessor$[rsp]
  0023a	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00242	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  00247	83 f8 01	 cmp	 eax, 1
  0024a	75 24		 jne	 SHORT $LN7@GetGLTFBin

; 149  :     {
; 150  :         return(Result);

  0024c	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  00251	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  00259	48 8b f0	 mov	 rsi, rax
  0025c	b9 18 00 00 00	 mov	 ecx, 24
  00261	f3 a4		 rep movsb
  00263	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
  0026b	e9 39 04 00 00	 jmp	 $LN1@GetGLTFBin
$LN7@GetGLTFBin:

; 151  :     }
; 152  :     *Count = (u32)RealCount;

  00270	f3 48 0f 2c 44
	24 30		 cvttss2si rax, DWORD PTR RealCount$[rsp]
  00277	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR Count$[rsp]
  0027f	89 01		 mov	 DWORD PTR [rcx], eax

; 153  :     
; 154  :     json_array_element_s *BufferViewElement = GrabJSONArrayElementIndexed(BufferViewIndex, BufferViews);

  00281	48 8b 94 24 38
	03 00 00	 mov	 rdx, QWORD PTR BufferViews$[rsp]
  00289	8b 4c 24 3c	 mov	 ecx, DWORD PTR BufferViewIndex$[rsp]
  0028d	e8 00 00 00 00	 call	 ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z ; GrabJSONArrayElementIndexed
  00292	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR BufferViewElement$[rsp], rax

; 155  :     json_object_s *BufferView = json_value_as_object(BufferViewElement->value);

  0029a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR BufferViewElement$[rsp]
  002a2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002a5	e8 00 00 00 00	 call	 json_value_as_object
  002aa	48 89 44 24 50	 mov	 QWORD PTR BufferView$[rsp], rax

; 156  :     
; 157  :     f32 RealByteOffset = 0;

  002af	0f 57 c0	 xorps	 xmm0, xmm0
  002b2	f3 0f 11 44 24
	34		 movss	 DWORD PTR RealByteOffset$[rsp], xmm0

; 158  :     if(GrabNumberFromJSONObject(CreateString("byteOffset"), BufferView, &RealByteOffset) == GLTF_RESULT_DOES_NOT_EXIST)

  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46153
  002bf	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  002c7	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  002cc	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  002d4	48 8b f9	 mov	 rdi, rcx
  002d7	48 8b f0	 mov	 rsi, rax
  002da	b9 10 00 00 00	 mov	 ecx, 16
  002df	f3 a4		 rep movsb
  002e1	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR $T18[rsp]
  002e9	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  002f1	48 8b f8	 mov	 rdi, rax
  002f4	48 8b f1	 mov	 rsi, rcx
  002f7	b9 10 00 00 00	 mov	 ecx, 16
  002fc	f3 a4		 rep movsb
  002fe	4c 8d 44 24 34	 lea	 r8, QWORD PTR RealByteOffset$[rsp]
  00303	48 8b 54 24 50	 mov	 rdx, QWORD PTR BufferView$[rsp]
  00308	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00310	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  00315	83 f8 01	 cmp	 eax, 1
  00318	75 24		 jne	 SHORT $LN8@GetGLTFBin

; 159  :     {
; 160  :         return(Result);

  0031a	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  0031f	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  00327	48 8b f0	 mov	 rsi, rax
  0032a	b9 18 00 00 00	 mov	 ecx, 24
  0032f	f3 a4		 rep movsb
  00331	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
  00339	e9 6b 03 00 00	 jmp	 $LN1@GetGLTFBin
$LN8@GetGLTFBin:

; 161  :     }
; 162  :     *ByteOffset = (u32)RealByteOffset;

  0033e	f3 48 0f 2c 44
	24 34		 cvttss2si rax, DWORD PTR RealByteOffset$[rsp]
  00345	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR ByteOffset$[rsp]
  0034d	89 01		 mov	 DWORD PTR [rcx], eax

; 163  :     
; 164  :     if(!Binary)

  0034f	48 83 bc 24 e8
	02 00 00 00	 cmp	 QWORD PTR Binary$[rsp], 0
  00358	0f 85 2c 03 00
	00		 jne	 $LN9@GetGLTFBin

; 165  :     {
; 166  :         f32 RealBufferIndex = 0;

  0035e	0f 57 c0	 xorps	 xmm0, xmm0
  00361	f3 0f 11 44 24
	38		 movss	 DWORD PTR RealBufferIndex$3[rsp], xmm0

; 167  :         if(GrabNumberFromJSONObject(CreateString("buffer"), BufferView, &RealBufferIndex) == GLTF_RESULT_DOES_NOT_EXIST)

  00367	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46156
  0036e	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  00376	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0037b	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00383	48 8b f9	 mov	 rdi, rcx
  00386	48 8b f0	 mov	 rsi, rax
  00389	b9 10 00 00 00	 mov	 ecx, 16
  0038e	f3 a4		 rep movsb
  00390	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR $T20[rsp]
  00398	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  003a0	48 8b f8	 mov	 rdi, rax
  003a3	48 8b f1	 mov	 rsi, rcx
  003a6	b9 10 00 00 00	 mov	 ecx, 16
  003ab	f3 a4		 rep movsb
  003ad	4c 8d 44 24 38	 lea	 r8, QWORD PTR RealBufferIndex$3[rsp]
  003b2	48 8b 54 24 50	 mov	 rdx, QWORD PTR BufferView$[rsp]
  003b7	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  003bf	e8 00 00 00 00	 call	 ?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ; GrabNumberFromJSONObject
  003c4	83 f8 01	 cmp	 eax, 1
  003c7	75 24		 jne	 SHORT $LN10@GetGLTFBin

; 168  :         {
; 169  :             return(Result);

  003c9	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  003ce	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  003d6	48 8b f0	 mov	 rsi, rax
  003d9	b9 18 00 00 00	 mov	 ecx, 24
  003de	f3 a4		 rep movsb
  003e0	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
  003e8	e9 bc 02 00 00	 jmp	 $LN1@GetGLTFBin
$LN10@GetGLTFBin:

; 170  :         }
; 171  :         s32 BufferIndex = (s32)RealBufferIndex;

  003ed	f3 0f 2c 44 24
	38		 cvttss2si eax, DWORD PTR RealBufferIndex$3[rsp]
  003f3	89 44 24 40	 mov	 DWORD PTR BufferIndex$4[rsp], eax

; 172  :         
; 173  :         json_array_element_s *BufferElement = GrabJSONArrayElementIndexed(BufferIndex, Buffers);

  003f7	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR Buffers$[rsp]
  003ff	8b 4c 24 40	 mov	 ecx, DWORD PTR BufferIndex$4[rsp]
  00403	e8 00 00 00 00	 call	 ?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z ; GrabJSONArrayElementIndexed
  00408	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR BufferElement$6[rsp], rax

; 174  :         json_object_s *Buffer = json_value_as_object(BufferElement->value);

  00410	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR BufferElement$6[rsp]
  00418	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0041b	e8 00 00 00 00	 call	 json_value_as_object
  00420	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR Buffer$7[rsp], rax

; 175  :         
; 176  :         json_object_element_s *BinNameElement = FindJSONObjectElement(CreateString("uri"), Buffer);

  00428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46157
  0042f	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  00437	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0043c	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00444	48 8b f9	 mov	 rdi, rcx
  00447	48 8b f0	 mov	 rsi, rax
  0044a	b9 10 00 00 00	 mov	 ecx, 16
  0044f	f3 a4		 rep movsb
  00451	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR $T22[rsp]
  00459	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00461	48 8b f8	 mov	 rdi, rax
  00464	48 8b f1	 mov	 rsi, rcx
  00467	b9 10 00 00 00	 mov	 ecx, 16
  0046c	f3 a4		 rep movsb
  0046e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR Buffer$7[rsp]
  00476	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0047e	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  00483	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR BinNameElement$8[rsp], rax

; 177  :         json_string_s *BinNameJSONString = json_value_as_string(BinNameElement->value);

  0048b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR BinNameElement$8[rsp]
  00493	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00497	e8 00 00 00 00	 call	 json_value_as_string
  0049c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR BinNameJSONString$9[rsp], rax

; 178  :         string8 BinName = CreateString((char *)BinNameJSONString->string);

  004a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR BinNameJSONString$9[rsp]
  004ac	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  004af	48 8d 8c 24 58
	02 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  004b7	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  004bc	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  004c4	48 8b f9	 mov	 rdi, rcx
  004c7	48 8b f0	 mov	 rsi, rax
  004ca	b9 10 00 00 00	 mov	 ecx, 16
  004cf	f3 a4		 rep movsb
  004d1	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR BinName$11[rsp]
  004d9	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  004e1	48 8b f8	 mov	 rdi, rax
  004e4	48 8b f1	 mov	 rsi, rcx
  004e7	b9 10 00 00 00	 mov	 ecx, 16
  004ec	f3 a4		 rep movsb

; 179  :         char *BinPath = PushArray(Arena, char, GLTFPath.Length + BinName.Length + CreateString("/").Length);

  004ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46158
  004f5	48 8d 8c 24 68
	02 00 00	 lea	 rcx, QWORD PTR $T37[rsp]
  004fd	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00502	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  0050a	48 8b f9	 mov	 rdi, rcx
  0050d	48 8b f0	 mov	 rsi, rax
  00510	b9 10 00 00 00	 mov	 ecx, 16
  00515	f3 a4		 rep movsb
  00517	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR GLTFPath$[rsp]
  0051f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00522	03 84 24 c0 00
	00 00		 add	 eax, DWORD PTR BinName$11[rsp+8]
  00529	03 84 24 98 01
	00 00		 add	 eax, DWORD PTR $T24[rsp+8]
  00530	48 98		 cdqe
  00532	48 8b d0	 mov	 rdx, rax
  00535	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR Arena$[rsp]
  0053d	e8 00 00 00 00	 call	 PushSize
  00542	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR BinPath$10[rsp], rax

; 180  :         string8 BinPathString = CreateString(BinPath);

  0054a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR BinPath$10[rsp]
  00552	48 8d 8c 24 78
	02 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  0055a	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  0055f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00567	48 8b f9	 mov	 rdi, rcx
  0056a	48 8b f0	 mov	 rsi, rax
  0056d	b9 10 00 00 00	 mov	 ecx, 16
  00572	f3 a4		 rep movsb
  00574	48 8d 44 24 70	 lea	 rax, QWORD PTR BinPathString$5[rsp]
  00579	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00581	48 8b f8	 mov	 rdi, rax
  00584	48 8b f1	 mov	 rsi, rcx
  00587	b9 10 00 00 00	 mov	 ecx, 16
  0058c	f3 a4		 rep movsb

; 181  :         GetPathNoFileName(&BinPathString, GLTFPath);

  0058e	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR $T26[rsp]
  00596	48 8b f8	 mov	 rdi, rax
  00599	48 8b b4 24 18
	03 00 00	 mov	 rsi, QWORD PTR GLTFPath$[rsp]
  005a1	b9 10 00 00 00	 mov	 ecx, 16
  005a6	f3 a4		 rep movsb
  005a8	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR $T26[rsp]
  005b0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR BinPathString$5[rsp]
  005b5	e8 00 00 00 00	 call	 ?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z ; GetPathNoFileName

; 182  :         StringConcat(&BinPathString, CreateString("/"));

  005ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG46159
  005c1	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  005c9	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  005ce	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  005d6	48 8b f9	 mov	 rdi, rcx
  005d9	48 8b f0	 mov	 rsi, rax
  005dc	b9 10 00 00 00	 mov	 ecx, 16
  005e1	f3 a4		 rep movsb
  005e3	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR $T28[rsp]
  005eb	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  005f3	48 8b f8	 mov	 rdi, rax
  005f6	48 8b f1	 mov	 rsi, rcx
  005f9	b9 10 00 00 00	 mov	 ecx, 16
  005fe	f3 a4		 rep movsb
  00600	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR $T28[rsp]
  00608	48 8d 4c 24 70	 lea	 rcx, QWORD PTR BinPathString$5[rsp]
  0060d	e8 00 00 00 00	 call	 ?StringConcat@@YAXPEAUstring8@@U1@@Z ; StringConcat

; 183  :         StringConcat(&BinPathString, BinName);

  00612	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR $T29[rsp]
  0061a	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR BinName$11[rsp]
  00622	48 8b f8	 mov	 rdi, rax
  00625	48 8b f1	 mov	 rsi, rcx
  00628	b9 10 00 00 00	 mov	 ecx, 16
  0062d	f3 a4		 rep movsb
  0062f	48 8d 94 24 e0
	01 00 00	 lea	 rdx, QWORD PTR $T29[rsp]
  00637	48 8d 4c 24 70	 lea	 rcx, QWORD PTR BinPathString$5[rsp]
  0063c	e8 00 00 00 00	 call	 ?StringConcat@@YAXPEAUstring8@@U1@@Z ; StringConcat

; 184  :         
; 185  :         Result = ReadFile8(BinPathString.String, Arena);

  00641	4c 8b 84 24 10
	03 00 00	 mov	 r8, QWORD PTR Arena$[rsp]
  00649	48 8b 54 24 70	 mov	 rdx, QWORD PTR BinPathString$5[rsp]
  0064e	48 8d 8c 24 a8
	02 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  00656	e8 00 00 00 00	 call	 ?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z ; ReadFile8
  0065b	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  00663	48 8b f9	 mov	 rdi, rcx
  00666	48 8b f0	 mov	 rsi, rax
  00669	b9 18 00 00 00	 mov	 ecx, 24
  0066e	f3 a4		 rep movsb
  00670	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  00675	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0067d	48 8b f8	 mov	 rdi, rax
  00680	48 8b f1	 mov	 rsi, rcx
  00683	b9 18 00 00 00	 mov	 ecx, 24
  00688	f3 a4		 rep movsb
$LN9@GetGLTFBin:

; 186  :     }
; 187  :     
; 188  :     return(Result);

  0068a	48 8d 44 24 58	 lea	 rax, QWORD PTR Result$[rsp]
  0068f	48 8b bc 24 e0
	02 00 00	 mov	 rdi, QWORD PTR $T42[rsp]
  00697	48 8b f0	 mov	 rsi, rax
  0069a	b9 18 00 00 00	 mov	 ecx, 24
  0069f	f3 a4		 rep movsb
  006a1	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR $T42[rsp]
$LN1@GetGLTFBin:

; 189  : }

  006a9	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  006b0	5f		 pop	 rdi
  006b1	5e		 pop	 rsi
  006b2	c3		 ret	 0
?GetGLTFBinaryInfo@@YA?AUfile_contents@@PEAEPEAI1Ustring8@@HPEAUmemory_arena@@2PEAUjson_object_s@@4PEAUjson_array_s@@55@Z ENDP ; GetGLTFBinaryInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
ElementIndex$1 = 32
Element$ = 40
ASCII$ = 48
Index$ = 80
Array$ = 88
Result$ = 96
?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z PROC ; GrabNumberFromJSONArray

; 83   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 84   :     json_array_element_s *Element = Array->start;

  00012	48 8b 44 24 58	 mov	 rax, QWORD PTR Array$[rsp]
  00017	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001a	48 89 44 24 28	 mov	 QWORD PTR Element$[rsp], rax

; 85   :     for(memory_index ElementIndex = 0;

  0001f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ElementIndex$1[rsp], 0
  00028	eb 0d		 jmp	 SHORT $LN4@GrabNumber
$LN2@GrabNumber:

; 87   :         ++ElementIndex)

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR ElementIndex$1[rsp]
  0002f	48 ff c0	 inc	 rax
  00032	48 89 44 24 20	 mov	 QWORD PTR ElementIndex$1[rsp], rax
$LN4@GrabNumber:

; 86   :         ElementIndex < Array->length;

  00037	48 8b 44 24 58	 mov	 rax, QWORD PTR Array$[rsp]
  0003c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00040	48 39 44 24 20	 cmp	 QWORD PTR ElementIndex$1[rsp], rax
  00045	73 1e		 jae	 SHORT $LN3@GrabNumber

; 88   :     {
; 89   :         if(ElementIndex == Index)

  00047	48 63 44 24 50	 movsxd	 rax, DWORD PTR Index$[rsp]
  0004c	48 39 44 24 20	 cmp	 QWORD PTR ElementIndex$1[rsp], rax
  00051	75 02		 jne	 SHORT $LN5@GrabNumber

; 90   :         {
; 91   :             break;

  00053	eb 10		 jmp	 SHORT $LN3@GrabNumber
$LN5@GrabNumber:

; 92   :         }
; 93   :         
; 94   :         Element = Element->next;

  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR Element$[rsp]
  0005a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005e	48 89 44 24 28	 mov	 QWORD PTR Element$[rsp], rax

; 95   :     }

  00063	eb c5		 jmp	 SHORT $LN2@GrabNumber
$LN3@GrabNumber:

; 96   :     
; 97   :     if(!Element)

  00065	48 83 7c 24 28
	00		 cmp	 QWORD PTR Element$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN6@GrabNumber

; 98   :     {
; 99   :         return(GLTF_RESULT_DOES_NOT_EXIST);

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	eb 30		 jmp	 SHORT $LN1@GrabNumber
$LN6@GrabNumber:

; 100  :     }
; 101  :     
; 102  :     json_number_s *ASCII = json_value_as_number(Element->value);

  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR Element$[rsp]
  00079	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007c	e8 00 00 00 00	 call	 json_value_as_number
  00081	48 89 44 24 30	 mov	 QWORD PTR ASCII$[rsp], rax

; 103  :     *Result = (f32)strtod(ASCII->number, 0);

  00086	33 d2		 xor	 edx, edx
  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR ASCII$[rsp]
  0008d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00090	e8 00 00 00 00	 call	 strtod
  00095	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR Result$[rsp]
  0009e	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 104  :     
; 105  :     return(GLTF_RESULT_SUCCESS);

  000a2	33 c0		 xor	 eax, eax
$LN1@GrabNumber:

; 106  : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
?GrabNumberFromJSONArray@@YA?AW4gltf_result@@HPEAUjson_array_s@@PEAM@Z ENDP ; GrabNumberFromJSONArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
Element$ = 32
ASCII$ = 40
$T1 = 48
Name$ = 96
Object$ = 104
Result$ = 112
?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z PROC ; GrabNumberFromJSONObject

; 67   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 68   :     json_object_element_s *Element = FindJSONObjectElement(Name, Object);

  00015	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0001a	48 8b f8	 mov	 rdi, rax
  0001d	48 8b 74 24 60	 mov	 rsi, QWORD PTR Name$[rsp]
  00022	b9 10 00 00 00	 mov	 ecx, 16
  00027	f3 a4		 rep movsb
  00029	48 8b 54 24 68	 mov	 rdx, QWORD PTR Object$[rsp]
  0002e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00033	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  00038	48 89 44 24 20	 mov	 QWORD PTR Element$[rsp], rax

; 69   :     
; 70   :     if(!Element)

  0003d	48 83 7c 24 20
	00		 cmp	 QWORD PTR Element$[rsp], 0
  00043	75 07		 jne	 SHORT $LN2@GrabNumber

; 71   :     {
; 72   :         return(GLTF_RESULT_DOES_NOT_EXIST);

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	eb 31		 jmp	 SHORT $LN1@GrabNumber
$LN2@GrabNumber:

; 73   :     }
; 74   :     
; 75   :     json_number_s *ASCII = json_value_as_number(Element->value);

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR Element$[rsp]
  00051	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00055	e8 00 00 00 00	 call	 json_value_as_number
  0005a	48 89 44 24 28	 mov	 QWORD PTR ASCII$[rsp], rax

; 76   :     *Result = (f32)strtod(ASCII->number, 0);

  0005f	33 d2		 xor	 edx, edx
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR ASCII$[rsp]
  00066	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00069	e8 00 00 00 00	 call	 strtod
  0006e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00072	48 8b 44 24 70	 mov	 rax, QWORD PTR Result$[rsp]
  00077	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 77   :     
; 78   :     return(GLTF_RESULT_SUCCESS);

  0007b	33 c0		 xor	 eax, eax
$LN1@GrabNumber:

; 79   : }

  0007d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00081	5f		 pop	 rdi
  00082	5e		 pop	 rsi
  00083	c3		 ret	 0
?GrabNumberFromJSONObject@@YA?AW4gltf_result@@Ustring8@@PEAUjson_object_s@@PEAM@Z ENDP ; GrabNumberFromJSONObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
Element$ = 32
Result$1 = 40
$T2 = 48
Name$ = 96
Object$ = 104
?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z PROC ; GrabJSONArray

; 46   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 47   :     json_object_element_s *Element = FindJSONObjectElement(Name, Object);

  00010	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00015	48 8b f8	 mov	 rdi, rax
  00018	48 8b 74 24 60	 mov	 rsi, QWORD PTR Name$[rsp]
  0001d	b9 10 00 00 00	 mov	 ecx, 16
  00022	f3 a4		 rep movsb
  00024	48 8b 54 24 68	 mov	 rdx, QWORD PTR Object$[rsp]
  00029	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0002e	e8 00 00 00 00	 call	 ?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ; FindJSONObjectElement
  00033	48 89 44 24 20	 mov	 QWORD PTR Element$[rsp], rax

; 48   :     
; 49   :     if(Element)

  00038	48 83 7c 24 20
	00		 cmp	 QWORD PTR Element$[rsp], 0
  0003e	74 1a		 je	 SHORT $LN2@GrabJSONAr

; 50   :     {
; 51   :         json_array_s *Result = json_value_as_array(Element->value);

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR Element$[rsp]
  00045	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00049	e8 00 00 00 00	 call	 json_value_as_array
  0004e	48 89 44 24 28	 mov	 QWORD PTR Result$1[rsp], rax

; 52   :         
; 53   :         return(Result);

  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR Result$1[rsp]
  00058	eb 02		 jmp	 SHORT $LN1@GrabJSONAr
$LN2@GrabJSONAr:

; 54   :     }
; 55   :     
; 56   :     return(0);

  0005a	33 c0		 xor	 eax, eax
$LN1@GrabJSONAr:

; 57   : }

  0005c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00060	5f		 pop	 rdi
  00061	5e		 pop	 rsi
  00062	c3		 ret	 0
?GrabJSONArray@@YAPEAUjson_array_s@@Ustring8@@PEAUjson_object_s@@@Z ENDP ; GrabJSONArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
LoopIndex$1 = 0
Result$ = 8
Index$ = 32
Array$ = 40
?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z PROC ; GrabJSONArrayElementIndexed

; 27   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 18	 sub	 rsp, 24

; 28   :     json_array_element_s *Result = Array->start;

  0000d	48 8b 44 24 28	 mov	 rax, QWORD PTR Array$[rsp]
  00012	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00015	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 29   :     for(u32 LoopIndex = 0;

  0001a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR LoopIndex$1[rsp], 0
  00021	eb 08		 jmp	 SHORT $LN4@GrabJSONAr
$LN2@GrabJSONAr:

; 31   :         ++LoopIndex)

  00023	8b 04 24	 mov	 eax, DWORD PTR LoopIndex$1[rsp]
  00026	ff c0		 inc	 eax
  00028	89 04 24	 mov	 DWORD PTR LoopIndex$1[rsp], eax
$LN4@GrabJSONAr:

; 30   :         LoopIndex < Array->length;

  0002b	8b 04 24	 mov	 eax, DWORD PTR LoopIndex$1[rsp]
  0002e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Array$[rsp]
  00033	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  00037	73 20		 jae	 SHORT $LN3@GrabJSONAr

; 32   :     {
; 33   :         if(LoopIndex == Index)

  00039	8b 44 24 20	 mov	 eax, DWORD PTR Index$[rsp]
  0003d	39 04 24	 cmp	 DWORD PTR LoopIndex$1[rsp], eax
  00040	75 07		 jne	 SHORT $LN5@GrabJSONAr

; 34   :         {
; 35   :             return(Result);

  00042	48 8b 44 24 08	 mov	 rax, QWORD PTR Result$[rsp]
  00047	eb 12		 jmp	 SHORT $LN1@GrabJSONAr
$LN5@GrabJSONAr:

; 36   :         }
; 37   :         
; 38   :         Result = Result->next;

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR Result$[rsp]
  0004e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00052	48 89 44 24 08	 mov	 QWORD PTR Result$[rsp], rax

; 39   :     }

  00057	eb ca		 jmp	 SHORT $LN2@GrabJSONAr
$LN3@GrabJSONAr:

; 40   :     
; 41   :     return(0);

  00059	33 c0		 xor	 eax, eax
$LN1@GrabJSONAr:

; 42   : }

  0005b	48 83 c4 18	 add	 rsp, 24
  0005f	c3		 ret	 0
?GrabJSONArrayElementIndexed@@YAPEAUjson_array_element_s@@IPEAUjson_array_s@@@Z ENDP ; GrabJSONArrayElementIndexed
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_gltf.cpp
_TEXT	SEGMENT
Result$ = 32
ObjectIndex$1 = 40
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
Name$ = 144
Object$ = 152
?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z PROC ; FindJSONObjectElement

; 8    : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 9    :     json_object_element_s *Result = Object->start;

  00010	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Object$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 20	 mov	 QWORD PTR Result$[rsp], rax

; 10   :     for(memory_index ObjectIndex = 0;

  00020	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR ObjectIndex$1[rsp], 0
  00029	eb 0d		 jmp	 SHORT $LN4@FindJSONOb
$LN2@FindJSONOb:

; 12   :         ++ObjectIndex)

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR ObjectIndex$1[rsp]
  00030	48 ff c0	 inc	 rax
  00033	48 89 44 24 28	 mov	 QWORD PTR ObjectIndex$1[rsp], rax
$LN4@FindJSONOb:

; 11   :         ObjectIndex < Object->length;

  00038	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR Object$[rsp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 39 44 24 28	 cmp	 QWORD PTR ObjectIndex$1[rsp], rax
  00049	0f 83 82 00 00
	00		 jae	 $LN3@FindJSONOb

; 13   :     {
; 14   :         if(CompareStringBinary(Name, CreateString((char *)Result->name->string)))

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR Result$[rsp]
  00054	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00057	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0005a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T5[rsp]
  0005f	e8 00 00 00 00	 call	 ?CreateString@@YA?AUstring8@@PEAD@Z ; CreateString
  00064	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00069	48 8b f9	 mov	 rdi, rcx
  0006c	48 8b f0	 mov	 rsi, rax
  0006f	b9 10 00 00 00	 mov	 ecx, 16
  00074	f3 a4		 rep movsb
  00076	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  0007b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00080	48 8b f8	 mov	 rdi, rax
  00083	48 8b f1	 mov	 rsi, rcx
  00086	b9 10 00 00 00	 mov	 ecx, 16
  0008b	f3 a4		 rep movsb
  0008d	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  00092	48 8b f8	 mov	 rdi, rax
  00095	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR Name$[rsp]
  0009d	b9 10 00 00 00	 mov	 ecx, 16
  000a2	f3 a4		 rep movsb
  000a4	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  000a9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  000ae	e8 00 00 00 00	 call	 ?CompareStringBinary@@YAHUstring8@@0@Z ; CompareStringBinary
  000b3	85 c0		 test	 eax, eax
  000b5	74 07		 je	 SHORT $LN5@FindJSONOb

; 15   :         {
; 16   :             return(Result);

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR Result$[rsp]
  000bc	eb 15		 jmp	 SHORT $LN1@FindJSONOb
$LN5@FindJSONOb:

; 17   :         }
; 18   :         
; 19   :         Result = Result->next;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR Result$[rsp]
  000c3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c7	48 89 44 24 20	 mov	 QWORD PTR Result$[rsp], rax

; 20   :     }

  000cc	e9 5a ff ff ff	 jmp	 $LN2@FindJSONOb
$LN3@FindJSONOb:

; 21   :     
; 22   :     return(0);

  000d1	33 c0		 xor	 eax, eax
$LN1@FindJSONOb:

; 23   : }

  000d3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000d7	5f		 pop	 rdi
  000d8	5e		 pop	 rsi
  000d9	c3		 ret	 0
?FindJSONObjectElement@@YAPEAUjson_object_element_s@@Ustring8@@PEAUjson_object_s@@@Z ENDP ; FindJSONObjectElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z
_TEXT	SEGMENT
offset$ = 0
src$ = 8
bytes_written$ = 16
tv161 = 24
data$ = 32
end$1 = 40
size$ = 48
i$2 = 56
i$3 = 64
flags_bitset$ = 72
inf_strlen$4 = 80
nan_strlen$5 = 88
state$ = 112
number$ = 120
?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z PROC ; json_parse_number, COMDAT

; 1831 :                        struct json_number_s *number) {

$LN46:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1832 :     const size_t flags_bitset = state->flags_bitset;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 89 44 24 48	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 1833 :     size_t offset = state->offset;

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00021	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00025	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1834 :     const size_t size = state->size;

  00029	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0002e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00032	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 1835 :     size_t bytes_written = 0;

  00037	48 c7 44 24 10
	00 00 00 00	 mov	 QWORD PTR bytes_written$[rsp], 0

; 1836 :     const char *const src = state->src;

  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 89 44 24 08	 mov	 QWORD PTR src$[rsp], rax

; 1837 :     char *data = state->data;

  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00052	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00056	48 89 44 24 20	 mov	 QWORD PTR data$[rsp], rax

; 1838 :     
; 1839 :     number->number = data;

  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR number$[rsp]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00065	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1840 :     
; 1841 :     if (json_parse_flags_allow_hexadecimal_numbers & flags_bitset) {

  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0006d	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00073	48 85 c0	 test	 rax, rax
  00076	0f 84 5b 01 00
	00		 je	 $LN14@json_parse

; 1842 :         if (('0' == src[offset]) &&

  0007c	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00080	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0008e	83 f8 30	 cmp	 eax, 48			; 00000030H
  00091	0f 85 40 01 00
	00		 jne	 $LN15@json_parse
  00097	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0009b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000a0	48 03 c8	 add	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000aa	83 f8 78	 cmp	 eax, 120		; 00000078H
  000ad	74 1c		 je	 SHORT $LN16@json_parse
  000af	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000b3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000c2	83 f8 58	 cmp	 eax, 88			; 00000058H
  000c5	0f 85 0c 01 00
	00		 jne	 $LN15@json_parse
$LN16@json_parse:
$LN2@json_parse:

; 1843 :             (('x' == src[offset + 1]) || ('X' == src[offset + 1]))) {
; 1844 :             /* consume hexadecimal digits. */
; 1845 :             while ((offset < size) &&

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  000d0	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  000d4	0f 83 fd 00 00
	00		 jae	 $LN3@json_parse
  000da	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000de	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ec	83 f8 30	 cmp	 eax, 48			; 00000030H
  000ef	7c 1b		 jl	 SHORT $LN18@json_parse
  000f1	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000f5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000fa	48 03 c8	 add	 rcx, rax
  000fd	48 8b c1	 mov	 rax, rcx
  00100	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00103	83 f8 39	 cmp	 eax, 57			; 00000039H
  00106	0f 8e 8a 00 00
	00		 jle	 $LN17@json_parse
$LN18@json_parse:
  0010c	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00110	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00115	48 03 c8	 add	 rcx, rax
  00118	48 8b c1	 mov	 rax, rcx
  0011b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0011e	83 f8 61	 cmp	 eax, 97			; 00000061H
  00121	7c 17		 jl	 SHORT $LN19@json_parse
  00123	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00127	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0012c	48 03 c8	 add	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00135	83 f8 66	 cmp	 eax, 102		; 00000066H
  00138	7e 5c		 jle	 SHORT $LN17@json_parse
$LN19@json_parse:
  0013a	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0013e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00143	48 03 c8	 add	 rcx, rax
  00146	48 8b c1	 mov	 rax, rcx
  00149	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0014c	83 f8 41	 cmp	 eax, 65			; 00000041H
  0014f	7c 17		 jl	 SHORT $LN20@json_parse
  00151	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00155	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0015a	48 03 c8	 add	 rcx, rax
  0015d	48 8b c1	 mov	 rax, rcx
  00160	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00163	83 f8 46	 cmp	 eax, 70			; 00000046H
  00166	7e 2e		 jle	 SHORT $LN17@json_parse
$LN20@json_parse:
  00168	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0016c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00171	48 03 c8	 add	 rcx, rax
  00174	48 8b c1	 mov	 rax, rcx
  00177	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017a	83 f8 78	 cmp	 eax, 120		; 00000078H
  0017d	74 17		 je	 SHORT $LN17@json_parse
  0017f	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00183	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00188	48 03 c8	 add	 rcx, rax
  0018b	48 8b c1	 mov	 rax, rcx
  0018e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00191	83 f8 58	 cmp	 eax, 88			; 00000058H
  00194	75 41		 jne	 SHORT $LN3@json_parse
$LN17@json_parse:

; 1846 :                    (('0' <= src[offset] && src[offset] <= '9') ||
; 1847 :                     ('a' <= src[offset] && src[offset] <= 'f') ||
; 1848 :                     ('A' <= src[offset] && src[offset] <= 'F') ||
; 1849 :                     ('x' == src[offset]) || ('X' == src[offset]))) {
; 1850 :                 data[bytes_written++] = src[offset++];

  00196	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0019b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  001a0	48 03 c8	 add	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  001aa	48 8b 54 24 08	 mov	 rdx, QWORD PTR src$[rsp]
  001af	48 03 d1	 add	 rdx, rcx
  001b2	48 8b ca	 mov	 rcx, rdx
  001b5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001b8	88 08		 mov	 BYTE PTR [rax], cl
  001ba	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  001bf	48 ff c0	 inc	 rax
  001c2	48 89 44 24 10	 mov	 QWORD PTR bytes_written$[rsp], rax
  001c7	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  001cb	48 ff c0	 inc	 rax
  001ce	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1851 :             }

  001d2	e9 f4 fe ff ff	 jmp	 $LN2@json_parse
$LN3@json_parse:
$LN15@json_parse:
$LN14@json_parse:
$LN4@json_parse:

; 1852 :         }
; 1853 :     }
; 1854 :     
; 1855 :     while (offset < size) {

  001d7	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  001dc	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  001e0	0f 83 a4 00 00
	00		 jae	 $LN5@json_parse

; 1856 :         int end = 0;

  001e6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR end$1[rsp], 0

; 1857 :         
; 1858 :         switch (src[offset]) {

  001ee	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  001f2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  001f7	48 03 c8	 add	 rcx, rax
  001fa	48 8b c1	 mov	 rax, rcx
  001fd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00200	89 44 24 18	 mov	 DWORD PTR tv161[rsp], eax
  00204	8b 44 24 18	 mov	 eax, DWORD PTR tv161[rsp]
  00208	83 e8 2b	 sub	 eax, 43			; 0000002bH
  0020b	89 44 24 18	 mov	 DWORD PTR tv161[rsp], eax
  0020f	83 7c 24 18 3a	 cmp	 DWORD PTR tv161[rsp], 58 ; 0000003aH
  00214	77 5e		 ja	 SHORT $LN36@json_parse
  00216	48 63 44 24 18	 movsxd	 rax, DWORD PTR tv161[rsp]
  0021b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00222	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN44@json_parse[rcx+rax]
  0022a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN45@json_parse[rcx+rax*4]
  00231	48 03 c1	 add	 rax, rcx
  00234	ff e0		 jmp	 rax
$LN21@json_parse:
$LN22@json_parse:
$LN23@json_parse:
$LN24@json_parse:
$LN25@json_parse:
$LN26@json_parse:
$LN27@json_parse:
$LN28@json_parse:
$LN29@json_parse:
$LN30@json_parse:
$LN31@json_parse:
$LN32@json_parse:
$LN33@json_parse:
$LN34@json_parse:
$LN35@json_parse:

; 1859 :             case '0':
; 1860 :             case '1':
; 1861 :             case '2':
; 1862 :             case '3':
; 1863 :             case '4':
; 1864 :             case '5':
; 1865 :             case '6':
; 1866 :             case '7':
; 1867 :             case '8':
; 1868 :             case '9':
; 1869 :             case '.':
; 1870 :             case 'e':
; 1871 :             case 'E':
; 1872 :             case '+':
; 1873 :             case '-':
; 1874 :             data[bytes_written++] = src[offset++];

  00236	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0023b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00240	48 03 c8	 add	 rcx, rax
  00243	48 8b c1	 mov	 rax, rcx
  00246	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0024a	48 8b 54 24 08	 mov	 rdx, QWORD PTR src$[rsp]
  0024f	48 03 d1	 add	 rdx, rcx
  00252	48 8b ca	 mov	 rcx, rdx
  00255	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00258	88 08		 mov	 BYTE PTR [rax], cl
  0025a	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0025f	48 ff c0	 inc	 rax
  00262	48 89 44 24 10	 mov	 QWORD PTR bytes_written$[rsp], rax
  00267	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0026b	48 ff c0	 inc	 rax
  0026e	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1875 :             break;

  00272	eb 08		 jmp	 SHORT $LN6@json_parse
$LN36@json_parse:

; 1876 :             default:
; 1877 :             end = 1;

  00274	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR end$1[rsp], 1
$LN6@json_parse:

; 1878 :             break;
; 1879 :         }
; 1880 :         
; 1881 :         if (0 != end) {

  0027c	83 7c 24 28 00	 cmp	 DWORD PTR end$1[rsp], 0
  00281	74 02		 je	 SHORT $LN37@json_parse

; 1882 :             break;

  00283	eb 05		 jmp	 SHORT $LN5@json_parse
$LN37@json_parse:

; 1883 :         }
; 1884 :     }

  00285	e9 4d ff ff ff	 jmp	 $LN4@json_parse
$LN5@json_parse:

; 1885 :     
; 1886 :     if (json_parse_flags_allow_inf_and_nan & flags_bitset) {

  0028a	48 8b 44 24 48	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0028f	48 25 00 10 00
	00		 and	 rax, 4096		; 00001000H
  00295	48 85 c0	 test	 rax, rax
  00298	0f 84 1a 01 00
	00		 je	 $LN38@json_parse

; 1887 :         const size_t inf_strlen = 8; /* = strlen("Infinity");. */

  0029e	48 c7 44 24 50
	08 00 00 00	 mov	 QWORD PTR inf_strlen$4[rsp], 8

; 1888 :         const size_t nan_strlen = 3; /* = strlen("NaN");. */

  002a7	48 c7 44 24 58
	03 00 00 00	 mov	 QWORD PTR nan_strlen$5[rsp], 3

; 1889 :         
; 1890 :         if (offset + inf_strlen < size) {

  002b0	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  002b4	48 83 c0 08	 add	 rax, 8
  002b8	48 3b 44 24 30	 cmp	 rax, QWORD PTR size$[rsp]
  002bd	73 75		 jae	 SHORT $LN39@json_parse

; 1891 :             if ('I' == src[offset]) {

  002bf	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  002c3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  002c8	48 03 c8	 add	 rcx, rax
  002cb	48 8b c1	 mov	 rax, rcx
  002ce	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002d1	83 f8 49	 cmp	 eax, 73			; 00000049H
  002d4	75 5e		 jne	 SHORT $LN40@json_parse

; 1892 :                 size_t i;
; 1893 :                 /* We found our special 'Infinity' keyword! */
; 1894 :                 for (i = 0; i < inf_strlen; i++) {

  002d6	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$2[rsp], 0
  002df	eb 0d		 jmp	 SHORT $LN10@json_parse
$LN8@json_parse:
  002e1	48 8b 44 24 38	 mov	 rax, QWORD PTR i$2[rsp]
  002e6	48 ff c0	 inc	 rax
  002e9	48 89 44 24 38	 mov	 QWORD PTR i$2[rsp], rax
$LN10@json_parse:
  002ee	48 83 7c 24 38
	08		 cmp	 QWORD PTR i$2[rsp], 8
  002f4	73 3e		 jae	 SHORT $LN9@json_parse

; 1895 :                     data[bytes_written++] = src[offset++];

  002f6	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  002fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00300	48 03 c8	 add	 rcx, rax
  00303	48 8b c1	 mov	 rax, rcx
  00306	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0030a	48 8b 54 24 08	 mov	 rdx, QWORD PTR src$[rsp]
  0030f	48 03 d1	 add	 rdx, rcx
  00312	48 8b ca	 mov	 rcx, rdx
  00315	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00318	88 08		 mov	 BYTE PTR [rax], cl
  0031a	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0031f	48 ff c0	 inc	 rax
  00322	48 89 44 24 10	 mov	 QWORD PTR bytes_written$[rsp], rax
  00327	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0032b	48 ff c0	 inc	 rax
  0032e	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1896 :                 }

  00332	eb ad		 jmp	 SHORT $LN8@json_parse
$LN9@json_parse:
$LN40@json_parse:
$LN39@json_parse:

; 1897 :             }
; 1898 :         }
; 1899 :         
; 1900 :         if (offset + nan_strlen < size) {

  00334	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00338	48 83 c0 03	 add	 rax, 3
  0033c	48 3b 44 24 30	 cmp	 rax, QWORD PTR size$[rsp]
  00341	73 75		 jae	 SHORT $LN41@json_parse

; 1901 :             if ('N' == src[offset]) {

  00343	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00347	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0034c	48 03 c8	 add	 rcx, rax
  0034f	48 8b c1	 mov	 rax, rcx
  00352	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00355	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00358	75 5e		 jne	 SHORT $LN42@json_parse

; 1902 :                 size_t i;
; 1903 :                 /* We found our special 'NaN' keyword! */
; 1904 :                 for (i = 0; i < nan_strlen; i++) {

  0035a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$3[rsp], 0
  00363	eb 0d		 jmp	 SHORT $LN13@json_parse
$LN11@json_parse:
  00365	48 8b 44 24 40	 mov	 rax, QWORD PTR i$3[rsp]
  0036a	48 ff c0	 inc	 rax
  0036d	48 89 44 24 40	 mov	 QWORD PTR i$3[rsp], rax
$LN13@json_parse:
  00372	48 83 7c 24 40
	03		 cmp	 QWORD PTR i$3[rsp], 3
  00378	73 3e		 jae	 SHORT $LN12@json_parse

; 1905 :                     data[bytes_written++] = src[offset++];

  0037a	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0037f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  00384	48 03 c8	 add	 rcx, rax
  00387	48 8b c1	 mov	 rax, rcx
  0038a	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0038e	48 8b 54 24 08	 mov	 rdx, QWORD PTR src$[rsp]
  00393	48 03 d1	 add	 rdx, rcx
  00396	48 8b ca	 mov	 rcx, rdx
  00399	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0039c	88 08		 mov	 BYTE PTR [rax], cl
  0039e	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003a3	48 ff c0	 inc	 rax
  003a6	48 89 44 24 10	 mov	 QWORD PTR bytes_written$[rsp], rax
  003ab	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  003af	48 ff c0	 inc	 rax
  003b2	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1906 :                 }

  003b6	eb ad		 jmp	 SHORT $LN11@json_parse
$LN12@json_parse:
$LN42@json_parse:
$LN41@json_parse:
$LN38@json_parse:

; 1907 :             }
; 1908 :         }
; 1909 :     }
; 1910 :     
; 1911 :     /* record the size of the number. */
; 1912 :     number->number_size = bytes_written;

  003b8	48 8b 44 24 78	 mov	 rax, QWORD PTR number$[rsp]
  003bd	48 8b 4c 24 10	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  003c2	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1913 :     /* add null terminator to number string. */
; 1914 :     data[bytes_written++] = '\0';

  003c6	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR data$[rsp]
  003d0	48 03 c8	 add	 rcx, rax
  003d3	48 8b c1	 mov	 rax, rcx
  003d6	c6 00 00	 mov	 BYTE PTR [rax], 0
  003d9	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003de	48 ff c0	 inc	 rax
  003e1	48 89 44 24 10	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1915 :     /* move data along. */
; 1916 :     state->data += bytes_written;

  003e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  003eb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  003ef	48 03 44 24 10	 add	 rax, QWORD PTR bytes_written$[rsp]
  003f4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  003f9	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1917 :     /* update offset. */
; 1918 :     state->offset = offset;

  003fd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00402	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  00406	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1919 : }

  0040a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0040e	c3		 ret	 0
  0040f	90		 npad	 1
$LN45@json_parse:
  00410	00 00 00 00	 DD	 $LN34@json_parse
  00414	00 00 00 00	 DD	 $LN35@json_parse
  00418	00 00 00 00	 DD	 $LN31@json_parse
  0041c	00 00 00 00	 DD	 $LN21@json_parse
  00420	00 00 00 00	 DD	 $LN22@json_parse
  00424	00 00 00 00	 DD	 $LN23@json_parse
  00428	00 00 00 00	 DD	 $LN24@json_parse
  0042c	00 00 00 00	 DD	 $LN25@json_parse
  00430	00 00 00 00	 DD	 $LN26@json_parse
  00434	00 00 00 00	 DD	 $LN27@json_parse
  00438	00 00 00 00	 DD	 $LN28@json_parse
  0043c	00 00 00 00	 DD	 $LN29@json_parse
  00440	00 00 00 00	 DD	 $LN30@json_parse
  00444	00 00 00 00	 DD	 $LN33@json_parse
  00448	00 00 00 00	 DD	 $LN32@json_parse
  0044c	00 00 00 00	 DD	 $LN36@json_parse
$LN44@json_parse:
  00450	00		 DB	 0
  00451	0f		 DB	 15
  00452	01		 DB	 1
  00453	02		 DB	 2
  00454	0f		 DB	 15
  00455	03		 DB	 3
  00456	04		 DB	 4
  00457	05		 DB	 5
  00458	06		 DB	 6
  00459	07		 DB	 7
  0045a	08		 DB	 8
  0045b	09		 DB	 9
  0045c	0a		 DB	 10
  0045d	0b		 DB	 11
  0045e	0c		 DB	 12
  0045f	0f		 DB	 15
  00460	0f		 DB	 15
  00461	0f		 DB	 15
  00462	0f		 DB	 15
  00463	0f		 DB	 15
  00464	0f		 DB	 15
  00465	0f		 DB	 15
  00466	0f		 DB	 15
  00467	0f		 DB	 15
  00468	0f		 DB	 15
  00469	0f		 DB	 15
  0046a	0d		 DB	 13
  0046b	0f		 DB	 15
  0046c	0f		 DB	 15
  0046d	0f		 DB	 15
  0046e	0f		 DB	 15
  0046f	0f		 DB	 15
  00470	0f		 DB	 15
  00471	0f		 DB	 15
  00472	0f		 DB	 15
  00473	0f		 DB	 15
  00474	0f		 DB	 15
  00475	0f		 DB	 15
  00476	0f		 DB	 15
  00477	0f		 DB	 15
  00478	0f		 DB	 15
  00479	0f		 DB	 15
  0047a	0f		 DB	 15
  0047b	0f		 DB	 15
  0047c	0f		 DB	 15
  0047d	0f		 DB	 15
  0047e	0f		 DB	 15
  0047f	0f		 DB	 15
  00480	0f		 DB	 15
  00481	0f		 DB	 15
  00482	0f		 DB	 15
  00483	0f		 DB	 15
  00484	0f		 DB	 15
  00485	0f		 DB	 15
  00486	0f		 DB	 15
  00487	0f		 DB	 15
  00488	0f		 DB	 15
  00489	0f		 DB	 15
  0048a	0e		 DB	 14
?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z ENDP ; json_parse_number
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z
_TEXT	SEGMENT
allow_comma$ = 32
element$1 = 40
previous$ = 48
elements$ = 56
value_ex$2 = 64
value$3 = 72
src$ = 80
size$ = 88
state$ = 112
array$ = 120
?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z PROC ; json_parse_array, COMDAT

; 1741 :                       struct json_array_s *array) {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1742 :     const char *const src = state->src;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 50	 mov	 QWORD PTR src$[rsp], rax

; 1743 :     const size_t size = state->size;

  0001b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00020	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00024	48 89 44 24 58	 mov	 QWORD PTR size$[rsp], rax

; 1744 :     size_t elements = 0;

  00029	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR elements$[rsp], 0

; 1745 :     int allow_comma = 0;

  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 1746 :     struct json_array_element_s *previous = json_null;

  0003a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR previous$[rsp], 0

; 1747 :     
; 1748 :     /* skip leading '['. */
; 1749 :     state->offset++;

  00043	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00048	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004c	48 ff c0	 inc	 rax
  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00054	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1750 :     
; 1751 :     (void)json_skip_all_skippables(state);

  00058	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0005d	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1752 :     
; 1753 :     /* reset elements. */
; 1754 :     elements = 0;

  00062	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR elements$[rsp], 0
$LN4@json_parse:

; 1755 :     
; 1756 :     do {
; 1757 :         struct json_array_element_s *element = json_null;

  0006b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR element$1[rsp], 0

; 1758 :         struct json_value_s *value = json_null;

  00074	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR value$3[rsp], 0

; 1759 :         
; 1760 :         (void)json_skip_all_skippables(state);

  0007d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00082	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1761 :         
; 1762 :         if (']' == src[state->offset]) {

  00087	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0008c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR src$[rsp]
  00095	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00099	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  0009c	75 1a		 jne	 SHORT $LN5@json_parse

; 1763 :             /* skip trailing ']'. */
; 1764 :             state->offset++;

  0009e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000a3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a7	48 ff c0	 inc	 rax
  000aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  000af	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1765 :             
; 1766 :             /* finished the array! */
; 1767 :             break;

  000b3	e9 84 01 00 00	 jmp	 $LN3@json_parse
$LN5@json_parse:

; 1768 :         }
; 1769 :         
; 1770 :         /* if we parsed at least one element previously, grok for a comma. */
; 1771 :         if (allow_comma) {

  000b8	83 7c 24 20 00	 cmp	 DWORD PTR allow_comma$[rsp], 0
  000bd	74 39		 je	 SHORT $LN6@json_parse

; 1772 :             if (',' == src[state->offset]) {

  000bf	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000c4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR src$[rsp]
  000cd	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000d1	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  000d4	75 22		 jne	 SHORT $LN7@json_parse

; 1773 :                 /* skip comma. */
; 1774 :                 state->offset++;

  000d6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000db	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000df	48 ff c0	 inc	 rax
  000e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  000e7	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1775 :                 allow_comma = 0;

  000eb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 1776 :                 continue;

  000f3	e9 30 01 00 00	 jmp	 $LN2@json_parse
$LN7@json_parse:
$LN6@json_parse:

; 1777 :             }
; 1778 :         }
; 1779 :         
; 1780 :         element = (struct json_array_element_s *)state->dom;

  000f8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000fd	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00101	48 89 44 24 28	 mov	 QWORD PTR element$1[rsp], rax

; 1781 :         
; 1782 :         state->dom += sizeof(struct json_array_element_s);

  00106	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0010b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0010f	48 83 c0 10	 add	 rax, 16
  00113	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00118	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1783 :         
; 1784 :         if (json_null == previous) {

  0011c	48 83 7c 24 30
	00		 cmp	 QWORD PTR previous$[rsp], 0
  00122	75 0f		 jne	 SHORT $LN8@json_parse

; 1785 :             /* this is our first element, so record it in our array. */
; 1786 :             array->start = element;

  00124	48 8b 44 24 78	 mov	 rax, QWORD PTR array$[rsp]
  00129	48 8b 4c 24 28	 mov	 rcx, QWORD PTR element$1[rsp]
  0012e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1787 :         } else {

  00131	eb 0e		 jmp	 SHORT $LN9@json_parse
$LN8@json_parse:

; 1788 :             previous->next = element;

  00133	48 8b 44 24 30	 mov	 rax, QWORD PTR previous$[rsp]
  00138	48 8b 4c 24 28	 mov	 rcx, QWORD PTR element$1[rsp]
  0013d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN9@json_parse:

; 1789 :         }
; 1790 :         
; 1791 :         previous = element;

  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR element$1[rsp]
  00146	48 89 44 24 30	 mov	 QWORD PTR previous$[rsp], rax

; 1792 :         
; 1793 :         if (json_parse_flags_allow_location_information & state->flags_bitset) {

  0014b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00150	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00154	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0015a	48 85 c0	 test	 rax, rax
  0015d	74 72		 je	 SHORT $LN10@json_parse

; 1794 :             struct json_value_ex_s *value_ex = (struct json_value_ex_s *)state->dom;

  0015f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00164	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00168	48 89 44 24 40	 mov	 QWORD PTR value_ex$2[rsp], rax

; 1795 :             state->dom += sizeof(struct json_value_ex_s);

  0016d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00172	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00176	48 83 c0 28	 add	 rax, 40			; 00000028H
  0017a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0017f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1796 :             
; 1797 :             value_ex->offset = state->offset;

  00183	48 8b 44 24 40	 mov	 rax, QWORD PTR value_ex$2[rsp]
  00188	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0018d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00191	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1798 :             value_ex->line_no = state->line_no;

  00195	48 8b 44 24 40	 mov	 rax, QWORD PTR value_ex$2[rsp]
  0019a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0019f	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001a3	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1799 :             value_ex->row_no = state->offset - state->line_offset;

  001a7	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  001ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  001b1	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001b5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001b9	48 2b c1	 sub	 rax, rcx
  001bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR value_ex$2[rsp]
  001c1	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1800 :             
; 1801 :             value = &(value_ex->value);

  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR value_ex$2[rsp]
  001ca	48 89 44 24 48	 mov	 QWORD PTR value$3[rsp], rax

; 1802 :         } else {

  001cf	eb 24		 jmp	 SHORT $LN11@json_parse
$LN10@json_parse:

; 1803 :             value = (struct json_value_s *)state->dom;

  001d1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  001d6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001da	48 89 44 24 48	 mov	 QWORD PTR value$3[rsp], rax

; 1804 :             state->dom += sizeof(struct json_value_s);

  001df	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  001e4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001e8	48 83 c0 10	 add	 rax, 16
  001ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  001f1	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN11@json_parse:

; 1805 :         }
; 1806 :         
; 1807 :         element->value = value;

  001f5	48 8b 44 24 28	 mov	 rax, QWORD PTR element$1[rsp]
  001fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$3[rsp]
  001ff	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1808 :         
; 1809 :         json_parse_value(state, /* is_global_object = */ 0, value);

  00202	4c 8b 44 24 48	 mov	 r8, QWORD PTR value$3[rsp]
  00207	33 d2		 xor	 edx, edx
  00209	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0020e	e8 00 00 00 00	 call	 ?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z ; json_parse_value

; 1810 :         
; 1811 :         /* successfully parsed an array element! */
; 1812 :         elements++;

  00213	48 8b 44 24 38	 mov	 rax, QWORD PTR elements$[rsp]
  00218	48 ff c0	 inc	 rax
  0021b	48 89 44 24 38	 mov	 QWORD PTR elements$[rsp], rax

; 1813 :         allow_comma = 1;

  00220	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 1
$LN2@json_parse:

; 1814 :     } while (state->offset < size);

  00228	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0022d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  00232	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00236	0f 82 2f fe ff
	ff		 jb	 $LN4@json_parse
$LN3@json_parse:

; 1815 :     
; 1816 :     /* end the linked list. */
; 1817 :     if (previous) {

  0023c	48 83 7c 24 30
	00		 cmp	 QWORD PTR previous$[rsp], 0
  00242	74 0d		 je	 SHORT $LN12@json_parse

; 1818 :         previous->next = json_null;

  00244	48 8b 44 24 30	 mov	 rax, QWORD PTR previous$[rsp]
  00249	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN12@json_parse:

; 1819 :     }
; 1820 :     
; 1821 :     if (0 == elements) {

  00251	48 83 7c 24 38
	00		 cmp	 QWORD PTR elements$[rsp], 0
  00257	75 0c		 jne	 SHORT $LN13@json_parse

; 1822 :         array->start = json_null;

  00259	48 8b 44 24 78	 mov	 rax, QWORD PTR array$[rsp]
  0025e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN13@json_parse:

; 1823 :     }
; 1824 :     
; 1825 :     array->length = elements;

  00265	48 8b 44 24 78	 mov	 rax, QWORD PTR array$[rsp]
  0026a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR elements$[rsp]
  0026f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1826 : }

  00273	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00277	c3		 ret	 0
?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z ENDP ; json_parse_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z
_TEXT	SEGMENT
allow_comma$ = 32
element$1 = 40
previous$ = 48
elements$ = 56
string_ex$2 = 64
string$3 = 72
value_ex$4 = 80
value$5 = 88
src$ = 96
flags_bitset$ = 104
size$ = 112
state$ = 144
is_global_object$ = 152
object$ = 160
?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z PROC ; json_parse_object, COMDAT

; 1604 :                        struct json_object_s *object) {

$LN23:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1605 :     const size_t flags_bitset = state->flags_bitset;

  00015	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0001d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00021	48 89 44 24 68	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 1606 :     const size_t size = state->size;

  00026	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0002e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00032	48 89 44 24 70	 mov	 QWORD PTR size$[rsp], rax

; 1607 :     const char *const src = state->src;

  00037	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 89 44 24 60	 mov	 QWORD PTR src$[rsp], rax

; 1608 :     size_t elements = 0;

  00047	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR elements$[rsp], 0

; 1609 :     int allow_comma = 0;

  00050	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 1610 :     struct json_object_element_s *previous = json_null;

  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR previous$[rsp], 0

; 1611 :     
; 1612 :     if (is_global_object) {

  00061	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00069	74 25		 je	 SHORT $LN4@json_parse

; 1613 :         /* if we skipped some whitespace, and then found an opening '{' of an. */
; 1614 :         /* object, we actually have a normal JSON object at the root of the DOM...
; 1615 :          */
; 1616 :         if ('{' == src[state->offset]) {

  0006b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00073	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00077	48 8b 4c 24 60	 mov	 rcx, QWORD PTR src$[rsp]
  0007c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00080	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  00083	75 0b		 jne	 SHORT $LN5@json_parse

; 1617 :             /* . and we don't actually have a global object after all! */
; 1618 :             is_global_object = 0;

  00085	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR is_global_object$[rsp], 0
$LN5@json_parse:
$LN4@json_parse:

; 1619 :         }
; 1620 :     }
; 1621 :     
; 1622 :     if (!is_global_object) {

  00090	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00098	75 1b		 jne	 SHORT $LN6@json_parse

; 1623 :         /* skip leading '{'. */
; 1624 :         state->offset++;

  0009a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000a2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a6	48 ff c0	 inc	 rax
  000a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000b1	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN6@json_parse:

; 1625 :     }
; 1626 :     
; 1627 :     (void)json_skip_all_skippables(state);

  000b5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000bd	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1628 :     
; 1629 :     /* reset elements. */
; 1630 :     elements = 0;

  000c2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR elements$[rsp], 0
$LN22@json_parse:
$LN2@json_parse:

; 1631 :     
; 1632 :     while (state->offset < size) {

  000cb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR size$[rsp]
  000d8	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000dc	0f 83 4c 03 00
	00		 jae	 $LN3@json_parse

; 1633 :         struct json_object_element_s *element = json_null;

  000e2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR element$1[rsp], 0

; 1634 :         struct json_string_s *string = json_null;

  000eb	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR string$3[rsp], 0

; 1635 :         struct json_value_s *value = json_null;

  000f4	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR value$5[rsp], 0

; 1636 :         
; 1637 :         if (!is_global_object) {

  000fd	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00105	75 49		 jne	 SHORT $LN7@json_parse

; 1638 :             (void)json_skip_all_skippables(state);

  00107	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0010f	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1639 :             
; 1640 :             if ('}' == src[state->offset]) {

  00114	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0011c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00120	48 8b 4c 24 60	 mov	 rcx, QWORD PTR src$[rsp]
  00125	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00129	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  0012c	75 20		 jne	 SHORT $LN9@json_parse

; 1641 :                 /* skip trailing '}'. */
; 1642 :                 state->offset++;

  0012e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00136	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013a	48 ff c0	 inc	 rax
  0013d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00145	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1643 :                 
; 1644 :                 /* finished the object! */
; 1645 :                 break;

  00149	e9 e0 02 00 00	 jmp	 $LN3@json_parse
$LN9@json_parse:

; 1646 :             }
; 1647 :         } else {

  0014e	eb 16		 jmp	 SHORT $LN8@json_parse
$LN7@json_parse:

; 1648 :             if (json_skip_all_skippables(state)) {

  00150	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00158	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  0015d	85 c0		 test	 eax, eax
  0015f	74 05		 je	 SHORT $LN10@json_parse

; 1649 :                 /* global object ends when the file ends! */
; 1650 :                 break;

  00161	e9 c8 02 00 00	 jmp	 $LN3@json_parse
$LN10@json_parse:
$LN8@json_parse:

; 1651 :             }
; 1652 :         }
; 1653 :         
; 1654 :         /* if we parsed at least one element previously, grok for a comma. */
; 1655 :         if (allow_comma) {

  00166	83 7c 24 20 00	 cmp	 DWORD PTR allow_comma$[rsp], 0
  0016b	74 42		 je	 SHORT $LN11@json_parse

; 1656 :             if (',' == src[state->offset]) {

  0016d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00175	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00179	48 8b 4c 24 60	 mov	 rcx, QWORD PTR src$[rsp]
  0017e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00182	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00185	75 28		 jne	 SHORT $LN12@json_parse

; 1657 :                 /* skip comma. */
; 1658 :                 state->offset++;

  00187	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0018f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00193	48 ff c0	 inc	 rax
  00196	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0019e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1659 :                 allow_comma = 0;

  001a2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 1660 :                 continue;

  001aa	e9 1c ff ff ff	 jmp	 $LN2@json_parse
$LN12@json_parse:
$LN11@json_parse:

; 1661 :             }
; 1662 :         }
; 1663 :         
; 1664 :         element = (struct json_object_element_s *)state->dom;

  001af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001b7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001bb	48 89 44 24 28	 mov	 QWORD PTR element$1[rsp], rax

; 1665 :         
; 1666 :         state->dom += sizeof(struct json_object_element_s);

  001c0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001c8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001cc	48 83 c0 18	 add	 rax, 24
  001d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  001d8	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1667 :         
; 1668 :         if (json_null == previous) {

  001dc	48 83 7c 24 30
	00		 cmp	 QWORD PTR previous$[rsp], 0
  001e2	75 12		 jne	 SHORT $LN13@json_parse

; 1669 :             /* this is our first element, so record it in our object. */
; 1670 :             object->start = element;

  001e4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR object$[rsp]
  001ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR element$1[rsp]
  001f1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1671 :         } else {

  001f4	eb 0e		 jmp	 SHORT $LN14@json_parse
$LN13@json_parse:

; 1672 :             previous->next = element;

  001f6	48 8b 44 24 30	 mov	 rax, QWORD PTR previous$[rsp]
  001fb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR element$1[rsp]
  00200	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN14@json_parse:

; 1673 :         }
; 1674 :         
; 1675 :         previous = element;

  00204	48 8b 44 24 28	 mov	 rax, QWORD PTR element$1[rsp]
  00209	48 89 44 24 30	 mov	 QWORD PTR previous$[rsp], rax

; 1676 :         
; 1677 :         if (json_parse_flags_allow_location_information & flags_bitset) {

  0020e	48 8b 44 24 68	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00213	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00219	48 85 c0	 test	 rax, rax
  0021c	0f 84 87 00 00
	00		 je	 $LN15@json_parse

; 1678 :             struct json_string_ex_s *string_ex =

  00222	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0022a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0022e	48 89 44 24 40	 mov	 QWORD PTR string_ex$2[rsp], rax

; 1679 :             (struct json_string_ex_s *)state->dom;
; 1680 :             state->dom += sizeof(struct json_string_ex_s);

  00233	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0023b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0023f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00243	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0024b	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1681 :             
; 1682 :             string_ex->offset = state->offset;

  0024f	48 8b 44 24 40	 mov	 rax, QWORD PTR string_ex$2[rsp]
  00254	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0025c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00260	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1683 :             string_ex->line_no = state->line_no;

  00264	48 8b 44 24 40	 mov	 rax, QWORD PTR string_ex$2[rsp]
  00269	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00271	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00275	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1684 :             string_ex->row_no = state->offset - state->line_offset;

  00279	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00281	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00289	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0028d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00291	48 2b c1	 sub	 rax, rcx
  00294	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string_ex$2[rsp]
  00299	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1685 :             
; 1686 :             string = &(string_ex->string);

  0029d	48 8b 44 24 40	 mov	 rax, QWORD PTR string_ex$2[rsp]
  002a2	48 89 44 24 48	 mov	 QWORD PTR string$3[rsp], rax

; 1687 :         } else {

  002a7	eb 2d		 jmp	 SHORT $LN16@json_parse
$LN15@json_parse:

; 1688 :             string = (struct json_string_s *)state->dom;

  002a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002b1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002b5	48 89 44 24 48	 mov	 QWORD PTR string$3[rsp], rax

; 1689 :             state->dom += sizeof(struct json_string_s);

  002ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002c2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002c6	48 83 c0 10	 add	 rax, 16
  002ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  002d2	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN16@json_parse:

; 1690 :         }
; 1691 :         
; 1692 :         element->name = string;

  002d6	48 8b 44 24 28	 mov	 rax, QWORD PTR element$1[rsp]
  002db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR string$3[rsp]
  002e0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1693 :         
; 1694 :         (void)json_parse_key(state, string);

  002e3	48 8b 54 24 48	 mov	 rdx, QWORD PTR string$3[rsp]
  002e8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  002f0	e8 00 00 00 00	 call	 ?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ; json_parse_key

; 1695 :         
; 1696 :         (void)json_skip_all_skippables(state);

  002f5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  002fd	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1697 :         
; 1698 :         /* skip colon or equals. */
; 1699 :         state->offset++;

  00302	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0030a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0030e	48 ff c0	 inc	 rax
  00311	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00319	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1700 :         
; 1701 :         (void)json_skip_all_skippables(state);

  0031d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00325	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1702 :         
; 1703 :         if (json_parse_flags_allow_location_information & flags_bitset) {

  0032a	48 8b 44 24 68	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0032f	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00335	48 85 c0	 test	 rax, rax
  00338	0f 84 87 00 00
	00		 je	 $LN17@json_parse

; 1704 :             struct json_value_ex_s *value_ex = (struct json_value_ex_s *)state->dom;

  0033e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00346	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0034a	48 89 44 24 50	 mov	 QWORD PTR value_ex$4[rsp], rax

; 1705 :             state->dom += sizeof(struct json_value_ex_s);

  0034f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00357	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0035b	48 83 c0 28	 add	 rax, 40			; 00000028H
  0035f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00367	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1706 :             
; 1707 :             value_ex->offset = state->offset;

  0036b	48 8b 44 24 50	 mov	 rax, QWORD PTR value_ex$4[rsp]
  00370	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00378	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0037c	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1708 :             value_ex->line_no = state->line_no;

  00380	48 8b 44 24 50	 mov	 rax, QWORD PTR value_ex$4[rsp]
  00385	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0038d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00391	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1709 :             value_ex->row_no = state->offset - state->line_offset;

  00395	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0039d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  003a5	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  003a9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  003ad	48 2b c1	 sub	 rax, rcx
  003b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value_ex$4[rsp]
  003b5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1710 :             
; 1711 :             value = &(value_ex->value);

  003b9	48 8b 44 24 50	 mov	 rax, QWORD PTR value_ex$4[rsp]
  003be	48 89 44 24 58	 mov	 QWORD PTR value$5[rsp], rax

; 1712 :         } else {

  003c3	eb 2d		 jmp	 SHORT $LN18@json_parse
$LN17@json_parse:

; 1713 :             value = (struct json_value_s *)state->dom;

  003c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003cd	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003d1	48 89 44 24 58	 mov	 QWORD PTR value$5[rsp], rax

; 1714 :             state->dom += sizeof(struct json_value_s);

  003d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003de	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003e2	48 83 c0 10	 add	 rax, 16
  003e6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  003ee	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN18@json_parse:

; 1715 :         }
; 1716 :         
; 1717 :         element->value = value;

  003f2	48 8b 44 24 28	 mov	 rax, QWORD PTR element$1[rsp]
  003f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR value$5[rsp]
  003fc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1718 :         
; 1719 :         json_parse_value(state, /* is_global_object = */ 0, value);

  00400	4c 8b 44 24 58	 mov	 r8, QWORD PTR value$5[rsp]
  00405	33 d2		 xor	 edx, edx
  00407	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0040f	e8 00 00 00 00	 call	 ?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z ; json_parse_value

; 1720 :         
; 1721 :         /* successfully parsed a name/value pair! */
; 1722 :         elements++;

  00414	48 8b 44 24 38	 mov	 rax, QWORD PTR elements$[rsp]
  00419	48 ff c0	 inc	 rax
  0041c	48 89 44 24 38	 mov	 QWORD PTR elements$[rsp], rax

; 1723 :         allow_comma = 1;

  00421	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 1

; 1724 :     }

  00429	e9 9d fc ff ff	 jmp	 $LN22@json_parse
$LN3@json_parse:

; 1725 :     
; 1726 :     /* if we had at least one element, end the linked list. */
; 1727 :     if (previous) {

  0042e	48 83 7c 24 30
	00		 cmp	 QWORD PTR previous$[rsp], 0
  00434	74 0d		 je	 SHORT $LN19@json_parse

; 1728 :         previous->next = json_null;

  00436	48 8b 44 24 30	 mov	 rax, QWORD PTR previous$[rsp]
  0043b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN19@json_parse:

; 1729 :     }
; 1730 :     
; 1731 :     if (0 == elements) {

  00443	48 83 7c 24 38
	00		 cmp	 QWORD PTR elements$[rsp], 0
  00449	75 0f		 jne	 SHORT $LN20@json_parse

; 1732 :         object->start = json_null;

  0044b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR object$[rsp]
  00453	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN20@json_parse:

; 1733 :     }
; 1734 :     
; 1735 :     object->length = elements;

  0045a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR object$[rsp]
  00462	48 8b 4c 24 38	 mov	 rcx, QWORD PTR elements$[rsp]
  00467	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1736 : }

  0046b	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00472	c3		 ret	 0
?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z ENDP ; json_parse_object
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z
_TEXT	SEGMENT
size$1 = 32
offset$2 = 40
src$3 = 48
data$4 = 56
state$ = 80
string$ = 88
?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z PROC ; json_parse_key, COMDAT

; 1563 :                     struct json_string_s *string) {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1564 :     if (json_parse_flags_allow_unquoted_keys & state->flags_bitset) {

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 83 e0 02	 and	 rax, 2
  0001b	48 85 c0	 test	 rax, rax
  0001e	0f 84 39 01 00
	00		 je	 $LN4@json_parse

; 1565 :         const char *const src = state->src;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 89 44 24 30	 mov	 QWORD PTR src$3[rsp], rax

; 1566 :         char *const data = state->data;

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00036	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0003a	48 89 44 24 38	 mov	 QWORD PTR data$4[rsp], rax

; 1567 :         size_t offset = state->offset;

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00044	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00048	48 89 44 24 28	 mov	 QWORD PTR offset$2[rsp], rax

; 1568 :         
; 1569 :         /* if we are allowing unquoted keys, check for quoted anyway... */
; 1570 :         if (('"' == src[offset]) || ('\'' == src[offset])) {

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$2[rsp]
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$3[rsp]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00060	83 f8 22	 cmp	 eax, 34			; 00000022H
  00063	74 18		 je	 SHORT $LN8@json_parse
  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$2[rsp]
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$3[rsp]
  0006f	48 03 c8	 add	 rcx, rax
  00072	48 8b c1	 mov	 rax, rcx
  00075	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00078	83 f8 27	 cmp	 eax, 39			; 00000027H
  0007b	75 14		 jne	 SHORT $LN6@json_parse
$LN8@json_parse:

; 1571 :             /* ... if we got a quote, just parse the key as a string as normal. */
; 1572 :             json_parse_string(state, string);

  0007d	48 8b 54 24 58	 mov	 rdx, QWORD PTR string$[rsp]
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00087	e8 00 00 00 00	 call	 ?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ; json_parse_string

; 1573 :         } else {

  0008c	e9 ca 00 00 00	 jmp	 $LN7@json_parse
$LN6@json_parse:

; 1574 :             size_t size = 0;

  00091	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR size$1[rsp], 0

; 1575 :             
; 1576 :             string->string = state->data;

  0009a	48 8b 44 24 58	 mov	 rax, QWORD PTR string$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000a4	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000a8	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@json_parse:

; 1577 :             
; 1578 :             while (is_valid_unquoted_key_char(src[offset])) {

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$2[rsp]
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$3[rsp]
  000b5	48 03 c8	 add	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000be	e8 00 00 00 00	 call	 ?is_valid_unquoted_key_char@@YAHD@Z ; is_valid_unquoted_key_char
  000c3	85 c0		 test	 eax, eax
  000c5	74 41		 je	 SHORT $LN3@json_parse

; 1579 :                 data[size++] = src[offset++];

  000c7	48 8b 44 24 20	 mov	 rax, QWORD PTR size$1[rsp]
  000cc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$4[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$2[rsp]
  000dc	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$3[rsp]
  000e1	48 03 d1	 add	 rdx, rcx
  000e4	48 8b ca	 mov	 rcx, rdx
  000e7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000ea	88 08		 mov	 BYTE PTR [rax], cl
  000ec	48 8b 44 24 20	 mov	 rax, QWORD PTR size$1[rsp]
  000f1	48 ff c0	 inc	 rax
  000f4	48 89 44 24 20	 mov	 QWORD PTR size$1[rsp], rax
  000f9	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$2[rsp]
  000fe	48 ff c0	 inc	 rax
  00101	48 89 44 24 28	 mov	 QWORD PTR offset$2[rsp], rax

; 1580 :             }

  00106	eb a3		 jmp	 SHORT $LN2@json_parse
$LN3@json_parse:

; 1581 :             
; 1582 :             /* add null terminator to string. */
; 1583 :             data[size] = '\0';

  00108	48 8b 44 24 20	 mov	 rax, QWORD PTR size$1[rsp]
  0010d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$4[rsp]
  00112	48 03 c8	 add	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1584 :             
; 1585 :             /* record the size of the string. */
; 1586 :             string->string_size = size++;

  0011b	48 8b 44 24 58	 mov	 rax, QWORD PTR string$[rsp]
  00120	48 8b 4c 24 20	 mov	 rcx, QWORD PTR size$1[rsp]
  00125	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00129	48 8b 44 24 20	 mov	 rax, QWORD PTR size$1[rsp]
  0012e	48 ff c0	 inc	 rax
  00131	48 89 44 24 20	 mov	 QWORD PTR size$1[rsp], rax

; 1587 :             
; 1588 :             /* move data along. */
; 1589 :             state->data += size;

  00136	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0013b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0013f	48 03 44 24 20	 add	 rax, QWORD PTR size$1[rsp]
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00149	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1590 :             
; 1591 :             /* update offset. */
; 1592 :             state->offset = offset;

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$2[rsp]
  00157	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN7@json_parse:

; 1593 :         }
; 1594 :     } else {

  0015b	eb 0f		 jmp	 SHORT $LN5@json_parse
$LN4@json_parse:

; 1595 :         /* we are only allowed to have quoted keys, so just parse a string! */
; 1596 :         json_parse_string(state, string);

  0015d	48 8b 54 24 58	 mov	 rdx, QWORD PTR string$[rsp]
  00162	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00167	e8 00 00 00 00	 call	 ?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ; json_parse_string
$LN5@json_parse:

; 1597 :     }
; 1598 : }

  0016c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00170	c3		 ret	 0
?json_parse_key@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ENDP ; json_parse_key
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z
_TEXT	SEGMENT
bytes_written$ = 32
codepoint$ = 40
data$ = 48
tv70 = 56
offset$ = 64
quote_to_use$ = 72
tv89 = 76
high_surrogate$ = 80
src$ = 88
tv88 = 96
surrogate_offset$1 = 100
state$ = 128
string$ = 136
?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z PROC ; json_parse_string, COMDAT

; 1431 :                        struct json_string_s *string) {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1432 :     size_t offset = state->offset;

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00016	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001a	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax

; 1433 :     size_t bytes_written = 0;

  0001f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR bytes_written$[rsp], 0

; 1434 :     const char *const src = state->src;

  00028	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 58	 mov	 QWORD PTR src$[rsp], rax

; 1435 :     const char quote_to_use = '\'' == src[offset] ? '\'' : '"';

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0003d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  00042	48 03 c8	 add	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004b	83 f8 27	 cmp	 eax, 39			; 00000027H
  0004e	75 07		 jne	 SHORT $LN31@json_parse
  00050	c6 44 24 38 27	 mov	 BYTE PTR tv70[rsp], 39	; 00000027H
  00055	eb 05		 jmp	 SHORT $LN32@json_parse
$LN31@json_parse:
  00057	c6 44 24 38 22	 mov	 BYTE PTR tv70[rsp], 34	; 00000022H
$LN32@json_parse:
  0005c	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv70[rsp]
  00061	88 44 24 48	 mov	 BYTE PTR quote_to_use$[rsp], al

; 1436 :     char *data = state->data;

  00065	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0006d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00071	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 1437 :     unsigned long high_surrogate = 0;

  00076	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR high_surrogate$[rsp], 0

; 1438 :     unsigned long codepoint;
; 1439 :     
; 1440 :     string->string = data;

  0007e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0008b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1441 :     
; 1442 :     /* skip leading '"' or '\''. */
; 1443 :     offset++;

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00093	48 ff c0	 inc	 rax
  00096	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
$LN33@json_parse:
$LN2@json_parse:

; 1444 :     
; 1445 :     while (quote_to_use != src[offset]) {

  0009b	0f be 44 24 48	 movsx	 eax, BYTE PTR quote_to_use$[rsp]
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  000a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR src$[rsp]
  000aa	48 03 d1	 add	 rdx, rcx
  000ad	48 8b ca	 mov	 rcx, rdx
  000b0	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000b3	3b c1		 cmp	 eax, ecx
  000b5	0f 84 fe 04 00
	00		 je	 $LN3@json_parse

; 1446 :         if ('\\' == src[offset]) {

  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  000c5	48 03 c8	 add	 rcx, rax
  000c8	48 8b c1	 mov	 rax, rcx
  000cb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ce	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  000d1	0f 85 9e 04 00
	00		 jne	 $LN6@json_parse

; 1447 :             /* skip the reverse solidus. */
; 1448 :             offset++;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  000dc	48 ff c0	 inc	 rax
  000df	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax

; 1449 :             
; 1450 :             switch (src[offset++]) {

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  000e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  000ee	48 03 c8	 add	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f7	89 44 24 60	 mov	 DWORD PTR tv88[rsp], eax
  000fb	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00100	48 ff c0	 inc	 rax
  00103	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
  00108	8b 44 24 60	 mov	 eax, DWORD PTR tv88[rsp]
  0010c	89 44 24 4c	 mov	 DWORD PTR tv89[rsp], eax
  00110	8b 44 24 4c	 mov	 eax, DWORD PTR tv89[rsp]
  00114	83 e8 0a	 sub	 eax, 10
  00117	89 44 24 4c	 mov	 DWORD PTR tv89[rsp], eax
  0011b	83 7c 24 4c 6b	 cmp	 DWORD PTR tv89[rsp], 107 ; 0000006bH
  00120	77 20		 ja	 SHORT $LN8@json_parse
  00122	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv89[rsp]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0012e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN34@json_parse[rcx+rax]
  00136	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN35@json_parse[rcx+rax*4]
  0013d	48 03 c1	 add	 rax, rcx
  00140	ff e0		 jmp	 rax
$LN8@json_parse:

; 1451 :                 default:
; 1452 :                 return; /* we cannot ever reach here. */

  00142	e9 de 04 00 00	 jmp	 $LN1@json_parse
$LN9@json_parse:

; 1453 :                 case 'u': {
; 1454 :                     codepoint = 0;

  00147	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR codepoint$[rsp], 0

; 1455 :                     if (!json_hexadecimal_value(&src[offset], 4, &codepoint)) {

  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00154	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  00159	48 03 c8	 add	 rcx, rax
  0015c	48 8b c1	 mov	 rax, rcx
  0015f	4c 8d 44 24 28	 lea	 r8, QWORD PTR codepoint$[rsp]
  00164	ba 04 00 00 00	 mov	 edx, 4
  00169	48 8b c8	 mov	 rcx, rax
  0016c	e8 00 00 00 00	 call	 ?json_hexadecimal_value@@YAHPEBDKPEAK@Z ; json_hexadecimal_value
  00171	85 c0		 test	 eax, eax
  00173	75 05		 jne	 SHORT $LN10@json_parse

; 1456 :                         return; /* this shouldn't happen as the value was already validated.

  00175	e9 ab 04 00 00	 jmp	 $LN1@json_parse
$LN10@json_parse:

; 1457 :                                  */
; 1458 :                     }
; 1459 :                     
; 1460 :                     offset += 4;

  0017a	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0017f	48 83 c0 04	 add	 rax, 4
  00183	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax

; 1461 :                     
; 1462 :                     if (codepoint <= 0x7fu) {

  00188	83 7c 24 28 7f	 cmp	 DWORD PTR codepoint$[rsp], 127 ; 0000007fH
  0018d	77 29		 ja	 SHORT $LN11@json_parse

; 1463 :                         data[bytes_written++] = (char)codepoint; /* 0xxxxxxx. */

  0018f	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00194	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00199	48 03 c8	 add	 rcx, rax
  0019c	48 8b c1	 mov	 rax, rcx
  0019f	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR codepoint$[rsp]
  001a4	88 08		 mov	 BYTE PTR [rax], cl
  001a6	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  001ab	48 ff c0	 inc	 rax
  001ae	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax
  001b3	e9 07 02 00 00	 jmp	 $LN12@json_parse
$LN11@json_parse:

; 1464 :                     } else if (codepoint <= 0x7ffu) {

  001b8	81 7c 24 28 ff
	07 00 00	 cmp	 DWORD PTR codepoint$[rsp], 2047 ; 000007ffH
  001c0	77 5a		 ja	 SHORT $LN13@json_parse

; 1465 :                         data[bytes_written++] =

  001c2	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  001c6	c1 e8 06	 shr	 eax, 6
  001c9	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  001ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  001d3	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	88 01		 mov	 BYTE PTR [rcx], al
  001e0	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  001e5	48 ff c0	 inc	 rax
  001e8	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1466 :                         (char)(0xc0u | (codepoint >> 6)); /* 110xxxxx. */
; 1467 :                         data[bytes_written++] =

  001ed	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  001f1	83 e0 3f	 and	 eax, 63			; 0000003fH
  001f4	0f ba e8 07	 bts	 eax, 7
  001f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  001fd	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  00202	48 03 d1	 add	 rdx, rcx
  00205	48 8b ca	 mov	 rcx, rdx
  00208	88 01		 mov	 BYTE PTR [rcx], al
  0020a	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0020f	48 ff c0	 inc	 rax
  00212	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax
  00217	e9 a3 01 00 00	 jmp	 $LN14@json_parse
$LN13@json_parse:

; 1468 :                         (char)(0x80u | (codepoint & 0x3fu)); /* 10xxxxxx. */
; 1469 :                     } else if (codepoint >= 0xd800 &&

  0021c	81 7c 24 28 00
	d8 00 00	 cmp	 DWORD PTR codepoint$[rsp], 55296 ; 0000d800H
  00224	72 1c		 jb	 SHORT $LN15@json_parse
  00226	81 7c 24 28 ff
	db 00 00	 cmp	 DWORD PTR codepoint$[rsp], 56319 ; 0000dbffH
  0022e	77 12		 ja	 SHORT $LN15@json_parse

; 1470 :                                codepoint <= 0xdbff) { /* high surrogate. */
; 1471 :                         high_surrogate = codepoint;

  00230	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  00234	89 44 24 50	 mov	 DWORD PTR high_surrogate$[rsp], eax

; 1472 :                         continue; /* we need the low half to form a complete codepoint. */

  00238	e9 5e fe ff ff	 jmp	 $LN2@json_parse
  0023d	e9 7d 01 00 00	 jmp	 $LN16@json_parse
$LN15@json_parse:

; 1473 :                     } else if (codepoint >= 0xdc00 &&

  00242	81 7c 24 28 00
	dc 00 00	 cmp	 DWORD PTR codepoint$[rsp], 56320 ; 0000dc00H
  0024a	0f 82 ed 00 00
	00		 jb	 $LN17@json_parse
  00250	81 7c 24 28 ff
	df 00 00	 cmp	 DWORD PTR codepoint$[rsp], 57343 ; 0000dfffH
  00258	0f 87 df 00 00
	00		 ja	 $LN17@json_parse

; 1474 :                                codepoint <= 0xdfff) { /* low surrogate. */
; 1475 :                         /* combine with the previously read half to obtain the complete
; 1476 :                          * codepoint. */
; 1477 :                         const unsigned long surrogate_offset =

  0025e	c7 44 24 64 00
	24 a0 fc	 mov	 DWORD PTR surrogate_offset$1[rsp], -56613888 ; fca02400H

; 1478 :                             0x10000u - (0xD800u << 10) - 0xDC00u;
; 1479 :                         codepoint = (high_surrogate << 10) + codepoint + surrogate_offset;

  00266	8b 44 24 50	 mov	 eax, DWORD PTR high_surrogate$[rsp]
  0026a	c1 e0 0a	 shl	 eax, 10
  0026d	b9 00 24 a0 fc	 mov	 ecx, -56613888		; fffffffffca02400H
  00272	48 8d 04 08	 lea	 rax, QWORD PTR [rax+rcx]
  00276	8b 4c 24 28	 mov	 ecx, DWORD PTR codepoint$[rsp]
  0027a	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  0027d	89 44 24 28	 mov	 DWORD PTR codepoint$[rsp], eax

; 1480 :                         high_surrogate = 0;

  00281	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR high_surrogate$[rsp], 0

; 1481 :                         data[bytes_written++] =

  00289	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  0028d	c1 e8 12	 shr	 eax, 18
  00290	0d f0 00 00 00	 or	 eax, 240		; 000000f0H
  00295	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  0029a	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  0029f	48 03 d1	 add	 rdx, rcx
  002a2	48 8b ca	 mov	 rcx, rdx
  002a5	88 01		 mov	 BYTE PTR [rcx], al
  002a7	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  002ac	48 ff c0	 inc	 rax
  002af	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1482 :                         (char)(0xF0u | (codepoint >> 18)); /* 11110xxx. */
; 1483 :                         data[bytes_written++] =

  002b4	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  002b8	c1 e8 0c	 shr	 eax, 12
  002bb	83 e0 3f	 and	 eax, 63			; 0000003fH
  002be	0f ba e8 07	 bts	 eax, 7
  002c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  002c7	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  002cc	48 03 d1	 add	 rdx, rcx
  002cf	48 8b ca	 mov	 rcx, rdx
  002d2	88 01		 mov	 BYTE PTR [rcx], al
  002d4	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  002d9	48 ff c0	 inc	 rax
  002dc	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1484 :                         (char)(0x80u | ((codepoint >> 12) & 0x3fu)); /* 10xxxxxx. */
; 1485 :                         data[bytes_written++] =

  002e1	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  002e5	c1 e8 06	 shr	 eax, 6
  002e8	83 e0 3f	 and	 eax, 63			; 0000003fH
  002eb	0f ba e8 07	 bts	 eax, 7
  002ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  002f4	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  002f9	48 03 d1	 add	 rdx, rcx
  002fc	48 8b ca	 mov	 rcx, rdx
  002ff	88 01		 mov	 BYTE PTR [rcx], al
  00301	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00306	48 ff c0	 inc	 rax
  00309	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1486 :                         (char)(0x80u | ((codepoint >> 6) & 0x3fu)); /* 10xxxxxx. */
; 1487 :                         data[bytes_written++] =

  0030e	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  00312	83 e0 3f	 and	 eax, 63			; 0000003fH
  00315	0f ba e8 07	 bts	 eax, 7
  00319	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  0031e	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  00323	48 03 d1	 add	 rdx, rcx
  00326	48 8b ca	 mov	 rcx, rdx
  00329	88 01		 mov	 BYTE PTR [rcx], al
  0032b	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00330	48 ff c0	 inc	 rax
  00333	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1488 :                         (char)(0x80u | (codepoint & 0x3fu)); /* 10xxxxxx. */
; 1489 :                     } else {

  00338	e9 82 00 00 00	 jmp	 $LN18@json_parse
$LN17@json_parse:

; 1490 :                         /* we assume the value was validated and thus is within the valid
; 1491 :                          * range. */
; 1492 :                         data[bytes_written++] =

  0033d	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  00341	c1 e8 0c	 shr	 eax, 12
  00344	0d e0 00 00 00	 or	 eax, 224		; 000000e0H
  00349	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  0034e	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  00353	48 03 d1	 add	 rdx, rcx
  00356	48 8b ca	 mov	 rcx, rdx
  00359	88 01		 mov	 BYTE PTR [rcx], al
  0035b	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00360	48 ff c0	 inc	 rax
  00363	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1493 :                         (char)(0xe0u | (codepoint >> 12)); /* 1110xxxx. */
; 1494 :                         data[bytes_written++] =

  00368	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  0036c	c1 e8 06	 shr	 eax, 6
  0036f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00372	0f ba e8 07	 bts	 eax, 7
  00376	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  0037b	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  00380	48 03 d1	 add	 rdx, rcx
  00383	48 8b ca	 mov	 rcx, rdx
  00386	88 01		 mov	 BYTE PTR [rcx], al
  00388	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0038d	48 ff c0	 inc	 rax
  00390	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1495 :                         (char)(0x80u | ((codepoint >> 6) & 0x3fu)); /* 10xxxxxx. */
; 1496 :                         data[bytes_written++] =

  00395	8b 44 24 28	 mov	 eax, DWORD PTR codepoint$[rsp]
  00399	83 e0 3f	 and	 eax, 63			; 0000003fH
  0039c	0f ba e8 07	 bts	 eax, 7
  003a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  003a5	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  003aa	48 03 d1	 add	 rdx, rcx
  003ad	48 8b ca	 mov	 rcx, rdx
  003b0	88 01		 mov	 BYTE PTR [rcx], al
  003b2	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003b7	48 ff c0	 inc	 rax
  003ba	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax
$LN18@json_parse:
$LN16@json_parse:
$LN14@json_parse:
$LN12@json_parse:

; 1497 :                         (char)(0x80u | (codepoint & 0x3fu)); /* 10xxxxxx. */
; 1498 :                     }
; 1499 :                 } break;

  003bf	e9 af 01 00 00	 jmp	 $LN4@json_parse
$LN19@json_parse:

; 1500 :                 case '"':
; 1501 :                 data[bytes_written++] = '"';

  003c4	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  003ce	48 03 c8	 add	 rcx, rax
  003d1	48 8b c1	 mov	 rax, rcx
  003d4	c6 00 22	 mov	 BYTE PTR [rax], 34	; 00000022H
  003d7	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003dc	48 ff c0	 inc	 rax
  003df	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1502 :                 break;

  003e4	e9 8a 01 00 00	 jmp	 $LN4@json_parse
$LN20@json_parse:

; 1503 :                 case '\\':
; 1504 :                 data[bytes_written++] = '\\';

  003e9	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  003ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  003f3	48 03 c8	 add	 rcx, rax
  003f6	48 8b c1	 mov	 rax, rcx
  003f9	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  003fc	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00401	48 ff c0	 inc	 rax
  00404	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1505 :                 break;

  00409	e9 65 01 00 00	 jmp	 $LN4@json_parse
$LN21@json_parse:

; 1506 :                 case '/':
; 1507 :                 data[bytes_written++] = '/';

  0040e	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00413	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00418	48 03 c8	 add	 rcx, rax
  0041b	48 8b c1	 mov	 rax, rcx
  0041e	c6 00 2f	 mov	 BYTE PTR [rax], 47	; 0000002fH
  00421	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00426	48 ff c0	 inc	 rax
  00429	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1508 :                 break;

  0042e	e9 40 01 00 00	 jmp	 $LN4@json_parse
$LN22@json_parse:

; 1509 :                 case 'b':
; 1510 :                 data[bytes_written++] = '\b';

  00433	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00438	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0043d	48 03 c8	 add	 rcx, rax
  00440	48 8b c1	 mov	 rax, rcx
  00443	c6 00 08	 mov	 BYTE PTR [rax], 8
  00446	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0044b	48 ff c0	 inc	 rax
  0044e	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1511 :                 break;

  00453	e9 1b 01 00 00	 jmp	 $LN4@json_parse
$LN23@json_parse:

; 1512 :                 case 'f':
; 1513 :                 data[bytes_written++] = '\f';

  00458	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0045d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00462	48 03 c8	 add	 rcx, rax
  00465	48 8b c1	 mov	 rax, rcx
  00468	c6 00 0c	 mov	 BYTE PTR [rax], 12
  0046b	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00470	48 ff c0	 inc	 rax
  00473	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1514 :                 break;

  00478	e9 f6 00 00 00	 jmp	 $LN4@json_parse
$LN24@json_parse:

; 1515 :                 case 'n':
; 1516 :                 data[bytes_written++] = '\n';

  0047d	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00482	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00487	48 03 c8	 add	 rcx, rax
  0048a	48 8b c1	 mov	 rax, rcx
  0048d	c6 00 0a	 mov	 BYTE PTR [rax], 10
  00490	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00495	48 ff c0	 inc	 rax
  00498	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1517 :                 break;

  0049d	e9 d1 00 00 00	 jmp	 $LN4@json_parse
$LN25@json_parse:

; 1518 :                 case 'r':
; 1519 :                 data[bytes_written++] = '\r';

  004a2	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  004a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  004ac	48 03 c8	 add	 rcx, rax
  004af	48 8b c1	 mov	 rax, rcx
  004b2	c6 00 0d	 mov	 BYTE PTR [rax], 13
  004b5	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  004ba	48 ff c0	 inc	 rax
  004bd	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1520 :                 break;

  004c2	e9 ac 00 00 00	 jmp	 $LN4@json_parse
$LN26@json_parse:

; 1521 :                 case 't':
; 1522 :                 data[bytes_written++] = '\t';

  004c7	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  004cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  004d1	48 03 c8	 add	 rcx, rax
  004d4	48 8b c1	 mov	 rax, rcx
  004d7	c6 00 09	 mov	 BYTE PTR [rax], 9
  004da	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  004df	48 ff c0	 inc	 rax
  004e2	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1523 :                 break;

  004e7	e9 87 00 00 00	 jmp	 $LN4@json_parse
$LN27@json_parse:

; 1524 :                 case '\r':
; 1525 :                 data[bytes_written++] = '\r';

  004ec	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  004f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  004f6	48 03 c8	 add	 rcx, rax
  004f9	48 8b c1	 mov	 rax, rcx
  004fc	c6 00 0d	 mov	 BYTE PTR [rax], 13
  004ff	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00504	48 ff c0	 inc	 rax
  00507	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1526 :                 
; 1527 :                 /* check if we have a "\r\n" sequence. */
; 1528 :                 if ('\n' == src[offset]) {

  0050c	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00511	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  00516	48 03 c8	 add	 rcx, rax
  00519	48 8b c1	 mov	 rax, rcx
  0051c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0051f	83 f8 0a	 cmp	 eax, 10
  00522	75 2d		 jne	 SHORT $LN28@json_parse

; 1529 :                     data[bytes_written++] = '\n';

  00524	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00529	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0052e	48 03 c8	 add	 rcx, rax
  00531	48 8b c1	 mov	 rax, rcx
  00534	c6 00 0a	 mov	 BYTE PTR [rax], 10
  00537	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0053c	48 ff c0	 inc	 rax
  0053f	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1530 :                     offset++;

  00544	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  00549	48 ff c0	 inc	 rax
  0054c	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
$LN28@json_parse:

; 1531 :                 }
; 1532 :                 
; 1533 :                 break;

  00551	eb 20		 jmp	 SHORT $LN4@json_parse
$LN29@json_parse:

; 1534 :                 case '\n':
; 1535 :                 data[bytes_written++] = '\n';

  00553	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  00558	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0055d	48 03 c8	 add	 rcx, rax
  00560	48 8b c1	 mov	 rax, rcx
  00563	c6 00 0a	 mov	 BYTE PTR [rax], 10
  00566	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0056b	48 ff c0	 inc	 rax
  0056e	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax
$LN4@json_parse:

; 1536 :                 break;
; 1537 :             }
; 1538 :         } else {

  00573	eb 3f		 jmp	 SHORT $LN7@json_parse
$LN6@json_parse:

; 1539 :             /* copy the character. */
; 1540 :             data[bytes_written++] = src[offset++];

  00575	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0057a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0057f	48 03 c8	 add	 rcx, rax
  00582	48 8b c1	 mov	 rax, rcx
  00585	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  0058a	48 8b 54 24 58	 mov	 rdx, QWORD PTR src$[rsp]
  0058f	48 03 d1	 add	 rdx, rcx
  00592	48 8b ca	 mov	 rcx, rdx
  00595	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00598	88 08		 mov	 BYTE PTR [rax], cl
  0059a	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  0059f	48 ff c0	 inc	 rax
  005a2	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax
  005a7	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  005ac	48 ff c0	 inc	 rax
  005af	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax
$LN7@json_parse:

; 1541 :         }
; 1542 :     }

  005b4	e9 e2 fa ff ff	 jmp	 $LN33@json_parse
$LN3@json_parse:

; 1543 :     
; 1544 :     /* skip trailing '"' or '\''. */
; 1545 :     offset++;

  005b9	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  005be	48 ff c0	 inc	 rax
  005c1	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax

; 1546 :     
; 1547 :     /* record the size of the string. */
; 1548 :     string->string_size = bytes_written;

  005c6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  005ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bytes_written$[rsp]
  005d3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1549 :     
; 1550 :     /* add null terminator to string. */
; 1551 :     data[bytes_written++] = '\0';

  005d7	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  005dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  005e1	48 03 c8	 add	 rcx, rax
  005e4	48 8b c1	 mov	 rax, rcx
  005e7	c6 00 00	 mov	 BYTE PTR [rax], 0
  005ea	48 8b 44 24 20	 mov	 rax, QWORD PTR bytes_written$[rsp]
  005ef	48 ff c0	 inc	 rax
  005f2	48 89 44 24 20	 mov	 QWORD PTR bytes_written$[rsp], rax

; 1552 :     
; 1553 :     /* move data along. */
; 1554 :     state->data += bytes_written;

  005f7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005ff	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00603	48 03 44 24 20	 add	 rax, QWORD PTR bytes_written$[rsp]
  00608	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00610	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1555 :     
; 1556 :     /* update offset. */
; 1557 :     state->offset = offset;

  00614	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0061c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  00621	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN1@json_parse:

; 1558 : }

  00625	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00629	c3		 ret	 0
  0062a	66 90		 npad	 2
$LN35@json_parse:
  0062c	00 00 00 00	 DD	 $LN29@json_parse
  00630	00 00 00 00	 DD	 $LN27@json_parse
  00634	00 00 00 00	 DD	 $LN19@json_parse
  00638	00 00 00 00	 DD	 $LN21@json_parse
  0063c	00 00 00 00	 DD	 $LN20@json_parse
  00640	00 00 00 00	 DD	 $LN22@json_parse
  00644	00 00 00 00	 DD	 $LN23@json_parse
  00648	00 00 00 00	 DD	 $LN24@json_parse
  0064c	00 00 00 00	 DD	 $LN25@json_parse
  00650	00 00 00 00	 DD	 $LN26@json_parse
  00654	00 00 00 00	 DD	 $LN9@json_parse
  00658	00 00 00 00	 DD	 $LN8@json_parse
$LN34@json_parse:
  0065c	00		 DB	 0
  0065d	0b		 DB	 11
  0065e	0b		 DB	 11
  0065f	01		 DB	 1
  00660	0b		 DB	 11
  00661	0b		 DB	 11
  00662	0b		 DB	 11
  00663	0b		 DB	 11
  00664	0b		 DB	 11
  00665	0b		 DB	 11
  00666	0b		 DB	 11
  00667	0b		 DB	 11
  00668	0b		 DB	 11
  00669	0b		 DB	 11
  0066a	0b		 DB	 11
  0066b	0b		 DB	 11
  0066c	0b		 DB	 11
  0066d	0b		 DB	 11
  0066e	0b		 DB	 11
  0066f	0b		 DB	 11
  00670	0b		 DB	 11
  00671	0b		 DB	 11
  00672	0b		 DB	 11
  00673	0b		 DB	 11
  00674	02		 DB	 2
  00675	0b		 DB	 11
  00676	0b		 DB	 11
  00677	0b		 DB	 11
  00678	0b		 DB	 11
  00679	0b		 DB	 11
  0067a	0b		 DB	 11
  0067b	0b		 DB	 11
  0067c	0b		 DB	 11
  0067d	0b		 DB	 11
  0067e	0b		 DB	 11
  0067f	0b		 DB	 11
  00680	0b		 DB	 11
  00681	03		 DB	 3
  00682	0b		 DB	 11
  00683	0b		 DB	 11
  00684	0b		 DB	 11
  00685	0b		 DB	 11
  00686	0b		 DB	 11
  00687	0b		 DB	 11
  00688	0b		 DB	 11
  00689	0b		 DB	 11
  0068a	0b		 DB	 11
  0068b	0b		 DB	 11
  0068c	0b		 DB	 11
  0068d	0b		 DB	 11
  0068e	0b		 DB	 11
  0068f	0b		 DB	 11
  00690	0b		 DB	 11
  00691	0b		 DB	 11
  00692	0b		 DB	 11
  00693	0b		 DB	 11
  00694	0b		 DB	 11
  00695	0b		 DB	 11
  00696	0b		 DB	 11
  00697	0b		 DB	 11
  00698	0b		 DB	 11
  00699	0b		 DB	 11
  0069a	0b		 DB	 11
  0069b	0b		 DB	 11
  0069c	0b		 DB	 11
  0069d	0b		 DB	 11
  0069e	0b		 DB	 11
  0069f	0b		 DB	 11
  006a0	0b		 DB	 11
  006a1	0b		 DB	 11
  006a2	0b		 DB	 11
  006a3	0b		 DB	 11
  006a4	0b		 DB	 11
  006a5	0b		 DB	 11
  006a6	0b		 DB	 11
  006a7	0b		 DB	 11
  006a8	0b		 DB	 11
  006a9	0b		 DB	 11
  006aa	0b		 DB	 11
  006ab	0b		 DB	 11
  006ac	0b		 DB	 11
  006ad	0b		 DB	 11
  006ae	04		 DB	 4
  006af	0b		 DB	 11
  006b0	0b		 DB	 11
  006b1	0b		 DB	 11
  006b2	0b		 DB	 11
  006b3	0b		 DB	 11
  006b4	05		 DB	 5
  006b5	0b		 DB	 11
  006b6	0b		 DB	 11
  006b7	0b		 DB	 11
  006b8	06		 DB	 6
  006b9	0b		 DB	 11
  006ba	0b		 DB	 11
  006bb	0b		 DB	 11
  006bc	0b		 DB	 11
  006bd	0b		 DB	 11
  006be	0b		 DB	 11
  006bf	0b		 DB	 11
  006c0	07		 DB	 7
  006c1	0b		 DB	 11
  006c2	0b		 DB	 11
  006c3	0b		 DB	 11
  006c4	08		 DB	 8
  006c5	0b		 DB	 11
  006c6	09		 DB	 9
  006c7	0a		 DB	 10
?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ENDP ; json_parse_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z
_TEXT	SEGMENT
tv83 = 32
offset$ = 40
src$ = 48
size$ = 56
flags_bitset$ = 64
state$ = 96
is_global_object$ = 104
value$ = 112
?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z PROC ; json_parse_value, COMDAT

; 1925 :                       struct json_value_s *value) {

$LN36:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1926 :     const size_t flags_bitset = state->flags_bitset;

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00017	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001b	48 89 44 24 40	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 1927 :     const char *const src = state->src;

  00020	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 89 44 24 30	 mov	 QWORD PTR src$[rsp], rax

; 1928 :     const size_t size = state->size;

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00032	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00036	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 1929 :     size_t offset;
; 1930 :     
; 1931 :     (void)json_skip_all_skippables(state);

  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00040	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 1932 :     
; 1933 :     /* cache offset now. */
; 1934 :     offset = state->offset;

  00045	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0004a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004e	48 89 44 24 28	 mov	 QWORD PTR offset$[rsp], rax

; 1935 :     
; 1936 :     if (is_global_object) {

  00053	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00058	74 50		 je	 SHORT $LN4@json_parse

; 1937 :         value->type = json_type_object;

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  0005f	48 c7 40 08 02
	00 00 00	 mov	 QWORD PTR [rax+8], 2

; 1938 :         value->payload = state->dom;

  00067	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00071	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00075	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1939 :         state->dom += sizeof(struct json_object_s);

  00078	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0007d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00081	48 83 c0 10	 add	 rax, 16
  00085	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0008a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1940 :         json_parse_object(state, /* is_global_object = */ 1,

  0008e	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00093	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00096	ba 01 00 00 00	 mov	 edx, 1
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000a0	e8 00 00 00 00	 call	 ?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z ; json_parse_object

; 1941 :                           (struct json_object_s *)value->payload);
; 1942 :     } else {

  000a5	e9 9f 05 00 00	 jmp	 $LN5@json_parse
$LN4@json_parse:

; 1943 :         switch (src[offset]) {

  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  000b4	48 03 c8	 add	 rcx, rax
  000b7	48 8b c1	 mov	 rax, rcx
  000ba	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000bd	89 44 24 20	 mov	 DWORD PTR tv83[rsp], eax
  000c1	8b 44 24 20	 mov	 eax, DWORD PTR tv83[rsp]
  000c5	83 e8 22	 sub	 eax, 34			; 00000022H
  000c8	89 44 24 20	 mov	 DWORD PTR tv83[rsp], eax
  000cc	83 7c 24 20 59	 cmp	 DWORD PTR tv83[rsp], 89	; 00000059H
  000d1	0f 87 4e 01 00
	00		 ja	 $LN23@json_parse
  000d7	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv83[rsp]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000e3	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN34@json_parse[rcx+rax]
  000eb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN35@json_parse[rcx+rax*4]
  000f2	48 03 c1	 add	 rax, rcx
  000f5	ff e0		 jmp	 rax
$LN6@json_parse:
$LN7@json_parse:

; 1944 :             case '"':
; 1945 :             case '\'':
; 1946 :             value->type = json_type_string;

  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  000fc	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1947 :             value->payload = state->dom;

  00104	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0010e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00112	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1948 :             state->dom += sizeof(struct json_string_s);

  00115	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0011a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0011e	48 83 c0 10	 add	 rax, 16
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00127	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1949 :             json_parse_string(state, (struct json_string_s *)value->payload);

  0012b	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00130	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00133	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00138	e8 00 00 00 00	 call	 ?json_parse_string@@YAXPEAUjson_parse_state_s@@PEAUjson_string_s@@@Z ; json_parse_string

; 1950 :             break;

  0013d	e9 07 05 00 00	 jmp	 $LN2@json_parse
$LN8@json_parse:

; 1951 :             case '{':
; 1952 :             value->type = json_type_object;

  00142	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00147	48 c7 40 08 02
	00 00 00	 mov	 QWORD PTR [rax+8], 2

; 1953 :             value->payload = state->dom;

  0014f	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00154	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00159	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0015d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1954 :             state->dom += sizeof(struct json_object_s);

  00160	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00165	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00169	48 83 c0 10	 add	 rax, 16
  0016d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00172	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1955 :             json_parse_object(state, /* is_global_object = */ 0,

  00176	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  0017b	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0017e	33 d2		 xor	 edx, edx
  00180	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00185	e8 00 00 00 00	 call	 ?json_parse_object@@YAXPEAUjson_parse_state_s@@HPEAUjson_object_s@@@Z ; json_parse_object

; 1956 :                               (struct json_object_s *)value->payload);
; 1957 :             break;

  0018a	e9 ba 04 00 00	 jmp	 $LN2@json_parse
$LN9@json_parse:

; 1958 :             case '[':
; 1959 :             value->type = json_type_array;

  0018f	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00194	48 c7 40 08 03
	00 00 00	 mov	 QWORD PTR [rax+8], 3

; 1960 :             value->payload = state->dom;

  0019c	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  001a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001a6	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001aa	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1961 :             state->dom += sizeof(struct json_array_s);

  001ad	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001b2	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001b6	48 83 c0 10	 add	 rax, 16
  001ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001bf	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1962 :             json_parse_array(state, (struct json_array_s *)value->payload);

  001c3	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  001c8	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001d0	e8 00 00 00 00	 call	 ?json_parse_array@@YAXPEAUjson_parse_state_s@@PEAUjson_array_s@@@Z ; json_parse_array

; 1963 :             break;

  001d5	e9 6f 04 00 00	 jmp	 $LN2@json_parse
$LN10@json_parse:
$LN11@json_parse:
$LN12@json_parse:
$LN13@json_parse:
$LN14@json_parse:
$LN15@json_parse:
$LN16@json_parse:
$LN17@json_parse:
$LN18@json_parse:
$LN19@json_parse:
$LN20@json_parse:
$LN21@json_parse:
$LN22@json_parse:

; 1964 :             case '-':
; 1965 :             case '+':
; 1966 :             case '0':
; 1967 :             case '1':
; 1968 :             case '2':
; 1969 :             case '3':
; 1970 :             case '4':
; 1971 :             case '5':
; 1972 :             case '6':
; 1973 :             case '7':
; 1974 :             case '8':
; 1975 :             case '9':
; 1976 :             case '.':
; 1977 :             value->type = json_type_number;

  001da	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  001df	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1

; 1978 :             value->payload = state->dom;

  001e7	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  001ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001f1	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001f5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1979 :             state->dom += sizeof(struct json_number_s);

  001f8	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001fd	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00201	48 83 c0 10	 add	 rax, 16
  00205	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0020a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1980 :             json_parse_number(state, (struct json_number_s *)value->payload);

  0020e	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00213	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00216	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0021b	e8 00 00 00 00	 call	 ?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z ; json_parse_number

; 1981 :             break;

  00220	e9 24 04 00 00	 jmp	 $LN2@json_parse
$LN23@json_parse:

; 1982 :             default:
; 1983 :             if ((offset + 4) <= size && 't' == src[offset + 0] &&
; 1984 :                 'r' == src[offset + 1] && 'u' == src[offset + 2] &&

  00225	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0022a	48 83 c0 04	 add	 rax, 4
  0022e	48 3b 44 24 38	 cmp	 rax, QWORD PTR size$[rsp]
  00233	0f 87 97 00 00
	00		 ja	 $LN24@json_parse
  00239	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0023e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00243	48 03 c8	 add	 rcx, rax
  00246	48 8b c1	 mov	 rax, rcx
  00249	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0024c	83 f8 74	 cmp	 eax, 116		; 00000074H
  0024f	75 7f		 jne	 SHORT $LN24@json_parse
  00251	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00256	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0025b	48 03 c8	 add	 rcx, rax
  0025e	48 8b c1	 mov	 rax, rcx
  00261	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00265	83 f8 72	 cmp	 eax, 114		; 00000072H
  00268	75 66		 jne	 SHORT $LN24@json_parse
  0026a	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0026f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00274	48 03 c8	 add	 rcx, rax
  00277	48 8b c1	 mov	 rax, rcx
  0027a	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  0027e	83 f8 75	 cmp	 eax, 117		; 00000075H
  00281	75 4d		 jne	 SHORT $LN24@json_parse
  00283	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00288	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0028d	48 03 c8	 add	 rcx, rax
  00290	48 8b c1	 mov	 rax, rcx
  00293	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  00297	83 f8 65	 cmp	 eax, 101		; 00000065H
  0029a	75 34		 jne	 SHORT $LN24@json_parse

; 1985 :                 'e' == src[offset + 3]) {
; 1986 :                 value->type = json_type_true;

  0029c	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  002a1	48 c7 40 08 04
	00 00 00	 mov	 QWORD PTR [rax+8], 4

; 1987 :                 value->payload = json_null;

  002a9	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  002ae	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1988 :                 state->offset += 4;

  002b5	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  002ba	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002be	48 83 c0 04	 add	 rax, 4
  002c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  002c7	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1989 :             } else if ((offset + 5) <= size && 'f' == src[offset + 0] &&

  002cb	e9 79 03 00 00	 jmp	 $LN25@json_parse
$LN24@json_parse:

; 1990 :                        'a' == src[offset + 1] && 'l' == src[offset + 2] &&
; 1991 :                        's' == src[offset + 3] && 'e' == src[offset + 4]) {

  002d0	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  002d5	48 83 c0 05	 add	 rax, 5
  002d9	48 3b 44 24 38	 cmp	 rax, QWORD PTR size$[rsp]
  002de	0f 87 b4 00 00
	00		 ja	 $LN26@json_parse
  002e4	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  002e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  002ee	48 03 c8	 add	 rcx, rax
  002f1	48 8b c1	 mov	 rax, rcx
  002f4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002f7	83 f8 66	 cmp	 eax, 102		; 00000066H
  002fa	0f 85 98 00 00
	00		 jne	 $LN26@json_parse
  00300	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00305	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0030a	48 03 c8	 add	 rcx, rax
  0030d	48 8b c1	 mov	 rax, rcx
  00310	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00314	83 f8 61	 cmp	 eax, 97			; 00000061H
  00317	75 7f		 jne	 SHORT $LN26@json_parse
  00319	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0031e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00323	48 03 c8	 add	 rcx, rax
  00326	48 8b c1	 mov	 rax, rcx
  00329	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  0032d	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  00330	75 66		 jne	 SHORT $LN26@json_parse
  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00337	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0033c	48 03 c8	 add	 rcx, rax
  0033f	48 8b c1	 mov	 rax, rcx
  00342	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  00346	83 f8 73	 cmp	 eax, 115		; 00000073H
  00349	75 4d		 jne	 SHORT $LN26@json_parse
  0034b	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00350	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00355	48 03 c8	 add	 rcx, rax
  00358	48 8b c1	 mov	 rax, rcx
  0035b	0f be 40 04	 movsx	 eax, BYTE PTR [rax+4]
  0035f	83 f8 65	 cmp	 eax, 101		; 00000065H
  00362	75 34		 jne	 SHORT $LN26@json_parse

; 1992 :                 value->type = json_type_false;

  00364	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00369	48 c7 40 08 05
	00 00 00	 mov	 QWORD PTR [rax+8], 5

; 1993 :                 value->payload = json_null;

  00371	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00376	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1994 :                 state->offset += 5;

  0037d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00382	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00386	48 83 c0 05	 add	 rax, 5
  0038a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0038f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1995 :             } else if ((offset + 4) <= size && 'n' == src[offset + 0] &&

  00393	e9 b1 02 00 00	 jmp	 $LN27@json_parse
$LN26@json_parse:

; 1996 :                        'u' == src[offset + 1] && 'l' == src[offset + 2] &&

  00398	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0039d	48 83 c0 04	 add	 rax, 4
  003a1	48 3b 44 24 38	 cmp	 rax, QWORD PTR size$[rsp]
  003a6	0f 87 97 00 00
	00		 ja	 $LN28@json_parse
  003ac	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  003b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  003b6	48 03 c8	 add	 rcx, rax
  003b9	48 8b c1	 mov	 rax, rcx
  003bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003bf	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  003c2	75 7f		 jne	 SHORT $LN28@json_parse
  003c4	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  003c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  003ce	48 03 c8	 add	 rcx, rax
  003d1	48 8b c1	 mov	 rax, rcx
  003d4	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  003d8	83 f8 75	 cmp	 eax, 117		; 00000075H
  003db	75 66		 jne	 SHORT $LN28@json_parse
  003dd	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  003e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  003e7	48 03 c8	 add	 rcx, rax
  003ea	48 8b c1	 mov	 rax, rcx
  003ed	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  003f1	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  003f4	75 4d		 jne	 SHORT $LN28@json_parse
  003f6	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  003fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00400	48 03 c8	 add	 rcx, rax
  00403	48 8b c1	 mov	 rax, rcx
  00406	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  0040a	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  0040d	75 34		 jne	 SHORT $LN28@json_parse

; 1997 :                        'l' == src[offset + 3]) {
; 1998 :                 value->type = json_type_null;

  0040f	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00414	48 c7 40 08 06
	00 00 00	 mov	 QWORD PTR [rax+8], 6

; 1999 :                 value->payload = json_null;

  0041c	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00421	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2000 :                 state->offset += 4;

  00428	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0042d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00431	48 83 c0 04	 add	 rax, 4
  00435	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0043a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2001 :             } else if ((json_parse_flags_allow_inf_and_nan & flags_bitset) &&

  0043e	e9 06 02 00 00	 jmp	 $LN29@json_parse
$LN28@json_parse:

; 2002 :                        (offset + 3) <= size && 'N' == src[offset + 0] &&
; 2003 :                        'a' == src[offset + 1] && 'N' == src[offset + 2]) {

  00443	48 8b 44 24 40	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00448	48 25 00 10 00
	00		 and	 rax, 4096		; 00001000H
  0044e	48 85 c0	 test	 rax, rax
  00451	0f 84 a9 00 00
	00		 je	 $LN30@json_parse
  00457	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0045c	48 83 c0 03	 add	 rax, 3
  00460	48 3b 44 24 38	 cmp	 rax, QWORD PTR size$[rsp]
  00465	0f 87 95 00 00
	00		 ja	 $LN30@json_parse
  0046b	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00470	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00475	48 03 c8	 add	 rcx, rax
  00478	48 8b c1	 mov	 rax, rcx
  0047b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0047e	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00481	75 7d		 jne	 SHORT $LN30@json_parse
  00483	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00488	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0048d	48 03 c8	 add	 rcx, rax
  00490	48 8b c1	 mov	 rax, rcx
  00493	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00497	83 f8 61	 cmp	 eax, 97			; 00000061H
  0049a	75 64		 jne	 SHORT $LN30@json_parse
  0049c	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  004a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  004a6	48 03 c8	 add	 rcx, rax
  004a9	48 8b c1	 mov	 rax, rcx
  004ac	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  004b0	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  004b3	75 4b		 jne	 SHORT $LN30@json_parse

; 2004 :                 value->type = json_type_number;

  004b5	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  004ba	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1

; 2005 :                 value->payload = state->dom;

  004c2	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  004c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  004cc	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  004d0	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2006 :                 state->dom += sizeof(struct json_number_s);

  004d3	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  004d8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  004dc	48 83 c0 10	 add	 rax, 16
  004e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  004e5	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 2007 :                 json_parse_number(state, (struct json_number_s *)value->payload);

  004e9	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  004ee	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  004f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  004f6	e8 00 00 00 00	 call	 ?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z ; json_parse_number

; 2008 :             } else if ((json_parse_flags_allow_inf_and_nan & flags_bitset) &&

  004fb	e9 49 01 00 00	 jmp	 $LN31@json_parse
$LN30@json_parse:

; 2009 :                        (offset + 8) <= size && 'I' == src[offset + 0] &&
; 2010 :                        'n' == src[offset + 1] && 'f' == src[offset + 2] &&
; 2011 :                        'i' == src[offset + 3] && 'n' == src[offset + 4] &&
; 2012 :                        'i' == src[offset + 5] && 't' == src[offset + 6] &&

  00500	48 8b 44 24 40	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00505	48 25 00 10 00
	00		 and	 rax, 4096		; 00001000H
  0050b	48 85 c0	 test	 rax, rax
  0050e	0f 84 35 01 00
	00		 je	 $LN32@json_parse
  00514	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00519	48 83 c0 08	 add	 rax, 8
  0051d	48 3b 44 24 38	 cmp	 rax, QWORD PTR size$[rsp]
  00522	0f 87 21 01 00
	00		 ja	 $LN32@json_parse
  00528	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0052d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00532	48 03 c8	 add	 rcx, rax
  00535	48 8b c1	 mov	 rax, rcx
  00538	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0053b	83 f8 49	 cmp	 eax, 73			; 00000049H
  0053e	0f 85 05 01 00
	00		 jne	 $LN32@json_parse
  00544	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00549	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0054e	48 03 c8	 add	 rcx, rax
  00551	48 8b c1	 mov	 rax, rcx
  00554	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00558	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0055b	0f 85 e8 00 00
	00		 jne	 $LN32@json_parse
  00561	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00566	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0056b	48 03 c8	 add	 rcx, rax
  0056e	48 8b c1	 mov	 rax, rcx
  00571	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00575	83 f8 66	 cmp	 eax, 102		; 00000066H
  00578	0f 85 cb 00 00
	00		 jne	 $LN32@json_parse
  0057e	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00583	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00588	48 03 c8	 add	 rcx, rax
  0058b	48 8b c1	 mov	 rax, rcx
  0058e	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  00592	83 f8 69	 cmp	 eax, 105		; 00000069H
  00595	0f 85 ae 00 00
	00		 jne	 $LN32@json_parse
  0059b	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  005a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  005a5	48 03 c8	 add	 rcx, rax
  005a8	48 8b c1	 mov	 rax, rcx
  005ab	0f be 40 04	 movsx	 eax, BYTE PTR [rax+4]
  005af	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  005b2	0f 85 91 00 00
	00		 jne	 $LN32@json_parse
  005b8	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  005bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  005c2	48 03 c8	 add	 rcx, rax
  005c5	48 8b c1	 mov	 rax, rcx
  005c8	0f be 40 05	 movsx	 eax, BYTE PTR [rax+5]
  005cc	83 f8 69	 cmp	 eax, 105		; 00000069H
  005cf	75 78		 jne	 SHORT $LN32@json_parse
  005d1	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  005d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  005db	48 03 c8	 add	 rcx, rax
  005de	48 8b c1	 mov	 rax, rcx
  005e1	0f be 40 06	 movsx	 eax, BYTE PTR [rax+6]
  005e5	83 f8 74	 cmp	 eax, 116		; 00000074H
  005e8	75 5f		 jne	 SHORT $LN32@json_parse
  005ea	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  005ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  005f4	48 03 c8	 add	 rcx, rax
  005f7	48 8b c1	 mov	 rax, rcx
  005fa	0f be 40 07	 movsx	 eax, BYTE PTR [rax+7]
  005fe	83 f8 79	 cmp	 eax, 121		; 00000079H
  00601	75 46		 jne	 SHORT $LN32@json_parse

; 2013 :                        'y' == src[offset + 7]) {
; 2014 :                 value->type = json_type_number;

  00603	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00608	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1

; 2015 :                 value->payload = state->dom;

  00610	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  00615	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0061a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0061e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2016 :                 state->dom += sizeof(struct json_number_s);

  00621	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00626	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0062a	48 83 c0 10	 add	 rax, 16
  0062e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00633	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 2017 :                 json_parse_number(state, (struct json_number_s *)value->payload);

  00637	48 8b 44 24 70	 mov	 rax, QWORD PTR value$[rsp]
  0063c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0063f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00644	e8 00 00 00 00	 call	 ?json_parse_number@@YAXPEAUjson_parse_state_s@@PEAUjson_number_s@@@Z ; json_parse_number
$LN32@json_parse:
$LN31@json_parse:
$LN29@json_parse:
$LN27@json_parse:
$LN25@json_parse:
$LN2@json_parse:
$LN5@json_parse:

; 2018 :             }
; 2019 :             break;
; 2020 :         }
; 2021 :     }
; 2022 : }

  00649	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0064d	c3		 ret	 0
  0064e	66 90		 npad	 2
$LN35@json_parse:
  00650	00 00 00 00	 DD	 $LN6@json_parse
  00654	00 00 00 00	 DD	 $LN7@json_parse
  00658	00 00 00 00	 DD	 $LN11@json_parse
  0065c	00 00 00 00	 DD	 $LN10@json_parse
  00660	00 00 00 00	 DD	 $LN22@json_parse
  00664	00 00 00 00	 DD	 $LN12@json_parse
  00668	00 00 00 00	 DD	 $LN13@json_parse
  0066c	00 00 00 00	 DD	 $LN14@json_parse
  00670	00 00 00 00	 DD	 $LN15@json_parse
  00674	00 00 00 00	 DD	 $LN16@json_parse
  00678	00 00 00 00	 DD	 $LN17@json_parse
  0067c	00 00 00 00	 DD	 $LN18@json_parse
  00680	00 00 00 00	 DD	 $LN19@json_parse
  00684	00 00 00 00	 DD	 $LN20@json_parse
  00688	00 00 00 00	 DD	 $LN21@json_parse
  0068c	00 00 00 00	 DD	 $LN9@json_parse
  00690	00 00 00 00	 DD	 $LN8@json_parse
  00694	00 00 00 00	 DD	 $LN23@json_parse
$LN34@json_parse:
  00698	00		 DB	 0
  00699	11		 DB	 17
  0069a	11		 DB	 17
  0069b	11		 DB	 17
  0069c	11		 DB	 17
  0069d	01		 DB	 1
  0069e	11		 DB	 17
  0069f	11		 DB	 17
  006a0	11		 DB	 17
  006a1	02		 DB	 2
  006a2	11		 DB	 17
  006a3	03		 DB	 3
  006a4	04		 DB	 4
  006a5	11		 DB	 17
  006a6	05		 DB	 5
  006a7	06		 DB	 6
  006a8	07		 DB	 7
  006a9	08		 DB	 8
  006aa	09		 DB	 9
  006ab	0a		 DB	 10
  006ac	0b		 DB	 11
  006ad	0c		 DB	 12
  006ae	0d		 DB	 13
  006af	0e		 DB	 14
  006b0	11		 DB	 17
  006b1	11		 DB	 17
  006b2	11		 DB	 17
  006b3	11		 DB	 17
  006b4	11		 DB	 17
  006b5	11		 DB	 17
  006b6	11		 DB	 17
  006b7	11		 DB	 17
  006b8	11		 DB	 17
  006b9	11		 DB	 17
  006ba	11		 DB	 17
  006bb	11		 DB	 17
  006bc	11		 DB	 17
  006bd	11		 DB	 17
  006be	11		 DB	 17
  006bf	11		 DB	 17
  006c0	11		 DB	 17
  006c1	11		 DB	 17
  006c2	11		 DB	 17
  006c3	11		 DB	 17
  006c4	11		 DB	 17
  006c5	11		 DB	 17
  006c6	11		 DB	 17
  006c7	11		 DB	 17
  006c8	11		 DB	 17
  006c9	11		 DB	 17
  006ca	11		 DB	 17
  006cb	11		 DB	 17
  006cc	11		 DB	 17
  006cd	11		 DB	 17
  006ce	11		 DB	 17
  006cf	11		 DB	 17
  006d0	11		 DB	 17
  006d1	0f		 DB	 15
  006d2	11		 DB	 17
  006d3	11		 DB	 17
  006d4	11		 DB	 17
  006d5	11		 DB	 17
  006d6	11		 DB	 17
  006d7	11		 DB	 17
  006d8	11		 DB	 17
  006d9	11		 DB	 17
  006da	11		 DB	 17
  006db	11		 DB	 17
  006dc	11		 DB	 17
  006dd	11		 DB	 17
  006de	11		 DB	 17
  006df	11		 DB	 17
  006e0	11		 DB	 17
  006e1	11		 DB	 17
  006e2	11		 DB	 17
  006e3	11		 DB	 17
  006e4	11		 DB	 17
  006e5	11		 DB	 17
  006e6	11		 DB	 17
  006e7	11		 DB	 17
  006e8	11		 DB	 17
  006e9	11		 DB	 17
  006ea	11		 DB	 17
  006eb	11		 DB	 17
  006ec	11		 DB	 17
  006ed	11		 DB	 17
  006ee	11		 DB	 17
  006ef	11		 DB	 17
  006f0	11		 DB	 17
  006f1	10		 DB	 16
?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z ENDP ; json_parse_value
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z
_TEXT	SEGMENT
offset$ = 0
src$ = 8
c$1 = 16
size$ = 24
inf_or_nan$2 = 32
tv335 = 36
had_leading_digits$ = 40
flags_bitset$ = 48
found$3 = 56
found$4 = 60
found_sign$5 = 64
i$6 = 72
i$7 = 80
nan$8 = 88
inf_strlen$9 = 96
nan_strlen$10 = 104
inf$11 = 112
__$ArrayPad$ = 128
state$ = 176
?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z PROC ; json_get_number_size, COMDAT

; 1111 : int json_get_number_size(struct json_parse_state_s *state) {

$LN70:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1112 :     const size_t flags_bitset = state->flags_bitset;

  00020	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00028	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002c	48 89 44 24 30	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 1113 :     size_t offset = state->offset;

  00031	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00039	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003d	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1114 :     const size_t size = state->size;

  00041	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 89 44 24 18	 mov	 QWORD PTR size$[rsp], rax

; 1115 :     int had_leading_digits = 0;

  00052	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR had_leading_digits$[rsp], 0

; 1116 :     const char *const src = state->src;

  0005a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 89 44 24 08	 mov	 QWORD PTR src$[rsp], rax

; 1117 :     
; 1118 :     state->dom_size += sizeof(struct json_number_s);

  0006a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00072	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00076	48 83 c0 10	 add	 rax, 16
  0007a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00082	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1119 :     
; 1120 :     if ((json_parse_flags_allow_hexadecimal_numbers & flags_bitset) &&
; 1121 :         (offset + 1 < size) && ('0' == src[offset]) &&

  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0008b	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00091	48 85 c0	 test	 rax, rax
  00094	0f 84 1b 01 00
	00		 je	 $LN19@json_get_n
  0009a	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0009e	48 ff c0	 inc	 rax
  000a1	48 3b 44 24 18	 cmp	 rax, QWORD PTR size$[rsp]
  000a6	0f 83 09 01 00
	00		 jae	 $LN19@json_get_n
  000ac	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000b0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000b5	48 03 c8	 add	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000be	83 f8 30	 cmp	 eax, 48			; 00000030H
  000c1	0f 85 ee 00 00
	00		 jne	 $LN19@json_get_n
  000c7	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000cb	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000d0	48 03 c8	 add	 rcx, rax
  000d3	48 8b c1	 mov	 rax, rcx
  000d6	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000da	83 f8 78	 cmp	 eax, 120		; 00000078H
  000dd	74 1c		 je	 SHORT $LN21@json_get_n
  000df	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000e3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000f2	83 f8 58	 cmp	 eax, 88			; 00000058H
  000f5	0f 85 ba 00 00
	00		 jne	 $LN19@json_get_n
$LN21@json_get_n:

; 1122 :         (('x' == src[offset + 1]) || ('X' == src[offset + 1]))) {
; 1123 :         /* skip the leading 0x that identifies a hexadecimal number. */
; 1124 :         offset += 2;

  000fb	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  000ff	48 83 c0 02	 add	 rax, 2
  00103	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax
$LN2@json_get_n:

; 1125 :         
; 1126 :         /* consume hexadecimal digits. */
; 1127 :         while ((offset < size) && (('0' <= src[offset] && src[offset] <= '9') ||

  00107	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  0010c	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  00110	0f 83 9a 00 00
	00		 jae	 $LN3@json_get_n
  00116	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0011a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0011f	48 03 c8	 add	 rcx, rax
  00122	48 8b c1	 mov	 rax, rcx
  00125	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00128	83 f8 30	 cmp	 eax, 48			; 00000030H
  0012b	7c 17		 jl	 SHORT $LN23@json_get_n
  0012d	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00131	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00136	48 03 c8	 add	 rcx, rax
  00139	48 8b c1	 mov	 rax, rcx
  0013c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0013f	83 f8 39	 cmp	 eax, 57			; 00000039H
  00142	7e 5c		 jle	 SHORT $LN22@json_get_n
$LN23@json_get_n:
  00144	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00148	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0014d	48 03 c8	 add	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00156	83 f8 61	 cmp	 eax, 97			; 00000061H
  00159	7c 17		 jl	 SHORT $LN24@json_get_n
  0015b	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0015f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00164	48 03 c8	 add	 rcx, rax
  00167	48 8b c1	 mov	 rax, rcx
  0016a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0016d	83 f8 66	 cmp	 eax, 102		; 00000066H
  00170	7e 2e		 jle	 SHORT $LN22@json_get_n
$LN24@json_get_n:
  00172	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00176	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0017b	48 03 c8	 add	 rcx, rax
  0017e	48 8b c1	 mov	 rax, rcx
  00181	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00184	83 f8 41	 cmp	 eax, 65			; 00000041H
  00187	7c 27		 jl	 SHORT $LN3@json_get_n
  00189	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0018d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00192	48 03 c8	 add	 rcx, rax
  00195	48 8b c1	 mov	 rax, rcx
  00198	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019b	83 f8 46	 cmp	 eax, 70			; 00000046H
  0019e	7f 10		 jg	 SHORT $LN3@json_get_n
$LN22@json_get_n:

; 1128 :                                    ('a' <= src[offset] && src[offset] <= 'f') ||
; 1129 :                                    ('A' <= src[offset] && src[offset] <= 'F'))) {
; 1130 :             offset++;

  001a0	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  001a4	48 ff c0	 inc	 rax
  001a7	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1131 :         }

  001ab	e9 57 ff ff ff	 jmp	 $LN2@json_get_n
$LN3@json_get_n:

; 1132 :     } else {

  001b0	e9 d9 05 00 00	 jmp	 $LN20@json_get_n
$LN19@json_get_n:

; 1133 :         int found_sign = 0;

  001b5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR found_sign$5[rsp], 0

; 1134 :         int inf_or_nan = 0;

  001bd	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR inf_or_nan$2[rsp], 0

; 1135 :         
; 1136 :         if ((offset < size) &&

  001c5	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  001ca	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  001ce	73 51		 jae	 SHORT $LN25@json_get_n
  001d0	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  001d4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  001d9	48 03 c8	 add	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001e2	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001e5	74 27		 je	 SHORT $LN26@json_get_n
  001e7	48 8b 44 24 30	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  001ec	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  001f2	48 85 c0	 test	 rax, rax
  001f5	74 2a		 je	 SHORT $LN25@json_get_n
  001f7	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  001fb	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00200	48 03 c8	 add	 rcx, rax
  00203	48 8b c1	 mov	 rax, rcx
  00206	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00209	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0020c	75 13		 jne	 SHORT $LN25@json_get_n
$LN26@json_get_n:

; 1137 :             (('-' == src[offset]) ||
; 1138 :              ((json_parse_flags_allow_leading_plus_sign & flags_bitset) &&
; 1139 :               ('+' == src[offset])))) {
; 1140 :             /* skip valid leading '-' or '+'. */
; 1141 :             offset++;

  0020e	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00212	48 ff c0	 inc	 rax
  00215	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1142 :             
; 1143 :             found_sign = 1;

  00219	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR found_sign$5[rsp], 1
$LN25@json_get_n:

; 1144 :         }
; 1145 :         
; 1146 :         if (json_parse_flags_allow_inf_and_nan & flags_bitset) {

  00221	48 8b 44 24 30	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00226	48 25 00 10 00
	00		 and	 rax, 4096		; 00001000H
  0022c	48 85 c0	 test	 rax, rax
  0022f	0f 84 a3 01 00
	00		 je	 $LN27@json_get_n

; 1147 :             const char inf[9] = "Infinity";

  00235	48 8d 44 24 70	 lea	 rax, QWORD PTR inf$11[rsp]
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KEBCLIFP@Infinity@
  00241	48 8b f8	 mov	 rdi, rax
  00244	48 8b f1	 mov	 rsi, rcx
  00247	b9 09 00 00 00	 mov	 ecx, 9
  0024c	f3 a4		 rep movsb

; 1148 :             const size_t inf_strlen = sizeof(inf) - 1;

  0024e	48 c7 44 24 60
	08 00 00 00	 mov	 QWORD PTR inf_strlen$9[rsp], 8

; 1149 :             const char nan[4] = "NaN";

  00257	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_03ICJPMMHB@NaN@
  0025d	89 44 24 58	 mov	 DWORD PTR nan$8[rsp], eax

; 1150 :             const size_t nan_strlen = sizeof(nan) - 1;

  00261	48 c7 44 24 68
	03 00 00 00	 mov	 QWORD PTR nan_strlen$10[rsp], 3

; 1151 :             
; 1152 :             if (offset + inf_strlen < size) {

  0026a	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0026e	48 83 c0 08	 add	 rax, 8
  00272	48 3b 44 24 18	 cmp	 rax, QWORD PTR size$[rsp]
  00277	73 75		 jae	 SHORT $LN28@json_get_n

; 1153 :                 int found = 1;

  00279	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR found$3[rsp], 1

; 1154 :                 size_t i;
; 1155 :                 for (i = 0; i < inf_strlen; i++) {

  00281	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR i$6[rsp], 0
  0028a	eb 0d		 jmp	 SHORT $LN6@json_get_n
$LN4@json_get_n:
  0028c	48 8b 44 24 48	 mov	 rax, QWORD PTR i$6[rsp]
  00291	48 ff c0	 inc	 rax
  00294	48 89 44 24 48	 mov	 QWORD PTR i$6[rsp], rax
$LN6@json_get_n:
  00299	48 83 7c 24 48
	08		 cmp	 QWORD PTR i$6[rsp], 8
  0029f	73 32		 jae	 SHORT $LN5@json_get_n

; 1156 :                     if (inf[i] != src[offset + i]) {

  002a1	48 8b 44 24 48	 mov	 rax, QWORD PTR i$6[rsp]
  002a6	0f be 44 04 70	 movsx	 eax, BYTE PTR inf$11[rsp+rax]
  002ab	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$6[rsp]
  002b0	48 8b 14 24	 mov	 rdx, QWORD PTR offset$[rsp]
  002b4	48 03 d1	 add	 rdx, rcx
  002b7	48 8b ca	 mov	 rcx, rdx
  002ba	48 8b 54 24 08	 mov	 rdx, QWORD PTR src$[rsp]
  002bf	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  002c3	3b c1		 cmp	 eax, ecx
  002c5	74 0a		 je	 SHORT $LN29@json_get_n

; 1157 :                         found = 0;

  002c7	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR found$3[rsp], 0

; 1158 :                         break;

  002cf	eb 02		 jmp	 SHORT $LN5@json_get_n
$LN29@json_get_n:

; 1159 :                     }
; 1160 :                 }

  002d1	eb b9		 jmp	 SHORT $LN4@json_get_n
$LN5@json_get_n:

; 1161 :                 
; 1162 :                 if (found) {

  002d3	83 7c 24 38 00	 cmp	 DWORD PTR found$3[rsp], 0
  002d8	74 14		 je	 SHORT $LN30@json_get_n

; 1163 :                     /* We found our special 'Infinity' keyword! */
; 1164 :                     offset += inf_strlen;

  002da	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  002de	48 83 c0 08	 add	 rax, 8
  002e2	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1165 :                     
; 1166 :                     inf_or_nan = 1;

  002e6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR inf_or_nan$2[rsp], 1
$LN30@json_get_n:
$LN28@json_get_n:

; 1167 :                 }
; 1168 :             }
; 1169 :             
; 1170 :             if (offset + nan_strlen < size) {

  002ee	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  002f2	48 83 c0 03	 add	 rax, 3
  002f6	48 3b 44 24 18	 cmp	 rax, QWORD PTR size$[rsp]
  002fb	73 75		 jae	 SHORT $LN31@json_get_n

; 1171 :                 int found = 1;

  002fd	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR found$4[rsp], 1

; 1172 :                 size_t i;
; 1173 :                 for (i = 0; i < nan_strlen; i++) {

  00305	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$7[rsp], 0
  0030e	eb 0d		 jmp	 SHORT $LN9@json_get_n
$LN7@json_get_n:
  00310	48 8b 44 24 50	 mov	 rax, QWORD PTR i$7[rsp]
  00315	48 ff c0	 inc	 rax
  00318	48 89 44 24 50	 mov	 QWORD PTR i$7[rsp], rax
$LN9@json_get_n:
  0031d	48 83 7c 24 50
	03		 cmp	 QWORD PTR i$7[rsp], 3
  00323	73 32		 jae	 SHORT $LN8@json_get_n

; 1174 :                     if (nan[i] != src[offset + i]) {

  00325	48 8b 44 24 50	 mov	 rax, QWORD PTR i$7[rsp]
  0032a	0f be 44 04 58	 movsx	 eax, BYTE PTR nan$8[rsp+rax]
  0032f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$7[rsp]
  00334	48 8b 14 24	 mov	 rdx, QWORD PTR offset$[rsp]
  00338	48 03 d1	 add	 rdx, rcx
  0033b	48 8b ca	 mov	 rcx, rdx
  0033e	48 8b 54 24 08	 mov	 rdx, QWORD PTR src$[rsp]
  00343	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00347	3b c1		 cmp	 eax, ecx
  00349	74 0a		 je	 SHORT $LN32@json_get_n

; 1175 :                         found = 0;

  0034b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR found$4[rsp], 0

; 1176 :                         break;

  00353	eb 02		 jmp	 SHORT $LN8@json_get_n
$LN32@json_get_n:

; 1177 :                     }
; 1178 :                 }

  00355	eb b9		 jmp	 SHORT $LN7@json_get_n
$LN8@json_get_n:

; 1179 :                 
; 1180 :                 if (found) {

  00357	83 7c 24 3c 00	 cmp	 DWORD PTR found$4[rsp], 0
  0035c	74 14		 je	 SHORT $LN33@json_get_n

; 1181 :                     /* We found our special 'NaN' keyword! */
; 1182 :                     offset += nan_strlen;

  0035e	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00362	48 83 c0 03	 add	 rax, 3
  00366	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1183 :                     
; 1184 :                     inf_or_nan = 1;

  0036a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR inf_or_nan$2[rsp], 1
$LN33@json_get_n:
$LN31@json_get_n:

; 1185 :                 }
; 1186 :             }
; 1187 :             
; 1188 :             if (inf_or_nan) {

  00372	83 7c 24 20 00	 cmp	 DWORD PTR inf_or_nan$2[rsp], 0
  00377	74 5f		 je	 SHORT $LN34@json_get_n

; 1189 :                 const char c = src[offset];

  00379	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0037d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00382	48 03 c8	 add	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0038b	88 44 24 10	 mov	 BYTE PTR c$1[rsp], al

; 1190 :                 if ((offset < size) && ('0' <= c && c <= '9')) {

  0038f	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  00394	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  00398	73 3e		 jae	 SHORT $LN35@json_get_n
  0039a	0f be 44 24 10	 movsx	 eax, BYTE PTR c$1[rsp]
  0039f	83 f8 30	 cmp	 eax, 48			; 00000030H
  003a2	7c 34		 jl	 SHORT $LN35@json_get_n
  003a4	0f be 44 24 10	 movsx	 eax, BYTE PTR c$1[rsp]
  003a9	83 f8 39	 cmp	 eax, 57			; 00000039H
  003ac	7f 2a		 jg	 SHORT $LN35@json_get_n

; 1191 :                     /* cannot follow an inf or nan with digits! */
; 1192 :                     state->error = json_parse_error_invalid_number_format;

  003ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003b6	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1193 :                     state->offset = offset;

  003be	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003c6	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  003ca	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1194 :                     return 1;

  003ce	b8 01 00 00 00	 mov	 eax, 1
  003d3	e9 cb 04 00 00	 jmp	 $LN1@json_get_n
$LN35@json_get_n:
$LN34@json_get_n:
$LN27@json_get_n:

; 1195 :                 }
; 1196 :             }
; 1197 :         }
; 1198 :         
; 1199 :         if (found_sign && !inf_or_nan && (offset < size) &&

  003d8	83 7c 24 40 00	 cmp	 DWORD PTR found_sign$5[rsp], 0
  003dd	0f 84 95 00 00
	00		 je	 $LN36@json_get_n
  003e3	83 7c 24 20 00	 cmp	 DWORD PTR inf_or_nan$2[rsp], 0
  003e8	0f 85 8a 00 00
	00		 jne	 $LN36@json_get_n
  003ee	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  003f3	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  003f7	73 7f		 jae	 SHORT $LN36@json_get_n
  003f9	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  003fd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00402	48 03 c8	 add	 rcx, rax
  00405	48 8b c1	 mov	 rax, rcx
  00408	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0040b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0040e	7c 17		 jl	 SHORT $LN37@json_get_n
  00410	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00414	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00419	48 03 c8	 add	 rcx, rax
  0041c	48 8b c1	 mov	 rax, rcx
  0041f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00422	83 f8 39	 cmp	 eax, 57			; 00000039H
  00425	7e 51		 jle	 SHORT $LN36@json_get_n
$LN37@json_get_n:

; 1200 :             !('0' <= src[offset] && src[offset] <= '9')) {
; 1201 :             /* check if we are allowing leading '.'. */
; 1202 :             if (!(json_parse_flags_allow_leading_or_trailing_decimal_point &
; 1203 :                   flags_bitset) ||

  00427	48 8b 44 24 30	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0042c	48 25 00 08 00
	00		 and	 rax, 2048		; 00000800H
  00432	48 85 c0	 test	 rax, rax
  00435	74 17		 je	 SHORT $LN39@json_get_n
  00437	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0043b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00440	48 03 c8	 add	 rcx, rax
  00443	48 8b c1	 mov	 rax, rcx
  00446	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00449	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0044c	74 2a		 je	 SHORT $LN38@json_get_n
$LN39@json_get_n:

; 1204 :                 ('.' != src[offset])) {
; 1205 :                 /* a leading '-' must be immediately followed by any digit! */
; 1206 :                 state->error = json_parse_error_invalid_number_format;

  0044e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00456	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1207 :                 state->offset = offset;

  0045e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00466	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0046a	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1208 :                 return 1;

  0046e	b8 01 00 00 00	 mov	 eax, 1
  00473	e9 2b 04 00 00	 jmp	 $LN1@json_get_n
$LN38@json_get_n:
$LN36@json_get_n:

; 1209 :             }
; 1210 :         }
; 1211 :         
; 1212 :         if ((offset < size) && ('0' == src[offset])) {

  00478	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  0047d	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  00481	0f 83 8d 00 00
	00		 jae	 $LN40@json_get_n
  00487	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0048b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00490	48 03 c8	 add	 rcx, rax
  00493	48 8b c1	 mov	 rax, rcx
  00496	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00499	83 f8 30	 cmp	 eax, 48			; 00000030H
  0049c	75 76		 jne	 SHORT $LN40@json_get_n

; 1213 :             /* skip valid '0'. */
; 1214 :             offset++;

  0049e	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  004a2	48 ff c0	 inc	 rax
  004a5	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1215 :             
; 1216 :             /* we need to record whether we had any leading digits for checks later.
; 1217 :              */
; 1218 :             had_leading_digits = 1;

  004a9	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR had_leading_digits$[rsp], 1

; 1219 :             
; 1220 :             if ((offset < size) && ('0' <= src[offset] && src[offset] <= '9')) {

  004b1	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  004b6	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  004ba	73 58		 jae	 SHORT $LN41@json_get_n
  004bc	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  004c0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  004c5	48 03 c8	 add	 rcx, rax
  004c8	48 8b c1	 mov	 rax, rcx
  004cb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004ce	83 f8 30	 cmp	 eax, 48			; 00000030H
  004d1	7c 41		 jl	 SHORT $LN41@json_get_n
  004d3	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  004d7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  004dc	48 03 c8	 add	 rcx, rax
  004df	48 8b c1	 mov	 rax, rcx
  004e2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004e5	83 f8 39	 cmp	 eax, 57			; 00000039H
  004e8	7f 2a		 jg	 SHORT $LN41@json_get_n

; 1221 :                 /* a leading '0' must not be immediately followed by any digit! */
; 1222 :                 state->error = json_parse_error_invalid_number_format;

  004ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004f2	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1223 :                 state->offset = offset;

  004fa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00502	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  00506	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1224 :                 return 1;

  0050a	b8 01 00 00 00	 mov	 eax, 1
  0050f	e9 8f 03 00 00	 jmp	 $LN1@json_get_n
$LN41@json_get_n:
$LN40@json_get_n:
$LN10@json_get_n:

; 1225 :             }
; 1226 :         }
; 1227 :         
; 1228 :         /* the main digits of our number next. */
; 1229 :         while ((offset < size) && ('0' <= src[offset] && src[offset] <= '9')) {

  00514	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  00519	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  0051d	73 43		 jae	 SHORT $LN11@json_get_n
  0051f	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00523	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00528	48 03 c8	 add	 rcx, rax
  0052b	48 8b c1	 mov	 rax, rcx
  0052e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00531	83 f8 30	 cmp	 eax, 48			; 00000030H
  00534	7c 2c		 jl	 SHORT $LN11@json_get_n
  00536	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0053a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0053f	48 03 c8	 add	 rcx, rax
  00542	48 8b c1	 mov	 rax, rcx
  00545	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00548	83 f8 39	 cmp	 eax, 57			; 00000039H
  0054b	7f 15		 jg	 SHORT $LN11@json_get_n

; 1230 :             offset++;

  0054d	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00551	48 ff c0	 inc	 rax
  00554	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1231 :             
; 1232 :             /* we need to record whether we had any leading digits for checks later.
; 1233 :              */
; 1234 :             had_leading_digits = 1;

  00558	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR had_leading_digits$[rsp], 1

; 1235 :         }

  00560	eb b2		 jmp	 SHORT $LN10@json_get_n
$LN11@json_get_n:

; 1236 :         
; 1237 :         if ((offset < size) && ('.' == src[offset])) {

  00562	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  00567	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  0056b	0f 83 e6 00 00
	00		 jae	 $LN42@json_get_n
  00571	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00575	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0057a	48 03 c8	 add	 rcx, rax
  0057d	48 8b c1	 mov	 rax, rcx
  00580	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00583	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00586	0f 85 cb 00 00
	00		 jne	 $LN42@json_get_n

; 1238 :             offset++;

  0058c	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00590	48 ff c0	 inc	 rax
  00593	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1239 :             
; 1240 :             if ((offset >= size) || !('0' <= src[offset] && src[offset] <= '9')) {

  00597	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  0059c	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  005a0	73 2e		 jae	 SHORT $LN44@json_get_n
  005a2	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  005a6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  005ab	48 03 c8	 add	 rcx, rax
  005ae	48 8b c1	 mov	 rax, rcx
  005b1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005b4	83 f8 30	 cmp	 eax, 48			; 00000030H
  005b7	7c 17		 jl	 SHORT $LN45@json_get_n
  005b9	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  005bd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  005c2	48 03 c8	 add	 rcx, rax
  005c5	48 8b c1	 mov	 rax, rcx
  005c8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005cb	83 f8 39	 cmp	 eax, 57			; 00000039H
  005ce	7e 41		 jle	 SHORT $LN43@json_get_n
$LN45@json_get_n:
$LN44@json_get_n:

; 1241 :                 if (!(json_parse_flags_allow_leading_or_trailing_decimal_point &
; 1242 :                       flags_bitset) ||

  005d0	48 8b 44 24 30	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  005d5	48 25 00 08 00
	00		 and	 rax, 2048		; 00000800H
  005db	48 85 c0	 test	 rax, rax
  005de	74 07		 je	 SHORT $LN47@json_get_n
  005e0	83 7c 24 28 00	 cmp	 DWORD PTR had_leading_digits$[rsp], 0
  005e5	75 2a		 jne	 SHORT $LN46@json_get_n
$LN47@json_get_n:

; 1243 :                     !had_leading_digits) {
; 1244 :                     /* a decimal point must be followed by at least one digit. */
; 1245 :                     state->error = json_parse_error_invalid_number_format;

  005e7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005ef	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1246 :                     state->offset = offset;

  005f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005ff	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  00603	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1247 :                     return 1;

  00607	b8 01 00 00 00	 mov	 eax, 1
  0060c	e9 92 02 00 00	 jmp	 $LN1@json_get_n
$LN46@json_get_n:
$LN43@json_get_n:
$LN12@json_get_n:

; 1248 :                 }
; 1249 :             }
; 1250 :             
; 1251 :             /* a decimal point can be followed by more digits of course! */
; 1252 :             while ((offset < size) && ('0' <= src[offset] && src[offset] <= '9')) {

  00611	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  00616	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  0061a	73 3b		 jae	 SHORT $LN13@json_get_n
  0061c	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00620	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00625	48 03 c8	 add	 rcx, rax
  00628	48 8b c1	 mov	 rax, rcx
  0062b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0062e	83 f8 30	 cmp	 eax, 48			; 00000030H
  00631	7c 24		 jl	 SHORT $LN13@json_get_n
  00633	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00637	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0063c	48 03 c8	 add	 rcx, rax
  0063f	48 8b c1	 mov	 rax, rcx
  00642	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00645	83 f8 39	 cmp	 eax, 57			; 00000039H
  00648	7f 0d		 jg	 SHORT $LN13@json_get_n

; 1253 :                 offset++;

  0064a	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0064e	48 ff c0	 inc	 rax
  00651	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1254 :             }

  00655	eb ba		 jmp	 SHORT $LN12@json_get_n
$LN13@json_get_n:
$LN42@json_get_n:

; 1255 :         }
; 1256 :         
; 1257 :         if ((offset < size) && ('e' == src[offset] || 'E' == src[offset])) {

  00657	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  0065c	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  00660	0f 83 28 01 00
	00		 jae	 $LN48@json_get_n
  00666	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0066a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  0066f	48 03 c8	 add	 rcx, rax
  00672	48 8b c1	 mov	 rax, rcx
  00675	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00678	83 f8 65	 cmp	 eax, 101		; 00000065H
  0067b	74 1b		 je	 SHORT $LN49@json_get_n
  0067d	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00681	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00686	48 03 c8	 add	 rcx, rax
  00689	48 8b c1	 mov	 rax, rcx
  0068c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0068f	83 f8 45	 cmp	 eax, 69			; 00000045H
  00692	0f 85 f6 00 00
	00		 jne	 $LN48@json_get_n
$LN49@json_get_n:

; 1258 :             /* our number has an exponent! Skip 'e' or 'E'. */
; 1259 :             offset++;

  00698	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0069c	48 ff c0	 inc	 rax
  0069f	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1260 :             
; 1261 :             if ((offset < size) && ('-' == src[offset] || '+' == src[offset])) {

  006a3	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  006a8	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  006ac	73 39		 jae	 SHORT $LN50@json_get_n
  006ae	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  006b2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  006b7	48 03 c8	 add	 rcx, rax
  006ba	48 8b c1	 mov	 rax, rcx
  006bd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  006c0	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  006c3	74 17		 je	 SHORT $LN51@json_get_n
  006c5	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  006c9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  006ce	48 03 c8	 add	 rcx, rax
  006d1	48 8b c1	 mov	 rax, rcx
  006d4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  006d7	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  006da	75 0b		 jne	 SHORT $LN50@json_get_n
$LN51@json_get_n:

; 1262 :                 /* skip optional '-' or '+'. */
; 1263 :                 offset++;

  006dc	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  006e0	48 ff c0	 inc	 rax
  006e3	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax
$LN50@json_get_n:

; 1264 :             }
; 1265 :             
; 1266 :             if ((offset < size) && !('0' <= src[offset] && src[offset] <= '9')) {

  006e7	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  006ec	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  006f0	73 58		 jae	 SHORT $LN52@json_get_n
  006f2	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  006f6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  006fb	48 03 c8	 add	 rcx, rax
  006fe	48 8b c1	 mov	 rax, rcx
  00701	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00704	83 f8 30	 cmp	 eax, 48			; 00000030H
  00707	7c 17		 jl	 SHORT $LN53@json_get_n
  00709	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0070d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00712	48 03 c8	 add	 rcx, rax
  00715	48 8b c1	 mov	 rax, rcx
  00718	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0071b	83 f8 39	 cmp	 eax, 57			; 00000039H
  0071e	7e 2a		 jle	 SHORT $LN52@json_get_n
$LN53@json_get_n:

; 1267 :                 /* an exponent must have at least one digit! */
; 1268 :                 state->error = json_parse_error_invalid_number_format;

  00720	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00728	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1269 :                 state->offset = offset;

  00730	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00738	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0073c	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1270 :                 return 1;

  00740	b8 01 00 00 00	 mov	 eax, 1
  00745	e9 59 01 00 00	 jmp	 $LN1@json_get_n
$LN52@json_get_n:
$LN16@json_get_n:

; 1271 :             }
; 1272 :             
; 1273 :             /* consume exponent digits. */
; 1274 :             do {
; 1275 :                 offset++;

  0074a	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0074e	48 ff c0	 inc	 rax
  00751	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 1276 :             } while ((offset < size) && ('0' <= src[offset] && src[offset] <= '9'));

  00755	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  0075a	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  0075e	73 2e		 jae	 SHORT $LN54@json_get_n
  00760	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  00764	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00769	48 03 c8	 add	 rcx, rax
  0076c	48 8b c1	 mov	 rax, rcx
  0076f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00772	83 f8 30	 cmp	 eax, 48			; 00000030H
  00775	7c 17		 jl	 SHORT $LN55@json_get_n
  00777	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  0077b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  00780	48 03 c8	 add	 rcx, rax
  00783	48 8b c1	 mov	 rax, rcx
  00786	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00789	83 f8 39	 cmp	 eax, 57			; 00000039H
  0078c	7e bc		 jle	 SHORT $LN16@json_get_n
$LN55@json_get_n:
$LN54@json_get_n:
$LN48@json_get_n:
$LN20@json_get_n:

; 1277 :         }
; 1278 :     }
; 1279 :     
; 1280 :     if (offset < size) {

  0078e	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  00793	48 39 04 24	 cmp	 QWORD PTR offset$[rsp], rax
  00797	0f 83 ab 00 00
	00		 jae	 $LN56@json_get_n

; 1281 :         switch (src[offset]) {

  0079d	48 8b 04 24	 mov	 rax, QWORD PTR offset$[rsp]
  007a1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR src$[rsp]
  007a6	48 03 c8	 add	 rcx, rax
  007a9	48 8b c1	 mov	 rax, rcx
  007ac	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007af	89 44 24 24	 mov	 DWORD PTR tv335[rsp], eax
  007b3	8b 44 24 24	 mov	 eax, DWORD PTR tv335[rsp]
  007b7	83 e8 09	 sub	 eax, 9
  007ba	89 44 24 24	 mov	 DWORD PTR tv335[rsp], eax
  007be	83 7c 24 24 74	 cmp	 DWORD PTR tv335[rsp], 116 ; 00000074H
  007c3	77 5c		 ja	 SHORT $LN66@json_get_n
  007c5	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv335[rsp]
  007ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  007d1	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN68@json_get_n[rcx+rax]
  007d9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN69@json_get_n[rcx+rax*4]
  007e0	48 03 c1	 add	 rax, rcx
  007e3	ff e0		 jmp	 rax
$LN57@json_get_n:
$LN58@json_get_n:
$LN59@json_get_n:
$LN60@json_get_n:
$LN61@json_get_n:
$LN62@json_get_n:
$LN63@json_get_n:

; 1282 :             case ' ':
; 1283 :             case '\t':
; 1284 :             case '\r':
; 1285 :             case '\n':
; 1286 :             case '}':
; 1287 :             case ',':
; 1288 :             case ']':
; 1289 :             /* all of the above are ok. */
; 1290 :             break;

  007e5	eb 61		 jmp	 SHORT $LN17@json_get_n
$LN64@json_get_n:

; 1291 :             case '=':
; 1292 :             if (json_parse_flags_allow_equals_in_object & flags_bitset) {

  007e7	48 8b 44 24 30	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  007ec	48 83 e0 08	 and	 rax, 8
  007f0	48 85 c0	 test	 rax, rax
  007f3	74 02		 je	 SHORT $LN65@json_get_n

; 1293 :                 break;

  007f5	eb 51		 jmp	 SHORT $LN17@json_get_n
$LN65@json_get_n:

; 1294 :             }
; 1295 :             
; 1296 :             state->error = json_parse_error_invalid_number_format;

  007f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007ff	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1297 :             state->offset = offset;

  00807	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0080f	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  00813	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1298 :             return 1;

  00817	b8 01 00 00 00	 mov	 eax, 1
  0081c	e9 82 00 00 00	 jmp	 $LN1@json_get_n
$LN66@json_get_n:

; 1299 :             default:
; 1300 :             state->error = json_parse_error_invalid_number_format;

  00821	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00829	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1301 :             state->offset = offset;

  00831	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00839	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0083d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1302 :             return 1;

  00841	b8 01 00 00 00	 mov	 eax, 1
  00846	eb 5b		 jmp	 SHORT $LN1@json_get_n
$LN17@json_get_n:
$LN56@json_get_n:

; 1303 :         }
; 1304 :     }
; 1305 :     
; 1306 :     state->data_size += offset - state->offset;

  00848	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00850	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00854	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  00858	48 2b c8	 sub	 rcx, rax
  0085b	48 8b c1	 mov	 rax, rcx
  0085e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00866	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  0086a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00872	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1307 :     
; 1308 :     /* one more byte for null terminator ending the number string! */
; 1309 :     state->data_size++;

  00876	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0087e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00882	48 ff c0	 inc	 rax
  00885	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0088d	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1310 :     
; 1311 :     /* update offset. */
; 1312 :     state->offset = offset;

  00891	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00899	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0089d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1313 :     
; 1314 :     return 0;

  008a1	33 c0		 xor	 eax, eax
$LN1@json_get_n:

; 1315 : }

  008a3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  008ab	48 33 cc	 xor	 rcx, rsp
  008ae	e8 00 00 00 00	 call	 __security_check_cookie
  008b3	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  008ba	5f		 pop	 rdi
  008bb	5e		 pop	 rsi
  008bc	c3		 ret	 0
  008bd	0f 1f 00	 npad	 3
$LN69@json_get_n:
  008c0	00 00 00 00	 DD	 $LN58@json_get_n
  008c4	00 00 00 00	 DD	 $LN60@json_get_n
  008c8	00 00 00 00	 DD	 $LN59@json_get_n
  008cc	00 00 00 00	 DD	 $LN57@json_get_n
  008d0	00 00 00 00	 DD	 $LN62@json_get_n
  008d4	00 00 00 00	 DD	 $LN64@json_get_n
  008d8	00 00 00 00	 DD	 $LN63@json_get_n
  008dc	00 00 00 00	 DD	 $LN61@json_get_n
  008e0	00 00 00 00	 DD	 $LN66@json_get_n
$LN68@json_get_n:
  008e4	00		 DB	 0
  008e5	01		 DB	 1
  008e6	08		 DB	 8
  008e7	08		 DB	 8
  008e8	02		 DB	 2
  008e9	08		 DB	 8
  008ea	08		 DB	 8
  008eb	08		 DB	 8
  008ec	08		 DB	 8
  008ed	08		 DB	 8
  008ee	08		 DB	 8
  008ef	08		 DB	 8
  008f0	08		 DB	 8
  008f1	08		 DB	 8
  008f2	08		 DB	 8
  008f3	08		 DB	 8
  008f4	08		 DB	 8
  008f5	08		 DB	 8
  008f6	08		 DB	 8
  008f7	08		 DB	 8
  008f8	08		 DB	 8
  008f9	08		 DB	 8
  008fa	08		 DB	 8
  008fb	03		 DB	 3
  008fc	08		 DB	 8
  008fd	08		 DB	 8
  008fe	08		 DB	 8
  008ff	08		 DB	 8
  00900	08		 DB	 8
  00901	08		 DB	 8
  00902	08		 DB	 8
  00903	08		 DB	 8
  00904	08		 DB	 8
  00905	08		 DB	 8
  00906	08		 DB	 8
  00907	04		 DB	 4
  00908	08		 DB	 8
  00909	08		 DB	 8
  0090a	08		 DB	 8
  0090b	08		 DB	 8
  0090c	08		 DB	 8
  0090d	08		 DB	 8
  0090e	08		 DB	 8
  0090f	08		 DB	 8
  00910	08		 DB	 8
  00911	08		 DB	 8
  00912	08		 DB	 8
  00913	08		 DB	 8
  00914	08		 DB	 8
  00915	08		 DB	 8
  00916	08		 DB	 8
  00917	08		 DB	 8
  00918	05		 DB	 5
  00919	08		 DB	 8
  0091a	08		 DB	 8
  0091b	08		 DB	 8
  0091c	08		 DB	 8
  0091d	08		 DB	 8
  0091e	08		 DB	 8
  0091f	08		 DB	 8
  00920	08		 DB	 8
  00921	08		 DB	 8
  00922	08		 DB	 8
  00923	08		 DB	 8
  00924	08		 DB	 8
  00925	08		 DB	 8
  00926	08		 DB	 8
  00927	08		 DB	 8
  00928	08		 DB	 8
  00929	08		 DB	 8
  0092a	08		 DB	 8
  0092b	08		 DB	 8
  0092c	08		 DB	 8
  0092d	08		 DB	 8
  0092e	08		 DB	 8
  0092f	08		 DB	 8
  00930	08		 DB	 8
  00931	08		 DB	 8
  00932	08		 DB	 8
  00933	08		 DB	 8
  00934	08		 DB	 8
  00935	08		 DB	 8
  00936	08		 DB	 8
  00937	08		 DB	 8
  00938	06		 DB	 6
  00939	08		 DB	 8
  0093a	08		 DB	 8
  0093b	08		 DB	 8
  0093c	08		 DB	 8
  0093d	08		 DB	 8
  0093e	08		 DB	 8
  0093f	08		 DB	 8
  00940	08		 DB	 8
  00941	08		 DB	 8
  00942	08		 DB	 8
  00943	08		 DB	 8
  00944	08		 DB	 8
  00945	08		 DB	 8
  00946	08		 DB	 8
  00947	08		 DB	 8
  00948	08		 DB	 8
  00949	08		 DB	 8
  0094a	08		 DB	 8
  0094b	08		 DB	 8
  0094c	08		 DB	 8
  0094d	08		 DB	 8
  0094e	08		 DB	 8
  0094f	08		 DB	 8
  00950	08		 DB	 8
  00951	08		 DB	 8
  00952	08		 DB	 8
  00953	08		 DB	 8
  00954	08		 DB	 8
  00955	08		 DB	 8
  00956	08		 DB	 8
  00957	08		 DB	 8
  00958	07		 DB	 7
?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ENDP ; json_get_number_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z
_TEXT	SEGMENT
allow_comma$ = 32
src$ = 40
elements$ = 48
flags_bitset$ = 56
size$ = 64
state$ = 96
?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z PROC ; json_get_array_size, COMDAT

; 1038 : int json_get_array_size(struct json_parse_state_s *state) {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1039 :     const size_t flags_bitset = state->flags_bitset;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00012	48 89 44 24 38	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 1040 :     size_t elements = 0;

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR elements$[rsp], 0

; 1041 :     int allow_comma = 0;

  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 1042 :     const char *const src = state->src;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 28	 mov	 QWORD PTR src$[rsp], rax

; 1043 :     const size_t size = state->size;

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0003a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003e	48 89 44 24 40	 mov	 QWORD PTR size$[rsp], rax

; 1044 :     
; 1045 :     if ('[' != src[state->offset]) {

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00048	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00051	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00055	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00058	74 17		 je	 SHORT $LN4@json_get_a

; 1046 :         /* expected array to begin with leading '['. */
; 1047 :         state->error = json_parse_error_unknown;

  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0005f	48 c7 40 50 0b
	00 00 00	 mov	 QWORD PTR [rax+80], 11

; 1048 :         return 1;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	e9 97 01 00 00	 jmp	 $LN1@json_get_a
$LN4@json_get_a:

; 1049 :     }
; 1050 :     
; 1051 :     /* skip leading '['. */
; 1052 :     state->offset++;

  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00076	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007a	48 ff c0	 inc	 rax
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00082	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1053 :     
; 1054 :     state->dom_size += sizeof(struct json_array_s);

  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0008b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0008f	48 83 c0 10	 add	 rax, 16
  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00098	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN16@json_get_a:
$LN2@json_get_a:

; 1055 :     
; 1056 :     while (state->offset < size) {

  0009c	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  000a6	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000aa	0f 83 46 01 00
	00		 jae	 $LN3@json_get_a

; 1057 :         if (json_skip_all_skippables(state)) {

  000b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000b5	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  000ba	85 c0		 test	 eax, eax
  000bc	74 17		 je	 SHORT $LN5@json_get_a

; 1058 :             state->error = json_parse_error_premature_end_of_buffer;

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000c3	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 1059 :             return 1;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	e9 33 01 00 00	 jmp	 $LN1@json_get_a
$LN5@json_get_a:

; 1060 :         }
; 1061 :         
; 1062 :         if (']' == src[state->offset]) {

  000d5	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000da	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  000e3	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000e7	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  000ea	75 34		 jne	 SHORT $LN6@json_get_a

; 1063 :             /* skip trailing ']'. */
; 1064 :             state->offset++;

  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000f1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f5	48 ff c0	 inc	 rax
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000fd	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1065 :             
; 1066 :             state->dom_size += sizeof(struct json_array_element_s) * elements;

  00101	48 6b 44 24 30
	10		 imul	 rax, QWORD PTR elements$[rsp], 16
  00107	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0010c	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  00110	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00115	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1067 :             
; 1068 :             /* finished the object! */
; 1069 :             return 0;

  00119	33 c0		 xor	 eax, eax
  0011b	e9 e8 00 00 00	 jmp	 $LN1@json_get_a
$LN6@json_get_a:

; 1070 :         }
; 1071 :         
; 1072 :         /* if we parsed at least once element previously, grok for a comma. */
; 1073 :         if (allow_comma) {

  00120	83 7c 24 20 00	 cmp	 DWORD PTR allow_comma$[rsp], 0
  00125	0f 84 9a 00 00
	00		 je	 $LN7@json_get_a

; 1074 :             if (',' == src[state->offset]) {

  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00130	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00134	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00139	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0013d	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00140	75 1f		 jne	 SHORT $LN8@json_get_a

; 1075 :                 /* skip comma. */
; 1076 :                 state->offset++;

  00142	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00147	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0014b	48 ff c0	 inc	 rax
  0014e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00153	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1077 :                 allow_comma = 0;

  00157	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0
  0015f	eb 25		 jmp	 SHORT $LN9@json_get_a
$LN8@json_get_a:

; 1078 :             } else if (!(json_parse_flags_allow_no_commas & flags_bitset)) {

  00161	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00166	48 83 e0 10	 and	 rax, 16
  0016a	48 85 c0	 test	 rax, rax
  0016d	75 17		 jne	 SHORT $LN10@json_get_a

; 1079 :                 state->error = json_parse_error_expected_comma_or_closing_bracket;

  0016f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00174	48 c7 40 50 01
	00 00 00	 mov	 QWORD PTR [rax+80], 1

; 1080 :                 return 1;

  0017c	b8 01 00 00 00	 mov	 eax, 1
  00181	e9 82 00 00 00	 jmp	 $LN1@json_get_a
$LN10@json_get_a:
$LN9@json_get_a:

; 1081 :             }
; 1082 :             
; 1083 :             if (json_parse_flags_allow_trailing_comma & flags_bitset) {

  00186	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0018b	48 83 e0 01	 and	 rax, 1
  0018f	48 85 c0	 test	 rax, rax
  00192	74 0f		 je	 SHORT $LN11@json_get_a

; 1084 :                 allow_comma = 0;

  00194	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 1085 :                 continue;

  0019c	e9 fb fe ff ff	 jmp	 $LN2@json_get_a

; 1086 :             } else {

  001a1	eb 22		 jmp	 SHORT $LN12@json_get_a
$LN11@json_get_a:

; 1087 :                 if (json_skip_all_skippables(state)) {

  001a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001a8	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  001ad	85 c0		 test	 eax, eax
  001af	74 14		 je	 SHORT $LN13@json_get_a

; 1088 :                     state->error = json_parse_error_premature_end_of_buffer;

  001b1	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001b6	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 1089 :                     return 1;

  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	eb 43		 jmp	 SHORT $LN1@json_get_a
$LN13@json_get_a:
$LN12@json_get_a:
$LN7@json_get_a:

; 1090 :                 }
; 1091 :             }
; 1092 :         }
; 1093 :         
; 1094 :         if (json_get_value_size(state, /* is_global_object = */ 0)) {

  001c5	33 d2		 xor	 edx, edx
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001cc	e8 00 00 00 00	 call	 ?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_value_size
  001d1	85 c0		 test	 eax, eax
  001d3	74 07		 je	 SHORT $LN14@json_get_a

; 1095 :             /* value parsing failed! */
; 1096 :             return 1;

  001d5	b8 01 00 00 00	 mov	 eax, 1
  001da	eb 2c		 jmp	 SHORT $LN1@json_get_a
$LN14@json_get_a:

; 1097 :         }
; 1098 :         
; 1099 :         /* successfully parsed an array element! */
; 1100 :         elements++;

  001dc	48 8b 44 24 30	 mov	 rax, QWORD PTR elements$[rsp]
  001e1	48 ff c0	 inc	 rax
  001e4	48 89 44 24 30	 mov	 QWORD PTR elements$[rsp], rax

; 1101 :         allow_comma = 1;

  001e9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 1

; 1102 :     }

  001f1	e9 a6 fe ff ff	 jmp	 $LN16@json_get_a
$LN3@json_get_a:

; 1103 :     
; 1104 :     /* we consumed the entire input before finding the closing ']' of the array!
; 1105 :      */
; 1106 :     state->error = json_parse_error_premature_end_of_buffer;

  001f6	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001fb	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 1107 :     return 1;

  00203	b8 01 00 00 00	 mov	 eax, 1
$LN1@json_get_a:

; 1108 : }

  00208	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020c	c3		 ret	 0
?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z ENDP ; json_get_array_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z
_TEXT	SEGMENT
current$1 = 32
allow_comma$ = 36
found_closing_brace$ = 40
src$ = 48
flags_bitset$ = 56
size$ = 64
elements$ = 72
state$ = 96
is_global_object$ = 104
?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z PROC ; json_get_object_size, COMDAT

; 902  :                          int is_global_object) {

$LN33:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 903  :     const size_t flags_bitset = state->flags_bitset;

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00012	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00016	48 89 44 24 38	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 904  :     const char *const src = state->src;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	48 89 44 24 30	 mov	 QWORD PTR src$[rsp], rax

; 905  :     const size_t size = state->size;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0002d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00031	48 89 44 24 40	 mov	 QWORD PTR size$[rsp], rax

; 906  :     size_t elements = 0;

  00036	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR elements$[rsp], 0

; 907  :     int allow_comma = 0;

  0003f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 908  :     int found_closing_brace = 0;

  00047	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR found_closing_brace$[rsp], 0

; 909  :     
; 910  :     if (is_global_object) {

  0004f	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00054	74 30		 je	 SHORT $LN5@json_get_o

; 911  :         /* if we found an opening '{' of an object, we actually have a normal JSON
; 912  :          * object at the root of the DOM... */
; 913  :         if (!json_skip_all_skippables(state) && '{' == state->src[state->offset]) {

  00056	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0005b	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  00060	85 c0		 test	 eax, eax
  00062	75 22		 jne	 SHORT $LN6@json_get_o
  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00069	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00072	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00075	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00079	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  0007c	75 08		 jne	 SHORT $LN6@json_get_o

; 914  :             /* . and we don't actually have a global object after all! */
; 915  :             is_global_object = 0;

  0007e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR is_global_object$[rsp], 0
$LN6@json_get_o:
$LN5@json_get_o:

; 916  :         }
; 917  :     }
; 918  :     
; 919  :     if (!is_global_object) {

  00086	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  0008b	75 43		 jne	 SHORT $LN7@json_get_o

; 920  :         if ('{' != src[state->offset]) {

  0008d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00092	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0009b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0009f	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  000a2	74 17		 je	 SHORT $LN8@json_get_o

; 921  :             state->error = json_parse_error_unknown;

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000a9	48 c7 40 50 0b
	00 00 00	 mov	 QWORD PTR [rax+80], 11

; 922  :             return 1;

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	e9 0c 03 00 00	 jmp	 $LN1@json_get_o
$LN8@json_get_o:

; 923  :         }
; 924  :         
; 925  :         /* skip leading '{'. */
; 926  :         state->offset++;

  000bb	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000c0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c4	48 ff c0	 inc	 rax
  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000cc	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN7@json_get_o:

; 927  :     }
; 928  :     
; 929  :     state->dom_size += sizeof(struct json_object_s);

  000d0	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000d5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000d9	48 83 c0 10	 add	 rax, 16
  000dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000e2	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 930  :     
; 931  :     if ((state->offset == size) && !is_global_object) {

  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  000f0	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000f4	75 1e		 jne	 SHORT $LN9@json_get_o
  000f6	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  000fb	75 17		 jne	 SHORT $LN9@json_get_o

; 932  :         state->error = json_parse_error_premature_end_of_buffer;

  000fd	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00102	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 933  :         return 1;

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	e9 b3 02 00 00	 jmp	 $LN1@json_get_o
$LN9@json_get_o:
$LN4@json_get_o:

; 934  :     }
; 935  :     
; 936  :     do {
; 937  :         if (!is_global_object) {

  00114	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00119	75 60		 jne	 SHORT $LN10@json_get_o

; 938  :             if (json_skip_all_skippables(state)) {

  0011b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00120	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  00125	85 c0		 test	 eax, eax
  00127	74 17		 je	 SHORT $LN12@json_get_o

; 939  :                 state->error = json_parse_error_premature_end_of_buffer;

  00129	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0012e	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 940  :                 return 1;

  00136	b8 01 00 00 00	 mov	 eax, 1
  0013b	e9 87 02 00 00	 jmp	 $LN1@json_get_o
$LN12@json_get_o:

; 941  :             }
; 942  :             
; 943  :             if ('}' == src[state->offset]) {

  00140	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00145	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00149	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0014e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00152	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00155	75 22		 jne	 SHORT $LN13@json_get_o

; 944  :                 /* skip trailing '}'. */
; 945  :                 state->offset++;

  00157	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0015c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00160	48 ff c0	 inc	 rax
  00163	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00168	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 946  :                 
; 947  :                 found_closing_brace = 1;

  0016c	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR found_closing_brace$[rsp], 1

; 948  :                 
; 949  :                 /* finished the object! */
; 950  :                 break;

  00174	e9 02 02 00 00	 jmp	 $LN3@json_get_o
$LN13@json_get_o:

; 951  :             }
; 952  :         } else {

  00179	eb 13		 jmp	 SHORT $LN11@json_get_o
$LN10@json_get_o:

; 953  :             /* we don't require brackets, so that means the object ends when the input
; 954  :              * stream ends! */
; 955  :             if (json_skip_all_skippables(state)) {

  0017b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00180	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  00185	85 c0		 test	 eax, eax
  00187	74 05		 je	 SHORT $LN14@json_get_o

; 956  :                 break;

  00189	e9 ed 01 00 00	 jmp	 $LN3@json_get_o
$LN14@json_get_o:
$LN11@json_get_o:

; 957  :             }
; 958  :         }
; 959  :         
; 960  :         /* if we parsed at least one element previously, grok for a comma. */
; 961  :         if (allow_comma) {

  0018e	83 7c 24 24 00	 cmp	 DWORD PTR allow_comma$[rsp], 0
  00193	0f 84 9f 00 00
	00		 je	 $LN15@json_get_o

; 962  :             if (',' == src[state->offset]) {

  00199	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0019e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  001a7	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  001ab	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  001ae	75 1f		 jne	 SHORT $LN16@json_get_o

; 963  :                 /* skip comma. */
; 964  :                 state->offset++;

  001b0	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001b5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001b9	48 ff c0	 inc	 rax
  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001c1	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 965  :                 allow_comma = 0;

  001c5	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0
  001cd	eb 2f		 jmp	 SHORT $LN17@json_get_o
$LN16@json_get_o:

; 966  :             } else if (json_parse_flags_allow_no_commas & flags_bitset) {

  001cf	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  001d4	48 83 e0 10	 and	 rax, 16
  001d8	48 85 c0	 test	 rax, rax
  001db	74 0a		 je	 SHORT $LN18@json_get_o

; 967  :                 /* we don't require a comma, and we didn't find one, which is ok! */
; 968  :                 allow_comma = 0;

  001dd	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 0

; 969  :             } else {

  001e5	eb 17		 jmp	 SHORT $LN19@json_get_o
$LN18@json_get_o:

; 970  :                 /* otherwise we are required to have a comma, and we found none. */
; 971  :                 state->error = json_parse_error_expected_comma_or_closing_bracket;

  001e7	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001ec	48 c7 40 50 01
	00 00 00	 mov	 QWORD PTR [rax+80], 1

; 972  :                 return 1;

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	e9 c9 01 00 00	 jmp	 $LN1@json_get_o
$LN19@json_get_o:
$LN17@json_get_o:

; 973  :             }
; 974  :             
; 975  :             if (json_parse_flags_allow_trailing_comma & flags_bitset) {

  001fe	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00203	48 83 e0 01	 and	 rax, 1
  00207	48 85 c0	 test	 rax, rax
  0020a	74 07		 je	 SHORT $LN20@json_get_o

; 976  :                 continue;

  0020c	e9 56 01 00 00	 jmp	 $LN2@json_get_o

; 977  :             } else {

  00211	eb 25		 jmp	 SHORT $LN21@json_get_o
$LN20@json_get_o:

; 978  :                 if (json_skip_all_skippables(state)) {

  00213	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00218	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  0021d	85 c0		 test	 eax, eax
  0021f	74 17		 je	 SHORT $LN22@json_get_o

; 979  :                     state->error = json_parse_error_premature_end_of_buffer;

  00221	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00226	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 980  :                     return 1;

  0022e	b8 01 00 00 00	 mov	 eax, 1
  00233	e9 8f 01 00 00	 jmp	 $LN1@json_get_o
$LN22@json_get_o:
$LN21@json_get_o:
$LN15@json_get_o:

; 981  :                 }
; 982  :             }
; 983  :         }
; 984  :         
; 985  :         if (json_get_key_size(state)) {

  00238	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0023d	e8 00 00 00 00	 call	 ?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_key_size
  00242	85 c0		 test	 eax, eax
  00244	74 17		 je	 SHORT $LN23@json_get_o

; 986  :             /* key parsing failed! */
; 987  :             state->error = json_parse_error_invalid_string;

  00246	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0024b	48 c7 40 50 08
	00 00 00	 mov	 QWORD PTR [rax+80], 8

; 988  :             return 1;

  00253	b8 01 00 00 00	 mov	 eax, 1
  00258	e9 6a 01 00 00	 jmp	 $LN1@json_get_o
$LN23@json_get_o:

; 989  :         }
; 990  :         
; 991  :         if (json_skip_all_skippables(state)) {

  0025d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00262	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  00267	85 c0		 test	 eax, eax
  00269	74 17		 je	 SHORT $LN24@json_get_o

; 992  :             state->error = json_parse_error_premature_end_of_buffer;

  0026b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00270	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 993  :             return 1;

  00278	b8 01 00 00 00	 mov	 eax, 1
  0027d	e9 45 01 00 00	 jmp	 $LN1@json_get_o
$LN24@json_get_o:

; 994  :         }
; 995  :         
; 996  :         if (json_parse_flags_allow_equals_in_object & flags_bitset) {

  00282	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00287	48 83 e0 08	 and	 rax, 8
  0028b	48 85 c0	 test	 rax, rax
  0028e	74 43		 je	 SHORT $LN25@json_get_o

; 997  :             const char current = src[state->offset];

  00290	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00295	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00299	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0029e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a2	88 44 24 20	 mov	 BYTE PTR current$1[rsp], al

; 998  :             if ((':' != current) && ('=' != current)) {

  002a6	0f be 44 24 20	 movsx	 eax, BYTE PTR current$1[rsp]
  002ab	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  002ae	74 21		 je	 SHORT $LN27@json_get_o
  002b0	0f be 44 24 20	 movsx	 eax, BYTE PTR current$1[rsp]
  002b5	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  002b8	74 17		 je	 SHORT $LN27@json_get_o

; 999  :                 state->error = json_parse_error_expected_colon;

  002ba	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  002bf	48 c7 40 50 02
	00 00 00	 mov	 QWORD PTR [rax+80], 2

; 1000 :                 return 1;

  002c7	b8 01 00 00 00	 mov	 eax, 1
  002cc	e9 f6 00 00 00	 jmp	 $LN1@json_get_o
$LN27@json_get_o:

; 1001 :             }
; 1002 :         } else {

  002d1	eb 2e		 jmp	 SHORT $LN26@json_get_o
$LN25@json_get_o:

; 1003 :             if (':' != src[state->offset]) {

  002d3	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  002d8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  002e1	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002e5	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  002e8	74 17		 je	 SHORT $LN28@json_get_o

; 1004 :                 state->error = json_parse_error_expected_colon;

  002ea	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  002ef	48 c7 40 50 02
	00 00 00	 mov	 QWORD PTR [rax+80], 2

; 1005 :                 return 1;

  002f7	b8 01 00 00 00	 mov	 eax, 1
  002fc	e9 c6 00 00 00	 jmp	 $LN1@json_get_o
$LN28@json_get_o:
$LN26@json_get_o:

; 1006 :             }
; 1007 :         }
; 1008 :         
; 1009 :         /* skip colon. */
; 1010 :         state->offset++;

  00301	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00306	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0030a	48 ff c0	 inc	 rax
  0030d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00312	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1011 :         
; 1012 :         if (json_skip_all_skippables(state)) {

  00316	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0031b	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  00320	85 c0		 test	 eax, eax
  00322	74 17		 je	 SHORT $LN29@json_get_o

; 1013 :             state->error = json_parse_error_premature_end_of_buffer;

  00324	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00329	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 1014 :             return 1;

  00331	b8 01 00 00 00	 mov	 eax, 1
  00336	e9 8c 00 00 00	 jmp	 $LN1@json_get_o
$LN29@json_get_o:

; 1015 :         }
; 1016 :         
; 1017 :         if (json_get_value_size(state, /* is_global_object = */ 0)) {

  0033b	33 d2		 xor	 edx, edx
  0033d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00342	e8 00 00 00 00	 call	 ?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_value_size
  00347	85 c0		 test	 eax, eax
  00349	74 07		 je	 SHORT $LN30@json_get_o

; 1018 :             /* value parsing failed! */
; 1019 :             return 1;

  0034b	b8 01 00 00 00	 mov	 eax, 1
  00350	eb 75		 jmp	 SHORT $LN1@json_get_o
$LN30@json_get_o:

; 1020 :         }
; 1021 :         
; 1022 :         /* successfully parsed a name/value pair! */
; 1023 :         elements++;

  00352	48 8b 44 24 48	 mov	 rax, QWORD PTR elements$[rsp]
  00357	48 ff c0	 inc	 rax
  0035a	48 89 44 24 48	 mov	 QWORD PTR elements$[rsp], rax

; 1024 :         allow_comma = 1;

  0035f	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR allow_comma$[rsp], 1
$LN2@json_get_o:

; 1025 :     } while (state->offset < size);

  00367	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0036c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00371	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00375	0f 82 99 fd ff
	ff		 jb	 $LN4@json_get_o
$LN3@json_get_o:

; 1026 :     
; 1027 :     if ((state->offset == size) && !is_global_object && !found_closing_brace) {

  0037b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00380	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00385	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00389	75 22		 jne	 SHORT $LN31@json_get_o
  0038b	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00390	75 1b		 jne	 SHORT $LN31@json_get_o
  00392	83 7c 24 28 00	 cmp	 DWORD PTR found_closing_brace$[rsp], 0
  00397	75 14		 jne	 SHORT $LN31@json_get_o

; 1028 :         state->error = json_parse_error_premature_end_of_buffer;

  00399	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0039e	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 1029 :         return 1;

  003a6	b8 01 00 00 00	 mov	 eax, 1
  003ab	eb 1a		 jmp	 SHORT $LN1@json_get_o
$LN31@json_get_o:

; 1030 :     }
; 1031 :     
; 1032 :     state->dom_size += sizeof(struct json_object_element_s) * elements;

  003ad	48 6b 44 24 48
	18		 imul	 rax, QWORD PTR elements$[rsp], 24
  003b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  003b8	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  003bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  003c1	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1033 :     
; 1034 :     return 0;

  003c5	33 c0		 xor	 eax, eax
$LN1@json_get_o:

; 1035 : }

  003c7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003cb	c3		 ret	 0
?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z ENDP ; json_get_object_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z
_TEXT	SEGMENT
offset$1 = 32
data_size$2 = 40
src$3 = 48
flags_bitset$ = 56
size$4 = 64
state$ = 96
?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z PROC	; json_get_key_size, COMDAT

; 853  : int json_get_key_size(struct json_parse_state_s *state) {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 854  :     const size_t flags_bitset = state->flags_bitset;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00012	48 89 44 24 38	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 855  :     
; 856  :     if (json_parse_flags_allow_unquoted_keys & flags_bitset) {

  00017	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0001c	48 83 e0 02	 and	 rax, 2
  00020	48 85 c0	 test	 rax, rax
  00023	0f 84 5a 01 00
	00		 je	 $LN4@json_get_k

; 857  :         size_t offset = state->offset;

  00029	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0002e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00032	48 89 44 24 20	 mov	 QWORD PTR offset$1[rsp], rax

; 858  :         const size_t size = state->size;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0003c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00040	48 89 44 24 40	 mov	 QWORD PTR size$4[rsp], rax

; 859  :         const char *const src = state->src;

  00045	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0004a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004d	48 89 44 24 30	 mov	 QWORD PTR src$3[rsp], rax

; 860  :         size_t data_size = state->data_size;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00057	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0005b	48 89 44 24 28	 mov	 QWORD PTR data_size$2[rsp], rax

; 861  :         
; 862  :         /* if we are allowing unquoted keys, first grok for a quote... */
; 863  :         if ('"' == src[offset]) {

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$1[rsp]
  00065	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$3[rsp]
  0006a	48 03 c8	 add	 rcx, rax
  0006d	48 8b c1	 mov	 rax, rcx
  00070	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00073	83 f8 22	 cmp	 eax, 34			; 00000022H
  00076	75 19		 jne	 SHORT $LN6@json_get_k

; 864  :             /* ... if we got a comma, just parse the key as a string as normal. */
; 865  :             return json_get_string_size(state, 1);

  00078	ba 01 00 00 00	 mov	 edx, 1
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00082	e8 00 00 00 00	 call	 ?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ; json_get_string_size
  00087	e9 06 01 00 00	 jmp	 $LN1@json_get_k
  0008c	e9 f0 00 00 00	 jmp	 $LN7@json_get_k
$LN6@json_get_k:

; 866  :         } else if ((json_parse_flags_allow_single_quoted_strings & flags_bitset) &&

  00091	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00096	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  0009c	48 85 c0	 test	 rax, rax
  0009f	74 31		 je	 SHORT $LN8@json_get_k
  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$1[rsp]
  000a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$3[rsp]
  000ab	48 03 c8	 add	 rcx, rax
  000ae	48 8b c1	 mov	 rax, rcx
  000b1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b4	83 f8 27	 cmp	 eax, 39			; 00000027H
  000b7	75 19		 jne	 SHORT $LN8@json_get_k

; 867  :                    ('\'' == src[offset])) {
; 868  :             /* ... if we got a comma, just parse the key as a string as normal. */
; 869  :             return json_get_string_size(state, 1);

  000b9	ba 01 00 00 00	 mov	 edx, 1
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000c3	e8 00 00 00 00	 call	 ?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ; json_get_string_size
  000c8	e9 c5 00 00 00	 jmp	 $LN1@json_get_k

; 870  :         } else {

  000cd	e9 af 00 00 00	 jmp	 $LN9@json_get_k
$LN8@json_get_k:
$LN2@json_get_k:

; 871  :             while ((offset < size) && is_valid_unquoted_key_char(src[offset])) {

  000d2	48 8b 44 24 40	 mov	 rax, QWORD PTR size$4[rsp]
  000d7	48 39 44 24 20	 cmp	 QWORD PTR offset$1[rsp], rax
  000dc	73 38		 jae	 SHORT $LN3@json_get_k
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$1[rsp]
  000e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$3[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000f1	e8 00 00 00 00	 call	 ?is_valid_unquoted_key_char@@YAHD@Z ; is_valid_unquoted_key_char
  000f6	85 c0		 test	 eax, eax
  000f8	74 1c		 je	 SHORT $LN3@json_get_k

; 872  :                 offset++;

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$1[rsp]
  000ff	48 ff c0	 inc	 rax
  00102	48 89 44 24 20	 mov	 QWORD PTR offset$1[rsp], rax

; 873  :                 data_size++;

  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR data_size$2[rsp]
  0010c	48 ff c0	 inc	 rax
  0010f	48 89 44 24 28	 mov	 QWORD PTR data_size$2[rsp], rax

; 874  :             }

  00114	eb bc		 jmp	 SHORT $LN2@json_get_k
$LN3@json_get_k:

; 875  :             
; 876  :             /* one more byte for null terminator ending the string! */
; 877  :             data_size++;

  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR data_size$2[rsp]
  0011b	48 ff c0	 inc	 rax
  0011e	48 89 44 24 28	 mov	 QWORD PTR data_size$2[rsp], rax

; 878  :             
; 879  :             if (json_parse_flags_allow_location_information & flags_bitset) {

  00123	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00128	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0012e	48 85 c0	 test	 rax, rax
  00131	74 18		 je	 SHORT $LN10@json_get_k

; 880  :                 state->dom_size += sizeof(struct json_string_ex_s);

  00133	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00138	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0013c	48 83 c0 28	 add	 rax, 40			; 00000028H
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00145	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 881  :             } else {

  00149	eb 16		 jmp	 SHORT $LN11@json_get_k
$LN10@json_get_k:

; 882  :                 state->dom_size += sizeof(struct json_string_s);

  0014b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00150	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00154	48 83 c0 10	 add	 rax, 16
  00158	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0015d	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN11@json_get_k:

; 883  :             }
; 884  :             
; 885  :             /* update offset. */
; 886  :             state->offset = offset;

  00161	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00166	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$1[rsp]
  0016b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 887  :             
; 888  :             /* update data_size. */
; 889  :             state->data_size = data_size;

  0016f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR data_size$2[rsp]
  00179	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 890  :             
; 891  :             return 0;

  0017d	33 c0		 xor	 eax, eax
  0017f	eb 11		 jmp	 SHORT $LN1@json_get_k
$LN9@json_get_k:
$LN7@json_get_k:

; 892  :         }
; 893  :     } else {

  00181	eb 0f		 jmp	 SHORT $LN5@json_get_k
$LN4@json_get_k:

; 894  :         /* we are only allowed to have quoted keys, so just parse a string! */
; 895  :         return json_get_string_size(state, 1);

  00183	ba 01 00 00 00	 mov	 edx, 1
  00188	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0018d	e8 00 00 00 00	 call	 ?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ; json_get_string_size
$LN5@json_get_k:
$LN1@json_get_k:

; 896  :     }
; 897  : }

  00192	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00196	c3		 ret	 0
?json_get_key_size@@YAHPEAUjson_parse_state_s@@@Z ENDP	; json_get_key_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?is_valid_unquoted_key_char@@YAHD@Z
_TEXT	SEGMENT
tv78 = 0
c$ = 32
?is_valid_unquoted_key_char@@YAHD@Z PROC		; is_valid_unquoted_key_char, COMDAT

; 847  : int is_valid_unquoted_key_char(const char c) {

$LN8:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 848  :     return (('0' <= c && c <= '9') || ('a' <= c && c <= 'z') ||

  00008	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0000d	83 f8 30	 cmp	 eax, 48			; 00000030H
  00010	7c 0a		 jl	 SHORT $LN3@is_valid_u
  00012	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00017	83 f8 39	 cmp	 eax, 57			; 00000039H
  0001a	7e 3b		 jle	 SHORT $LN5@is_valid_u
$LN3@is_valid_u:
  0001c	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00021	83 f8 61	 cmp	 eax, 97			; 00000061H
  00024	7c 0a		 jl	 SHORT $LN4@is_valid_u
  00026	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0002b	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0002e	7e 27		 jle	 SHORT $LN5@is_valid_u
$LN4@is_valid_u:
  00030	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00035	83 f8 41	 cmp	 eax, 65			; 00000041H
  00038	7c 0a		 jl	 SHORT $LN6@is_valid_u
  0003a	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0003f	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00042	7e 13		 jle	 SHORT $LN5@is_valid_u
$LN6@is_valid_u:
  00044	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00049	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0004c	74 09		 je	 SHORT $LN5@is_valid_u
  0004e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv78[rsp], 0
  00055	eb 07		 jmp	 SHORT $LN7@is_valid_u
$LN5@is_valid_u:
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv78[rsp], 1
$LN7@is_valid_u:
  0005e	8b 04 24	 mov	 eax, DWORD PTR tv78[rsp]

; 849  :             ('A' <= c && c <= 'Z') || ('_' == c));
; 850  : }

  00061	48 83 c4 18	 add	 rsp, 24
  00065	c3		 ret	 0
?is_valid_unquoted_key_char@@YAHD@Z ENDP		; is_valid_unquoted_key_char
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z
_TEXT	SEGMENT
offset$ = 32
tv73 = 40
codepoint$ = 44
quote_to_use$ = 48
src$ = 56
data_size$ = 64
tv154 = 72
high_surrogate$ = 76
tv71 = 80
is_single_quote$ = 84
tv136 = 88
size$ = 96
flags_bitset$ = 104
state$ = 128
is_key$ = 136
?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z PROC ; json_get_string_size, COMDAT

; 666  : int json_get_string_size(struct json_parse_state_s *state, size_t is_key) {

$LN57:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 667  :     size_t offset = state->offset;

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00016	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001a	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 668  :     const size_t size = state->size;

  0001f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 44 24 60	 mov	 QWORD PTR size$[rsp], rax

; 669  :     size_t data_size = 0;

  00030	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR data_size$[rsp], 0

; 670  :     const char *const src = state->src;

  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	48 89 44 24 38	 mov	 QWORD PTR src$[rsp], rax

; 671  :     const int is_single_quote = '\'' == src[offset];

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0004e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  00053	48 03 c8	 add	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005c	83 f8 27	 cmp	 eax, 39			; 00000027H
  0005f	75 0a		 jne	 SHORT $LN51@json_get_s
  00061	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  00069	eb 08		 jmp	 SHORT $LN52@json_get_s
$LN51@json_get_s:
  0006b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN52@json_get_s:
  00073	8b 44 24 50	 mov	 eax, DWORD PTR tv71[rsp]
  00077	89 44 24 54	 mov	 DWORD PTR is_single_quote$[rsp], eax

; 672  :     const char quote_to_use = is_single_quote ? '\'' : '"';

  0007b	83 7c 24 54 00	 cmp	 DWORD PTR is_single_quote$[rsp], 0
  00080	74 07		 je	 SHORT $LN53@json_get_s
  00082	c6 44 24 28 27	 mov	 BYTE PTR tv73[rsp], 39	; 00000027H
  00087	eb 05		 jmp	 SHORT $LN54@json_get_s
$LN53@json_get_s:
  00089	c6 44 24 28 22	 mov	 BYTE PTR tv73[rsp], 34	; 00000022H
$LN54@json_get_s:
  0008e	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv73[rsp]
  00093	88 44 24 30	 mov	 BYTE PTR quote_to_use$[rsp], al

; 673  :     const size_t flags_bitset = state->flags_bitset;

  00097	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0009f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a3	48 89 44 24 68	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 674  :     unsigned long codepoint;
; 675  :     unsigned long high_surrogate = 0;

  000a8	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR high_surrogate$[rsp], 0

; 676  :     
; 677  :     if ((json_parse_flags_allow_location_information & flags_bitset) != 0 &&

  000b0	48 8b 44 24 68	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  000b5	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  000bb	48 85 c0	 test	 rax, rax
  000be	74 29		 je	 SHORT $LN8@json_get_s
  000c0	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR is_key$[rsp], 0
  000c9	74 1e		 je	 SHORT $LN8@json_get_s

; 678  :         is_key != 0) {
; 679  :         state->dom_size += sizeof(struct json_string_ex_s);

  000cb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000d3	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000d7	48 83 c0 28	 add	 rax, 40			; 00000028H
  000db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000e3	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 680  :     } else {

  000e7	eb 1c		 jmp	 SHORT $LN9@json_get_s
$LN8@json_get_s:

; 681  :         state->dom_size += sizeof(struct json_string_s);

  000e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000f1	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000f5	48 83 c0 10	 add	 rax, 16
  000f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00101	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN9@json_get_s:

; 682  :     }
; 683  :     
; 684  :     if ('"' != src[offset]) {

  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0010a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  0010f	48 03 c8	 add	 rcx, rax
  00112	48 8b c1	 mov	 rax, rcx
  00115	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00118	83 f8 22	 cmp	 eax, 34			; 00000022H
  0011b	74 42		 je	 SHORT $LN10@json_get_s

; 685  :         /* if we are allowed single quoted strings check for that too. */
; 686  :         if (!((json_parse_flags_allow_single_quoted_strings & flags_bitset) &&

  0011d	48 8b 44 24 68	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00122	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  00128	48 85 c0	 test	 rax, rax
  0012b	74 07		 je	 SHORT $LN12@json_get_s
  0012d	83 7c 24 54 00	 cmp	 DWORD PTR is_single_quote$[rsp], 0
  00132	75 2b		 jne	 SHORT $LN11@json_get_s
$LN12@json_get_s:

; 687  :               is_single_quote)) {
; 688  :             state->error = json_parse_error_expected_opening_quote;

  00134	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0013c	48 c7 40 50 03
	00 00 00	 mov	 QWORD PTR [rax+80], 3

; 689  :             state->offset = offset;

  00144	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0014c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00151	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 690  :             return 1;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	e9 b6 04 00 00	 jmp	 $LN1@json_get_s
$LN11@json_get_s:
$LN10@json_get_s:

; 691  :         }
; 692  :     }
; 693  :     
; 694  :     /* skip leading '"' or '\''. */
; 695  :     offset++;

  0015f	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00164	48 ff c0	 inc	 rax
  00167	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax
$LN2@json_get_s:

; 696  :     
; 697  :     while ((offset < size) && (quote_to_use != src[offset])) {

  0016c	48 8b 44 24 60	 mov	 rax, QWORD PTR size$[rsp]
  00171	48 39 44 24 20	 cmp	 QWORD PTR offset$[rsp], rax
  00176	0f 83 0a 04 00
	00		 jae	 $LN3@json_get_s
  0017c	0f be 44 24 30	 movsx	 eax, BYTE PTR quote_to_use$[rsp]
  00181	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00186	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  0018b	48 03 d1	 add	 rdx, rcx
  0018e	48 8b ca	 mov	 rcx, rdx
  00191	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00194	3b c1		 cmp	 eax, ecx
  00196	0f 84 ea 03 00
	00		 je	 $LN3@json_get_s

; 698  :         /* add space for the character. */
; 699  :         data_size++;

  0019c	48 8b 44 24 40	 mov	 rax, QWORD PTR data_size$[rsp]
  001a1	48 ff c0	 inc	 rax
  001a4	48 89 44 24 40	 mov	 QWORD PTR data_size$[rsp], rax

; 700  :         
; 701  :         switch (src[offset]) {

  001a9	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  001b3	48 03 c8	 add	 rcx, rax
  001b6	48 8b c1	 mov	 rax, rcx
  001b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bc	88 44 24 58	 mov	 BYTE PTR tv136[rsp], al
  001c0	80 7c 24 58 00	 cmp	 BYTE PTR tv136[rsp], 0
  001c5	74 09		 je	 SHORT $LN14@json_get_s
  001c7	80 7c 24 58 09	 cmp	 BYTE PTR tv136[rsp], 9
  001cc	74 02		 je	 SHORT $LN15@json_get_s

; 702  :             default:
; 703  :             break;

  001ce	eb 2b		 jmp	 SHORT $LN4@json_get_s
$LN14@json_get_s:
$LN15@json_get_s:

; 704  :             case '\0':
; 705  :             case '\t':
; 706  :             state->error = json_parse_error_invalid_string;

  001d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001d8	48 c7 40 50 08
	00 00 00	 mov	 QWORD PTR [rax+80], 8

; 707  :             state->offset = offset;

  001e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  001ed	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 708  :             return 1;

  001f1	b8 01 00 00 00	 mov	 eax, 1
  001f6	e9 1a 04 00 00	 jmp	 $LN1@json_get_s
$LN4@json_get_s:

; 709  :         }
; 710  :         
; 711  :         if ('\\' == src[offset]) {

  001fb	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00200	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  00205	48 03 c8	 add	 rcx, rax
  00208	48 8b c1	 mov	 rax, rcx
  0020b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0020e	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00211	0f 85 e3 02 00
	00		 jne	 $LN16@json_get_s

; 712  :             /* skip reverse solidus character. */
; 713  :             offset++;

  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0021c	48 ff c0	 inc	 rax
  0021f	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 714  :             
; 715  :             if (offset == size) {

  00224	48 8b 44 24 60	 mov	 rax, QWORD PTR size$[rsp]
  00229	48 39 44 24 20	 cmp	 QWORD PTR offset$[rsp], rax
  0022e	75 2b		 jne	 SHORT $LN18@json_get_s

; 716  :                 state->error = json_parse_error_premature_end_of_buffer;

  00230	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00238	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 717  :                 state->offset = offset;

  00240	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00248	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  0024d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 718  :                 return 1;

  00251	b8 01 00 00 00	 mov	 eax, 1
  00256	e9 ba 03 00 00	 jmp	 $LN1@json_get_s
$LN18@json_get_s:

; 719  :             }
; 720  :             
; 721  :             switch (src[offset]) {

  0025b	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00260	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  00265	48 03 c8	 add	 rcx, rax
  00268	48 8b c1	 mov	 rax, rcx
  0026b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0026e	89 44 24 48	 mov	 DWORD PTR tv154[rsp], eax
  00272	8b 44 24 48	 mov	 eax, DWORD PTR tv154[rsp]
  00276	83 e8 22	 sub	 eax, 34			; 00000022H
  00279	89 44 24 48	 mov	 DWORD PTR tv154[rsp], eax
  0027d	83 7c 24 48 53	 cmp	 DWORD PTR tv154[rsp], 83 ; 00000053H
  00282	77 20		 ja	 SHORT $LN19@json_get_s
  00284	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv154[rsp]
  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00290	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN55@json_get_s[rcx+rax]
  00298	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN56@json_get_s[rcx+rax*4]
  0029f	48 03 c1	 add	 rax, rcx
  002a2	ff e0		 jmp	 rax
$LN19@json_get_s:

; 722  :                 default:
; 723  :                 state->error = json_parse_error_invalid_string_escape_sequence;

  002a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002ac	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 724  :                 state->offset = offset;

  002b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002bc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  002c1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 725  :                 return 1;

  002c5	b8 01 00 00 00	 mov	 eax, 1
  002ca	e9 46 03 00 00	 jmp	 $LN1@json_get_s
$LN20@json_get_s:
$LN21@json_get_s:
$LN22@json_get_s:
$LN23@json_get_s:
$LN24@json_get_s:
$LN25@json_get_s:
$LN26@json_get_s:
$LN27@json_get_s:

; 726  :                 case '"':
; 727  :                 case '\\':
; 728  :                 case '/':
; 729  :                 case 'b':
; 730  :                 case 'f':
; 731  :                 case 'n':
; 732  :                 case 'r':
; 733  :                 case 't':
; 734  :                 /* all valid characters! */
; 735  :                 offset++;

  002cf	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  002d4	48 ff c0	 inc	 rax
  002d7	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 736  :                 break;

  002dc	e9 14 02 00 00	 jmp	 $LN6@json_get_s
$LN28@json_get_s:

; 737  :                 case 'u':
; 738  :                 if (!(offset + 5 < size)) {

  002e1	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  002e6	48 83 c0 05	 add	 rax, 5
  002ea	48 3b 44 24 60	 cmp	 rax, QWORD PTR size$[rsp]
  002ef	72 2b		 jb	 SHORT $LN29@json_get_s

; 739  :                     /* invalid escaped unicode sequence! */
; 740  :                     state->error = json_parse_error_invalid_string_escape_sequence;

  002f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002f9	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 741  :                     state->offset = offset;

  00301	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00309	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  0030e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 742  :                     return 1;

  00312	b8 01 00 00 00	 mov	 eax, 1
  00317	e9 f9 02 00 00	 jmp	 $LN1@json_get_s
$LN29@json_get_s:

; 743  :                 }
; 744  :                 
; 745  :                 codepoint = 0;

  0031c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR codepoint$[rsp], 0

; 746  :                 if (!json_hexadecimal_value(&src[offset + 1], 4, &codepoint)) {

  00324	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  00329	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  0032e	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00333	4c 8d 44 24 2c	 lea	 r8, QWORD PTR codepoint$[rsp]
  00338	ba 04 00 00 00	 mov	 edx, 4
  0033d	48 8b c8	 mov	 rcx, rax
  00340	e8 00 00 00 00	 call	 ?json_hexadecimal_value@@YAHPEBDKPEAK@Z ; json_hexadecimal_value
  00345	85 c0		 test	 eax, eax
  00347	75 2b		 jne	 SHORT $LN30@json_get_s

; 747  :                     /* escaped unicode sequences must contain 4 hexadecimal digits! */
; 748  :                     state->error = json_parse_error_invalid_string_escape_sequence;

  00349	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00351	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 749  :                     state->offset = offset;

  00359	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00361	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00366	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 750  :                     return 1;

  0036a	b8 01 00 00 00	 mov	 eax, 1
  0036f	e9 a1 02 00 00	 jmp	 $LN1@json_get_s
$LN30@json_get_s:

; 751  :                 }
; 752  :                 
; 753  :                 /* Valid sequence!
; 754  :                  * see: https://en.wikipedia.org/wiki/UTF-8#Invalid_code_points.
; 755  :                  *      1       7       U + 0000        U + 007F        0xxxxxxx.
; 756  :                  *      2       11      U + 0080        U + 07FF        110xxxxx
; 757  :                  * 10xxxxxx.
; 758  :                  *      3       16      U + 0800        U + FFFF        1110xxxx
; 759  :                  * 10xxxxxx        10xxxxxx.
; 760  :                  *      4       21      U + 10000       U + 10FFFF      11110xxx
; 761  :                  * 10xxxxxx        10xxxxxx        10xxxxxx.
; 762  :                  * Note: the high and low surrogate halves used by UTF-16 (U+D800
; 763  :                  * through U+DFFF) and code points not encodable by UTF-16 (those after
; 764  :                  * U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must
; 765  :                  * be treated as an invalid byte sequence. */
; 766  :                 
; 767  :                 if (high_surrogate != 0) {

  00374	83 7c 24 4c 00	 cmp	 DWORD PTR high_surrogate$[rsp], 0
  00379	74 5c		 je	 SHORT $LN31@json_get_s

; 768  :                     /* we previously read the high half of the \uxxxx\uxxxx pair, so now
; 769  :                      * we expect the low half. */
; 770  :                     if (codepoint >= 0xdc00 &&

  0037b	81 7c 24 2c 00
	dc 00 00	 cmp	 DWORD PTR codepoint$[rsp], 56320 ; 0000dc00H
  00383	72 22		 jb	 SHORT $LN33@json_get_s
  00385	81 7c 24 2c ff
	df 00 00	 cmp	 DWORD PTR codepoint$[rsp], 57343 ; 0000dfffH
  0038d	77 18		 ja	 SHORT $LN33@json_get_s

; 771  :                         codepoint <= 0xdfff) { /* low surrogate range. */
; 772  :                         data_size += 3;

  0038f	48 8b 44 24 40	 mov	 rax, QWORD PTR data_size$[rsp]
  00394	48 83 c0 03	 add	 rax, 3
  00398	48 89 44 24 40	 mov	 QWORD PTR data_size$[rsp], rax

; 773  :                         high_surrogate = 0;

  0039d	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR high_surrogate$[rsp], 0

; 774  :                     } else {

  003a5	eb 2b		 jmp	 SHORT $LN34@json_get_s
$LN33@json_get_s:

; 775  :                         state->error = json_parse_error_invalid_string_escape_sequence;

  003a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003af	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 776  :                         state->offset = offset;

  003b7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  003c4	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 777  :                         return 1;

  003c8	b8 01 00 00 00	 mov	 eax, 1
  003cd	e9 43 02 00 00	 jmp	 $LN1@json_get_s
$LN34@json_get_s:

; 778  :                     }

  003d2	e9 10 01 00 00	 jmp	 $LN32@json_get_s
$LN31@json_get_s:

; 779  :                 } else if (codepoint <= 0x7f) {

  003d7	83 7c 24 2c 7f	 cmp	 DWORD PTR codepoint$[rsp], 127 ; 0000007fH
  003dc	77 0f		 ja	 SHORT $LN35@json_get_s

; 780  :                     data_size += 0;

  003de	48 8b 44 24 40	 mov	 rax, QWORD PTR data_size$[rsp]
  003e3	48 89 44 24 40	 mov	 QWORD PTR data_size$[rsp], rax
  003e8	e9 fa 00 00 00	 jmp	 $LN36@json_get_s
$LN35@json_get_s:

; 781  :                 } else if (codepoint <= 0x7ff) {

  003ed	81 7c 24 2c ff
	07 00 00	 cmp	 DWORD PTR codepoint$[rsp], 2047 ; 000007ffH
  003f5	77 12		 ja	 SHORT $LN37@json_get_s

; 782  :                     data_size += 1;

  003f7	48 8b 44 24 40	 mov	 rax, QWORD PTR data_size$[rsp]
  003fc	48 ff c0	 inc	 rax
  003ff	48 89 44 24 40	 mov	 QWORD PTR data_size$[rsp], rax
  00404	e9 de 00 00 00	 jmp	 $LN38@json_get_s
$LN37@json_get_s:

; 783  :                 } else if (codepoint >= 0xd800 &&

  00409	81 7c 24 2c 00
	d8 00 00	 cmp	 DWORD PTR codepoint$[rsp], 55296 ; 0000d800H
  00411	0f 82 81 00 00
	00		 jb	 $LN39@json_get_s
  00417	81 7c 24 2c ff
	db 00 00	 cmp	 DWORD PTR codepoint$[rsp], 56319 ; 0000dbffH
  0041f	77 77		 ja	 SHORT $LN39@json_get_s

; 784  :                            codepoint <= 0xdbff) { /* high surrogate range. */
; 785  :                     /* The codepoint is the first half of a "utf-16 surrogate pair". so we
; 786  :                      * need the other half for it to be valid: \uHHHH\uLLLL. */
; 787  :                     if (offset + 11 > size || '\\' != src[offset + 5] ||

  00421	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00426	48 83 c0 0b	 add	 rax, 11
  0042a	48 3b 44 24 60	 cmp	 rax, QWORD PTR size$[rsp]
  0042f	77 32		 ja	 SHORT $LN42@json_get_s
  00431	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00436	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  0043b	48 03 c8	 add	 rcx, rax
  0043e	48 8b c1	 mov	 rax, rcx
  00441	0f be 40 05	 movsx	 eax, BYTE PTR [rax+5]
  00445	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00448	75 19		 jne	 SHORT $LN42@json_get_s
  0044a	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0044f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  00454	48 03 c8	 add	 rcx, rax
  00457	48 8b c1	 mov	 rax, rcx
  0045a	0f be 40 06	 movsx	 eax, BYTE PTR [rax+6]
  0045e	83 f8 75	 cmp	 eax, 117		; 00000075H
  00461	74 2b		 je	 SHORT $LN41@json_get_s
$LN42@json_get_s:

; 788  :                         'u' != src[offset + 6]) {
; 789  :                         state->error = json_parse_error_invalid_string_escape_sequence;

  00463	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0046b	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 790  :                         state->offset = offset;

  00473	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0047b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00480	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 791  :                         return 1;

  00484	b8 01 00 00 00	 mov	 eax, 1
  00489	e9 87 01 00 00	 jmp	 $LN1@json_get_s
$LN41@json_get_s:

; 792  :                     }
; 793  :                     high_surrogate = codepoint;

  0048e	8b 44 24 2c	 mov	 eax, DWORD PTR codepoint$[rsp]
  00492	89 44 24 4c	 mov	 DWORD PTR high_surrogate$[rsp], eax
  00496	eb 4f		 jmp	 SHORT $LN40@json_get_s
$LN39@json_get_s:

; 794  :                 } else if (codepoint >= 0xd800 &&

  00498	81 7c 24 2c 00
	d8 00 00	 cmp	 DWORD PTR codepoint$[rsp], 55296 ; 0000d800H
  004a0	72 37		 jb	 SHORT $LN43@json_get_s
  004a2	81 7c 24 2c ff
	df 00 00	 cmp	 DWORD PTR codepoint$[rsp], 57343 ; 0000dfffH
  004aa	77 2d		 ja	 SHORT $LN43@json_get_s

; 795  :                            codepoint <= 0xdfff) { /* low surrogate range. */
; 796  :                     /* we did not read the other half before. */
; 797  :                     state->error = json_parse_error_invalid_string_escape_sequence;

  004ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004b4	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 798  :                     state->offset = offset;

  004bc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  004c9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 799  :                     return 1;

  004cd	b8 01 00 00 00	 mov	 eax, 1
  004d2	e9 3e 01 00 00	 jmp	 $LN1@json_get_s

; 800  :                 } else {

  004d7	eb 0e		 jmp	 SHORT $LN44@json_get_s
$LN43@json_get_s:

; 801  :                     data_size += 2;

  004d9	48 8b 44 24 40	 mov	 rax, QWORD PTR data_size$[rsp]
  004de	48 83 c0 02	 add	 rax, 2
  004e2	48 89 44 24 40	 mov	 QWORD PTR data_size$[rsp], rax
$LN44@json_get_s:
$LN40@json_get_s:
$LN38@json_get_s:
$LN36@json_get_s:
$LN32@json_get_s:

; 802  :                 }
; 803  :                 /* escaped codepoints after 0xffff are supported in json through utf-16
; 804  :                  * surrogate pairs: \uD83D\uDD25 for U+1F525. */
; 805  :                 
; 806  :                 offset += 5;

  004e7	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  004ec	48 83 c0 05	 add	 rax, 5
  004f0	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax
$LN6@json_get_s:

; 807  :                 break;
; 808  :             }
; 809  :         } else if (('\r' == src[offset]) || ('\n' == src[offset])) {

  004f5	e9 87 00 00 00	 jmp	 $LN17@json_get_s
$LN16@json_get_s:
  004fa	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  004ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  00504	48 03 c8	 add	 rcx, rax
  00507	48 8b c1	 mov	 rax, rcx
  0050a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0050d	83 f8 0d	 cmp	 eax, 13
  00510	74 18		 je	 SHORT $LN47@json_get_s
  00512	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00517	48 8b 4c 24 38	 mov	 rcx, QWORD PTR src$[rsp]
  0051c	48 03 c8	 add	 rcx, rax
  0051f	48 8b c1	 mov	 rax, rcx
  00522	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00525	83 f8 0a	 cmp	 eax, 10
  00528	75 4a		 jne	 SHORT $LN45@json_get_s
$LN47@json_get_s:

; 810  :             if (!(json_parse_flags_allow_multi_line_strings & flags_bitset)) {

  0052a	48 8b 44 24 68	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0052f	48 25 00 20 00
	00		 and	 rax, 8192		; 00002000H
  00535	48 85 c0	 test	 rax, rax
  00538	75 2b		 jne	 SHORT $LN48@json_get_s

; 811  :                 /* invalid escaped unicode sequence! */
; 812  :                 state->error = json_parse_error_invalid_string_escape_sequence;

  0053a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00542	48 c7 40 50 04
	00 00 00	 mov	 QWORD PTR [rax+80], 4

; 813  :                 state->offset = offset;

  0054a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00552	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00557	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 814  :                 return 1;

  0055b	b8 01 00 00 00	 mov	 eax, 1
  00560	e9 b0 00 00 00	 jmp	 $LN1@json_get_s
$LN48@json_get_s:

; 815  :             }
; 816  :             
; 817  :             offset++;

  00565	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0056a	48 ff c0	 inc	 rax
  0056d	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 818  :         } else {

  00572	eb 0d		 jmp	 SHORT $LN46@json_get_s
$LN45@json_get_s:

; 819  :             /* skip character (valid part of sequence). */
; 820  :             offset++;

  00574	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00579	48 ff c0	 inc	 rax
  0057c	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax
$LN46@json_get_s:
$LN17@json_get_s:

; 821  :         }
; 822  :     }

  00581	e9 e6 fb ff ff	 jmp	 $LN2@json_get_s
$LN3@json_get_s:

; 823  :     
; 824  :     /* If the offset is equal to the size, we had a non-terminated string! */
; 825  :     if (offset == size) {

  00586	48 8b 44 24 60	 mov	 rax, QWORD PTR size$[rsp]
  0058b	48 39 44 24 20	 cmp	 QWORD PTR offset$[rsp], rax
  00590	75 2b		 jne	 SHORT $LN49@json_get_s

; 826  :         state->error = json_parse_error_premature_end_of_buffer;

  00592	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0059a	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 827  :         state->offset = offset - 1;

  005a2	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  005a7	48 ff c8	 dec	 rax
  005aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  005b2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 828  :         return 1;

  005b6	b8 01 00 00 00	 mov	 eax, 1
  005bb	eb 58		 jmp	 SHORT $LN1@json_get_s
$LN49@json_get_s:

; 829  :     }
; 830  :     
; 831  :     /* skip trailing '"' or '\''. */
; 832  :     offset++;

  005bd	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  005c2	48 ff c0	 inc	 rax
  005c5	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 833  :     
; 834  :     /* add enough space to store the string. */
; 835  :     state->data_size += data_size;

  005ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005d2	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  005d6	48 03 44 24 40	 add	 rax, QWORD PTR data_size$[rsp]
  005db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  005e3	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 836  :     
; 837  :     /* one more byte for null terminator ending the string! */
; 838  :     state->data_size++;

  005e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005ef	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  005f3	48 ff c0	 inc	 rax
  005f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  005fe	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 839  :     
; 840  :     /* update offset. */
; 841  :     state->offset = offset;

  00602	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0060a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  0060f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 842  :     
; 843  :     return 0;

  00613	33 c0		 xor	 eax, eax
$LN1@json_get_s:

; 844  : }

  00615	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00619	c3		 ret	 0
  0061a	66 90		 npad	 2
$LN56@json_get_s:
  0061c	00 00 00 00	 DD	 $LN20@json_get_s
  00620	00 00 00 00	 DD	 $LN22@json_get_s
  00624	00 00 00 00	 DD	 $LN21@json_get_s
  00628	00 00 00 00	 DD	 $LN23@json_get_s
  0062c	00 00 00 00	 DD	 $LN24@json_get_s
  00630	00 00 00 00	 DD	 $LN25@json_get_s
  00634	00 00 00 00	 DD	 $LN26@json_get_s
  00638	00 00 00 00	 DD	 $LN27@json_get_s
  0063c	00 00 00 00	 DD	 $LN28@json_get_s
  00640	00 00 00 00	 DD	 $LN19@json_get_s
$LN55@json_get_s:
  00644	00		 DB	 0
  00645	09		 DB	 9
  00646	09		 DB	 9
  00647	09		 DB	 9
  00648	09		 DB	 9
  00649	09		 DB	 9
  0064a	09		 DB	 9
  0064b	09		 DB	 9
  0064c	09		 DB	 9
  0064d	09		 DB	 9
  0064e	09		 DB	 9
  0064f	09		 DB	 9
  00650	09		 DB	 9
  00651	01		 DB	 1
  00652	09		 DB	 9
  00653	09		 DB	 9
  00654	09		 DB	 9
  00655	09		 DB	 9
  00656	09		 DB	 9
  00657	09		 DB	 9
  00658	09		 DB	 9
  00659	09		 DB	 9
  0065a	09		 DB	 9
  0065b	09		 DB	 9
  0065c	09		 DB	 9
  0065d	09		 DB	 9
  0065e	09		 DB	 9
  0065f	09		 DB	 9
  00660	09		 DB	 9
  00661	09		 DB	 9
  00662	09		 DB	 9
  00663	09		 DB	 9
  00664	09		 DB	 9
  00665	09		 DB	 9
  00666	09		 DB	 9
  00667	09		 DB	 9
  00668	09		 DB	 9
  00669	09		 DB	 9
  0066a	09		 DB	 9
  0066b	09		 DB	 9
  0066c	09		 DB	 9
  0066d	09		 DB	 9
  0066e	09		 DB	 9
  0066f	09		 DB	 9
  00670	09		 DB	 9
  00671	09		 DB	 9
  00672	09		 DB	 9
  00673	09		 DB	 9
  00674	09		 DB	 9
  00675	09		 DB	 9
  00676	09		 DB	 9
  00677	09		 DB	 9
  00678	09		 DB	 9
  00679	09		 DB	 9
  0067a	09		 DB	 9
  0067b	09		 DB	 9
  0067c	09		 DB	 9
  0067d	09		 DB	 9
  0067e	02		 DB	 2
  0067f	09		 DB	 9
  00680	09		 DB	 9
  00681	09		 DB	 9
  00682	09		 DB	 9
  00683	09		 DB	 9
  00684	03		 DB	 3
  00685	09		 DB	 9
  00686	09		 DB	 9
  00687	09		 DB	 9
  00688	04		 DB	 4
  00689	09		 DB	 9
  0068a	09		 DB	 9
  0068b	09		 DB	 9
  0068c	09		 DB	 9
  0068d	09		 DB	 9
  0068e	09		 DB	 9
  0068f	09		 DB	 9
  00690	05		 DB	 5
  00691	09		 DB	 9
  00692	09		 DB	 9
  00693	09		 DB	 9
  00694	06		 DB	 6
  00695	09		 DB	 9
  00696	07		 DB	 7
  00697	08		 DB	 8
?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ENDP ; json_get_string_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z
_TEXT	SEGMENT
tv87 = 32
offset$ = 40
src$ = 48
flags_bitset$ = 56
size$ = 64
state$ = 96
is_global_object$ = 104
?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z PROC ; json_get_value_size, COMDAT

; 1320 :                         int is_global_object) {

$LN45:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1321 :     const size_t flags_bitset = state->flags_bitset;

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00012	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00016	48 89 44 24 38	 mov	 QWORD PTR flags_bitset$[rsp], rax

; 1322 :     const char *const src = state->src;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	48 89 44 24 30	 mov	 QWORD PTR src$[rsp], rax

; 1323 :     size_t offset;
; 1324 :     const size_t size = state->size;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0002d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00031	48 89 44 24 40	 mov	 QWORD PTR size$[rsp], rax

; 1325 :     
; 1326 :     if (json_parse_flags_allow_location_information & flags_bitset) {

  00036	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0003b	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00041	48 85 c0	 test	 rax, rax
  00044	74 18		 je	 SHORT $LN4@json_get_v

; 1327 :         state->dom_size += sizeof(struct json_value_ex_s);

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0004b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00058	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1328 :     } else {

  0005c	eb 16		 jmp	 SHORT $LN5@json_get_v
$LN4@json_get_v:

; 1329 :         state->dom_size += sizeof(struct json_value_s);

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00063	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00067	48 83 c0 10	 add	 rax, 16
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00070	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN5@json_get_v:

; 1330 :     }
; 1331 :     
; 1332 :     if (is_global_object) {

  00074	83 7c 24 68 00	 cmp	 DWORD PTR is_global_object$[rsp], 0
  00079	74 19		 je	 SHORT $LN6@json_get_v

; 1333 :         return json_get_object_size(state, /* is_global_object = */ 1);

  0007b	ba 01 00 00 00	 mov	 edx, 1
  00080	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00085	e8 00 00 00 00	 call	 ?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_object_size
  0008a	e9 e2 04 00 00	 jmp	 $LN1@json_get_v

; 1334 :     } else {

  0008f	e9 dd 04 00 00	 jmp	 $LN7@json_get_v
$LN6@json_get_v:

; 1335 :         if (json_skip_all_skippables(state)) {

  00094	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00099	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables
  0009e	85 c0		 test	 eax, eax
  000a0	74 17		 je	 SHORT $LN8@json_get_v

; 1336 :             state->error = json_parse_error_premature_end_of_buffer;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000a7	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 1337 :             return 1;

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	e9 b8 04 00 00	 jmp	 $LN1@json_get_v
$LN8@json_get_v:

; 1338 :         }
; 1339 :         
; 1340 :         /* can cache offset now. */
; 1341 :         offset = state->offset;

  000b9	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000be	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c2	48 89 44 24 28	 mov	 QWORD PTR offset$[rsp], rax

; 1342 :         
; 1343 :         switch (src[offset]) {

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  000cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000da	89 44 24 20	 mov	 DWORD PTR tv87[rsp], eax
  000de	8b 44 24 20	 mov	 eax, DWORD PTR tv87[rsp]
  000e2	83 e8 22	 sub	 eax, 34			; 00000022H
  000e5	89 44 24 20	 mov	 DWORD PTR tv87[rsp], eax
  000e9	83 7c 24 20 59	 cmp	 DWORD PTR tv87[rsp], 89	; 00000059H
  000ee	0f 87 0a 01 00
	00		 ja	 $LN32@json_get_v
  000f4	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv87[rsp]
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00100	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN43@json_get_v[rcx+rax]
  00108	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN44@json_get_v[rcx+rax*4]
  0010f	48 03 c1	 add	 rax, rcx
  00112	ff e0		 jmp	 rax
$LN9@json_get_v:

; 1344 :             case '"':
; 1345 :             return json_get_string_size(state, 0);

  00114	33 d2		 xor	 edx, edx
  00116	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0011b	e8 00 00 00 00	 call	 ?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ; json_get_string_size
  00120	e9 4c 04 00 00	 jmp	 $LN1@json_get_v
$LN10@json_get_v:

; 1346 :             case '\'':
; 1347 :             if (json_parse_flags_allow_single_quoted_strings & flags_bitset) {

  00125	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0012a	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  00130	48 85 c0	 test	 rax, rax
  00133	74 13		 je	 SHORT $LN11@json_get_v

; 1348 :                 return json_get_string_size(state, 0);

  00135	33 d2		 xor	 edx, edx
  00137	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0013c	e8 00 00 00 00	 call	 ?json_get_string_size@@YAHPEAUjson_parse_state_s@@_K@Z ; json_get_string_size
  00141	e9 2b 04 00 00	 jmp	 $LN1@json_get_v

; 1349 :             } else {

  00146	eb 17		 jmp	 SHORT $LN12@json_get_v
$LN11@json_get_v:

; 1350 :                 /* invalid value! */
; 1351 :                 state->error = json_parse_error_invalid_value;

  00148	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0014d	48 c7 40 50 06
	00 00 00	 mov	 QWORD PTR [rax+80], 6

; 1352 :                 return 1;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	e9 12 04 00 00	 jmp	 $LN1@json_get_v
$LN12@json_get_v:
$LN13@json_get_v:

; 1353 :             }
; 1354 :             case '{':
; 1355 :             return json_get_object_size(state, /* is_global_object = */ 0);

  0015f	33 d2		 xor	 edx, edx
  00161	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00166	e8 00 00 00 00	 call	 ?json_get_object_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_object_size
  0016b	e9 01 04 00 00	 jmp	 $LN1@json_get_v
$LN14@json_get_v:

; 1356 :             case '[':
; 1357 :             return json_get_array_size(state);

  00170	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00175	e8 00 00 00 00	 call	 ?json_get_array_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_array_size
  0017a	e9 f2 03 00 00	 jmp	 $LN1@json_get_v
$LN15@json_get_v:
$LN16@json_get_v:
$LN17@json_get_v:
$LN18@json_get_v:
$LN19@json_get_v:
$LN20@json_get_v:
$LN21@json_get_v:
$LN22@json_get_v:
$LN23@json_get_v:
$LN24@json_get_v:
$LN25@json_get_v:

; 1358 :             case '-':
; 1359 :             case '0':
; 1360 :             case '1':
; 1361 :             case '2':
; 1362 :             case '3':
; 1363 :             case '4':
; 1364 :             case '5':
; 1365 :             case '6':
; 1366 :             case '7':
; 1367 :             case '8':
; 1368 :             case '9':
; 1369 :             return json_get_number_size(state);

  0017f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00184	e8 00 00 00 00	 call	 ?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_number_size
  00189	e9 e3 03 00 00	 jmp	 $LN1@json_get_v
$LN26@json_get_v:

; 1370 :             case '+':
; 1371 :             if (json_parse_flags_allow_leading_plus_sign & flags_bitset) {

  0018e	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  00193	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00199	48 85 c0	 test	 rax, rax
  0019c	74 11		 je	 SHORT $LN27@json_get_v

; 1372 :                 return json_get_number_size(state);

  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001a3	e8 00 00 00 00	 call	 ?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_number_size
  001a8	e9 c4 03 00 00	 jmp	 $LN1@json_get_v

; 1373 :             } else {

  001ad	eb 17		 jmp	 SHORT $LN28@json_get_v
$LN27@json_get_v:

; 1374 :                 /* invalid value! */
; 1375 :                 state->error = json_parse_error_invalid_number_format;

  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001b4	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1376 :                 return 1;

  001bc	b8 01 00 00 00	 mov	 eax, 1
  001c1	e9 ab 03 00 00	 jmp	 $LN1@json_get_v
$LN28@json_get_v:
$LN29@json_get_v:

; 1377 :             }
; 1378 :             case '.':
; 1379 :             if (json_parse_flags_allow_leading_or_trailing_decimal_point &

  001c6	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  001cb	48 25 00 08 00
	00		 and	 rax, 2048		; 00000800H
  001d1	48 85 c0	 test	 rax, rax
  001d4	74 11		 je	 SHORT $LN30@json_get_v

; 1380 :                 flags_bitset) {
; 1381 :                 return json_get_number_size(state);

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001db	e8 00 00 00 00	 call	 ?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_number_size
  001e0	e9 8c 03 00 00	 jmp	 $LN1@json_get_v

; 1382 :             } else {

  001e5	eb 17		 jmp	 SHORT $LN31@json_get_v
$LN30@json_get_v:

; 1383 :                 /* invalid value! */
; 1384 :                 state->error = json_parse_error_invalid_number_format;

  001e7	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001ec	48 c7 40 50 05
	00 00 00	 mov	 QWORD PTR [rax+80], 5

; 1385 :                 return 1;

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	e9 73 03 00 00	 jmp	 $LN1@json_get_v
$LN31@json_get_v:
$LN32@json_get_v:

; 1386 :             }
; 1387 :             default:
; 1388 :             if ((offset + 4) <= size && 't' == src[offset + 0] &&
; 1389 :                 'r' == src[offset + 1] && 'u' == src[offset + 2] &&

  001fe	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00203	48 83 c0 04	 add	 rax, 4
  00207	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  0020c	0f 87 85 00 00
	00		 ja	 $LN33@json_get_v
  00212	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00217	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0021c	48 03 c8	 add	 rcx, rax
  0021f	48 8b c1	 mov	 rax, rcx
  00222	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00225	83 f8 74	 cmp	 eax, 116		; 00000074H
  00228	75 6d		 jne	 SHORT $LN33@json_get_v
  0022a	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0022f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00234	48 03 c8	 add	 rcx, rax
  00237	48 8b c1	 mov	 rax, rcx
  0023a	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0023e	83 f8 72	 cmp	 eax, 114		; 00000072H
  00241	75 54		 jne	 SHORT $LN33@json_get_v
  00243	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00248	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0024d	48 03 c8	 add	 rcx, rax
  00250	48 8b c1	 mov	 rax, rcx
  00253	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00257	83 f8 75	 cmp	 eax, 117		; 00000075H
  0025a	75 3b		 jne	 SHORT $LN33@json_get_v
  0025c	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00261	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00266	48 03 c8	 add	 rcx, rax
  00269	48 8b c1	 mov	 rax, rcx
  0026c	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  00270	83 f8 65	 cmp	 eax, 101		; 00000065H
  00273	75 22		 jne	 SHORT $LN33@json_get_v

; 1390 :                 'e' == src[offset + 3]) {
; 1391 :                 state->offset += 4;

  00275	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0027a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0027e	48 83 c0 04	 add	 rax, 4
  00282	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00287	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1392 :                 return 0;

  0028b	33 c0		 xor	 eax, eax
  0028d	e9 df 02 00 00	 jmp	 $LN1@json_get_v

; 1393 :             } else if ((offset + 5) <= size && 'f' == src[offset + 0] &&

  00292	e9 c8 02 00 00	 jmp	 $LN34@json_get_v
$LN33@json_get_v:

; 1394 :                        'a' == src[offset + 1] && 'l' == src[offset + 2] &&
; 1395 :                        's' == src[offset + 3] && 'e' == src[offset + 4]) {

  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0029c	48 83 c0 05	 add	 rax, 5
  002a0	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  002a5	0f 87 a2 00 00
	00		 ja	 $LN35@json_get_v
  002ab	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  002b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  002b5	48 03 c8	 add	 rcx, rax
  002b8	48 8b c1	 mov	 rax, rcx
  002bb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002be	83 f8 66	 cmp	 eax, 102		; 00000066H
  002c1	0f 85 86 00 00
	00		 jne	 $LN35@json_get_v
  002c7	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  002cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  002d1	48 03 c8	 add	 rcx, rax
  002d4	48 8b c1	 mov	 rax, rcx
  002d7	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  002db	83 f8 61	 cmp	 eax, 97			; 00000061H
  002de	75 6d		 jne	 SHORT $LN35@json_get_v
  002e0	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  002e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  002ea	48 03 c8	 add	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  002f4	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  002f7	75 54		 jne	 SHORT $LN35@json_get_v
  002f9	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  002fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00303	48 03 c8	 add	 rcx, rax
  00306	48 8b c1	 mov	 rax, rcx
  00309	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  0030d	83 f8 73	 cmp	 eax, 115		; 00000073H
  00310	75 3b		 jne	 SHORT $LN35@json_get_v
  00312	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00317	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0031c	48 03 c8	 add	 rcx, rax
  0031f	48 8b c1	 mov	 rax, rcx
  00322	0f be 40 04	 movsx	 eax, BYTE PTR [rax+4]
  00326	83 f8 65	 cmp	 eax, 101		; 00000065H
  00329	75 22		 jne	 SHORT $LN35@json_get_v

; 1396 :                 state->offset += 5;

  0032b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00330	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00334	48 83 c0 05	 add	 rax, 5
  00338	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0033d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1397 :                 return 0;

  00341	33 c0		 xor	 eax, eax
  00343	e9 29 02 00 00	 jmp	 $LN1@json_get_v

; 1398 :             } else if ((offset + 4) <= size && 'n' == state->src[offset + 0] &&

  00348	e9 12 02 00 00	 jmp	 $LN36@json_get_v
$LN35@json_get_v:

; 1399 :                        'u' == state->src[offset + 1] &&
; 1400 :                        'l' == state->src[offset + 2] &&

  0034d	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00352	48 83 c0 04	 add	 rax, 4
  00356	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  0035b	77 7d		 ja	 SHORT $LN37@json_get_v
  0035d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00362	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00365	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$[rsp]
  0036a	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0036e	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00371	75 67		 jne	 SHORT $LN37@json_get_v
  00373	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00378	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0037b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$[rsp]
  00380	0f be 44 08 01	 movsx	 eax, BYTE PTR [rax+rcx+1]
  00385	83 f8 75	 cmp	 eax, 117		; 00000075H
  00388	75 50		 jne	 SHORT $LN37@json_get_v
  0038a	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0038f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00392	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$[rsp]
  00397	0f be 44 08 02	 movsx	 eax, BYTE PTR [rax+rcx+2]
  0039c	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  0039f	75 39		 jne	 SHORT $LN37@json_get_v
  003a1	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  003a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$[rsp]
  003ae	0f be 44 08 03	 movsx	 eax, BYTE PTR [rax+rcx+3]
  003b3	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  003b6	75 22		 jne	 SHORT $LN37@json_get_v

; 1401 :                        'l' == state->src[offset + 3]) {
; 1402 :                 state->offset += 4;

  003b8	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  003bd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  003c1	48 83 c0 04	 add	 rax, 4
  003c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  003ca	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1403 :                 return 0;

  003ce	33 c0		 xor	 eax, eax
  003d0	e9 9c 01 00 00	 jmp	 $LN1@json_get_v

; 1404 :             } else if ((json_parse_flags_allow_inf_and_nan & flags_bitset) &&

  003d5	e9 85 01 00 00	 jmp	 $LN38@json_get_v
$LN37@json_get_v:

; 1405 :                        (offset + 3) <= size && 'N' == src[offset + 0] &&
; 1406 :                        'a' == src[offset + 1] && 'N' == src[offset + 2]) {

  003da	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  003df	48 25 00 10 00
	00		 and	 rax, 4096		; 00001000H
  003e5	48 85 c0	 test	 rax, rax
  003e8	74 6e		 je	 SHORT $LN39@json_get_v
  003ea	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  003ef	48 83 c0 03	 add	 rax, 3
  003f3	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  003f8	77 5e		 ja	 SHORT $LN39@json_get_v
  003fa	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  003ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00404	48 03 c8	 add	 rcx, rax
  00407	48 8b c1	 mov	 rax, rcx
  0040a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0040d	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00410	75 46		 jne	 SHORT $LN39@json_get_v
  00412	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00417	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0041c	48 03 c8	 add	 rcx, rax
  0041f	48 8b c1	 mov	 rax, rcx
  00422	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00426	83 f8 61	 cmp	 eax, 97			; 00000061H
  00429	75 2d		 jne	 SHORT $LN39@json_get_v
  0042b	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00430	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00435	48 03 c8	 add	 rcx, rax
  00438	48 8b c1	 mov	 rax, rcx
  0043b	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  0043f	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00442	75 14		 jne	 SHORT $LN39@json_get_v

; 1407 :                 return json_get_number_size(state);

  00444	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00449	e8 00 00 00 00	 call	 ?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_number_size
  0044e	e9 1e 01 00 00	 jmp	 $LN1@json_get_v

; 1408 :             } else if ((json_parse_flags_allow_inf_and_nan & flags_bitset) &&

  00453	e9 07 01 00 00	 jmp	 $LN40@json_get_v
$LN39@json_get_v:

; 1409 :                        (offset + 8) <= size && 'I' == src[offset + 0] &&
; 1410 :                        'n' == src[offset + 1] && 'f' == src[offset + 2] &&
; 1411 :                        'i' == src[offset + 3] && 'n' == src[offset + 4] &&
; 1412 :                        'i' == src[offset + 5] && 't' == src[offset + 6] &&

  00458	48 8b 44 24 38	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  0045d	48 25 00 10 00
	00		 and	 rax, 4096		; 00001000H
  00463	48 85 c0	 test	 rax, rax
  00466	0f 84 f3 00 00
	00		 je	 $LN41@json_get_v
  0046c	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00471	48 83 c0 08	 add	 rax, 8
  00475	48 3b 44 24 40	 cmp	 rax, QWORD PTR size$[rsp]
  0047a	0f 87 df 00 00
	00		 ja	 $LN41@json_get_v
  00480	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00485	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0048a	48 03 c8	 add	 rcx, rax
  0048d	48 8b c1	 mov	 rax, rcx
  00490	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00493	83 f8 49	 cmp	 eax, 73			; 00000049H
  00496	0f 85 c3 00 00
	00		 jne	 $LN41@json_get_v
  0049c	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  004a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  004a6	48 03 c8	 add	 rcx, rax
  004a9	48 8b c1	 mov	 rax, rcx
  004ac	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  004b0	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  004b3	0f 85 a6 00 00
	00		 jne	 $LN41@json_get_v
  004b9	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  004be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  004c3	48 03 c8	 add	 rcx, rax
  004c6	48 8b c1	 mov	 rax, rcx
  004c9	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  004cd	83 f8 66	 cmp	 eax, 102		; 00000066H
  004d0	0f 85 89 00 00
	00		 jne	 $LN41@json_get_v
  004d6	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  004db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  004e0	48 03 c8	 add	 rcx, rax
  004e3	48 8b c1	 mov	 rax, rcx
  004e6	0f be 40 03	 movsx	 eax, BYTE PTR [rax+3]
  004ea	83 f8 69	 cmp	 eax, 105		; 00000069H
  004ed	75 70		 jne	 SHORT $LN41@json_get_v
  004ef	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  004f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  004f9	48 03 c8	 add	 rcx, rax
  004fc	48 8b c1	 mov	 rax, rcx
  004ff	0f be 40 04	 movsx	 eax, BYTE PTR [rax+4]
  00503	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00506	75 57		 jne	 SHORT $LN41@json_get_v
  00508	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0050d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00512	48 03 c8	 add	 rcx, rax
  00515	48 8b c1	 mov	 rax, rcx
  00518	0f be 40 05	 movsx	 eax, BYTE PTR [rax+5]
  0051c	83 f8 69	 cmp	 eax, 105		; 00000069H
  0051f	75 3e		 jne	 SHORT $LN41@json_get_v
  00521	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  00526	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  0052b	48 03 c8	 add	 rcx, rax
  0052e	48 8b c1	 mov	 rax, rcx
  00531	0f be 40 06	 movsx	 eax, BYTE PTR [rax+6]
  00535	83 f8 74	 cmp	 eax, 116		; 00000074H
  00538	75 25		 jne	 SHORT $LN41@json_get_v
  0053a	48 8b 44 24 28	 mov	 rax, QWORD PTR offset$[rsp]
  0053f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$[rsp]
  00544	48 03 c8	 add	 rcx, rax
  00547	48 8b c1	 mov	 rax, rcx
  0054a	0f be 40 07	 movsx	 eax, BYTE PTR [rax+7]
  0054e	83 f8 79	 cmp	 eax, 121		; 00000079H
  00551	75 0c		 jne	 SHORT $LN41@json_get_v

; 1413 :                        'y' == src[offset + 7]) {
; 1414 :                 return json_get_number_size(state);

  00553	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00558	e8 00 00 00 00	 call	 ?json_get_number_size@@YAHPEAUjson_parse_state_s@@@Z ; json_get_number_size
  0055d	eb 12		 jmp	 SHORT $LN1@json_get_v
$LN41@json_get_v:
$LN40@json_get_v:
$LN38@json_get_v:
$LN36@json_get_v:
$LN34@json_get_v:

; 1415 :             }
; 1416 :             
; 1417 :             /* invalid value! */
; 1418 :             state->error = json_parse_error_invalid_value;

  0055f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00564	48 c7 40 50 06
	00 00 00	 mov	 QWORD PTR [rax+80], 6

; 1419 :             return 1;

  0056c	b8 01 00 00 00	 mov	 eax, 1
$LN7@json_get_v:
$LN1@json_get_v:

; 1420 :         }
; 1421 :     }
; 1422 : }

  00571	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00575	c3		 ret	 0
  00576	66 90		 npad	 2
$LN44@json_get_v:
  00578	00 00 00 00	 DD	 $LN9@json_get_v
  0057c	00 00 00 00	 DD	 $LN10@json_get_v
  00580	00 00 00 00	 DD	 $LN26@json_get_v
  00584	00 00 00 00	 DD	 $LN15@json_get_v
  00588	00 00 00 00	 DD	 $LN29@json_get_v
  0058c	00 00 00 00	 DD	 $LN16@json_get_v
  00590	00 00 00 00	 DD	 $LN17@json_get_v
  00594	00 00 00 00	 DD	 $LN18@json_get_v
  00598	00 00 00 00	 DD	 $LN19@json_get_v
  0059c	00 00 00 00	 DD	 $LN20@json_get_v
  005a0	00 00 00 00	 DD	 $LN21@json_get_v
  005a4	00 00 00 00	 DD	 $LN22@json_get_v
  005a8	00 00 00 00	 DD	 $LN23@json_get_v
  005ac	00 00 00 00	 DD	 $LN24@json_get_v
  005b0	00 00 00 00	 DD	 $LN25@json_get_v
  005b4	00 00 00 00	 DD	 $LN14@json_get_v
  005b8	00 00 00 00	 DD	 $LN13@json_get_v
  005bc	00 00 00 00	 DD	 $LN32@json_get_v
$LN43@json_get_v:
  005c0	00		 DB	 0
  005c1	11		 DB	 17
  005c2	11		 DB	 17
  005c3	11		 DB	 17
  005c4	11		 DB	 17
  005c5	01		 DB	 1
  005c6	11		 DB	 17
  005c7	11		 DB	 17
  005c8	11		 DB	 17
  005c9	02		 DB	 2
  005ca	11		 DB	 17
  005cb	03		 DB	 3
  005cc	04		 DB	 4
  005cd	11		 DB	 17
  005ce	05		 DB	 5
  005cf	06		 DB	 6
  005d0	07		 DB	 7
  005d1	08		 DB	 8
  005d2	09		 DB	 9
  005d3	0a		 DB	 10
  005d4	0b		 DB	 11
  005d5	0c		 DB	 12
  005d6	0d		 DB	 13
  005d7	0e		 DB	 14
  005d8	11		 DB	 17
  005d9	11		 DB	 17
  005da	11		 DB	 17
  005db	11		 DB	 17
  005dc	11		 DB	 17
  005dd	11		 DB	 17
  005de	11		 DB	 17
  005df	11		 DB	 17
  005e0	11		 DB	 17
  005e1	11		 DB	 17
  005e2	11		 DB	 17
  005e3	11		 DB	 17
  005e4	11		 DB	 17
  005e5	11		 DB	 17
  005e6	11		 DB	 17
  005e7	11		 DB	 17
  005e8	11		 DB	 17
  005e9	11		 DB	 17
  005ea	11		 DB	 17
  005eb	11		 DB	 17
  005ec	11		 DB	 17
  005ed	11		 DB	 17
  005ee	11		 DB	 17
  005ef	11		 DB	 17
  005f0	11		 DB	 17
  005f1	11		 DB	 17
  005f2	11		 DB	 17
  005f3	11		 DB	 17
  005f4	11		 DB	 17
  005f5	11		 DB	 17
  005f6	11		 DB	 17
  005f7	11		 DB	 17
  005f8	11		 DB	 17
  005f9	0f		 DB	 15
  005fa	11		 DB	 17
  005fb	11		 DB	 17
  005fc	11		 DB	 17
  005fd	11		 DB	 17
  005fe	11		 DB	 17
  005ff	11		 DB	 17
  00600	11		 DB	 17
  00601	11		 DB	 17
  00602	11		 DB	 17
  00603	11		 DB	 17
  00604	11		 DB	 17
  00605	11		 DB	 17
  00606	11		 DB	 17
  00607	11		 DB	 17
  00608	11		 DB	 17
  00609	11		 DB	 17
  0060a	11		 DB	 17
  0060b	11		 DB	 17
  0060c	11		 DB	 17
  0060d	11		 DB	 17
  0060e	11		 DB	 17
  0060f	11		 DB	 17
  00610	11		 DB	 17
  00611	11		 DB	 17
  00612	11		 DB	 17
  00613	11		 DB	 17
  00614	11		 DB	 17
  00615	11		 DB	 17
  00616	11		 DB	 17
  00617	11		 DB	 17
  00618	11		 DB	 17
  00619	10		 DB	 16
?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z ENDP ; json_get_value_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z
_TEXT	SEGMENT
did_consume$ = 32
size$ = 40
state$ = 64
?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z PROC ; json_skip_all_skippables, COMDAT

; 615  : int json_skip_all_skippables(struct json_parse_state_s *state) {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 616  :     /* skip all whitespace and other skippables until there are none left. note
; 617  :      * that the previous version suffered from read past errors should. the
; 618  :      * stream end on json_skip_c_style_comments eg. '{"a" ' with comments flag.
; 619  :      */
; 620  :     
; 621  :     int did_consume = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR did_consume$[rsp], 0

; 622  :     const size_t size = state->size;

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 623  :     
; 624  :     if (json_parse_flags_allow_c_style_comments & state->flags_bitset) {

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00024	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00028	48 83 e0 20	 and	 rax, 32			; 00000020H
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 78		 je	 SHORT $LN8@json_skip_
$LN4@json_skip_:

; 625  :         do {
; 626  :             if (state->offset == size) {

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  0003b	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  0003f	75 17		 jne	 SHORT $LN10@json_skip_

; 627  :                 state->error = json_parse_error_premature_end_of_buffer;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00046	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 628  :                 return 1;

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	e9 b0 00 00 00	 jmp	 $LN1@json_skip_
$LN10@json_skip_:

; 629  :             }
; 630  :             
; 631  :             did_consume = json_skip_whitespace(state);

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0005d	e8 00 00 00 00	 call	 ?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_whitespace
  00062	89 44 24 20	 mov	 DWORD PTR did_consume$[rsp], eax

; 632  :             
; 633  :             /* This should really be checked on access, not in front of every call.
; 634  :              */
; 635  :             if (state->offset >= size) {

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  00070	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00074	72 14		 jb	 SHORT $LN11@json_skip_

; 636  :                 state->error = json_parse_error_premature_end_of_buffer;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0007b	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 637  :                 return 1;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	eb 7e		 jmp	 SHORT $LN1@json_skip_
$LN11@json_skip_:

; 638  :             }
; 639  :             
; 640  :             did_consume |= json_skip_c_style_comments(state);

  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0008f	e8 00 00 00 00	 call	 ?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_c_style_comments
  00094	8b 4c 24 20	 mov	 ecx, DWORD PTR did_consume$[rsp]
  00098	0b c8		 or	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	89 44 24 20	 mov	 DWORD PTR did_consume$[rsp], eax

; 641  :         } while (0 != did_consume);

  000a0	83 7c 24 20 00	 cmp	 DWORD PTR did_consume$[rsp], 0
  000a5	75 8a		 jne	 SHORT $LN4@json_skip_

; 642  :     } else {

  000a7	eb 39		 jmp	 SHORT $LN9@json_skip_
$LN8@json_skip_:
$LN7@json_skip_:

; 643  :         do {
; 644  :             if (state->offset == size) {

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000ae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  000b3	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000b7	75 14		 jne	 SHORT $LN12@json_skip_

; 645  :                 state->error = json_parse_error_premature_end_of_buffer;

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000be	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 646  :                 return 1;

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	eb 3b		 jmp	 SHORT $LN1@json_skip_
$LN12@json_skip_:

; 647  :             }
; 648  :             
; 649  :             did_consume = json_skip_whitespace(state);

  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000d2	e8 00 00 00 00	 call	 ?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_whitespace
  000d7	89 44 24 20	 mov	 DWORD PTR did_consume$[rsp], eax

; 650  :         } while (0 != did_consume);

  000db	83 7c 24 20 00	 cmp	 DWORD PTR did_consume$[rsp], 0
  000e0	75 c7		 jne	 SHORT $LN7@json_skip_
$LN9@json_skip_:

; 651  :     }
; 652  :     
; 653  :     if (state->offset == size) {

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000e7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  000ec	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000f0	75 14		 jne	 SHORT $LN13@json_skip_

; 654  :         state->error = json_parse_error_premature_end_of_buffer;

  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000f7	48 c7 40 50 07
	00 00 00	 mov	 QWORD PTR [rax+80], 7

; 655  :         return 1;

  000ff	b8 01 00 00 00	 mov	 eax, 1
  00104	eb 02		 jmp	 SHORT $LN1@json_skip_
$LN13@json_skip_:

; 656  :     }
; 657  :     
; 658  :     return 0;

  00106	33 c0		 xor	 eax, eax
$LN1@json_skip_:

; 659  : }

  00108	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010c	c3		 ret	 0
?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ENDP ; json_skip_all_skippables
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z
_TEXT	SEGMENT
tv129 = 0
state$ = 32
?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z PROC ; json_skip_c_style_comments, COMDAT

; 544  : int json_skip_c_style_comments(struct json_parse_state_s *state) {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 545  :     /* to have a C-style comment we need at least 2 characters of space */
; 546  :     if ((state->offset + 2) > state->size) {

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00012	48 83 c0 02	 add	 rax, 2
  00016	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0001b	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  0001f	76 07		 jbe	 SHORT $LN8@json_skip_

; 547  :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	e9 2a 02 00 00	 jmp	 $LN1@json_skip_
$LN8@json_skip_:

; 548  :     }
; 549  :     
; 550  :     /* do we have a comment? */
; 551  :     if ('/' == state->src[state->offset]) {

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0002d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00036	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00039	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003d	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00040	0f 85 0a 02 00
	00		 jne	 $LN9@json_skip_

; 552  :         if ('/' == state->src[state->offset + 1]) {

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00054	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00057	0f be 44 01 01	 movsx	 eax, BYTE PTR [rcx+rax+1]
  0005c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0005f	0f 85 d1 00 00
	00		 jne	 $LN10@json_skip_

; 553  :             /* we had a comment of the form // */
; 554  :             
; 555  :             /* skip first '/' */
; 556  :             state->offset++;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0006e	48 ff c0	 inc	 rax
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00076	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 557  :             
; 558  :             /* skip second '/' */
; 559  :             state->offset++;

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00083	48 ff c0	 inc	 rax
  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0008b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN2@json_skip_:

; 560  :             
; 561  :             while (state->offset < state->size) {

  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00094	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00099	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0009d	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000a1	0f 83 80 00 00
	00		 jae	 $LN3@json_skip_

; 562  :                 switch (state->src[state->offset]) {

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ac	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000b5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000b8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000bc	88 04 24	 mov	 BYTE PTR tv129[rsp], al
  000bf	80 3c 24 0a	 cmp	 BYTE PTR tv129[rsp], 10
  000c3	74 17		 je	 SHORT $LN13@json_skip_

; 563  :                     default:
; 564  :                     /* skip the character in the comment */
; 565  :                     state->offset++;

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ca	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ce	48 ff c0	 inc	 rax
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000d6	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 566  :                     break;

  000da	eb 46		 jmp	 SHORT $LN4@json_skip_
$LN13@json_skip_:

; 567  :                     case '\n':
; 568  :                     /* if we have a newline, our comment has ended! Skip the newline */
; 569  :                     state->offset++;

  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e5	48 ff c0	 inc	 rax
  000e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000ed	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 570  :                     
; 571  :                     /* we entered a newline, so move our line info forward */
; 572  :                     state->line_no++;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f6	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000fa	48 ff c0	 inc	 rax
  000fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00102	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 573  :                     state->line_offset = state->offset;

  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0010b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00110	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00114	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 574  :                     return 1;

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	e9 30 01 00 00	 jmp	 $LN1@json_skip_
$LN4@json_skip_:

; 575  :                 }
; 576  :             }

  00122	e9 68 ff ff ff	 jmp	 $LN2@json_skip_
$LN3@json_skip_:

; 577  :             
; 578  :             /* we reached the end of the JSON file! */
; 579  :             return 1;

  00127	b8 01 00 00 00	 mov	 eax, 1
  0012c	e9 21 01 00 00	 jmp	 $LN1@json_skip_
  00131	e9 1a 01 00 00	 jmp	 $LN11@json_skip_
$LN10@json_skip_:

; 580  :         } else if ('*' == state->src[state->offset + 1]) {

  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0013b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0013f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00144	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00147	0f be 44 01 01	 movsx	 eax, BYTE PTR [rcx+rax+1]
  0014c	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0014f	0f 85 fb 00 00
	00		 jne	 $LN14@json_skip_

; 581  :             /* we had a comment in the C-style long form */
; 582  :             
; 583  :             /* skip '/' */
; 584  :             state->offset++;

  00155	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0015a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0015e	48 ff c0	 inc	 rax
  00161	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00166	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 585  :             
; 586  :             /* skip '*' */
; 587  :             state->offset++;

  0016a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0016f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00173	48 ff c0	 inc	 rax
  00176	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0017b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN6@json_skip_:

; 588  :             
; 589  :             while (state->offset + 1 < state->size) {

  0017f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00184	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00188	48 ff c0	 inc	 rax
  0018b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00190	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  00194	0f 83 af 00 00
	00		 jae	 $LN7@json_skip_

; 590  :                 if (('*' == state->src[state->offset]) &&

  0019a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0019f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001a8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ab	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  001af	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  001b2	75 3a		 jne	 SHORT $LN15@json_skip_
  001b4	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001b9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001c2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001c5	0f be 44 01 01	 movsx	 eax, BYTE PTR [rcx+rax+1]
  001ca	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  001cd	75 1f		 jne	 SHORT $LN15@json_skip_

; 591  :                     ('/' == state->src[state->offset + 1])) {
; 592  :                     /* we reached the end of our comment! */
; 593  :                     state->offset += 2;

  001cf	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001d4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001d8	48 83 c0 02	 add	 rax, 2
  001dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001e1	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 594  :                     return 1;

  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	eb 66		 jmp	 SHORT $LN1@json_skip_
  001ec	eb 41		 jmp	 SHORT $LN16@json_skip_
$LN15@json_skip_:

; 595  :                 } else if ('\n' == state->src[state->offset]) {

  001ee	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001f3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001f7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001fc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001ff	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00203	83 f8 0a	 cmp	 eax, 10
  00206	75 27		 jne	 SHORT $LN17@json_skip_

; 596  :                     /* we entered a newline, so move our line info forward */
; 597  :                     state->line_no++;

  00208	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0020d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00211	48 ff c0	 inc	 rax
  00214	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00219	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 598  :                     state->line_offset = state->offset;

  0021d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00222	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00227	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0022b	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx
$LN17@json_skip_:
$LN16@json_skip_:

; 599  :                 }
; 600  :                 
; 601  :                 /* skip character within comment */
; 602  :                 state->offset++;

  0022f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00234	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00238	48 ff c0	 inc	 rax
  0023b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00240	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 603  :             }

  00244	e9 36 ff ff ff	 jmp	 $LN6@json_skip_
$LN7@json_skip_:

; 604  :             
; 605  :             /* comment wasn't ended correctly which is a failure */
; 606  :             return 1;

  00249	b8 01 00 00 00	 mov	 eax, 1
  0024e	eb 02		 jmp	 SHORT $LN1@json_skip_
$LN14@json_skip_:
$LN11@json_skip_:
$LN9@json_skip_:

; 607  :         }
; 608  :     }
; 609  :     
; 610  :     /* we didn't have any comment, which is ok too! */
; 611  :     return 0;

  00250	33 c0		 xor	 eax, eax
$LN1@json_skip_:

; 612  : }

  00252	48 83 c4 18	 add	 rsp, 24
  00256	c3		 ret	 0
?json_skip_c_style_comments@@YAHPEAUjson_parse_state_s@@@Z ENDP ; json_skip_c_style_comments
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z
_TEXT	SEGMENT
tv72 = 0
tv82 = 4
offset$ = 8
src$ = 16
size$ = 24
state$ = 48
?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z PROC ; json_skip_whitespace, COMDAT

; 498  : int json_skip_whitespace(struct json_parse_state_s *state) {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :     size_t offset = state->offset;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0000e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00012	48 89 44 24 08	 mov	 QWORD PTR offset$[rsp], rax

; 500  :     const size_t size = state->size;

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	48 89 44 24 18	 mov	 QWORD PTR size$[rsp], rax

; 501  :     const char *const src = state->src;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 44 24 10	 mov	 QWORD PTR src$[rsp], rax

; 502  :     
; 503  :     if (offset >= state->size) {

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00037	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003b	48 39 44 24 08	 cmp	 QWORD PTR offset$[rsp], rax
  00040	72 07		 jb	 SHORT $LN9@json_skip_

; 504  :         return 0;

  00042	33 c0		 xor	 eax, eax
  00044	e9 d2 00 00 00	 jmp	 $LN1@json_skip_
$LN9@json_skip_:

; 505  :     }
; 506  :     
; 507  :     /* the only valid whitespace according to ECMA-404 is ' ', '\n', '\r' and
; 508  :      * '\t'. */
; 509  :     switch (src[offset]) {

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR offset$[rsp]
  0004e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR src$[rsp]
  00053	48 03 c8	 add	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005c	88 04 24	 mov	 BYTE PTR tv72[rsp], al
  0005f	80 3c 24 09	 cmp	 BYTE PTR tv72[rsp], 9
  00063	74 19		 je	 SHORT $LN13@json_skip_
  00065	80 3c 24 0a	 cmp	 BYTE PTR tv72[rsp], 10
  00069	74 13		 je	 SHORT $LN14@json_skip_
  0006b	80 3c 24 0d	 cmp	 BYTE PTR tv72[rsp], 13
  0006f	74 0d		 je	 SHORT $LN12@json_skip_
  00071	80 3c 24 20	 cmp	 BYTE PTR tv72[rsp], 32	; 00000020H
  00075	74 07		 je	 SHORT $LN11@json_skip_

; 510  :         default:
; 511  :         return 0;

  00077	33 c0		 xor	 eax, eax
  00079	e9 9d 00 00 00	 jmp	 $LN1@json_skip_
$LN11@json_skip_:
$LN12@json_skip_:
$LN13@json_skip_:
$LN14@json_skip_:
$LN6@json_skip_:

; 512  :         case ' ':
; 513  :         case '\r':
; 514  :         case '\t':
; 515  :         case '\n':
; 516  :         break;
; 517  :     }
; 518  :     
; 519  :     do {
; 520  :         switch (src[offset]) {

  0007e	48 8b 44 24 08	 mov	 rax, QWORD PTR offset$[rsp]
  00083	48 8b 4c 24 10	 mov	 rcx, QWORD PTR src$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00091	88 44 24 04	 mov	 BYTE PTR tv82[rsp], al
  00095	80 7c 24 04 09	 cmp	 BYTE PTR tv82[rsp], 9
  0009a	74 2a		 je	 SHORT $LN18@json_skip_
  0009c	80 7c 24 04 0a	 cmp	 BYTE PTR tv82[rsp], 10
  000a1	74 25		 je	 SHORT $LN19@json_skip_
  000a3	80 7c 24 04 0d	 cmp	 BYTE PTR tv82[rsp], 13
  000a8	74 1c		 je	 SHORT $LN17@json_skip_
  000aa	80 7c 24 04 20	 cmp	 BYTE PTR tv82[rsp], 32	; 00000020H
  000af	74 15		 je	 SHORT $LN16@json_skip_

; 521  :             default:
; 522  :             /* Update offset. */
; 523  :             state->offset = offset;

  000b1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR offset$[rsp]
  000bb	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 524  :             return 1;

  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	eb 55		 jmp	 SHORT $LN1@json_skip_
$LN16@json_skip_:
$LN17@json_skip_:
$LN18@json_skip_:

; 525  :             case ' ':
; 526  :             case '\r':
; 527  :             case '\t':
; 528  :             break;

  000c6	eb 23		 jmp	 SHORT $LN7@json_skip_
$LN19@json_skip_:

; 529  :             case '\n':
; 530  :             state->line_no++;

  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000cd	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000d1	48 ff c0	 inc	 rax
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000d9	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 531  :             state->line_offset = offset;

  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000e2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR offset$[rsp]
  000e7	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx
$LN7@json_skip_:

; 532  :             break;
; 533  :         }
; 534  :         
; 535  :         offset++;

  000eb	48 8b 44 24 08	 mov	 rax, QWORD PTR offset$[rsp]
  000f0	48 ff c0	 inc	 rax
  000f3	48 89 44 24 08	 mov	 QWORD PTR offset$[rsp], rax

; 536  :     } while (offset < size);

  000f8	48 8b 44 24 18	 mov	 rax, QWORD PTR size$[rsp]
  000fd	48 39 44 24 08	 cmp	 QWORD PTR offset$[rsp], rax
  00102	0f 82 76 ff ff
	ff		 jb	 $LN6@json_skip_

; 537  :     
; 538  :     /* Update offset. */
; 539  :     state->offset = offset;

  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0010d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR offset$[rsp]
  00112	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 540  :     return 1;

  00116	b8 01 00 00 00	 mov	 eax, 1
$LN1@json_skip_:

; 541  : }

  0011b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011f	c3		 ret	 0
?json_skip_whitespace@@YAHPEAUjson_parse_state_s@@@Z ENDP ; json_skip_whitespace
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_hexadecimal_value@@YAHPEBDKPEAK@Z
_TEXT	SEGMENT
digit$ = 32
p$ = 40
c$ = 64
size$ = 72
result$ = 80
?json_hexadecimal_value@@YAHPEBDKPEAK@Z PROC		; json_hexadecimal_value, COMDAT

; 477  :                            unsigned long *result) {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 478  :     const char *p;
; 479  :     int digit;
; 480  :     
; 481  :     if (size > sizeof(unsigned long) * 2) {

  00012	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00016	48 83 f8 08	 cmp	 rax, 8
  0001a	76 07		 jbe	 SHORT $LN5@json_hexad

; 482  :         return 0;

  0001c	33 c0		 xor	 eax, eax
  0001e	e9 8c 00 00 00	 jmp	 $LN1@json_hexad
$LN5@json_hexad:

; 483  :     }
; 484  :     
; 485  :     *result = 0;

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  00028	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 486  :     for (p = c; (unsigned long)(p - c) < size; ++p) {

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00033	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  00038	eb 0d		 jmp	 SHORT $LN4@json_hexad
$LN2@json_hexad:
  0003a	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0003f	48 ff c0	 inc	 rax
  00042	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN4@json_hexad:
  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00051	48 2b c8	 sub	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	3b 44 24 48	 cmp	 eax, DWORD PTR size$[rsp]
  0005b	73 4d		 jae	 SHORT $LN3@json_hexad

; 487  :         *result <<= 4;

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  00062	8b 00		 mov	 eax, DWORD PTR [rax]
  00064	c1 e0 04	 shl	 eax, 4
  00067	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  0006c	89 01		 mov	 DWORD PTR [rcx], eax

; 488  :         digit = json_hexadecimal_digit(*p);

  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00073	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00076	e8 00 00 00 00	 call	 ?json_hexadecimal_digit@@YAHD@Z ; json_hexadecimal_digit
  0007b	89 44 24 20	 mov	 DWORD PTR digit$[rsp], eax

; 489  :         if (digit < 0 || digit > 15) {

  0007f	83 7c 24 20 00	 cmp	 DWORD PTR digit$[rsp], 0
  00084	7c 07		 jl	 SHORT $LN7@json_hexad
  00086	83 7c 24 20 0f	 cmp	 DWORD PTR digit$[rsp], 15
  0008b	7e 04		 jle	 SHORT $LN6@json_hexad
$LN7@json_hexad:

; 490  :             return 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 1e		 jmp	 SHORT $LN1@json_hexad
$LN6@json_hexad:

; 491  :         }
; 492  :         *result |= (unsigned char)digit;

  00091	0f b6 44 24 20	 movzx	 eax, BYTE PTR digit$[rsp]
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0009d	0b c8		 or	 ecx, eax
  0009f	8b c1		 mov	 eax, ecx
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  000a6	89 01		 mov	 DWORD PTR [rcx], eax

; 493  :     }

  000a8	eb 90		 jmp	 SHORT $LN2@json_hexad
$LN3@json_hexad:

; 494  :     return 1;

  000aa	b8 01 00 00 00	 mov	 eax, 1
$LN1@json_hexad:

; 495  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?json_hexadecimal_value@@YAHPEBDKPEAK@Z ENDP		; json_hexadecimal_value
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT ?json_hexadecimal_digit@@YAHD@Z
_TEXT	SEGMENT
c$ = 8
?json_hexadecimal_digit@@YAHD@Z PROC			; json_hexadecimal_digit, COMDAT

; 461  : int json_hexadecimal_digit(const char c) {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 462  :     if ('0' <= c && c <= '9') {

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 30	 cmp	 eax, 48			; 00000030H
  0000c	7c 14		 jl	 SHORT $LN2@json_hexad
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 39	 cmp	 eax, 57			; 00000039H
  00016	7f 0a		 jg	 SHORT $LN2@json_hexad

; 463  :         return c - '0';

  00018	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  0001d	83 e8 30	 sub	 eax, 48			; 00000030H
  00020	eb 41		 jmp	 SHORT $LN1@json_hexad
$LN2@json_hexad:

; 464  :     }
; 465  :     if ('a' <= c && c <= 'f') {

  00022	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00027	83 f8 61	 cmp	 eax, 97			; 00000061H
  0002a	7c 14		 jl	 SHORT $LN3@json_hexad
  0002c	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00031	83 f8 66	 cmp	 eax, 102		; 00000066H
  00034	7f 0a		 jg	 SHORT $LN3@json_hexad

; 466  :         return c - 'a' + 10;

  00036	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  0003b	83 e8 57	 sub	 eax, 87			; 00000057H
  0003e	eb 23		 jmp	 SHORT $LN1@json_hexad
$LN3@json_hexad:

; 467  :     }
; 468  :     if ('A' <= c && c <= 'F') {

  00040	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00045	83 f8 41	 cmp	 eax, 65			; 00000041H
  00048	7c 14		 jl	 SHORT $LN4@json_hexad
  0004a	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  0004f	83 f8 46	 cmp	 eax, 70			; 00000046H
  00052	7f 0a		 jg	 SHORT $LN4@json_hexad

; 469  :         return c - 'A' + 10;

  00054	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00059	83 e8 37	 sub	 eax, 55			; 00000037H
  0005c	eb 05		 jmp	 SHORT $LN1@json_hexad
$LN4@json_hexad:

; 470  :     }
; 471  :     return -1;

  0005e	b8 ff ff ff ff	 mov	 eax, -1
$LN1@json_hexad:

; 472  : }

  00063	c3		 ret	 0
?json_hexadecimal_digit@@YAHD@Z ENDP			; json_hexadecimal_digit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT json_value_as_array
_TEXT	SEGMENT
value$ = 8
json_value_as_array PROC				; COMDAT

; 2422 : struct json_array_s *json_value_as_array(struct json_value_s *const value) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2423 :     if (value->type != json_type_array) {

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0000a	48 83 78 08 03	 cmp	 QWORD PTR [rax+8], 3
  0000f	74 04		 je	 SHORT $LN2@json_value

; 2424 :         return json_null;

  00011	33 c0		 xor	 eax, eax
  00013	eb 08		 jmp	 SHORT $LN1@json_value
$LN2@json_value:

; 2425 :     }
; 2426 :     
; 2427 :     return (struct json_array_s *)value->payload;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@json_value:

; 2428 : }

  0001d	c3		 ret	 0
json_value_as_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT json_value_as_object
_TEXT	SEGMENT
value$ = 8
json_value_as_object PROC				; COMDAT

; 2414 : struct json_object_s *json_value_as_object(struct json_value_s *const value) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2415 :     if (value->type != json_type_object) {

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0000a	48 83 78 08 02	 cmp	 QWORD PTR [rax+8], 2
  0000f	74 04		 je	 SHORT $LN2@json_value

; 2416 :         return json_null;

  00011	33 c0		 xor	 eax, eax
  00013	eb 08		 jmp	 SHORT $LN1@json_value
$LN2@json_value:

; 2417 :     }
; 2418 :     
; 2419 :     return (struct json_object_s *)value->payload;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@json_value:

; 2420 : }

  0001d	c3		 ret	 0
json_value_as_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT json_value_as_number
_TEXT	SEGMENT
value$ = 8
json_value_as_number PROC				; COMDAT

; 2406 : struct json_number_s *json_value_as_number(struct json_value_s *const value) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2407 :     if (value->type != json_type_number) {

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0000a	48 83 78 08 01	 cmp	 QWORD PTR [rax+8], 1
  0000f	74 04		 je	 SHORT $LN2@json_value

; 2408 :         return json_null;

  00011	33 c0		 xor	 eax, eax
  00013	eb 08		 jmp	 SHORT $LN1@json_value
$LN2@json_value:

; 2409 :     }
; 2410 :     
; 2411 :     return (struct json_number_s *)value->payload;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@json_value:

; 2412 : }

  0001d	c3		 ret	 0
json_value_as_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT json_value_as_string
_TEXT	SEGMENT
value$ = 8
json_value_as_string PROC				; COMDAT

; 2398 : struct json_string_s *json_value_as_string(struct json_value_s *const value) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2399 :     if (value->type != json_type_string) {

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0000a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0000f	74 04		 je	 SHORT $LN2@json_value

; 2400 :         return json_null;

  00011	33 c0		 xor	 eax, eax
  00013	eb 08		 jmp	 SHORT $LN1@json_value
$LN2@json_value:

; 2401 :     }
; 2402 :     
; 2403 :     return (struct json_string_s *)value->payload;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR value$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN1@json_value:

; 2404 : }

  0001d	c3		 ret	 0
json_value_as_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT json_parse_ex
_TEXT	SEGMENT
input_error$ = 32
value_ex$1 = 40
allocation$ = 48
state$ = 64
total_size$ = 160
value$ = 168
src$ = 192
src_size$ = 200
flags_bitset$ = 208
alloc_func_ptr$ = 216
user_data$ = 224
result$ = 232
json_parse_ex PROC					; COMDAT

; 2027 :               void *user_data, struct json_parse_result_s *result) {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2028 :     struct json_parse_state_s state;
; 2029 :     void *allocation;
; 2030 :     struct json_value_s *value;
; 2031 :     size_t total_size;
; 2032 :     int input_error;
; 2033 :     
; 2034 :     if (result) {

  0001b	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  00024	74 3f		 je	 SHORT $LN2@json_parse

; 2035 :         result->error = json_parse_error_none;

  00026	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  0002e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2036 :         result->error_offset = 0;

  00035	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  0003d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 2037 :         result->error_line_no = 0;

  00045	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  0004d	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 2038 :         result->error_row_no = 0;

  00055	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  0005d	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN2@json_parse:

; 2039 :     }
; 2040 :     
; 2041 :     if (json_null == src) {

  00065	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR src$[rsp], 0
  0006e	75 07		 jne	 SHORT $LN3@json_parse

; 2042 :         /* invalid src pointer was null! */
; 2043 :         return json_null;

  00070	33 c0		 xor	 eax, eax
  00072	e9 bb 02 00 00	 jmp	 $LN1@json_parse
$LN3@json_parse:

; 2044 :     }
; 2045 :     
; 2046 :     state.src = (const char *)src;

  00077	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR src$[rsp]
  0007f	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax

; 2047 :     state.size = src_size;

  00084	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR src_size$[rsp]
  0008c	48 89 44 24 48	 mov	 QWORD PTR state$[rsp+8], rax

; 2048 :     state.offset = 0;

  00091	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR state$[rsp+16], 0

; 2049 :     state.line_no = 1;

  0009a	48 c7 84 24 80
	00 00 00 01 00
	00 00		 mov	 QWORD PTR state$[rsp+64], 1

; 2050 :     state.line_offset = 0;

  000a6	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR state$[rsp+72], 0

; 2051 :     state.error = json_parse_error_none;

  000b2	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR state$[rsp+80], 0

; 2052 :     state.dom_size = 0;

  000be	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR state$[rsp+48], 0

; 2053 :     state.data_size = 0;

  000c7	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR state$[rsp+56], 0

; 2054 :     state.flags_bitset = flags_bitset;

  000d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR flags_bitset$[rsp]
  000d8	48 89 44 24 58	 mov	 QWORD PTR state$[rsp+24], rax

; 2055 :     
; 2056 :     input_error = json_get_value_size(

  000dd	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp+24]
  000e2	48 83 e0 04	 and	 rax, 4
  000e6	8b d0		 mov	 edx, eax
  000e8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  000ed	e8 00 00 00 00	 call	 ?json_get_value_size@@YAHPEAUjson_parse_state_s@@H@Z ; json_get_value_size
  000f2	89 44 24 20	 mov	 DWORD PTR input_error$[rsp], eax

; 2057 :                                       &state, (int)(json_parse_flags_allow_global_object & state.flags_bitset));
; 2058 :     
; 2059 :     if (0 == input_error) {

  000f6	83 7c 24 20 00	 cmp	 DWORD PTR input_error$[rsp], 0
  000fb	75 2a		 jne	 SHORT $LN4@json_parse

; 2060 :         json_skip_all_skippables(&state);

  000fd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  00102	e8 00 00 00 00	 call	 ?json_skip_all_skippables@@YAHPEAUjson_parse_state_s@@@Z ; json_skip_all_skippables

; 2061 :         
; 2062 :         if (state.offset != state.size) {

  00107	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp+8]
  0010c	48 39 44 24 50	 cmp	 QWORD PTR state$[rsp+16], rax
  00111	74 14		 je	 SHORT $LN5@json_parse

; 2063 :             /* our parsing didn't have an error, but there are characters remaining in
; 2064 :              * the input that weren't part of the JSON! */
; 2065 :             
; 2066 :             state.error = json_parse_error_unexpected_trailing_characters;

  00113	48 c7 84 24 90
	00 00 00 0a 00
	00 00		 mov	 QWORD PTR state$[rsp+80], 10

; 2067 :             input_error = 1;

  0011f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR input_error$[rsp], 1
$LN5@json_parse:
$LN4@json_parse:

; 2068 :         }
; 2069 :     }
; 2070 :     
; 2071 :     if (input_error) {

  00127	83 7c 24 20 00	 cmp	 DWORD PTR input_error$[rsp], 0
  0012c	74 69		 je	 SHORT $LN6@json_parse

; 2072 :         /* parsing value's size failed (most likely an invalid JSON DOM!). */
; 2073 :         if (result) {

  0012e	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  00137	74 57		 je	 SHORT $LN7@json_parse

; 2074 :             result->error = state.error;

  00139	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00141	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp+80]
  00149	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2075 :             result->error_offset = state.offset;

  0014c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00154	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp+16]
  00159	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2076 :             result->error_line_no = state.line_no;

  0015d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00165	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp+64]
  0016d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2077 :             result->error_row_no = state.offset - state.line_offset;

  00171	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp+72]
  00179	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp+16]
  0017e	48 2b c8	 sub	 rcx, rax
  00181	48 8b c1	 mov	 rax, rcx
  00184	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0018c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN7@json_parse:

; 2078 :         }
; 2079 :         return json_null;

  00190	33 c0		 xor	 eax, eax
  00192	e9 9b 01 00 00	 jmp	 $LN1@json_parse
$LN6@json_parse:

; 2080 :     }
; 2081 :     
; 2082 :     /* our total allocation is the combination of the dom and data sizes (we. */
; 2083 :     /* first encode the structure of the JSON, and then the data referenced by. */
; 2084 :     /* the JSON values). */
; 2085 :     total_size = state.dom_size + state.data_size;

  00197	48 8b 44 24 78	 mov	 rax, QWORD PTR state$[rsp+56]
  0019c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp+48]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	48 8b c1	 mov	 rax, rcx
  001a7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR total_size$[rsp], rax

; 2086 :     
; 2087 :     if (json_null == alloc_func_ptr) {

  001af	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR alloc_func_ptr$[rsp], 0
  001b8	75 14		 jne	 SHORT $LN8@json_parse

; 2088 :         allocation = malloc(total_size);

  001ba	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR total_size$[rsp]
  001c2	e8 00 00 00 00	 call	 malloc
  001c7	48 89 44 24 30	 mov	 QWORD PTR allocation$[rsp], rax

; 2089 :     } else {

  001cc	eb 1c		 jmp	 SHORT $LN9@json_parse
$LN8@json_parse:

; 2090 :         allocation = alloc_func_ptr(user_data, total_size);

  001ce	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR total_size$[rsp]
  001d6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR user_data$[rsp]
  001de	ff 94 24 d8 00
	00 00		 call	 QWORD PTR alloc_func_ptr$[rsp]
  001e5	48 89 44 24 30	 mov	 QWORD PTR allocation$[rsp], rax
$LN9@json_parse:

; 2091 :     }
; 2092 :     
; 2093 :     if (json_null == allocation) {

  001ea	48 83 7c 24 30
	00		 cmp	 QWORD PTR allocation$[rsp], 0
  001f0	75 51		 jne	 SHORT $LN10@json_parse

; 2094 :         /* malloc failed! */
; 2095 :         if (result) {

  001f2	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  001fb	74 3f		 je	 SHORT $LN11@json_parse

; 2096 :             result->error = json_parse_error_allocator_failed;

  001fd	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00205	48 c7 00 09 00
	00 00		 mov	 QWORD PTR [rax], 9

; 2097 :             result->error_offset = 0;

  0020c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00214	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 2098 :             result->error_line_no = 0;

  0021c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00224	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 2099 :             result->error_row_no = 0;

  0022c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00234	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
$LN11@json_parse:

; 2100 :         }
; 2101 :         
; 2102 :         return json_null;

  0023c	33 c0		 xor	 eax, eax
  0023e	e9 ef 00 00 00	 jmp	 $LN1@json_parse
$LN10@json_parse:

; 2103 :     }
; 2104 :     
; 2105 :     /* reset offset so we can reuse it. */
; 2106 :     state.offset = 0;

  00243	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR state$[rsp+16], 0

; 2107 :     
; 2108 :     /* reset the line information so we can reuse it. */
; 2109 :     state.line_no = 1;

  0024c	48 c7 84 24 80
	00 00 00 01 00
	00 00		 mov	 QWORD PTR state$[rsp+64], 1

; 2110 :     state.line_offset = 0;

  00258	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR state$[rsp+72], 0

; 2111 :     
; 2112 :     state.dom = (char *)allocation;

  00264	48 8b 44 24 30	 mov	 rax, QWORD PTR allocation$[rsp]
  00269	48 89 44 24 68	 mov	 QWORD PTR state$[rsp+40], rax

; 2113 :     state.data = state.dom + state.dom_size;

  0026e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp+48]
  00273	48 8b 4c 24 68	 mov	 rcx, QWORD PTR state$[rsp+40]
  00278	48 03 c8	 add	 rcx, rax
  0027b	48 8b c1	 mov	 rax, rcx
  0027e	48 89 44 24 60	 mov	 QWORD PTR state$[rsp+32], rax

; 2114 :     
; 2115 :     if (json_parse_flags_allow_location_information & state.flags_bitset) {

  00283	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp+24]
  00288	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0028e	48 85 c0	 test	 rax, rax
  00291	74 62		 je	 SHORT $LN12@json_parse

; 2116 :         struct json_value_ex_s *value_ex = (struct json_value_ex_s *)state.dom;

  00293	48 8b 44 24 68	 mov	 rax, QWORD PTR state$[rsp+40]
  00298	48 89 44 24 28	 mov	 QWORD PTR value_ex$1[rsp], rax

; 2117 :         state.dom += sizeof(struct json_value_ex_s);

  0029d	48 8b 44 24 68	 mov	 rax, QWORD PTR state$[rsp+40]
  002a2	48 83 c0 28	 add	 rax, 40			; 00000028H
  002a6	48 89 44 24 68	 mov	 QWORD PTR state$[rsp+40], rax

; 2118 :         
; 2119 :         value_ex->offset = state.offset;

  002ab	48 8b 44 24 28	 mov	 rax, QWORD PTR value_ex$1[rsp]
  002b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp+16]
  002b5	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 2120 :         value_ex->line_no = state.line_no;

  002b9	48 8b 44 24 28	 mov	 rax, QWORD PTR value_ex$1[rsp]
  002be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp+64]
  002c6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2121 :         value_ex->row_no = state.offset - state.line_offset;

  002ca	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp+72]
  002d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp+16]
  002d7	48 2b c8	 sub	 rcx, rax
  002da	48 8b c1	 mov	 rax, rcx
  002dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR value_ex$1[rsp]
  002e2	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 2122 :         
; 2123 :         value = &(value_ex->value);

  002e6	48 8b 44 24 28	 mov	 rax, QWORD PTR value_ex$1[rsp]
  002eb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR value$[rsp], rax

; 2124 :     } else {

  002f3	eb 1b		 jmp	 SHORT $LN13@json_parse
$LN12@json_parse:

; 2125 :         value = (struct json_value_s *)state.dom;

  002f5	48 8b 44 24 68	 mov	 rax, QWORD PTR state$[rsp+40]
  002fa	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR value$[rsp], rax

; 2126 :         state.dom += sizeof(struct json_value_s);

  00302	48 8b 44 24 68	 mov	 rax, QWORD PTR state$[rsp+40]
  00307	48 83 c0 10	 add	 rax, 16
  0030b	48 89 44 24 68	 mov	 QWORD PTR state$[rsp+40], rax
$LN13@json_parse:

; 2127 :     }
; 2128 :     
; 2129 :     json_parse_value(

  00310	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp+24]
  00315	48 83 e0 04	 and	 rax, 4
  00319	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR value$[rsp]
  00321	8b d0		 mov	 edx, eax
  00323	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  00328	e8 00 00 00 00	 call	 ?json_parse_value@@YAXPEAUjson_parse_state_s@@HPEAUjson_value_s@@@Z ; json_parse_value

; 2130 :                      &state, (int)(json_parse_flags_allow_global_object & state.flags_bitset),
; 2131 :                      value);
; 2132 :     
; 2133 :     return (struct json_value_s *)allocation;

  0032d	48 8b 44 24 30	 mov	 rax, QWORD PTR allocation$[rsp]
$LN1@json_parse:

; 2134 : }

  00332	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00339	c3		 ret	 0
json_parse_ex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\json.h
;	COMDAT json_parse
_TEXT	SEGMENT
src$ = 64
src_size$ = 72
json_parse PROC						; COMDAT

; 2136 : struct json_value_s *json_parse(const void *src, size_t src_size) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2137 :     return json_parse_ex(src, src_size, json_parse_flags_default, json_null,

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00020	45 33 c9	 xor	 r9d, r9d
  00023	45 33 c0	 xor	 r8d, r8d
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR src_size$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR src$[rsp]
  00030	e8 00 00 00 00	 call	 json_parse_ex

; 2138 :                          json_null, json_null);
; 2139 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
json_parse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.cpp
_TEXT	SEGMENT
Result$ = 32
$T1 = 96
FileName$ = 104
Arena$ = 112
?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z PROC ; ReadFile8

; 39   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 40   :     file_contents Result = {0};

  00015	48 8d 44 24 20	 lea	 rax, QWORD PTR Result$[rsp]
  0001a	48 8b f8	 mov	 rdi, rax
  0001d	33 c0		 xor	 eax, eax
  0001f	b9 18 00 00 00	 mov	 ecx, 24
  00024	f3 aa		 rep stosb

; 41   :     
; 42   :     Result.Handle = Platform->OpenFile8(FileName, FILE_OPEN_READ);

  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR FileName$[rsp]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00037	ff 50 08	 call	 QWORD PTR [rax+8]
  0003a	48 89 44 24 20	 mov	 QWORD PTR Result$[rsp], rax

; 43   :     Result.Size = Platform->GetFileSize(Result.Handle);

  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Result$[rsp]
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0004b	ff 50 10	 call	 QWORD PTR [rax+16]
  0004e	89 44 24 30	 mov	 DWORD PTR Result$[rsp+16], eax

; 44   :     Result.Data = PushSize(Arena, Result.Size);

  00052	8b 44 24 30	 mov	 eax, DWORD PTR Result$[rsp+16]
  00056	8b d0		 mov	 edx, eax
  00058	48 8b 4c 24 70	 mov	 rcx, QWORD PTR Arena$[rsp]
  0005d	e8 00 00 00 00	 call	 PushSize
  00062	48 89 44 24 28	 mov	 QWORD PTR Result$[rsp+8], rax

; 45   :     Platform->ReadEntireFile(Result.Handle, Result.Size, Result.Data);

  00067	4c 8b 44 24 28	 mov	 r8, QWORD PTR Result$[rsp+8]
  0006c	8b 54 24 30	 mov	 edx, DWORD PTR Result$[rsp+16]
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Result$[rsp]
  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0007c	ff 50 18	 call	 QWORD PTR [rax+24]

; 46   :     
; 47   :     return(Result);

  0007f	48 8d 44 24 20	 lea	 rax, QWORD PTR Result$[rsp]
  00084	48 8b 7c 24 60	 mov	 rdi, QWORD PTR $T1[rsp]
  00089	48 8b f0	 mov	 rsi, rax
  0008c	b9 18 00 00 00	 mov	 ecx, 24
  00091	f3 a4		 rep movsb
  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]

; 48   : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	5f		 pop	 rdi
  0009d	5e		 pop	 rsi
  0009e	c3		 ret	 0
?ReadFile8@@YA?AUfile_contents@@PEADPEAUmemory_arena@@@Z ENDP ; ReadFile8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_player.cpp
_TEXT	SEGMENT
Y$ = 0
Entity$ = 32
OtherEntity$ = 40
?OnCollidePlayer@@YAXPEAUentity@@0@Z PROC		; OnCollidePlayer

; 83   : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 84   :     int Y = 0;

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR Y$[rsp], 0

; 85   : }

  00015	48 83 c4 18	 add	 rsp, 24
  00019	c3		 ret	 0
?OnCollidePlayer@@YAXPEAUentity@@0@Z ENDP		; OnCollidePlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_player.cpp
_TEXT	SEGMENT
MouseXAxis$ = 32
MouseYAxis$ = 36
MouseY$ = 40
MouseX$ = 44
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
$T7 = 144
$T8 = 160
$T9 = 176
$T10 = 192
$T11 = 208
$T12 = 224
$T13 = 240
$T14 = 256
$T15 = 272
$T16 = 288
$T17 = 304
$T18 = 320
$T19 = 336
$T20 = 352
$T21 = 368
$T22 = 384
Movement$ = 400
$T23 = 408
GroundedRotation$ = 416
$T24 = 432
$T25 = 448
$T26 = 464
$T27 = 480
$T28 = 496
$T29 = 512
$T30 = 528
$T31 = 544
$T32 = 560
$T33 = 576
$T34 = 592
__$ArrayPad$ = 608
Entity$ = 656
DeltaTime$ = 664
?RunPlayer@@YAXPEAUentity@@M@Z PROC			; RunPlayer

; 15   : {

$LN12:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 81 ec 78 02
	00 00		 sub	 rsp, 632		; 00000278H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 16   :     s32 MouseXAxis = Input->Mouse.X - State->LastInput.Mouse.X;

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  00034	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  00037	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0003a	2b c1		 sub	 eax, ecx
  0003c	89 44 24 20	 mov	 DWORD PTR MouseXAxis$[rsp], eax

; 17   :     s32 MouseYAxis = Input->Mouse.Y - State->LastInput.Mouse.Y;

  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?State@@3PEAUgame_state@@EA
  0004e	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  00051	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00054	2b c1		 sub	 eax, ecx
  00056	89 44 24 24	 mov	 DWORD PTR MouseYAxis$[rsp], eax

; 18   :     
; 19   :     f32 MouseX = MouseXAxis * GlobalSensitivity * DeltaTime;

  0005a	f3 0f 2a 44 24
	20		 cvtsi2ss xmm0, DWORD PTR MouseXAxis$[rsp]
  00060	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?GlobalSensitivity@@3MA
  00068	f3 0f 59 84 24
	98 02 00 00	 mulss	 xmm0, DWORD PTR DeltaTime$[rsp]
  00071	f3 0f 11 44 24
	2c		 movss	 DWORD PTR MouseX$[rsp], xmm0

; 20   :     f32 MouseY = MouseYAxis * GlobalSensitivity * DeltaTime;

  00077	f3 0f 2a 44 24
	24		 cvtsi2ss xmm0, DWORD PTR MouseYAxis$[rsp]
  0007d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?GlobalSensitivity@@3MA
  00085	f3 0f 59 84 24
	98 02 00 00	 mulss	 xmm0, DWORD PTR DeltaTime$[rsp]
  0008e	f3 0f 11 44 24
	28		 movss	 DWORD PTR MouseY$[rsp], xmm0

; 21   :     
; 22   :     XRotation += MouseY;

  00094	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?XRotation@@3MA
  0009c	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR MouseY$[rsp]
  000a2	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?XRotation@@3MA, xmm0

; 23   :     if(XRotation > GlobalMaxPitch)

  000aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?XRotation@@3MA
  000b2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?GlobalMaxPitch@@3MA
  000b9	76 10		 jbe	 SHORT $LN2@RunPlayer

; 24   :         XRotation = GlobalMaxPitch;

  000bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?GlobalMaxPitch@@3MA
  000c3	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?XRotation@@3MA, xmm0
$LN2@RunPlayer:

; 25   :     if(XRotation < GlobalMinPitch)

  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?GlobalMinPitch@@3MA
  000d3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?XRotation@@3MA
  000da	76 10		 jbe	 SHORT $LN3@RunPlayer

; 26   :         XRotation = GlobalMinPitch;

  000dc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?GlobalMinPitch@@3MA
  000e4	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?XRotation@@3MA, xmm0
$LN3@RunPlayer:

; 27   :     
; 28   :     YRotation -= MouseX;

  000ec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?YRotation@@3MA
  000f4	f3 0f 5c 44 24
	2c		 subss	 xmm0, DWORD PTR MouseX$[rsp]
  000fa	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?YRotation@@3MA, xmm0

; 29   :     
; 30   :     Entity->Camera.Rotation = V3EulerToRotation(V3(XRotation, YRotation, 0.0f));

  00102	0f 57 db	 xorps	 xmm3, xmm3
  00105	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR ?YRotation@@3MA
  0010d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?XRotation@@3MA
  00115	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  0011d	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00122	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  0012a	48 8b f9	 mov	 rdi, rcx
  0012d	48 8b f0	 mov	 rsi, rax
  00130	b9 0c 00 00 00	 mov	 ecx, 12
  00135	f3 a4		 rep movsb
  00137	48 8d 44 24 70	 lea	 rax, QWORD PTR $T5[rsp]
  0013c	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  00144	48 8b f8	 mov	 rdi, rax
  00147	48 8b f1	 mov	 rsi, rcx
  0014a	b9 0c 00 00 00	 mov	 ecx, 12
  0014f	f3 a4		 rep movsb
  00151	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T5[rsp]
  00156	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  0015e	e8 00 00 00 00	 call	 ?V3EulerToRotation@@YA?ATv3@@T1@@Z ; V3EulerToRotation
  00163	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  0016b	48 8b f9	 mov	 rdi, rcx
  0016e	48 8b f0	 mov	 rsi, rax
  00171	b9 0c 00 00 00	 mov	 ecx, 12
  00176	f3 a4		 rep movsb
  00178	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  00180	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00188	48 8d b8 a4 00
	00 00		 lea	 rdi, QWORD PTR [rax+164]
  0018f	48 8b f1	 mov	 rsi, rcx
  00192	b9 0c 00 00 00	 mov	 ecx, 12
  00197	f3 a4		 rep movsb

; 31   :     Entity->Rotation = V3(0.0f, -YRotation, 0.0f);

  00199	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?YRotation@@3MA
  001a1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001a8	0f 57 db	 xorps	 xmm3, xmm3
  001ab	0f 28 d0	 movaps	 xmm2, xmm0
  001ae	0f 57 c9	 xorps	 xmm1, xmm1
  001b1	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  001b9	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  001be	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  001c6	48 8b f9	 mov	 rdi, rcx
  001c9	48 8b f0	 mov	 rsi, rax
  001cc	b9 0c 00 00 00	 mov	 ecx, 12
  001d1	f3 a4		 rep movsb
  001d3	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  001db	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  001e3	48 8d 78 30	 lea	 rdi, QWORD PTR [rax+48]
  001e7	48 8b f1	 mov	 rsi, rcx
  001ea	b9 0c 00 00 00	 mov	 ecx, 12
  001ef	f3 a4		 rep movsb

; 32   :     
; 33   :     v2 Movement = {};

  001f1	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR Movement$[rsp]
  001f9	48 8b f8	 mov	 rdi, rax
  001fc	33 c0		 xor	 eax, eax
  001fe	b9 08 00 00 00	 mov	 ecx, 8
  00203	f3 aa		 rep stosb

; 34   :     if(Input->Keyboard.W)

  00205	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0020c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00210	74 11		 je	 SHORT $LN4@RunPlayer

; 35   :     {
; 36   :         Movement.z = -1.0f;

  00212	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0021a	f3 0f 11 84 24
	94 01 00 00	 movss	 DWORD PTR Movement$[rsp+4], xmm0
$LN4@RunPlayer:

; 37   :     }
; 38   :     if(Input->Keyboard.S)

  00223	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0022a	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0022e	74 11		 je	 SHORT $LN5@RunPlayer

; 39   :     {
; 40   :         Movement.z = 1.0f;

  00230	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00238	f3 0f 11 84 24
	94 01 00 00	 movss	 DWORD PTR Movement$[rsp+4], xmm0
$LN5@RunPlayer:

; 41   :     }
; 42   :     if(Input->Keyboard.D)

  00241	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00248	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0024c	74 11		 je	 SHORT $LN6@RunPlayer

; 43   :     {
; 44   :         Movement.x = 1.0f;

  0024e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00256	f3 0f 11 84 24
	90 01 00 00	 movss	 DWORD PTR Movement$[rsp], xmm0
$LN6@RunPlayer:

; 45   :     }
; 46   :     if(Input->Keyboard.A)

  0025f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00266	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  0026a	74 11		 je	 SHORT $LN7@RunPlayer

; 47   :     {
; 48   :         Movement.x = -1.0f;

  0026c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00274	f3 0f 11 84 24
	90 01 00 00	 movss	 DWORD PTR Movement$[rsp], xmm0
$LN7@RunPlayer:

; 49   :     }
; 50   :     Movement = V2Normalize(Movement);

  0027d	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR Movement$[rsp]
  00285	e8 00 00 00 00	 call	 ?V2Normalize@@YA?ATv2@@T1@@Z ; V2Normalize
  0028a	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR $T23[rsp], rax
  00292	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR $T23[rsp]
  0029a	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR Movement$[rsp], rax

; 51   :     Movement *= GlobalSpeed*DeltaTime;

  002a2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?GlobalSpeed@@3MA
  002aa	f3 0f 59 84 24
	98 02 00 00	 mulss	 xmm0, DWORD PTR DeltaTime$[rsp]
  002b3	0f 28 c8	 movaps	 xmm1, xmm0
  002b6	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR Movement$[rsp]
  002be	e8 00 00 00 00	 call	 ??X@YAAEATv2@@AEAT0@M@Z	; operator*=

; 52   :     
; 53   :     v3 GroundedRotation = V3Normalize(V3(Entity->Camera.Rotation.x, 0.0f, Entity->Camera.Rotation.z));

  002c3	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  002cb	f3 0f 10 98 ac
	00 00 00	 movss	 xmm3, DWORD PTR [rax+172]
  002d3	0f 57 d2	 xorps	 xmm2, xmm2
  002d6	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  002de	f3 0f 10 88 a4
	00 00 00	 movss	 xmm1, DWORD PTR [rax+164]
  002e6	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  002ee	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  002f3	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  002fb	48 8b f9	 mov	 rdi, rcx
  002fe	48 8b f0	 mov	 rsi, rax
  00301	b9 0c 00 00 00	 mov	 ecx, 12
  00306	f3 a4		 rep movsb
  00308	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  00310	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  00318	48 8b f8	 mov	 rdi, rax
  0031b	48 8b f1	 mov	 rsi, rcx
  0031e	b9 0c 00 00 00	 mov	 ecx, 12
  00323	f3 a4		 rep movsb
  00325	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  0032d	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00335	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  0033a	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  00342	48 8b f9	 mov	 rdi, rcx
  00345	48 8b f0	 mov	 rsi, rax
  00348	b9 0c 00 00 00	 mov	 ecx, 12
  0034d	f3 a4		 rep movsb
  0034f	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR GroundedRotation$[rsp]
  00357	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  0035f	48 8b f8	 mov	 rdi, rax
  00362	48 8b f1	 mov	 rsi, rcx
  00365	b9 0c 00 00 00	 mov	 ecx, 12
  0036a	f3 a4		 rep movsb

; 54   :     Entity->Camera.Position = Entity->Camera.Position + GroundedRotation*Movement.z;

  0036c	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  00374	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR GroundedRotation$[rsp]
  0037c	48 8b f8	 mov	 rdi, rax
  0037f	48 8b f1	 mov	 rsi, rcx
  00382	b9 0c 00 00 00	 mov	 ecx, 12
  00387	f3 a4		 rep movsb
  00389	f3 0f 10 94 24
	94 01 00 00	 movss	 xmm2, DWORD PTR Movement$[rsp+4]
  00392	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T11[rsp]
  0039a	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  003a2	e8 00 00 00 00	 call	 ??D@YA?ATv3@@T0@M@Z	; operator*
  003a7	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T29[rsp]
  003af	48 8b f9	 mov	 rdi, rcx
  003b2	48 8b f0	 mov	 rsi, rax
  003b5	b9 0c 00 00 00	 mov	 ecx, 12
  003ba	f3 a4		 rep movsb
  003bc	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  003c1	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T29[rsp]
  003c9	48 8b f8	 mov	 rdi, rax
  003cc	48 8b f1	 mov	 rsi, rcx
  003cf	b9 0c 00 00 00	 mov	 ecx, 12
  003d4	f3 a4		 rep movsb
  003d6	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  003db	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  003e3	48 8b f8	 mov	 rdi, rax
  003e6	48 8d b1 98 00
	00 00		 lea	 rsi, QWORD PTR [rcx+152]
  003ed	b9 0c 00 00 00	 mov	 ecx, 12
  003f2	f3 a4		 rep movsb
  003f4	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  003f9	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  003fe	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00406	e8 00 00 00 00	 call	 ??H@YA?ATv3@@T0@0@Z	; operator+
  0040b	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00413	48 8b f9	 mov	 rdi, rcx
  00416	48 8b f0	 mov	 rsi, rax
  00419	b9 0c 00 00 00	 mov	 ecx, 12
  0041e	f3 a4		 rep movsb
  00420	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  00428	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00430	48 8d b8 98 00
	00 00		 lea	 rdi, QWORD PTR [rax+152]
  00437	48 8b f1	 mov	 rsi, rcx
  0043a	b9 0c 00 00 00	 mov	 ecx, 12
  0043f	f3 a4		 rep movsb

; 55   :     Entity->Camera.Position = (Entity->Camera.Position +

  00441	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  00449	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  00451	48 8b f8	 mov	 rdi, rax
  00454	48 8d b1 b0 00
	00 00		 lea	 rsi, QWORD PTR [rcx+176]
  0045b	b9 0c 00 00 00	 mov	 ecx, 12
  00460	f3 a4		 rep movsb
  00462	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  0046a	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR GroundedRotation$[rsp]
  00472	48 8b f8	 mov	 rdi, rax
  00475	48 8b f1	 mov	 rsi, rcx
  00478	b9 0c 00 00 00	 mov	 ecx, 12
  0047d	f3 a4		 rep movsb
  0047f	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR $T6[rsp]
  00487	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  0048f	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00497	e8 00 00 00 00	 call	 ?V3Cross@@YA?ATv3@@T1@0@Z ; V3Cross
  0049c	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  004a4	48 8b f9	 mov	 rdi, rcx
  004a7	48 8b f0	 mov	 rsi, rax
  004aa	b9 0c 00 00 00	 mov	 ecx, 12
  004af	f3 a4		 rep movsb
  004b1	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  004b9	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  004c1	48 8b f8	 mov	 rdi, rax
  004c4	48 8b f1	 mov	 rsi, rcx
  004c7	b9 0c 00 00 00	 mov	 ecx, 12
  004cc	f3 a4		 rep movsb
  004ce	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  004d6	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  004de	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  004e3	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  004eb	48 8b f9	 mov	 rdi, rcx
  004ee	48 8b f0	 mov	 rsi, rax
  004f1	b9 0c 00 00 00	 mov	 ecx, 12
  004f6	f3 a4		 rep movsb
  004f8	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  00500	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  00508	48 8b f8	 mov	 rdi, rax
  0050b	48 8b f1	 mov	 rsi, rcx
  0050e	b9 0c 00 00 00	 mov	 ecx, 12
  00513	f3 a4		 rep movsb
  00515	f3 0f 10 94 24
	90 01 00 00	 movss	 xmm2, DWORD PTR Movement$[rsp]
  0051e	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T10[rsp]
  00526	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  0052e	e8 00 00 00 00	 call	 ??D@YA?ATv3@@T0@M@Z	; operator*
  00533	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0053b	48 8b f9	 mov	 rdi, rcx
  0053e	48 8b f0	 mov	 rsi, rax
  00541	b9 0c 00 00 00	 mov	 ecx, 12
  00546	f3 a4		 rep movsb
  00548	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0054d	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  00555	48 8b f8	 mov	 rdi, rax
  00558	48 8b f1	 mov	 rsi, rcx
  0055b	b9 0c 00 00 00	 mov	 ecx, 12
  00560	f3 a4		 rep movsb
  00562	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  00567	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  0056f	48 8b f8	 mov	 rdi, rax
  00572	48 8d b1 98 00
	00 00		 lea	 rsi, QWORD PTR [rcx+152]
  00579	b9 0c 00 00 00	 mov	 ecx, 12
  0057e	f3 a4		 rep movsb
  00580	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  00585	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T4[rsp]
  0058a	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  00592	e8 00 00 00 00	 call	 ??H@YA?ATv3@@T0@0@Z	; operator+
  00597	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  0059f	48 8b f9	 mov	 rdi, rcx
  005a2	48 8b f0	 mov	 rsi, rax
  005a5	b9 0c 00 00 00	 mov	 ecx, 12
  005aa	f3 a4		 rep movsb
  005ac	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  005b4	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  005bc	48 8d b8 98 00
	00 00		 lea	 rdi, QWORD PTR [rax+152]
  005c3	48 8b f1	 mov	 rsi, rcx
  005c6	b9 0c 00 00 00	 mov	 ecx, 12
  005cb	f3 a4		 rep movsb

; 56   :                                V3Normalize(V3Cross(GroundedRotation, Entity->Camera.Up)) *
; 57   :                                Movement.x);
; 58   :     if(Input->Keyboard.Enter && !State->LastInput.Keyboard.Enter)

  005cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  005d4	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  005d8	74 22		 je	 SHORT $LN8@RunPlayer
  005da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  005e1	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  005e5	75 15		 jne	 SHORT $LN8@RunPlayer

; 59   :     {
; 60   :         Entity->Position.y = 10.0f;

  005e7	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  005ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  005f7	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN8@RunPlayer:

; 61   :     }
; 62   :     
; 63   :     if(Input->Keyboard.Space && Entity->Position.y <= 3.0f)

  005fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00603	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00607	74 3b		 je	 SHORT $LN9@RunPlayer
  00609	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  00611	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00619	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  0061d	72 25		 jb	 SHORT $LN9@RunPlayer

; 64   :     {
; 65   :         YVelocity = Sqrt(JumpHeight * -2.0f * Gravity);

  0061f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?JumpHeight@@3MA
  00627	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@c0000000
  0062f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?Gravity@@3MA
  00637	e8 00 00 00 00	 call	 ?Sqrt@@YAMM@Z		; Sqrt
  0063c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?YVelocity@@3MA, xmm0
$LN9@RunPlayer:

; 66   :     }
; 67   :     YVelocity += Gravity*DeltaTime;

  00644	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?Gravity@@3MA
  0064c	f3 0f 59 84 24
	98 02 00 00	 mulss	 xmm0, DWORD PTR DeltaTime$[rsp]
  00655	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?YVelocity@@3MA
  0065d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00661	0f 28 c1	 movaps	 xmm0, xmm1
  00664	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?YVelocity@@3MA, xmm0

; 68   :     Entity->Position.y += YVelocity*DeltaTime;

  0066c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?YVelocity@@3MA
  00674	f3 0f 59 84 24
	98 02 00 00	 mulss	 xmm0, DWORD PTR DeltaTime$[rsp]
  0067d	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  00685	f3 0f 10 48 1c	 movss	 xmm1, DWORD PTR [rax+28]
  0068a	f3 0f 58 c8	 addss	 xmm1, xmm0
  0068e	0f 28 c1	 movaps	 xmm0, xmm1
  00691	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  00699	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0

; 69   :     
; 70   :     if(Entity->Position.y < 3.0f)

  0069e	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  006a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  006ae	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  006b2	76 25		 jbe	 SHORT $LN10@RunPlayer

; 71   :     {
; 72   :         YVelocity = -0.2f;

  006b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@be4ccccd
  006bc	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?YVelocity@@3MA, xmm0

; 73   :         Entity->Position.y = 3.0f;

  006c4	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  006cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  006d4	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN10@RunPlayer:

; 74   :     }
; 75   :     
; 76   :     Entity->Camera.Position.y = Entity->Position.y;

  006d9	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  006e1	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  006e9	f3 0f 10 41 1c	 movss	 xmm0, DWORD PTR [rcx+28]
  006ee	f3 0f 11 80 9c
	00 00 00	 movss	 DWORD PTR [rax+156], xmm0

; 77   :     
; 78   :     Entity->Position.x = Entity->Camera.Position.x;

  006f6	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  006fe	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  00706	f3 0f 10 81 98
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+152]
  0070e	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 79   :     Entity->Position.z = Entity->Camera.Position.z;

  00713	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR Entity$[rsp]
  0071b	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR Entity$[rsp]
  00723	f3 0f 10 81 a0
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+160]
  0072b	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0

; 80   : }

  00730	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00738	48 33 cc	 xor	 rcx, rsp
  0073b	e8 00 00 00 00	 call	 __security_check_cookie
  00740	48 81 c4 78 02
	00 00		 add	 rsp, 632		; 00000278H
  00747	5f		 pop	 rdi
  00748	5e		 pop	 rsi
  00749	c3		 ret	 0
?RunPlayer@@YAXPEAUentity@@M@Z ENDP			; RunPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
off$1 = 32
i$ = 36
font_collection$ = 64
name_utf8$ = 72
flags$ = 80
?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z PROC	; stbtt_FindMatchingFont_internal

; 4920 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4921 :    stbtt_int32 i;
; 4922 :    for (i=0;;++i) {

  00013	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001b	eb 0a		 jmp	 SHORT $LN4@stbtt_Find
$LN2@stbtt_Find:
  0001d	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00021	ff c0		 inc	 eax
  00023	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Find:

; 4923 :       stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);

  00027	8b 54 24 24	 mov	 edx, DWORD PTR i$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  00030	e8 00 00 00 00	 call	 stbtt_GetFontOffsetForIndex
  00035	89 44 24 20	 mov	 DWORD PTR off$1[rsp], eax

; 4924 :       if (off < 0) return off;

  00039	83 7c 24 20 00	 cmp	 DWORD PTR off$1[rsp], 0
  0003e	7d 06		 jge	 SHORT $LN5@stbtt_Find
  00040	8b 44 24 20	 mov	 eax, DWORD PTR off$1[rsp]
  00044	eb 24		 jmp	 SHORT $LN1@stbtt_Find
$LN5@stbtt_Find:

; 4925 :       if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))

  00046	44 8b 4c 24 50	 mov	 r9d, DWORD PTR flags$[rsp]
  0004b	4c 8b 44 24 48	 mov	 r8, QWORD PTR name_utf8$[rsp]
  00050	8b 54 24 20	 mov	 edx, DWORD PTR off$1[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  00059	e8 00 00 00 00	 call	 ?stbtt__matches@@YAHPEAEI0H@Z ; stbtt__matches
  0005e	85 c0		 test	 eax, eax
  00060	74 06		 je	 SHORT $LN6@stbtt_Find

; 4926 :          return off;

  00062	8b 44 24 20	 mov	 eax, DWORD PTR off$1[rsp]
  00066	eb 02		 jmp	 SHORT $LN1@stbtt_Find
$LN6@stbtt_Find:

; 4927 :    }

  00068	eb b3		 jmp	 SHORT $LN2@stbtt_Find
$LN1@stbtt_Find:

; 4928 : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z ENDP	; stbtt_FindMatchingFont_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
nm$ = 48
nlen$ = 52
hd$ = 56
tv194 = 64
tv193 = 72
fc$ = 96
offset$ = 104
name$ = 112
flags$ = 120
?stbtt__matches@@YAHPEAEI0H@Z PROC			; stbtt__matches

; 4891 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4892 :    stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR name$[rsp]
  0001c	48 89 44 24 48	 mov	 QWORD PTR tv193[rsp], rax
  00021	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR tv194[rsp], -1
$LL15@stbtt__mat:
  0002a	48 ff 44 24 40	 inc	 QWORD PTR tv194[rsp]
  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR tv193[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv194[rsp]
  00039	80 3c 08 00	 cmp	 BYTE PTR [rax+rcx], 0
  0003d	75 eb		 jne	 SHORT $LL15@stbtt__mat
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR tv194[rsp]
  00044	89 44 24 34	 mov	 DWORD PTR nlen$[rsp], eax

; 4893 :    stbtt_uint32 nm,hd;
; 4894 :    if (!stbtt__isfont(fc+offset)) return 0;

  00048	8b 44 24 68	 mov	 eax, DWORD PTR offset$[rsp]
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  00051	48 03 c8	 add	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b c8	 mov	 rcx, rax
  0005a	e8 00 00 00 00	 call	 ?stbtt__isfont@@YAHPEAE@Z ; stbtt__isfont
  0005f	85 c0		 test	 eax, eax
  00061	75 07		 jne	 SHORT $LN2@stbtt__mat
  00063	33 c0		 xor	 eax, eax
  00065	e9 c2 01 00 00	 jmp	 $LN1@stbtt__mat
$LN2@stbtt__mat:

; 4895 : 
; 4896 :    // check italics/bold/underline flags in macStyle...
; 4897 :    if (flags) {

  0006a	83 7c 24 78 00	 cmp	 DWORD PTR flags$[rsp], 0
  0006f	74 47		 je	 SHORT $LN3@stbtt__mat

; 4898 :       hd = stbtt__find_table(fc, offset, "head");

  00071	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44168
  00078	8b 54 24 68	 mov	 edx, DWORD PTR offset$[rsp]
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  00081	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00086	89 44 24 38	 mov	 DWORD PTR hd$[rsp], eax

; 4899 :       if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;

  0008a	8b 44 24 38	 mov	 eax, DWORD PTR hd$[rsp]
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  00093	48 8d 44 01 2c	 lea	 rax, QWORD PTR [rcx+rax+44]
  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000a0	0f b7 c0	 movzx	 eax, ax
  000a3	83 e0 07	 and	 eax, 7
  000a6	8b 4c 24 78	 mov	 ecx, DWORD PTR flags$[rsp]
  000aa	83 e1 07	 and	 ecx, 7
  000ad	3b c1		 cmp	 eax, ecx
  000af	74 07		 je	 SHORT $LN4@stbtt__mat
  000b1	33 c0		 xor	 eax, eax
  000b3	e9 74 01 00 00	 jmp	 $LN1@stbtt__mat
$LN4@stbtt__mat:
$LN3@stbtt__mat:

; 4900 :    }
; 4901 : 
; 4902 :    nm = stbtt__find_table(fc, offset, "name");

  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44170
  000bf	8b 54 24 68	 mov	 edx, DWORD PTR offset$[rsp]
  000c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  000c8	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  000cd	89 44 24 30	 mov	 DWORD PTR nm$[rsp], eax

; 4903 :    if (!nm) return 0;

  000d1	83 7c 24 30 00	 cmp	 DWORD PTR nm$[rsp], 0
  000d6	75 07		 jne	 SHORT $LN5@stbtt__mat
  000d8	33 c0		 xor	 eax, eax
  000da	e9 4d 01 00 00	 jmp	 $LN1@stbtt__mat
$LN5@stbtt__mat:

; 4904 : 
; 4905 :    if (flags) {

  000df	83 7c 24 78 00	 cmp	 DWORD PTR flags$[rsp], 0
  000e4	0f 84 a7 00 00
	00		 je	 $LN6@stbtt__mat

; 4906 :       // if we checked the macStyle flags, then just check the family and ignore the subfamily
; 4907 :       if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;

  000ea	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1
  000f2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fa	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nlen$[rsp]
  000ff	4c 8b 44 24 70	 mov	 r8, QWORD PTR name$[rsp]
  00104	8b 54 24 30	 mov	 edx, DWORD PTR nm$[rsp]
  00108	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  0010d	e8 00 00 00 00	 call	 ?stbtt__matchpair@@YAHPEAEI0HHH@Z ; stbtt__matchpair
  00112	85 c0		 test	 eax, eax
  00114	74 0a		 je	 SHORT $LN8@stbtt__mat
  00116	b8 01 00 00 00	 mov	 eax, 1
  0011b	e9 0c 01 00 00	 jmp	 $LN1@stbtt__mat
$LN8@stbtt__mat:

; 4908 :       if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;

  00120	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1
  00128	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00130	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nlen$[rsp]
  00135	4c 8b 44 24 70	 mov	 r8, QWORD PTR name$[rsp]
  0013a	8b 54 24 30	 mov	 edx, DWORD PTR nm$[rsp]
  0013e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  00143	e8 00 00 00 00	 call	 ?stbtt__matchpair@@YAHPEAEI0HHH@Z ; stbtt__matchpair
  00148	85 c0		 test	 eax, eax
  0014a	74 0a		 je	 SHORT $LN9@stbtt__mat
  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	e9 d6 00 00 00	 jmp	 $LN1@stbtt__mat
$LN9@stbtt__mat:

; 4909 :       if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;

  00156	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1
  0015e	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00166	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nlen$[rsp]
  0016b	4c 8b 44 24 70	 mov	 r8, QWORD PTR name$[rsp]
  00170	8b 54 24 30	 mov	 edx, DWORD PTR nm$[rsp]
  00174	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  00179	e8 00 00 00 00	 call	 ?stbtt__matchpair@@YAHPEAEI0HHH@Z ; stbtt__matchpair
  0017e	85 c0		 test	 eax, eax
  00180	74 0a		 je	 SHORT $LN10@stbtt__mat
  00182	b8 01 00 00 00	 mov	 eax, 1
  00187	e9 a0 00 00 00	 jmp	 $LN1@stbtt__mat
$LN10@stbtt__mat:

; 4910 :    } else {

  0018c	e9 99 00 00 00	 jmp	 $LN7@stbtt__mat
$LN6@stbtt__mat:

; 4911 :       if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;

  00191	c7 44 24 28 11
	00 00 00	 mov	 DWORD PTR [rsp+40], 17
  00199	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a1	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nlen$[rsp]
  001a6	4c 8b 44 24 70	 mov	 r8, QWORD PTR name$[rsp]
  001ab	8b 54 24 30	 mov	 edx, DWORD PTR nm$[rsp]
  001af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  001b4	e8 00 00 00 00	 call	 ?stbtt__matchpair@@YAHPEAEI0HHH@Z ; stbtt__matchpair
  001b9	85 c0		 test	 eax, eax
  001bb	74 07		 je	 SHORT $LN11@stbtt__mat
  001bd	b8 01 00 00 00	 mov	 eax, 1
  001c2	eb 68		 jmp	 SHORT $LN1@stbtt__mat
$LN11@stbtt__mat:

; 4912 :       if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;

  001c4	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  001cc	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  001d4	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nlen$[rsp]
  001d9	4c 8b 44 24 70	 mov	 r8, QWORD PTR name$[rsp]
  001de	8b 54 24 30	 mov	 edx, DWORD PTR nm$[rsp]
  001e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  001e7	e8 00 00 00 00	 call	 ?stbtt__matchpair@@YAHPEAEI0HHH@Z ; stbtt__matchpair
  001ec	85 c0		 test	 eax, eax
  001ee	74 07		 je	 SHORT $LN12@stbtt__mat
  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	eb 35		 jmp	 SHORT $LN1@stbtt__mat
$LN12@stbtt__mat:

; 4913 :       if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;

  001f7	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1
  001ff	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00207	44 8b 4c 24 34	 mov	 r9d, DWORD PTR nlen$[rsp]
  0020c	4c 8b 44 24 70	 mov	 r8, QWORD PTR name$[rsp]
  00211	8b 54 24 30	 mov	 edx, DWORD PTR nm$[rsp]
  00215	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fc$[rsp]
  0021a	e8 00 00 00 00	 call	 ?stbtt__matchpair@@YAHPEAEI0HHH@Z ; stbtt__matchpair
  0021f	85 c0		 test	 eax, eax
  00221	74 07		 je	 SHORT $LN13@stbtt__mat
  00223	b8 01 00 00 00	 mov	 eax, 1
  00228	eb 02		 jmp	 SHORT $LN1@stbtt__mat
$LN13@stbtt__mat:
$LN7@stbtt__mat:

; 4914 :    }
; 4915 : 
; 4916 :    return 0;

  0022a	33 c0		 xor	 eax, eax
$LN1@stbtt__mat:

; 4917 : }

  0022c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00230	c3		 ret	 0
?stbtt__matches@@YAHPEAEI0H@Z ENDP			; stbtt__matches
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
loc$1 = 32
matchlen$2 = 36
i$ = 40
platform$3 = 44
slen$4 = 48
encoding$5 = 52
off$6 = 56
count$ = 60
stringOffset$ = 64
id$7 = 68
language$8 = 72
tv231 = 80
fc$ = 112
nm$ = 120
name$ = 128
nlen$ = 136
target_id$ = 144
next_id$ = 152
?stbtt__matchpair@@YAHPEAEI0HHH@Z PROC			; stbtt__matchpair

; 4844 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4845 :    stbtt_int32 i;
; 4846 :    stbtt_int32 count = ttUSHORT(fc+nm+2);

  00017	8b 44 24 78	 mov	 eax, DWORD PTR nm$[rsp]
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  00020	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0002d	0f b7 c0	 movzx	 eax, ax
  00030	89 44 24 3c	 mov	 DWORD PTR count$[rsp], eax

; 4847 :    stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

  00034	8b 44 24 78	 mov	 eax, DWORD PTR nm$[rsp]
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  0003d	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0004a	0f b7 c0	 movzx	 eax, ax
  0004d	8b 4c 24 78	 mov	 ecx, DWORD PTR nm$[rsp]
  00051	03 c8		 add	 ecx, eax
  00053	8b c1		 mov	 eax, ecx
  00055	89 44 24 40	 mov	 DWORD PTR stringOffset$[rsp], eax

; 4848 : 
; 4849 :    for (i=0; i < count; ++i) {

  00059	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00061	eb 0a		 jmp	 SHORT $LN4@stbtt__mat
$LN2@stbtt__mat:
  00063	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00067	ff c0		 inc	 eax
  00069	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__mat:
  0006d	8b 44 24 3c	 mov	 eax, DWORD PTR count$[rsp]
  00071	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00075	0f 8d e8 02 00
	00		 jge	 $LN3@stbtt__mat

; 4850 :       stbtt_uint32 loc = nm + 6 + 12 * i;

  0007b	6b 44 24 28 0c	 imul	 eax, DWORD PTR i$[rsp], 12
  00080	8b 4c 24 78	 mov	 ecx, DWORD PTR nm$[rsp]
  00084	8d 44 01 06	 lea	 eax, DWORD PTR [rcx+rax+6]
  00088	89 44 24 20	 mov	 DWORD PTR loc$1[rsp], eax

; 4851 :       stbtt_int32 id = ttUSHORT(fc+loc+6);

  0008c	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  00090	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  00095	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000a2	0f b7 c0	 movzx	 eax, ax
  000a5	89 44 24 44	 mov	 DWORD PTR id$7[rsp], eax

; 4852 :       if (id == target_id) {

  000a9	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR target_id$[rsp]
  000b0	39 44 24 44	 cmp	 DWORD PTR id$7[rsp], eax
  000b4	0f 85 a4 02 00
	00		 jne	 $LN5@stbtt__mat

; 4853 :          // find the encoding
; 4854 :          stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

  000ba	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  000c3	48 03 c8	 add	 rcx, rax
  000c6	48 8b c1	 mov	 rax, rcx
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000d1	0f b7 c0	 movzx	 eax, ax
  000d4	89 44 24 2c	 mov	 DWORD PTR platform$3[rsp], eax
  000d8	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  000e1	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  000e6	48 8b c8	 mov	 rcx, rax
  000e9	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000ee	0f b7 c0	 movzx	 eax, ax
  000f1	89 44 24 34	 mov	 DWORD PTR encoding$5[rsp], eax
  000f5	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  000fe	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00103	48 8b c8	 mov	 rcx, rax
  00106	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0010b	0f b7 c0	 movzx	 eax, ax
  0010e	89 44 24 48	 mov	 DWORD PTR language$8[rsp], eax

; 4855 : 
; 4856 :          // is this a Unicode encoding?
; 4857 :          if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {

  00112	83 7c 24 2c 00	 cmp	 DWORD PTR platform$3[rsp], 0
  00117	74 24		 je	 SHORT $LN7@stbtt__mat
  00119	83 7c 24 2c 03	 cmp	 DWORD PTR platform$3[rsp], 3
  0011e	75 07		 jne	 SHORT $LN8@stbtt__mat
  00120	83 7c 24 34 01	 cmp	 DWORD PTR encoding$5[rsp], 1
  00125	74 16		 je	 SHORT $LN7@stbtt__mat
$LN8@stbtt__mat:
  00127	83 7c 24 2c 03	 cmp	 DWORD PTR platform$3[rsp], 3
  0012c	0f 85 2c 02 00
	00		 jne	 $LN6@stbtt__mat
  00132	83 7c 24 34 0a	 cmp	 DWORD PTR encoding$5[rsp], 10
  00137	0f 85 21 02 00
	00		 jne	 $LN6@stbtt__mat
$LN7@stbtt__mat:

; 4858 :             stbtt_int32 slen = ttUSHORT(fc+loc+8);

  0013d	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  00141	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  00146	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0014b	48 8b c8	 mov	 rcx, rax
  0014e	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00153	0f b7 c0	 movzx	 eax, ax
  00156	89 44 24 30	 mov	 DWORD PTR slen$4[rsp], eax

; 4859 :             stbtt_int32 off = ttUSHORT(fc+loc+10);

  0015a	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0015e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  00163	48 8d 44 01 0a	 lea	 rax, QWORD PTR [rcx+rax+10]
  00168	48 8b c8	 mov	 rcx, rax
  0016b	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00170	0f b7 c0	 movzx	 eax, ax
  00173	89 44 24 38	 mov	 DWORD PTR off$6[rsp], eax

; 4860 : 
; 4861 :             // check if there's a prefix match
; 4862 :             stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);

  00177	48 63 44 24 40	 movsxd	 rax, DWORD PTR stringOffset$[rsp]
  0017c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  00181	48 03 c8	 add	 rcx, rax
  00184	48 8b c1	 mov	 rax, rcx
  00187	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR off$6[rsp]
  0018c	48 03 c1	 add	 rax, rcx
  0018f	44 8b 4c 24 30	 mov	 r9d, DWORD PTR slen$4[rsp]
  00194	4c 8b c0	 mov	 r8, rax
  00197	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR nlen$[rsp]
  0019e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  001a6	e8 00 00 00 00	 call	 ?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z ; stbtt__CompareUTF8toUTF16_bigendian_prefix
  001ab	89 44 24 24	 mov	 DWORD PTR matchlen$2[rsp], eax

; 4863 :             if (matchlen >= 0) {

  001af	83 7c 24 24 00	 cmp	 DWORD PTR matchlen$2[rsp], 0
  001b4	0f 8c a4 01 00
	00		 jl	 $LN9@stbtt__mat

; 4864 :                // check for target_id+1 immediately following, with same encoding & language
; 4865 :                if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {

  001ba	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001be	ff c0		 inc	 eax
  001c0	3b 44 24 3c	 cmp	 eax, DWORD PTR count$[rsp]
  001c4	0f 8d 80 01 00
	00		 jge	 $LN10@stbtt__mat
  001ca	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  001ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  001d3	48 8d 44 01 12	 lea	 rax, QWORD PTR [rcx+rax+18]
  001d8	48 8b c8	 mov	 rcx, rax
  001db	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001e0	0f b7 c0	 movzx	 eax, ax
  001e3	3b 84 24 98 00
	00 00		 cmp	 eax, DWORD PTR next_id$[rsp]
  001ea	0f 85 5a 01 00
	00		 jne	 $LN10@stbtt__mat
  001f0	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  001f4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  001f9	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  001fe	48 8b c8	 mov	 rcx, rax
  00201	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00206	0f b7 c0	 movzx	 eax, ax
  00209	3b 44 24 2c	 cmp	 eax, DWORD PTR platform$3[rsp]
  0020d	0f 85 37 01 00
	00		 jne	 $LN10@stbtt__mat
  00213	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  00217	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  0021c	48 8d 44 01 0e	 lea	 rax, QWORD PTR [rcx+rax+14]
  00221	48 8b c8	 mov	 rcx, rax
  00224	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00229	0f b7 c0	 movzx	 eax, ax
  0022c	3b 44 24 34	 cmp	 eax, DWORD PTR encoding$5[rsp]
  00230	0f 85 14 01 00
	00		 jne	 $LN10@stbtt__mat
  00236	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0023a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  0023f	48 8d 44 01 10	 lea	 rax, QWORD PTR [rcx+rax+16]
  00244	48 8b c8	 mov	 rcx, rax
  00247	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0024c	0f b7 c0	 movzx	 eax, ax
  0024f	3b 44 24 48	 cmp	 eax, DWORD PTR language$8[rsp]
  00253	0f 85 f1 00 00
	00		 jne	 $LN10@stbtt__mat

; 4866 :                   slen = ttUSHORT(fc+loc+12+8);

  00259	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0025d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  00262	48 8d 44 01 14	 lea	 rax, QWORD PTR [rcx+rax+20]
  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0026f	0f b7 c0	 movzx	 eax, ax
  00272	89 44 24 30	 mov	 DWORD PTR slen$4[rsp], eax

; 4867 :                   off = ttUSHORT(fc+loc+12+10);

  00276	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0027a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  0027f	48 8d 44 01 16	 lea	 rax, QWORD PTR [rcx+rax+22]
  00284	48 8b c8	 mov	 rcx, rax
  00287	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0028c	0f b7 c0	 movzx	 eax, ax
  0028f	89 44 24 38	 mov	 DWORD PTR off$6[rsp], eax

; 4868 :                   if (slen == 0) {

  00293	83 7c 24 30 00	 cmp	 DWORD PTR slen$4[rsp], 0
  00298	75 1c		 jne	 SHORT $LN12@stbtt__mat

; 4869 :                      if (matchlen == nlen)

  0029a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR nlen$[rsp]
  002a1	39 44 24 24	 cmp	 DWORD PTR matchlen$2[rsp], eax
  002a5	75 0a		 jne	 SHORT $LN14@stbtt__mat

; 4870 :                         return 1;

  002a7	b8 01 00 00 00	 mov	 eax, 1
  002ac	e9 b4 00 00 00	 jmp	 $LN1@stbtt__mat
$LN14@stbtt__mat:
  002b1	e9 92 00 00 00	 jmp	 $LN13@stbtt__mat
$LN12@stbtt__mat:

; 4871 :                   } else if (matchlen < nlen && name[matchlen] == ' ') {

  002b6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR nlen$[rsp]
  002bd	39 44 24 24	 cmp	 DWORD PTR matchlen$2[rsp], eax
  002c1	0f 8d 81 00 00
	00		 jge	 $LN15@stbtt__mat
  002c7	48 63 44 24 24	 movsxd	 rax, DWORD PTR matchlen$2[rsp]
  002cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  002d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d8	83 f8 20	 cmp	 eax, 32			; 00000020H
  002db	75 6b		 jne	 SHORT $LN15@stbtt__mat

; 4872 :                      ++matchlen;

  002dd	8b 44 24 24	 mov	 eax, DWORD PTR matchlen$2[rsp]
  002e1	ff c0		 inc	 eax
  002e3	89 44 24 24	 mov	 DWORD PTR matchlen$2[rsp], eax

; 4873 :                      if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))

  002e7	48 63 44 24 40	 movsxd	 rax, DWORD PTR stringOffset$[rsp]
  002ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fc$[rsp]
  002f1	48 03 c8	 add	 rcx, rax
  002f4	48 8b c1	 mov	 rax, rcx
  002f7	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR off$6[rsp]
  002fc	48 03 c1	 add	 rax, rcx
  002ff	8b 4c 24 24	 mov	 ecx, DWORD PTR matchlen$2[rsp]
  00303	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR nlen$[rsp]
  0030a	2b d1		 sub	 edx, ecx
  0030c	8b ca		 mov	 ecx, edx
  0030e	48 63 54 24 24	 movsxd	 rdx, DWORD PTR matchlen$2[rsp]
  00313	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR name$[rsp]
  0031b	4c 03 c2	 add	 r8, rdx
  0031e	49 8b d0	 mov	 rdx, r8
  00321	48 89 54 24 50	 mov	 QWORD PTR tv231[rsp], rdx
  00326	44 8b 4c 24 30	 mov	 r9d, DWORD PTR slen$4[rsp]
  0032b	4c 8b c0	 mov	 r8, rax
  0032e	8b d1		 mov	 edx, ecx
  00330	48 8b 44 24 50	 mov	 rax, QWORD PTR tv231[rsp]
  00335	48 8b c8	 mov	 rcx, rax
  00338	e8 00 00 00 00	 call	 ?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z ; stbtt_CompareUTF8toUTF16_bigendian_internal
  0033d	85 c0		 test	 eax, eax
  0033f	74 07		 je	 SHORT $LN16@stbtt__mat

; 4874 :                         return 1;

  00341	b8 01 00 00 00	 mov	 eax, 1
  00346	eb 1d		 jmp	 SHORT $LN1@stbtt__mat
$LN16@stbtt__mat:
$LN15@stbtt__mat:
$LN13@stbtt__mat:

; 4875 :                   }
; 4876 :                } else {

  00348	eb 14		 jmp	 SHORT $LN11@stbtt__mat
$LN10@stbtt__mat:

; 4877 :                   // if nothing immediately following
; 4878 :                   if (matchlen == nlen)

  0034a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR nlen$[rsp]
  00351	39 44 24 24	 cmp	 DWORD PTR matchlen$2[rsp], eax
  00355	75 07		 jne	 SHORT $LN17@stbtt__mat

; 4879 :                      return 1;

  00357	b8 01 00 00 00	 mov	 eax, 1
  0035c	eb 07		 jmp	 SHORT $LN1@stbtt__mat
$LN17@stbtt__mat:
$LN11@stbtt__mat:
$LN9@stbtt__mat:
$LN6@stbtt__mat:
$LN5@stbtt__mat:

; 4880 :                }
; 4881 :             }
; 4882 :          }
; 4883 : 
; 4884 :          // @TODO handle other encodings
; 4885 :       }
; 4886 :    }

  0035e	e9 00 fd ff ff	 jmp	 $LN2@stbtt__mat
$LN3@stbtt__mat:

; 4887 :    return 0;

  00363	33 c0		 xor	 eax, eax
$LN1@stbtt__mat:

; 4888 : }

  00365	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00369	c3		 ret	 0
?stbtt__matchpair@@YAHPEAEI0HHH@Z ENDP			; stbtt__matchpair
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv70 = 32
s1$ = 64
len1$ = 72
s2$ = 80
len2$ = 88
?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z PROC ; stbtt_CompareUTF8toUTF16_bigendian_internal

; 4816 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4817 :    return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);

  00017	44 8b 4c 24 58	 mov	 r9d, DWORD PTR len2$[rsp]
  0001c	4c 8b 44 24 50	 mov	 r8, QWORD PTR s2$[rsp]
  00021	8b 54 24 48	 mov	 edx, DWORD PTR len1$[rsp]
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s1$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z ; stbtt__CompareUTF8toUTF16_bigendian_prefix
  0002f	39 44 24 48	 cmp	 DWORD PTR len1$[rsp], eax
  00033	75 0a		 jne	 SHORT $LN3@stbtt_Comp
  00035	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN4@stbtt_Comp
$LN3@stbtt_Comp:
  0003f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@stbtt_Comp:
  00047	8b 44 24 20	 mov	 eax, DWORD PTR tv70[rsp]

; 4818 : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z ENDP ; stbtt_CompareUTF8toUTF16_bigendian_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 0
ch$1 = 4
c$2 = 8
ch2$3 = 12
tv85 = 16
tv84 = 20
tv132 = 24
tv131 = 28
tv143 = 32
tv142 = 36
tv175 = 40
tv174 = 44
tv186 = 48
tv185 = 52
tv197 = 56
tv196 = 60
tv207 = 64
tv206 = 68
tv226 = 72
tv225 = 76
tv238 = 80
tv237 = 84
tv249 = 88
tv248 = 92
s1$ = 112
len1$ = 120
s2$ = 128
len2$ = 136
?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z PROC ; stbtt__CompareUTF8toUTF16_bigendian_prefix

; 4777 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4778 :    stbtt_int32 i=0;

  00017	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
$LN2@stbtt__Com:

; 4779 : 
; 4780 :    // convert utf16 to utf8 and compare the results while converting
; 4781 :    while (len2) {

  0001e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR len2$[rsp], 0
  00026	0f 84 03 04 00
	00		 je	 $LN3@stbtt__Com

; 4782 :       stbtt_uint16 ch = s2[0]*256 + s2[1];

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 00	 imul	 rax, rax, 0
  00035	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s2$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	48 6b c9 01	 imul	 rcx, rcx, 1
  00050	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s2$[rsp]
  00058	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005c	03 c1		 add	 eax, ecx
  0005e	66 89 44 24 04	 mov	 WORD PTR ch$1[rsp], ax

; 4783 :       if (ch < 0x80) {

  00063	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00068	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0006d	7d 4e		 jge	 SHORT $LN4@stbtt__Com

; 4784 :          if (i >= len1) return -1;

  0006f	8b 44 24 78	 mov	 eax, DWORD PTR len1$[rsp]
  00073	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00076	7c 0a		 jl	 SHORT $LN6@stbtt__Com
  00078	b8 ff ff ff ff	 mov	 eax, -1
  0007d	e9 b0 03 00 00	 jmp	 $LN1@stbtt__Com
$LN6@stbtt__Com:

; 4785 :          if (s1[i++] != ch) return -1;

  00082	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  0008b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008f	89 44 24 14	 mov	 DWORD PTR tv84[rsp], eax
  00093	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00098	89 44 24 10	 mov	 DWORD PTR tv85[rsp], eax
  0009c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0009f	ff c0		 inc	 eax
  000a1	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  000a4	8b 44 24 10	 mov	 eax, DWORD PTR tv85[rsp]
  000a8	39 44 24 14	 cmp	 DWORD PTR tv84[rsp], eax
  000ac	74 0a		 je	 SHORT $LN7@stbtt__Com
  000ae	b8 ff ff ff ff	 mov	 eax, -1
  000b3	e9 7a 03 00 00	 jmp	 $LN1@stbtt__Com
$LN7@stbtt__Com:
  000b8	e9 48 03 00 00	 jmp	 $LN5@stbtt__Com
$LN4@stbtt__Com:

; 4786 :       } else if (ch < 0x800) {

  000bd	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  000c2	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  000c7	0f 8d 96 00 00
	00		 jge	 $LN8@stbtt__Com

; 4787 :          if (i+1 >= len1) return -1;

  000cd	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	3b 44 24 78	 cmp	 eax, DWORD PTR len1$[rsp]
  000d6	7c 0a		 jl	 SHORT $LN10@stbtt__Com
  000d8	b8 ff ff ff ff	 mov	 eax, -1
  000dd	e9 50 03 00 00	 jmp	 $LN1@stbtt__Com
$LN10@stbtt__Com:

; 4788 :          if (s1[i++] != 0xc0 + (ch >> 6)) return -1;

  000e2	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  000eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ef	89 44 24 1c	 mov	 DWORD PTR tv131[rsp], eax
  000f3	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  000f8	c1 f8 06	 sar	 eax, 6
  000fb	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  00100	89 44 24 18	 mov	 DWORD PTR tv132[rsp], eax
  00104	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00107	ff c0		 inc	 eax
  00109	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0010c	8b 44 24 18	 mov	 eax, DWORD PTR tv132[rsp]
  00110	39 44 24 1c	 cmp	 DWORD PTR tv131[rsp], eax
  00114	74 0a		 je	 SHORT $LN11@stbtt__Com
  00116	b8 ff ff ff ff	 mov	 eax, -1
  0011b	e9 12 03 00 00	 jmp	 $LN1@stbtt__Com
$LN11@stbtt__Com:

; 4789 :          if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;

  00120	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00124	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  00129	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0012d	89 44 24 24	 mov	 DWORD PTR tv142[rsp], eax
  00131	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00136	83 e0 3f	 and	 eax, 63			; 0000003fH
  00139	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0013e	89 44 24 20	 mov	 DWORD PTR tv143[rsp], eax
  00142	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00145	ff c0		 inc	 eax
  00147	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0014a	8b 44 24 20	 mov	 eax, DWORD PTR tv143[rsp]
  0014e	39 44 24 24	 cmp	 DWORD PTR tv142[rsp], eax
  00152	74 0a		 je	 SHORT $LN12@stbtt__Com
  00154	b8 ff ff ff ff	 mov	 eax, -1
  00159	e9 d4 02 00 00	 jmp	 $LN1@stbtt__Com
$LN12@stbtt__Com:
  0015e	e9 a2 02 00 00	 jmp	 $LN9@stbtt__Com
$LN8@stbtt__Com:

; 4790 :       } else if (ch >= 0xd800 && ch < 0xdc00) {

  00163	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00168	3d 00 d8 00 00	 cmp	 eax, 55296		; 0000d800H
  0016d	0f 8c 9e 01 00
	00		 jl	 $LN13@stbtt__Com
  00173	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00178	3d 00 dc 00 00	 cmp	 eax, 56320		; 0000dc00H
  0017d	0f 8d 8e 01 00
	00		 jge	 $LN13@stbtt__Com

; 4791 :          stbtt_uint32 c;
; 4792 :          stbtt_uint16 ch2 = s2[2]*256 + s2[3];

  00183	b8 01 00 00 00	 mov	 eax, 1
  00188	48 6b c0 02	 imul	 rax, rax, 2
  0018c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s2$[rsp]
  00194	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00198	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0019e	b9 01 00 00 00	 mov	 ecx, 1
  001a3	48 6b c9 03	 imul	 rcx, rcx, 3
  001a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s2$[rsp]
  001af	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001b3	03 c1		 add	 eax, ecx
  001b5	66 89 44 24 0c	 mov	 WORD PTR ch2$3[rsp], ax

; 4793 :          if (i+3 >= len1) return -1;

  001ba	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  001bd	83 c0 03	 add	 eax, 3
  001c0	3b 44 24 78	 cmp	 eax, DWORD PTR len1$[rsp]
  001c4	7c 0a		 jl	 SHORT $LN15@stbtt__Com
  001c6	b8 ff ff ff ff	 mov	 eax, -1
  001cb	e9 62 02 00 00	 jmp	 $LN1@stbtt__Com
$LN15@stbtt__Com:

; 4794 :          c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;

  001d0	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  001d5	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  001da	c1 e0 0a	 shl	 eax, 10
  001dd	0f b7 4c 24 0c	 movzx	 ecx, WORD PTR ch2$3[rsp]
  001e2	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  001e9	89 44 24 08	 mov	 DWORD PTR c$2[rsp], eax

; 4795 :          if (s1[i++] != 0xf0 + (c >> 18)) return -1;

  001ed	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  001f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fa	89 44 24 2c	 mov	 DWORD PTR tv174[rsp], eax
  001fe	8b 44 24 08	 mov	 eax, DWORD PTR c$2[rsp]
  00202	c1 e8 12	 shr	 eax, 18
  00205	05 f0 00 00 00	 add	 eax, 240		; 000000f0H
  0020a	89 44 24 28	 mov	 DWORD PTR tv175[rsp], eax
  0020e	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00211	ff c0		 inc	 eax
  00213	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00216	8b 44 24 28	 mov	 eax, DWORD PTR tv175[rsp]
  0021a	39 44 24 2c	 cmp	 DWORD PTR tv174[rsp], eax
  0021e	74 0a		 je	 SHORT $LN16@stbtt__Com
  00220	b8 ff ff ff ff	 mov	 eax, -1
  00225	e9 08 02 00 00	 jmp	 $LN1@stbtt__Com
$LN16@stbtt__Com:

; 4796 :          if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;

  0022a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  00233	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00237	89 44 24 34	 mov	 DWORD PTR tv185[rsp], eax
  0023b	8b 44 24 08	 mov	 eax, DWORD PTR c$2[rsp]
  0023f	c1 e8 0c	 shr	 eax, 12
  00242	83 e0 3f	 and	 eax, 63			; 0000003fH
  00245	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0024a	89 44 24 30	 mov	 DWORD PTR tv186[rsp], eax
  0024e	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00251	ff c0		 inc	 eax
  00253	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00256	8b 44 24 30	 mov	 eax, DWORD PTR tv186[rsp]
  0025a	39 44 24 34	 cmp	 DWORD PTR tv185[rsp], eax
  0025e	74 0a		 je	 SHORT $LN17@stbtt__Com
  00260	b8 ff ff ff ff	 mov	 eax, -1
  00265	e9 c8 01 00 00	 jmp	 $LN1@stbtt__Com
$LN17@stbtt__Com:

; 4797 :          if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;

  0026a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0026e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  00273	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00277	89 44 24 3c	 mov	 DWORD PTR tv196[rsp], eax
  0027b	8b 44 24 08	 mov	 eax, DWORD PTR c$2[rsp]
  0027f	c1 e8 06	 shr	 eax, 6
  00282	83 e0 3f	 and	 eax, 63			; 0000003fH
  00285	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0028a	89 44 24 38	 mov	 DWORD PTR tv197[rsp], eax
  0028e	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00291	ff c0		 inc	 eax
  00293	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00296	8b 44 24 38	 mov	 eax, DWORD PTR tv197[rsp]
  0029a	39 44 24 3c	 cmp	 DWORD PTR tv196[rsp], eax
  0029e	74 0a		 je	 SHORT $LN18@stbtt__Com
  002a0	b8 ff ff ff ff	 mov	 eax, -1
  002a5	e9 88 01 00 00	 jmp	 $LN1@stbtt__Com
$LN18@stbtt__Com:

; 4798 :          if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;

  002aa	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  002ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  002b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b7	89 44 24 44	 mov	 DWORD PTR tv206[rsp], eax
  002bb	8b 44 24 08	 mov	 eax, DWORD PTR c$2[rsp]
  002bf	83 e0 3f	 and	 eax, 63			; 0000003fH
  002c2	05 80 00 00 00	 add	 eax, 128		; 00000080H
  002c7	89 44 24 40	 mov	 DWORD PTR tv207[rsp], eax
  002cb	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  002ce	ff c0		 inc	 eax
  002d0	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  002d3	8b 44 24 40	 mov	 eax, DWORD PTR tv207[rsp]
  002d7	39 44 24 44	 cmp	 DWORD PTR tv206[rsp], eax
  002db	74 0a		 je	 SHORT $LN19@stbtt__Com
  002dd	b8 ff ff ff ff	 mov	 eax, -1
  002e2	e9 4b 01 00 00	 jmp	 $LN1@stbtt__Com
$LN19@stbtt__Com:

; 4799 :          s2 += 2; // plus another 2 below

  002e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s2$[rsp]
  002ef	48 83 c0 02	 add	 rax, 2
  002f3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s2$[rsp], rax

; 4800 :          len2 -= 2;

  002fb	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR len2$[rsp]
  00302	83 e8 02	 sub	 eax, 2
  00305	89 84 24 88 00
	00 00		 mov	 DWORD PTR len2$[rsp], eax
  0030c	e9 f4 00 00 00	 jmp	 $LN14@stbtt__Com
$LN13@stbtt__Com:

; 4801 :       } else if (ch >= 0xdc00 && ch < 0xe000) {

  00311	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00316	3d 00 dc 00 00	 cmp	 eax, 56320		; 0000dc00H
  0031b	7c 1b		 jl	 SHORT $LN20@stbtt__Com
  0031d	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00322	3d 00 e0 00 00	 cmp	 eax, 57344		; 0000e000H
  00327	7d 0f		 jge	 SHORT $LN20@stbtt__Com

; 4802 :          return -1;

  00329	b8 ff ff ff ff	 mov	 eax, -1
  0032e	e9 ff 00 00 00	 jmp	 $LN1@stbtt__Com

; 4803 :       } else {

  00333	e9 cd 00 00 00	 jmp	 $LN21@stbtt__Com
$LN20@stbtt__Com:

; 4804 :          if (i+2 >= len1) return -1;

  00338	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0033b	83 c0 02	 add	 eax, 2
  0033e	3b 44 24 78	 cmp	 eax, DWORD PTR len1$[rsp]
  00342	7c 0a		 jl	 SHORT $LN22@stbtt__Com
  00344	b8 ff ff ff ff	 mov	 eax, -1
  00349	e9 e4 00 00 00	 jmp	 $LN1@stbtt__Com
$LN22@stbtt__Com:

; 4805 :          if (s1[i++] != 0xe0 + (ch >> 12)) return -1;

  0034e	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  00357	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035b	89 44 24 4c	 mov	 DWORD PTR tv225[rsp], eax
  0035f	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  00364	c1 f8 0c	 sar	 eax, 12
  00367	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  0036c	89 44 24 48	 mov	 DWORD PTR tv226[rsp], eax
  00370	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00373	ff c0		 inc	 eax
  00375	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00378	8b 44 24 48	 mov	 eax, DWORD PTR tv226[rsp]
  0037c	39 44 24 4c	 cmp	 DWORD PTR tv225[rsp], eax
  00380	74 0a		 je	 SHORT $LN23@stbtt__Com
  00382	b8 ff ff ff ff	 mov	 eax, -1
  00387	e9 a6 00 00 00	 jmp	 $LN1@stbtt__Com
$LN23@stbtt__Com:

; 4806 :          if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;

  0038c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00390	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  00395	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00399	89 44 24 54	 mov	 DWORD PTR tv237[rsp], eax
  0039d	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  003a2	c1 f8 06	 sar	 eax, 6
  003a5	83 e0 3f	 and	 eax, 63			; 0000003fH
  003a8	05 80 00 00 00	 add	 eax, 128		; 00000080H
  003ad	89 44 24 50	 mov	 DWORD PTR tv238[rsp], eax
  003b1	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  003b4	ff c0		 inc	 eax
  003b6	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  003b9	8b 44 24 50	 mov	 eax, DWORD PTR tv238[rsp]
  003bd	39 44 24 54	 cmp	 DWORD PTR tv237[rsp], eax
  003c1	74 07		 je	 SHORT $LN24@stbtt__Com
  003c3	b8 ff ff ff ff	 mov	 eax, -1
  003c8	eb 68		 jmp	 SHORT $LN1@stbtt__Com
$LN24@stbtt__Com:

; 4807 :          if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;

  003ca	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  003ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s1$[rsp]
  003d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d7	89 44 24 5c	 mov	 DWORD PTR tv248[rsp], eax
  003db	0f b7 44 24 04	 movzx	 eax, WORD PTR ch$1[rsp]
  003e0	83 e0 3f	 and	 eax, 63			; 0000003fH
  003e3	05 80 00 00 00	 add	 eax, 128		; 00000080H
  003e8	89 44 24 58	 mov	 DWORD PTR tv249[rsp], eax
  003ec	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  003ef	ff c0		 inc	 eax
  003f1	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  003f4	8b 44 24 58	 mov	 eax, DWORD PTR tv249[rsp]
  003f8	39 44 24 5c	 cmp	 DWORD PTR tv248[rsp], eax
  003fc	74 07		 je	 SHORT $LN25@stbtt__Com
  003fe	b8 ff ff ff ff	 mov	 eax, -1
  00403	eb 2d		 jmp	 SHORT $LN1@stbtt__Com
$LN25@stbtt__Com:
$LN21@stbtt__Com:
$LN14@stbtt__Com:
$LN9@stbtt__Com:
$LN5@stbtt__Com:

; 4808 :       }
; 4809 :       s2 += 2;

  00405	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s2$[rsp]
  0040d	48 83 c0 02	 add	 rax, 2
  00411	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s2$[rsp], rax

; 4810 :       len2 -= 2;

  00419	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR len2$[rsp]
  00420	83 e8 02	 sub	 eax, 2
  00423	89 84 24 88 00
	00 00		 mov	 DWORD PTR len2$[rsp], eax

; 4811 :    }

  0042a	e9 ef fb ff ff	 jmp	 $LN2@stbtt__Com
$LN3@stbtt__Com:

; 4812 :    return i;

  0042f	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
$LN1@stbtt__Com:

; 4813 : }

  00432	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00436	c3		 ret	 0
?stbtt__CompareUTF8toUTF16_bigendian_prefix@@YAHPEAEH0H@Z ENDP ; stbtt__CompareUTF8toUTF16_bigendian_prefix
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
q$ = 32
p$ = 36
s$ = 40
u$1 = 44
v$2 = 48
m$3 = 52
u$4 = 56
d$ = 60
z$5 = 64
p3$ = 68
v$6 = 72
n$7 = 76
a$ = 96
b$ = 104
c$ = 112
r$ = 120
?stbtt__solve_cubic@@YAHMMMPEAM@Z PROC			; stbtt__solve_cubic

; 4545 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00011	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00017	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4546 :    float s = -a / 3;

  0001b	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR a$[rsp]
  00021	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00028	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  00030	f3 0f 11 44 24
	28		 movss	 DWORD PTR s$[rsp], xmm0

; 4547 :    float p = b - a*a / 3;

  00036	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR a$[rsp]
  0003c	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR a$[rsp]
  00042	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  0004a	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR b$[rsp]
  00050	f3 0f 5c c8	 subss	 xmm1, xmm0
  00054	0f 28 c1	 movaps	 xmm0, xmm1
  00057	f3 0f 11 44 24
	24		 movss	 DWORD PTR p$[rsp], xmm0

; 4548 :    float q = a * (2*a*a - 9*b) / 27 + c;

  0005d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00065	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR a$[rsp]
  0006b	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR a$[rsp]
  00071	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@41100000
  00079	f3 0f 59 4c 24
	68		 mulss	 xmm1, DWORD PTR b$[rsp]
  0007f	f3 0f 5c c1	 subss	 xmm0, xmm1
  00083	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR a$[rsp]
  00089	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0008d	0f 28 c1	 movaps	 xmm0, xmm1
  00090	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41d80000
  00098	f3 0f 58 44 24
	70		 addss	 xmm0, DWORD PTR c$[rsp]
  0009e	f3 0f 11 44 24
	20		 movss	 DWORD PTR q$[rsp], xmm0

; 4549 :    float p3 = p*p*p;

  000a4	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR p$[rsp]
  000aa	f3 0f 59 44 24
	24		 mulss	 xmm0, DWORD PTR p$[rsp]
  000b0	f3 0f 59 44 24
	24		 mulss	 xmm0, DWORD PTR p$[rsp]
  000b6	f3 0f 11 44 24
	44		 movss	 DWORD PTR p3$[rsp], xmm0

; 4550 :    float d = q*q + 4*p3 / 27;

  000bc	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR q$[rsp]
  000c2	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR q$[rsp]
  000c8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  000d0	f3 0f 59 4c 24
	44		 mulss	 xmm1, DWORD PTR p3$[rsp]
  000d6	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@41d80000
  000de	f3 0f 58 c1	 addss	 xmm0, xmm1
  000e2	f3 0f 11 44 24
	3c		 movss	 DWORD PTR d$[rsp], xmm0

; 4551 :    if (d >= 0) {

  000e8	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR d$[rsp]
  000ee	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000f5	0f 82 ad 00 00
	00		 jb	 $LN2@stbtt__sol

; 4552 :       float z = (float) STBTT_sqrt(d);

  000fb	f3 0f 5a 44 24
	3c		 cvtss2sd xmm0, DWORD PTR d$[rsp]
  00101	e8 00 00 00 00	 call	 sqrt
  00106	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0010a	f3 0f 11 44 24
	40		 movss	 DWORD PTR z$5[rsp], xmm0

; 4553 :       float u = (-q + z) / 2;

  00110	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR q$[rsp]
  00116	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0011d	f3 0f 58 44 24
	40		 addss	 xmm0, DWORD PTR z$5[rsp]
  00123	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0012b	f3 0f 11 44 24
	2c		 movss	 DWORD PTR u$1[rsp], xmm0

; 4554 :       float v = (-q - z) / 2;

  00131	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR q$[rsp]
  00137	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0013e	f3 0f 5c 44 24
	40		 subss	 xmm0, DWORD PTR z$5[rsp]
  00144	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0014c	f3 0f 11 44 24
	30		 movss	 DWORD PTR v$2[rsp], xmm0

; 4555 :       u = stbtt__cuberoot(u);

  00152	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR u$1[rsp]
  00158	e8 00 00 00 00	 call	 ?stbtt__cuberoot@@YAMM@Z ; stbtt__cuberoot
  0015d	f3 0f 11 44 24
	2c		 movss	 DWORD PTR u$1[rsp], xmm0

; 4556 :       v = stbtt__cuberoot(v);

  00163	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR v$2[rsp]
  00169	e8 00 00 00 00	 call	 ?stbtt__cuberoot@@YAMM@Z ; stbtt__cuberoot
  0016e	f3 0f 11 44 24
	30		 movss	 DWORD PTR v$2[rsp], xmm0

; 4557 :       r[0] = s + u + v;

  00174	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR s$[rsp]
  0017a	f3 0f 58 44 24
	2c		 addss	 xmm0, DWORD PTR u$1[rsp]
  00180	f3 0f 58 44 24
	30		 addss	 xmm0, DWORD PTR v$2[rsp]
  00186	b8 04 00 00 00	 mov	 eax, 4
  0018b	48 6b c0 00	 imul	 rax, rax, 0
  0018f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR r$[rsp]
  00194	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 4558 :       return 1;

  00199	b8 01 00 00 00	 mov	 eax, 1
  0019e	e9 59 01 00 00	 jmp	 $LN1@stbtt__sol

; 4559 :    } else {

  001a3	e9 54 01 00 00	 jmp	 $LN3@stbtt__sol
$LN2@stbtt__sol:

; 4560 :       float u = (float) STBTT_sqrt(-p/3);

  001a8	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR p$[rsp]
  001ae	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001b5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  001bd	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001c1	e8 00 00 00 00	 call	 sqrt
  001c6	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001ca	f3 0f 11 44 24
	38		 movss	 DWORD PTR u$4[rsp], xmm0

; 4561 :       float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative

  001d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c1d80000
  001d8	f3 0f 5e 44 24
	44		 divss	 xmm0, DWORD PTR p3$[rsp]
  001de	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001e2	e8 00 00 00 00	 call	 sqrt
  001e7	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  001ee	f3 0f 5a 4c 24
	20		 cvtss2sd xmm1, DWORD PTR q$[rsp]
  001f4	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  001f8	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  00200	e8 00 00 00 00	 call	 acos
  00205	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00209	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  00211	f3 0f 11 44 24
	48		 movss	 DWORD PTR v$6[rsp], xmm0

; 4562 :       float m = (float) STBTT_cos(v);

  00217	f3 0f 5a 44 24
	48		 cvtss2sd xmm0, DWORD PTR v$6[rsp]
  0021d	e8 00 00 00 00	 call	 cos
  00222	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00226	f3 0f 11 44 24
	34		 movss	 DWORD PTR m$3[rsp], xmm0

; 4563 :       float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;

  0022c	f3 0f 5a 44 24
	48		 cvtss2sd xmm0, DWORD PTR v$6[rsp]
  00232	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff921fafc8b007a
  0023a	e8 00 00 00 00	 call	 cos
  0023f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00243	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3fddb3d7
  0024b	f3 0f 11 44 24
	4c		 movss	 DWORD PTR n$7[rsp], xmm0

; 4564 :       r[0] = s + u * 2 * m;

  00251	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR u$4[rsp]
  00257	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0025f	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR m$3[rsp]
  00265	f3 0f 10 4c 24
	28		 movss	 xmm1, DWORD PTR s$[rsp]
  0026b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0026f	0f 28 c1	 movaps	 xmm0, xmm1
  00272	b8 04 00 00 00	 mov	 eax, 4
  00277	48 6b c0 00	 imul	 rax, rax, 0
  0027b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR r$[rsp]
  00280	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 4565 :       r[1] = s - u * (m + n);

  00285	f3 0f 10 44 24
	34		 movss	 xmm0, DWORD PTR m$3[rsp]
  0028b	f3 0f 58 44 24
	4c		 addss	 xmm0, DWORD PTR n$7[rsp]
  00291	f3 0f 10 4c 24
	38		 movss	 xmm1, DWORD PTR u$4[rsp]
  00297	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0029b	0f 28 c1	 movaps	 xmm0, xmm1
  0029e	f3 0f 10 4c 24
	28		 movss	 xmm1, DWORD PTR s$[rsp]
  002a4	f3 0f 5c c8	 subss	 xmm1, xmm0
  002a8	0f 28 c1	 movaps	 xmm0, xmm1
  002ab	b8 04 00 00 00	 mov	 eax, 4
  002b0	48 6b c0 01	 imul	 rax, rax, 1
  002b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR r$[rsp]
  002b9	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 4566 :       r[2] = s - u * (m - n);

  002be	f3 0f 10 44 24
	34		 movss	 xmm0, DWORD PTR m$3[rsp]
  002c4	f3 0f 5c 44 24
	4c		 subss	 xmm0, DWORD PTR n$7[rsp]
  002ca	f3 0f 10 4c 24
	38		 movss	 xmm1, DWORD PTR u$4[rsp]
  002d0	f3 0f 59 c8	 mulss	 xmm1, xmm0
  002d4	0f 28 c1	 movaps	 xmm0, xmm1
  002d7	f3 0f 10 4c 24
	28		 movss	 xmm1, DWORD PTR s$[rsp]
  002dd	f3 0f 5c c8	 subss	 xmm1, xmm0
  002e1	0f 28 c1	 movaps	 xmm0, xmm1
  002e4	b8 04 00 00 00	 mov	 eax, 4
  002e9	48 6b c0 02	 imul	 rax, rax, 2
  002ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR r$[rsp]
  002f2	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 4567 : 
; 4568 :       //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
; 4569 :       //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
; 4570 :       //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
; 4571 :       return 3;

  002f7	b8 03 00 00 00	 mov	 eax, 3
$LN3@stbtt__sol:
$LN1@stbtt__sol:

; 4572 :    }
; 4573 : }

  002fc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00300	c3		 ret	 0
?stbtt__solve_cubic@@YAHMMMPEAM@Z ENDP			; stbtt__solve_cubic
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
x$ = 48
?stbtt__cuberoot@@YAMM@Z PROC				; stbtt__cuberoot

; 4536 : {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4537 :    if (x<0)

  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	0f 2f 44 24 30	 comiss	 xmm0, DWORD PTR x$[rsp]
  00012	76 2d		 jbe	 SHORT $LN2@stbtt__cub

; 4538 :       return -(float) STBTT_pow(-x,1.0f/3.0f);

  00014	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR x$[rsp]
  0001a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00021	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00025	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fd5555560000000
  0002d	e8 00 00 00 00	 call	 pow
  00032	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00036	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0003d	eb 19		 jmp	 SHORT $LN1@stbtt__cub
  0003f	eb 17		 jmp	 SHORT $LN3@stbtt__cub
$LN2@stbtt__cub:

; 4539 :    else
; 4540 :       return  (float) STBTT_pow( x,1.0f/3.0f);

  00041	f3 0f 5a 44 24
	30		 cvtss2sd xmm0, DWORD PTR x$[rsp]
  00047	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fd5555560000000
  0004f	e8 00 00 00 00	 call	 pow
  00054	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
$LN3@stbtt__cub:
$LN1@stbtt__cub:

; 4541 : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
?stbtt__cuberoot@@YAMM@Z ENDP				; stbtt__cuberoot
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 48
y1$1 = 52
y0$2 = 56
y2$3 = 60
x1$4 = 64
winding$ = 68
x0$5 = 72
y0$6 = 76
y1$7 = 80
x2$8 = 84
x0$9 = 88
x1$10 = 92
y_frac$ = 96
tv140 = 100
tv144 = 104
tv148 = 108
tv163 = 112
tv204 = 116
tv207 = 120
tv208 = 124
tv210 = 128
tv213 = 132
tv214 = 136
tv216 = 140
tv219 = 144
tv220 = 148
tv276 = 152
tv280 = 156
tv284 = 160
tv299 = 164
tv319 = 168
num_hits$11 = 172
tv364 = 176
q1$12 = 184
ay$13 = 192
by$14 = 196
ax$15 = 200
x_inter$16 = 204
x_inter$17 = 208
q2$18 = 216
q0$19 = 224
ray$ = 232
orig$ = 240
hits$20 = 248
__$ArrayPad$ = 264
x$ = 288
y$ = 296
nverts$ = 304
verts$ = 312
?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z PROC ; stbtt__compute_crossings_x

; 4468 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00010	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4469 :    int i;
; 4470 :    float orig[2], ray[2] = { 1, 0 };

  0002f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00037	f3 0f 11 84 24
	e8 00 00 00	 movss	 DWORD PTR ray$[rsp], xmm0
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 84 24
	ec 00 00 00	 movss	 DWORD PTR ray$[rsp+4], xmm0

; 4471 :    float y_frac;
; 4472 :    int winding = 0;

  0004c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR winding$[rsp], 0

; 4473 : 
; 4474 :    // make sure y never passes through a vertex of the shape
; 4475 :    y_frac = (float) STBTT_fmod(y, 1.0f);

  00054	f3 0f 5a 84 24
	28 01 00 00	 cvtss2sd xmm0, DWORD PTR y$[rsp]
  0005d	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00065	e8 00 00 00 00	 call	 fmod
  0006a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0006e	f3 0f 11 44 24
	60		 movss	 DWORD PTR y_frac$[rsp], xmm0

; 4476 :    if (y_frac < 0.01f)

  00074	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  0007c	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR y_frac$[rsp]
  00081	76 1c		 jbe	 SHORT $LN5@stbtt__com

; 4477 :       y += 0.01f;

  00083	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y$[rsp]
  0008c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3c23d70a
  00094	f3 0f 11 84 24
	28 01 00 00	 movss	 DWORD PTR y$[rsp], xmm0
  0009d	eb 29		 jmp	 SHORT $LN6@stbtt__com
$LN5@stbtt__com:

; 4478 :    else if (y_frac > 0.99f)

  0009f	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y_frac$[rsp]
  000a5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f7d70a4
  000ac	76 1a		 jbe	 SHORT $LN7@stbtt__com

; 4479 :       y -= 0.01f;

  000ae	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y$[rsp]
  000b7	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3c23d70a
  000bf	f3 0f 11 84 24
	28 01 00 00	 movss	 DWORD PTR y$[rsp], xmm0
$LN7@stbtt__com:
$LN6@stbtt__com:

; 4480 : 
; 4481 :    orig[0] = x;

  000c8	b8 04 00 00 00	 mov	 eax, 4
  000cd	48 6b c0 00	 imul	 rax, rax, 0
  000d1	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR x$[rsp]
  000da	f3 0f 11 84 04
	f0 00 00 00	 movss	 DWORD PTR orig$[rsp+rax], xmm0

; 4482 :    orig[1] = y;

  000e3	b8 04 00 00 00	 mov	 eax, 4
  000e8	48 6b c0 01	 imul	 rax, rax, 1
  000ec	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y$[rsp]
  000f5	f3 0f 11 84 04
	f0 00 00 00	 movss	 DWORD PTR orig$[rsp+rax], xmm0

; 4483 : 
; 4484 :    // test a ray from (-infinity,y) to (x,y)
; 4485 :    for (i=0; i < nverts; ++i) {

  000fe	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00106	eb 0a		 jmp	 SHORT $LN4@stbtt__com
$LN2@stbtt__com:
  00108	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0010c	ff c0		 inc	 eax
  0010e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__com:
  00112	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR nverts$[rsp]
  00119	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0011d	0f 8d d6 07 00
	00		 jge	 $LN3@stbtt__com

; 4486 :       if (verts[i].type == STBTT_vline) {

  00123	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00128	48 6b c0 0e	 imul	 rax, rax, 14
  0012c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00134	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  00139	83 f8 02	 cmp	 eax, 2
  0013c	0f 85 94 01 00
	00		 jne	 $LN8@stbtt__com

; 4487 :          int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;

  00142	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00146	ff c8		 dec	 eax
  00148	48 98		 cdqe
  0014a	48 6b c0 0e	 imul	 rax, rax, 14
  0014e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00156	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0015a	89 44 24 58	 mov	 DWORD PTR x0$9[rsp], eax
  0015e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00162	ff c8		 dec	 eax
  00164	48 98		 cdqe
  00166	48 6b c0 0e	 imul	 rax, rax, 14
  0016a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00172	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00177	89 44 24 4c	 mov	 DWORD PTR y0$6[rsp], eax

; 4488 :          int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;

  0017b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00180	48 6b c0 0e	 imul	 rax, rax, 14
  00184	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  0018c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00190	89 44 24 5c	 mov	 DWORD PTR x1$10[rsp], eax
  00194	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00199	48 6b c0 0e	 imul	 rax, rax, 14
  0019d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  001a5	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  001aa	89 44 24 50	 mov	 DWORD PTR y1$7[rsp], eax

; 4489 :          if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {

  001ae	8b 44 24 50	 mov	 eax, DWORD PTR y1$7[rsp]
  001b2	39 44 24 4c	 cmp	 DWORD PTR y0$6[rsp], eax
  001b6	7d 0a		 jge	 SHORT $LN23@stbtt__com
  001b8	8b 44 24 4c	 mov	 eax, DWORD PTR y0$6[rsp]
  001bc	89 44 24 64	 mov	 DWORD PTR tv140[rsp], eax
  001c0	eb 08		 jmp	 SHORT $LN24@stbtt__com
$LN23@stbtt__com:
  001c2	8b 44 24 50	 mov	 eax, DWORD PTR y1$7[rsp]
  001c6	89 44 24 64	 mov	 DWORD PTR tv140[rsp], eax
$LN24@stbtt__com:
  001ca	f3 0f 2a 44 24
	64		 cvtsi2ss xmm0, DWORD PTR tv140[rsp]
  001d0	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR y$[rsp]
  001d9	0f 2f c8	 comiss	 xmm1, xmm0
  001dc	0f 86 f4 00 00
	00		 jbe	 $LN9@stbtt__com
  001e2	8b 44 24 50	 mov	 eax, DWORD PTR y1$7[rsp]
  001e6	39 44 24 4c	 cmp	 DWORD PTR y0$6[rsp], eax
  001ea	7d 0a		 jge	 SHORT $LN25@stbtt__com
  001ec	8b 44 24 50	 mov	 eax, DWORD PTR y1$7[rsp]
  001f0	89 44 24 68	 mov	 DWORD PTR tv144[rsp], eax
  001f4	eb 08		 jmp	 SHORT $LN26@stbtt__com
$LN25@stbtt__com:
  001f6	8b 44 24 4c	 mov	 eax, DWORD PTR y0$6[rsp]
  001fa	89 44 24 68	 mov	 DWORD PTR tv144[rsp], eax
$LN26@stbtt__com:
  001fe	f3 0f 2a 44 24
	68		 cvtsi2ss xmm0, DWORD PTR tv144[rsp]
  00204	0f 2f 84 24 28
	01 00 00	 comiss	 xmm0, DWORD PTR y$[rsp]
  0020c	0f 86 c4 00 00
	00		 jbe	 $LN9@stbtt__com
  00212	8b 44 24 5c	 mov	 eax, DWORD PTR x1$10[rsp]
  00216	39 44 24 58	 cmp	 DWORD PTR x0$9[rsp], eax
  0021a	7d 0a		 jge	 SHORT $LN27@stbtt__com
  0021c	8b 44 24 58	 mov	 eax, DWORD PTR x0$9[rsp]
  00220	89 44 24 6c	 mov	 DWORD PTR tv148[rsp], eax
  00224	eb 08		 jmp	 SHORT $LN28@stbtt__com
$LN27@stbtt__com:
  00226	8b 44 24 5c	 mov	 eax, DWORD PTR x1$10[rsp]
  0022a	89 44 24 6c	 mov	 DWORD PTR tv148[rsp], eax
$LN28@stbtt__com:
  0022e	f3 0f 2a 44 24
	6c		 cvtsi2ss xmm0, DWORD PTR tv148[rsp]
  00234	f3 0f 10 8c 24
	20 01 00 00	 movss	 xmm1, DWORD PTR x$[rsp]
  0023d	0f 2f c8	 comiss	 xmm1, xmm0
  00240	0f 86 90 00 00
	00		 jbe	 $LN9@stbtt__com

; 4490 :             float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;

  00246	f3 0f 2a 44 24
	4c		 cvtsi2ss xmm0, DWORD PTR y0$6[rsp]
  0024c	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR y$[rsp]
  00255	f3 0f 5c c8	 subss	 xmm1, xmm0
  00259	0f 28 c1	 movaps	 xmm0, xmm1
  0025c	8b 44 24 4c	 mov	 eax, DWORD PTR y0$6[rsp]
  00260	8b 4c 24 50	 mov	 ecx, DWORD PTR y1$7[rsp]
  00264	2b c8		 sub	 ecx, eax
  00266	8b c1		 mov	 eax, ecx
  00268	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  0026c	f3 0f 5e c1	 divss	 xmm0, xmm1
  00270	8b 44 24 58	 mov	 eax, DWORD PTR x0$9[rsp]
  00274	8b 4c 24 5c	 mov	 ecx, DWORD PTR x1$10[rsp]
  00278	2b c8		 sub	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00280	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00284	f3 0f 2a 4c 24
	58		 cvtsi2ss xmm1, DWORD PTR x0$9[rsp]
  0028a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0028e	f3 0f 11 84 24
	d0 00 00 00	 movss	 DWORD PTR x_inter$17[rsp], xmm0

; 4491 :             if (x_inter < x)

  00297	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR x$[rsp]
  002a0	0f 2f 84 24 d0
	00 00 00	 comiss	 xmm0, DWORD PTR x_inter$17[rsp]
  002a8	76 2c		 jbe	 SHORT $LN10@stbtt__com

; 4492 :                winding += (y0 < y1) ? 1 : -1;

  002aa	8b 44 24 50	 mov	 eax, DWORD PTR y1$7[rsp]
  002ae	39 44 24 4c	 cmp	 DWORD PTR y0$6[rsp], eax
  002b2	7d 0a		 jge	 SHORT $LN29@stbtt__com
  002b4	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  002bc	eb 08		 jmp	 SHORT $LN30@stbtt__com
$LN29@stbtt__com:
  002be	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR tv163[rsp], -1
$LN30@stbtt__com:
  002c6	8b 44 24 70	 mov	 eax, DWORD PTR tv163[rsp]
  002ca	8b 4c 24 44	 mov	 ecx, DWORD PTR winding$[rsp]
  002ce	03 c8		 add	 ecx, eax
  002d0	8b c1		 mov	 eax, ecx
  002d2	89 44 24 44	 mov	 DWORD PTR winding$[rsp], eax
$LN10@stbtt__com:
$LN9@stbtt__com:
$LN8@stbtt__com:

; 4493 :          }
; 4494 :       }
; 4495 :       if (verts[i].type == STBTT_vcurve) {

  002d6	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  002db	48 6b c0 0e	 imul	 rax, rax, 14
  002df	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  002e7	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  002ec	83 f8 03	 cmp	 eax, 3
  002ef	0f 85 ff 05 00
	00		 jne	 $LN11@stbtt__com

; 4496 :          int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;

  002f5	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  002f9	ff c8		 dec	 eax
  002fb	48 98		 cdqe
  002fd	48 6b c0 0e	 imul	 rax, rax, 14
  00301	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00309	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0030d	89 44 24 48	 mov	 DWORD PTR x0$5[rsp], eax
  00311	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00315	ff c8		 dec	 eax
  00317	48 98		 cdqe
  00319	48 6b c0 0e	 imul	 rax, rax, 14
  0031d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00325	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  0032a	89 44 24 38	 mov	 DWORD PTR y0$2[rsp], eax

; 4497 :          int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;

  0032e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00333	48 6b c0 0e	 imul	 rax, rax, 14
  00337	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  0033f	0f bf 44 01 04	 movsx	 eax, WORD PTR [rcx+rax+4]
  00344	89 44 24 40	 mov	 DWORD PTR x1$4[rsp], eax
  00348	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0034d	48 6b c0 0e	 imul	 rax, rax, 14
  00351	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00359	0f bf 44 01 06	 movsx	 eax, WORD PTR [rcx+rax+6]
  0035e	89 44 24 34	 mov	 DWORD PTR y1$1[rsp], eax

; 4498 :          int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;

  00362	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00367	48 6b c0 0e	 imul	 rax, rax, 14
  0036b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00373	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00377	89 44 24 54	 mov	 DWORD PTR x2$8[rsp], eax
  0037b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00380	48 6b c0 0e	 imul	 rax, rax, 14
  00384	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  0038c	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00391	89 44 24 3c	 mov	 DWORD PTR y2$3[rsp], eax

; 4499 :          int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));

  00395	8b 44 24 54	 mov	 eax, DWORD PTR x2$8[rsp]
  00399	39 44 24 40	 cmp	 DWORD PTR x1$4[rsp], eax
  0039d	7d 0a		 jge	 SHORT $LN31@stbtt__com
  0039f	8b 44 24 40	 mov	 eax, DWORD PTR x1$4[rsp]
  003a3	89 44 24 74	 mov	 DWORD PTR tv204[rsp], eax
  003a7	eb 08		 jmp	 SHORT $LN32@stbtt__com
$LN31@stbtt__com:
  003a9	8b 44 24 54	 mov	 eax, DWORD PTR x2$8[rsp]
  003ad	89 44 24 74	 mov	 DWORD PTR tv204[rsp], eax
$LN32@stbtt__com:
  003b1	8b 44 24 74	 mov	 eax, DWORD PTR tv204[rsp]
  003b5	39 44 24 48	 cmp	 DWORD PTR x0$5[rsp], eax
  003b9	7d 0a		 jge	 SHORT $LN35@stbtt__com
  003bb	8b 44 24 48	 mov	 eax, DWORD PTR x0$5[rsp]
  003bf	89 44 24 7c	 mov	 DWORD PTR tv208[rsp], eax
  003c3	eb 24		 jmp	 SHORT $LN36@stbtt__com
$LN35@stbtt__com:
  003c5	8b 44 24 54	 mov	 eax, DWORD PTR x2$8[rsp]
  003c9	39 44 24 40	 cmp	 DWORD PTR x1$4[rsp], eax
  003cd	7d 0a		 jge	 SHORT $LN33@stbtt__com
  003cf	8b 44 24 40	 mov	 eax, DWORD PTR x1$4[rsp]
  003d3	89 44 24 78	 mov	 DWORD PTR tv207[rsp], eax
  003d7	eb 08		 jmp	 SHORT $LN34@stbtt__com
$LN33@stbtt__com:
  003d9	8b 44 24 54	 mov	 eax, DWORD PTR x2$8[rsp]
  003dd	89 44 24 78	 mov	 DWORD PTR tv207[rsp], eax
$LN34@stbtt__com:
  003e1	8b 44 24 78	 mov	 eax, DWORD PTR tv207[rsp]
  003e5	89 44 24 7c	 mov	 DWORD PTR tv208[rsp], eax
$LN36@stbtt__com:
  003e9	8b 44 24 7c	 mov	 eax, DWORD PTR tv208[rsp]
  003ed	89 84 24 c8 00
	00 00		 mov	 DWORD PTR ax$15[rsp], eax
  003f4	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  003f8	39 44 24 34	 cmp	 DWORD PTR y1$1[rsp], eax
  003fc	7d 0d		 jge	 SHORT $LN37@stbtt__com
  003fe	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  00402	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv210[rsp], eax
  00409	eb 0b		 jmp	 SHORT $LN38@stbtt__com
$LN37@stbtt__com:
  0040b	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  0040f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv210[rsp], eax
$LN38@stbtt__com:
  00416	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv210[rsp]
  0041d	39 44 24 38	 cmp	 DWORD PTR y0$2[rsp], eax
  00421	7d 0d		 jge	 SHORT $LN41@stbtt__com
  00423	8b 44 24 38	 mov	 eax, DWORD PTR y0$2[rsp]
  00427	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv214[rsp], eax
  0042e	eb 30		 jmp	 SHORT $LN42@stbtt__com
$LN41@stbtt__com:
  00430	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  00434	39 44 24 34	 cmp	 DWORD PTR y1$1[rsp], eax
  00438	7d 0d		 jge	 SHORT $LN39@stbtt__com
  0043a	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  0043e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  00445	eb 0b		 jmp	 SHORT $LN40@stbtt__com
$LN39@stbtt__com:
  00447	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  0044b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
$LN40@stbtt__com:
  00452	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv213[rsp]
  00459	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv214[rsp], eax
$LN42@stbtt__com:
  00460	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv214[rsp]
  00467	89 84 24 c0 00
	00 00		 mov	 DWORD PTR ay$13[rsp], eax

; 4500 :          int by = STBTT_max(y0,STBTT_max(y1,y2));

  0046e	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  00472	39 44 24 34	 cmp	 DWORD PTR y1$1[rsp], eax
  00476	7d 0d		 jge	 SHORT $LN43@stbtt__com
  00478	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  0047c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  00483	eb 0b		 jmp	 SHORT $LN44@stbtt__com
$LN43@stbtt__com:
  00485	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  00489	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
$LN44@stbtt__com:
  00490	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv216[rsp]
  00497	39 44 24 38	 cmp	 DWORD PTR y0$2[rsp], eax
  0049b	7d 32		 jge	 SHORT $LN47@stbtt__com
  0049d	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  004a1	39 44 24 34	 cmp	 DWORD PTR y1$1[rsp], eax
  004a5	7d 0d		 jge	 SHORT $LN45@stbtt__com
  004a7	8b 44 24 3c	 mov	 eax, DWORD PTR y2$3[rsp]
  004ab	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv219[rsp], eax
  004b2	eb 0b		 jmp	 SHORT $LN46@stbtt__com
$LN45@stbtt__com:
  004b4	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  004b8	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv219[rsp], eax
$LN46@stbtt__com:
  004bf	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv219[rsp]
  004c6	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv220[rsp], eax
  004cd	eb 0b		 jmp	 SHORT $LN48@stbtt__com
$LN47@stbtt__com:
  004cf	8b 44 24 38	 mov	 eax, DWORD PTR y0$2[rsp]
  004d3	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv220[rsp], eax
$LN48@stbtt__com:
  004da	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv220[rsp]
  004e1	89 84 24 c4 00
	00 00		 mov	 DWORD PTR by$14[rsp], eax

; 4501 :          if (y > ay && y < by && x > ax) {

  004e8	f3 0f 2a 84 24
	c0 00 00 00	 cvtsi2ss xmm0, DWORD PTR ay$13[rsp]
  004f1	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR y$[rsp]
  004fa	0f 2f c8	 comiss	 xmm1, xmm0
  004fd	0f 86 f1 03 00
	00		 jbe	 $LN12@stbtt__com
  00503	f3 0f 2a 84 24
	c4 00 00 00	 cvtsi2ss xmm0, DWORD PTR by$14[rsp]
  0050c	0f 2f 84 24 28
	01 00 00	 comiss	 xmm0, DWORD PTR y$[rsp]
  00514	0f 86 da 03 00
	00		 jbe	 $LN12@stbtt__com
  0051a	f3 0f 2a 84 24
	c8 00 00 00	 cvtsi2ss xmm0, DWORD PTR ax$15[rsp]
  00523	f3 0f 10 8c 24
	20 01 00 00	 movss	 xmm1, DWORD PTR x$[rsp]
  0052c	0f 2f c8	 comiss	 xmm1, xmm0
  0052f	0f 86 bf 03 00
	00		 jbe	 $LN12@stbtt__com

; 4502 :             float q0[2],q1[2],q2[2];
; 4503 :             float hits[2][2];
; 4504 :             q0[0] = (float)x0;

  00535	f3 0f 2a 44 24
	48		 cvtsi2ss xmm0, DWORD PTR x0$5[rsp]
  0053b	b8 04 00 00 00	 mov	 eax, 4
  00540	48 6b c0 00	 imul	 rax, rax, 0
  00544	f3 0f 11 84 04
	e0 00 00 00	 movss	 DWORD PTR q0$19[rsp+rax], xmm0

; 4505 :             q0[1] = (float)y0;

  0054d	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR y0$2[rsp]
  00553	b8 04 00 00 00	 mov	 eax, 4
  00558	48 6b c0 01	 imul	 rax, rax, 1
  0055c	f3 0f 11 84 04
	e0 00 00 00	 movss	 DWORD PTR q0$19[rsp+rax], xmm0

; 4506 :             q1[0] = (float)x1;

  00565	f3 0f 2a 44 24
	40		 cvtsi2ss xmm0, DWORD PTR x1$4[rsp]
  0056b	b8 04 00 00 00	 mov	 eax, 4
  00570	48 6b c0 00	 imul	 rax, rax, 0
  00574	f3 0f 11 84 04
	b8 00 00 00	 movss	 DWORD PTR q1$12[rsp+rax], xmm0

; 4507 :             q1[1] = (float)y1;

  0057d	f3 0f 2a 44 24
	34		 cvtsi2ss xmm0, DWORD PTR y1$1[rsp]
  00583	b8 04 00 00 00	 mov	 eax, 4
  00588	48 6b c0 01	 imul	 rax, rax, 1
  0058c	f3 0f 11 84 04
	b8 00 00 00	 movss	 DWORD PTR q1$12[rsp+rax], xmm0

; 4508 :             q2[0] = (float)x2;

  00595	f3 0f 2a 44 24
	54		 cvtsi2ss xmm0, DWORD PTR x2$8[rsp]
  0059b	b8 04 00 00 00	 mov	 eax, 4
  005a0	48 6b c0 00	 imul	 rax, rax, 0
  005a4	f3 0f 11 84 04
	d8 00 00 00	 movss	 DWORD PTR q2$18[rsp+rax], xmm0

; 4509 :             q2[1] = (float)y2;

  005ad	f3 0f 2a 44 24
	3c		 cvtsi2ss xmm0, DWORD PTR y2$3[rsp]
  005b3	b8 04 00 00 00	 mov	 eax, 4
  005b8	48 6b c0 01	 imul	 rax, rax, 1
  005bc	f3 0f 11 84 04
	d8 00 00 00	 movss	 DWORD PTR q2$18[rsp+rax], xmm0

; 4510 :             if (equal(q0,q1) || equal(q1,q2)) {

  005c5	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR q1$12[rsp]
  005cd	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR q0$19[rsp]
  005d5	e8 00 00 00 00	 call	 ?equal@@YAHPEAM0@Z	; equal
  005da	85 c0		 test	 eax, eax
  005dc	75 1d		 jne	 SHORT $LN15@stbtt__com
  005de	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR q2$18[rsp]
  005e6	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR q1$12[rsp]
  005ee	e8 00 00 00 00	 call	 ?equal@@YAHPEAM0@Z	; equal
  005f3	85 c0		 test	 eax, eax
  005f5	0f 84 bd 01 00
	00		 je	 $LN13@stbtt__com
$LN15@stbtt__com:

; 4511 :                x0 = (int)verts[i-1].x;

  005fb	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005ff	ff c8		 dec	 eax
  00601	48 98		 cdqe
  00603	48 6b c0 0e	 imul	 rax, rax, 14
  00607	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  0060f	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00613	89 44 24 48	 mov	 DWORD PTR x0$5[rsp], eax

; 4512 :                y0 = (int)verts[i-1].y;

  00617	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0061b	ff c8		 dec	 eax
  0061d	48 98		 cdqe
  0061f	48 6b c0 0e	 imul	 rax, rax, 14
  00623	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  0062b	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00630	89 44 24 38	 mov	 DWORD PTR y0$2[rsp], eax

; 4513 :                x1 = (int)verts[i  ].x;

  00634	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00639	48 6b c0 0e	 imul	 rax, rax, 14
  0063d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  00645	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00649	89 44 24 40	 mov	 DWORD PTR x1$4[rsp], eax

; 4514 :                y1 = (int)verts[i  ].y;

  0064d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00652	48 6b c0 0e	 imul	 rax, rax, 14
  00656	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR verts$[rsp]
  0065e	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00663	89 44 24 34	 mov	 DWORD PTR y1$1[rsp], eax

; 4515 :                if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {

  00667	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  0066b	39 44 24 38	 cmp	 DWORD PTR y0$2[rsp], eax
  0066f	7d 0d		 jge	 SHORT $LN49@stbtt__com
  00671	8b 44 24 38	 mov	 eax, DWORD PTR y0$2[rsp]
  00675	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv276[rsp], eax
  0067c	eb 0b		 jmp	 SHORT $LN50@stbtt__com
$LN49@stbtt__com:
  0067e	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  00682	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv276[rsp], eax
$LN50@stbtt__com:
  00689	f3 0f 2a 84 24
	98 00 00 00	 cvtsi2ss xmm0, DWORD PTR tv276[rsp]
  00692	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR y$[rsp]
  0069b	0f 2f c8	 comiss	 xmm1, xmm0
  0069e	0f 86 0f 01 00
	00		 jbe	 $LN16@stbtt__com
  006a4	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  006a8	39 44 24 38	 cmp	 DWORD PTR y0$2[rsp], eax
  006ac	7d 0d		 jge	 SHORT $LN51@stbtt__com
  006ae	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  006b2	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv280[rsp], eax
  006b9	eb 0b		 jmp	 SHORT $LN52@stbtt__com
$LN51@stbtt__com:
  006bb	8b 44 24 38	 mov	 eax, DWORD PTR y0$2[rsp]
  006bf	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv280[rsp], eax
$LN52@stbtt__com:
  006c6	f3 0f 2a 84 24
	9c 00 00 00	 cvtsi2ss xmm0, DWORD PTR tv280[rsp]
  006cf	0f 2f 84 24 28
	01 00 00	 comiss	 xmm0, DWORD PTR y$[rsp]
  006d7	0f 86 d6 00 00
	00		 jbe	 $LN16@stbtt__com
  006dd	8b 44 24 40	 mov	 eax, DWORD PTR x1$4[rsp]
  006e1	39 44 24 48	 cmp	 DWORD PTR x0$5[rsp], eax
  006e5	7d 0d		 jge	 SHORT $LN53@stbtt__com
  006e7	8b 44 24 48	 mov	 eax, DWORD PTR x0$5[rsp]
  006eb	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
  006f2	eb 0b		 jmp	 SHORT $LN54@stbtt__com
$LN53@stbtt__com:
  006f4	8b 44 24 40	 mov	 eax, DWORD PTR x1$4[rsp]
  006f8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
$LN54@stbtt__com:
  006ff	f3 0f 2a 84 24
	a0 00 00 00	 cvtsi2ss xmm0, DWORD PTR tv284[rsp]
  00708	f3 0f 10 8c 24
	20 01 00 00	 movss	 xmm1, DWORD PTR x$[rsp]
  00711	0f 2f c8	 comiss	 xmm1, xmm0
  00714	0f 86 99 00 00
	00		 jbe	 $LN16@stbtt__com

; 4516 :                   float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;

  0071a	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR y0$2[rsp]
  00720	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR y$[rsp]
  00729	f3 0f 5c c8	 subss	 xmm1, xmm0
  0072d	0f 28 c1	 movaps	 xmm0, xmm1
  00730	8b 44 24 38	 mov	 eax, DWORD PTR y0$2[rsp]
  00734	8b 4c 24 34	 mov	 ecx, DWORD PTR y1$1[rsp]
  00738	2b c8		 sub	 ecx, eax
  0073a	8b c1		 mov	 eax, ecx
  0073c	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00740	f3 0f 5e c1	 divss	 xmm0, xmm1
  00744	8b 44 24 48	 mov	 eax, DWORD PTR x0$5[rsp]
  00748	8b 4c 24 40	 mov	 ecx, DWORD PTR x1$4[rsp]
  0074c	2b c8		 sub	 ecx, eax
  0074e	8b c1		 mov	 eax, ecx
  00750	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00754	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00758	f3 0f 2a 4c 24
	48		 cvtsi2ss xmm1, DWORD PTR x0$5[rsp]
  0075e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00762	f3 0f 11 84 24
	cc 00 00 00	 movss	 DWORD PTR x_inter$16[rsp], xmm0

; 4517 :                   if (x_inter < x)

  0076b	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR x$[rsp]
  00774	0f 2f 84 24 cc
	00 00 00	 comiss	 xmm0, DWORD PTR x_inter$16[rsp]
  0077c	76 35		 jbe	 SHORT $LN17@stbtt__com

; 4518 :                      winding += (y0 < y1) ? 1 : -1;

  0077e	8b 44 24 34	 mov	 eax, DWORD PTR y1$1[rsp]
  00782	39 44 24 38	 cmp	 DWORD PTR y0$2[rsp], eax
  00786	7d 0d		 jge	 SHORT $LN55@stbtt__com
  00788	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv299[rsp], 1
  00793	eb 0b		 jmp	 SHORT $LN56@stbtt__com
$LN55@stbtt__com:
  00795	c7 84 24 a4 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv299[rsp], -1
$LN56@stbtt__com:
  007a0	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv299[rsp]
  007a7	8b 4c 24 44	 mov	 ecx, DWORD PTR winding$[rsp]
  007ab	03 c8		 add	 ecx, eax
  007ad	8b c1		 mov	 eax, ecx
  007af	89 44 24 44	 mov	 DWORD PTR winding$[rsp], eax
$LN17@stbtt__com:
$LN16@stbtt__com:

; 4519 :                }
; 4520 :             } else {

  007b3	e9 3c 01 00 00	 jmp	 $LN14@stbtt__com
$LN13@stbtt__com:

; 4521 :                int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);

  007b8	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR hits$20[rsp]
  007c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007c5	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR q2$18[rsp]
  007cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d2	4c 8d 8c 24 b8
	00 00 00	 lea	 r9, QWORD PTR q1$12[rsp]
  007da	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR q0$19[rsp]
  007e2	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR ray$[rsp]
  007ea	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR orig$[rsp]
  007f2	e8 00 00 00 00	 call	 ?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z ; stbtt__ray_intersect_bezier
  007f7	89 84 24 ac 00
	00 00		 mov	 DWORD PTR num_hits$11[rsp], eax

; 4522 :                if (num_hits >= 1)

  007fe	83 bc 24 ac 00
	00 00 01	 cmp	 DWORD PTR num_hits$11[rsp], 1
  00806	7c 71		 jl	 SHORT $LN18@stbtt__com

; 4523 :                   if (hits[0][0] < 0)

  00808	b8 08 00 00 00	 mov	 eax, 8
  0080d	48 6b c0 00	 imul	 rax, rax, 0
  00811	48 8d 84 04 f8
	00 00 00	 lea	 rax, QWORD PTR hits$20[rsp+rax]
  00819	b9 04 00 00 00	 mov	 ecx, 4
  0081e	48 6b c9 00	 imul	 rcx, rcx, 0
  00822	0f 57 c0	 xorps	 xmm0, xmm0
  00825	0f 2f 04 08	 comiss	 xmm0, DWORD PTR [rax+rcx]
  00829	76 4e		 jbe	 SHORT $LN19@stbtt__com

; 4524 :                      winding += (hits[0][1] < 0 ? -1 : 1);

  0082b	b8 08 00 00 00	 mov	 eax, 8
  00830	48 6b c0 00	 imul	 rax, rax, 0
  00834	48 8d 84 04 f8
	00 00 00	 lea	 rax, QWORD PTR hits$20[rsp+rax]
  0083c	b9 04 00 00 00	 mov	 ecx, 4
  00841	48 6b c9 01	 imul	 rcx, rcx, 1
  00845	0f 57 c0	 xorps	 xmm0, xmm0
  00848	0f 2f 04 08	 comiss	 xmm0, DWORD PTR [rax+rcx]
  0084c	76 0d		 jbe	 SHORT $LN57@stbtt__com
  0084e	c7 84 24 a8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv319[rsp], -1
  00859	eb 0b		 jmp	 SHORT $LN58@stbtt__com
$LN57@stbtt__com:
  0085b	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv319[rsp], 1
$LN58@stbtt__com:
  00866	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv319[rsp]
  0086d	8b 4c 24 44	 mov	 ecx, DWORD PTR winding$[rsp]
  00871	03 c8		 add	 ecx, eax
  00873	8b c1		 mov	 eax, ecx
  00875	89 44 24 44	 mov	 DWORD PTR winding$[rsp], eax
$LN19@stbtt__com:
$LN18@stbtt__com:

; 4525 :                if (num_hits >= 2)

  00879	83 bc 24 ac 00
	00 00 02	 cmp	 DWORD PTR num_hits$11[rsp], 2
  00881	7c 71		 jl	 SHORT $LN20@stbtt__com

; 4526 :                   if (hits[1][0] < 0)

  00883	b8 08 00 00 00	 mov	 eax, 8
  00888	48 6b c0 01	 imul	 rax, rax, 1
  0088c	48 8d 84 04 f8
	00 00 00	 lea	 rax, QWORD PTR hits$20[rsp+rax]
  00894	b9 04 00 00 00	 mov	 ecx, 4
  00899	48 6b c9 00	 imul	 rcx, rcx, 0
  0089d	0f 57 c0	 xorps	 xmm0, xmm0
  008a0	0f 2f 04 08	 comiss	 xmm0, DWORD PTR [rax+rcx]
  008a4	76 4e		 jbe	 SHORT $LN21@stbtt__com

; 4527 :                      winding += (hits[1][1] < 0 ? -1 : 1);

  008a6	b8 08 00 00 00	 mov	 eax, 8
  008ab	48 6b c0 01	 imul	 rax, rax, 1
  008af	48 8d 84 04 f8
	00 00 00	 lea	 rax, QWORD PTR hits$20[rsp+rax]
  008b7	b9 04 00 00 00	 mov	 ecx, 4
  008bc	48 6b c9 01	 imul	 rcx, rcx, 1
  008c0	0f 57 c0	 xorps	 xmm0, xmm0
  008c3	0f 2f 04 08	 comiss	 xmm0, DWORD PTR [rax+rcx]
  008c7	76 0d		 jbe	 SHORT $LN59@stbtt__com
  008c9	c7 84 24 b0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv364[rsp], -1
  008d4	eb 0b		 jmp	 SHORT $LN60@stbtt__com
$LN59@stbtt__com:
  008d6	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv364[rsp], 1
$LN60@stbtt__com:
  008e1	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv364[rsp]
  008e8	8b 4c 24 44	 mov	 ecx, DWORD PTR winding$[rsp]
  008ec	03 c8		 add	 ecx, eax
  008ee	8b c1		 mov	 eax, ecx
  008f0	89 44 24 44	 mov	 DWORD PTR winding$[rsp], eax
$LN21@stbtt__com:
$LN20@stbtt__com:
$LN14@stbtt__com:
$LN12@stbtt__com:
$LN11@stbtt__com:

; 4528 :             }
; 4529 :          }
; 4530 :       }
; 4531 :    }

  008f4	e9 0f f8 ff ff	 jmp	 $LN2@stbtt__com
$LN3@stbtt__com:

; 4532 :    return winding;

  008f9	8b 44 24 44	 mov	 eax, DWORD PTR winding$[rsp]

; 4533 : }

  008fd	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00905	48 33 cc	 xor	 rcx, rsp
  00908	e8 00 00 00 00	 call	 __security_check_cookie
  0090d	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00914	c3		 ret	 0
?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z ENDP ; stbtt__compute_crossings_x
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv74 = 0
a$ = 32
b$ = 40
?equal@@YAHPEAM0@Z PROC					; equal

; 4463 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 4464 :    return (a[0] == b[0] && a[1] == b[1]);

  0000e	b8 04 00 00 00	 mov	 eax, 4
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	b9 04 00 00 00	 mov	 ecx, 4
  0001c	48 6b c9 00	 imul	 rcx, rcx, 0
  00020	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  00025	4c 8b 44 24 28	 mov	 r8, QWORD PTR b$[rsp]
  0002a	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  0002f	41 0f 2e 04 08	 ucomiss xmm0, DWORD PTR [r8+rcx]
  00034	7a 35		 jp	 SHORT $LN3@equal
  00036	75 33		 jne	 SHORT $LN3@equal
  00038	b8 04 00 00 00	 mov	 eax, 4
  0003d	48 6b c0 01	 imul	 rax, rax, 1
  00041	b9 04 00 00 00	 mov	 ecx, 4
  00046	48 6b c9 01	 imul	 rcx, rcx, 1
  0004a	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  0004f	4c 8b 44 24 28	 mov	 r8, QWORD PTR b$[rsp]
  00054	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  00059	41 0f 2e 04 08	 ucomiss xmm0, DWORD PTR [r8+rcx]
  0005e	7a 0b		 jp	 SHORT $LN3@equal
  00060	75 09		 jne	 SHORT $LN3@equal
  00062	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv74[rsp], 1
  00069	eb 07		 jmp	 SHORT $LN4@equal
$LN3@equal:
  0006b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN4@equal:
  00072	8b 04 24	 mov	 eax, DWORD PTR tv74[rsp]

; 4465 : }

  00075	48 83 c4 18	 add	 rsp, 24
  00079	c3		 ret	 0
?equal@@YAHPEAM0@Z ENDP					; equal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
s0$ = 32
s1$ = 36
num_s$ = 40
b$ = 44
a$ = 48
rayn_x$1 = 52
rayn_y$2 = 56
q0perp$ = 60
d$3 = 64
q0d$4 = 68
q1perp$ = 72
discr$5 = 76
rcpna$6 = 80
c$ = 84
rcp_len2$7 = 88
q10d$8 = 92
q0rd$9 = 96
q20d$10 = 100
q2perp$ = 104
roperp$ = 108
q1d$11 = 112
q2d$12 = 116
rod$13 = 120
orig$ = 144
ray$ = 152
q0$ = 160
q1$ = 168
q2$ = 176
hits$ = 184
?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z PROC	; stbtt__ray_intersect_bezier

; 4399 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 4400 :    float q0perp = q0[1]*ray[0] - q0[0]*ray[1];

  0001b	b8 04 00 00 00	 mov	 eax, 4
  00020	48 6b c0 01	 imul	 rax, rax, 1
  00024	b9 04 00 00 00	 mov	 ecx, 4
  00029	48 6b c9 00	 imul	 rcx, rcx, 0
  0002d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR q0$[rsp]
  00035	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  0003d	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  00042	f3 41 0f 59 04
	08		 mulss	 xmm0, DWORD PTR [r8+rcx]
  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	48 6b c0 00	 imul	 rax, rax, 0
  00051	b9 04 00 00 00	 mov	 ecx, 4
  00056	48 6b c9 01	 imul	 rcx, rcx, 1
  0005a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR q0$[rsp]
  00062	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  0006a	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [rdx+rax]
  0006f	f3 41 0f 59 0c
	08		 mulss	 xmm1, DWORD PTR [r8+rcx]
  00075	f3 0f 5c c1	 subss	 xmm0, xmm1
  00079	f3 0f 11 44 24
	3c		 movss	 DWORD PTR q0perp$[rsp], xmm0

; 4401 :    float q1perp = q1[1]*ray[0] - q1[0]*ray[1];

  0007f	b8 04 00 00 00	 mov	 eax, 4
  00084	48 6b c0 01	 imul	 rax, rax, 1
  00088	b9 04 00 00 00	 mov	 ecx, 4
  0008d	48 6b c9 00	 imul	 rcx, rcx, 0
  00091	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR q1$[rsp]
  00099	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  000a1	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  000a6	f3 41 0f 59 04
	08		 mulss	 xmm0, DWORD PTR [r8+rcx]
  000ac	b8 04 00 00 00	 mov	 eax, 4
  000b1	48 6b c0 00	 imul	 rax, rax, 0
  000b5	b9 04 00 00 00	 mov	 ecx, 4
  000ba	48 6b c9 01	 imul	 rcx, rcx, 1
  000be	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR q1$[rsp]
  000c6	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  000ce	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [rdx+rax]
  000d3	f3 41 0f 59 0c
	08		 mulss	 xmm1, DWORD PTR [r8+rcx]
  000d9	f3 0f 5c c1	 subss	 xmm0, xmm1
  000dd	f3 0f 11 44 24
	48		 movss	 DWORD PTR q1perp$[rsp], xmm0

; 4402 :    float q2perp = q2[1]*ray[0] - q2[0]*ray[1];

  000e3	b8 04 00 00 00	 mov	 eax, 4
  000e8	48 6b c0 01	 imul	 rax, rax, 1
  000ec	b9 04 00 00 00	 mov	 ecx, 4
  000f1	48 6b c9 00	 imul	 rcx, rcx, 0
  000f5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR q2$[rsp]
  000fd	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  00105	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  0010a	f3 41 0f 59 04
	08		 mulss	 xmm0, DWORD PTR [r8+rcx]
  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	48 6b c0 00	 imul	 rax, rax, 0
  00119	b9 04 00 00 00	 mov	 ecx, 4
  0011e	48 6b c9 01	 imul	 rcx, rcx, 1
  00122	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR q2$[rsp]
  0012a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  00132	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [rdx+rax]
  00137	f3 41 0f 59 0c
	08		 mulss	 xmm1, DWORD PTR [r8+rcx]
  0013d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00141	f3 0f 11 44 24
	68		 movss	 DWORD PTR q2perp$[rsp], xmm0

; 4403 :    float roperp = orig[1]*ray[0] - orig[0]*ray[1];

  00147	b8 04 00 00 00	 mov	 eax, 4
  0014c	48 6b c0 01	 imul	 rax, rax, 1
  00150	b9 04 00 00 00	 mov	 ecx, 4
  00155	48 6b c9 00	 imul	 rcx, rcx, 0
  00159	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR orig$[rsp]
  00161	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  00169	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  0016e	f3 41 0f 59 04
	08		 mulss	 xmm0, DWORD PTR [r8+rcx]
  00174	b8 04 00 00 00	 mov	 eax, 4
  00179	48 6b c0 00	 imul	 rax, rax, 0
  0017d	b9 04 00 00 00	 mov	 ecx, 4
  00182	48 6b c9 01	 imul	 rcx, rcx, 1
  00186	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR orig$[rsp]
  0018e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  00196	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [rdx+rax]
  0019b	f3 41 0f 59 0c
	08		 mulss	 xmm1, DWORD PTR [r8+rcx]
  001a1	f3 0f 5c c1	 subss	 xmm0, xmm1
  001a5	f3 0f 11 44 24
	6c		 movss	 DWORD PTR roperp$[rsp], xmm0

; 4404 : 
; 4405 :    float a = q0perp - 2*q1perp + q2perp;

  001ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001b3	f3 0f 59 44 24
	48		 mulss	 xmm0, DWORD PTR q1perp$[rsp]
  001b9	f3 0f 10 4c 24
	3c		 movss	 xmm1, DWORD PTR q0perp$[rsp]
  001bf	f3 0f 5c c8	 subss	 xmm1, xmm0
  001c3	0f 28 c1	 movaps	 xmm0, xmm1
  001c6	f3 0f 58 44 24
	68		 addss	 xmm0, DWORD PTR q2perp$[rsp]
  001cc	f3 0f 11 44 24
	30		 movss	 DWORD PTR a$[rsp], xmm0

; 4406 :    float b = q1perp - q0perp;

  001d2	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR q1perp$[rsp]
  001d8	f3 0f 5c 44 24
	3c		 subss	 xmm0, DWORD PTR q0perp$[rsp]
  001de	f3 0f 11 44 24
	2c		 movss	 DWORD PTR b$[rsp], xmm0

; 4407 :    float c = q0perp - roperp;

  001e4	f3 0f 10 44 24
	3c		 movss	 xmm0, DWORD PTR q0perp$[rsp]
  001ea	f3 0f 5c 44 24
	6c		 subss	 xmm0, DWORD PTR roperp$[rsp]
  001f0	f3 0f 11 44 24
	54		 movss	 DWORD PTR c$[rsp], xmm0

; 4408 : 
; 4409 :    float s0 = 0., s1 = 0.;

  001f6	0f 57 c0	 xorps	 xmm0, xmm0
  001f9	f3 0f 11 44 24
	20		 movss	 DWORD PTR s0$[rsp], xmm0
  001ff	0f 57 c0	 xorps	 xmm0, xmm0
  00202	f3 0f 11 44 24
	24		 movss	 DWORD PTR s1$[rsp], xmm0

; 4410 :    int num_s = 0;

  00208	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR num_s$[rsp], 0

; 4411 : 
; 4412 :    if (a != 0.0) {

  00210	f3 0f 5a 44 24
	30		 cvtss2sd xmm0, DWORD PTR a$[rsp]
  00216	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0021e	7a 06		 jp	 SHORT $LN14@stbtt__ray
  00220	0f 84 0e 01 00
	00		 je	 $LN2@stbtt__ray
$LN14@stbtt__ray:

; 4413 :       float discr = b*b - a*c;

  00226	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR b$[rsp]
  0022c	f3 0f 59 44 24
	2c		 mulss	 xmm0, DWORD PTR b$[rsp]
  00232	f3 0f 10 4c 24
	30		 movss	 xmm1, DWORD PTR a$[rsp]
  00238	f3 0f 59 4c 24
	54		 mulss	 xmm1, DWORD PTR c$[rsp]
  0023e	f3 0f 5c c1	 subss	 xmm0, xmm1
  00242	f3 0f 11 44 24
	4c		 movss	 DWORD PTR discr$5[rsp], xmm0

; 4414 :       if (discr > 0.0) {

  00248	f3 0f 5a 44 24
	4c		 cvtss2sd xmm0, DWORD PTR discr$5[rsp]
  0024e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00256	0f 86 d6 00 00
	00		 jbe	 $LN4@stbtt__ray

; 4415 :          float rcpna = -1 / a;

  0025c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00264	f3 0f 5e 44 24
	30		 divss	 xmm0, DWORD PTR a$[rsp]
  0026a	f3 0f 11 44 24
	50		 movss	 DWORD PTR rcpna$6[rsp], xmm0

; 4416 :          float d = (float) STBTT_sqrt(discr);

  00270	f3 0f 5a 44 24
	4c		 cvtss2sd xmm0, DWORD PTR discr$5[rsp]
  00276	e8 00 00 00 00	 call	 sqrt
  0027b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0027f	f3 0f 11 44 24
	40		 movss	 DWORD PTR d$3[rsp], xmm0

; 4417 :          s0 = (b+d) * rcpna;

  00285	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR b$[rsp]
  0028b	f3 0f 58 44 24
	40		 addss	 xmm0, DWORD PTR d$3[rsp]
  00291	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR rcpna$6[rsp]
  00297	f3 0f 11 44 24
	20		 movss	 DWORD PTR s0$[rsp], xmm0

; 4418 :          s1 = (b-d) * rcpna;

  0029d	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR b$[rsp]
  002a3	f3 0f 5c 44 24
	40		 subss	 xmm0, DWORD PTR d$3[rsp]
  002a9	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR rcpna$6[rsp]
  002af	f3 0f 11 44 24
	24		 movss	 DWORD PTR s1$[rsp], xmm0

; 4419 :          if (s0 >= 0.0 && s0 <= 1.0)

  002b5	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR s0$[rsp]
  002bb	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  002c3	72 1c		 jb	 SHORT $LN5@stbtt__ray
  002c5	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR s0$[rsp]
  002cb	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  002d3	66 0f 2f c8	 comisd	 xmm1, xmm0
  002d7	72 08		 jb	 SHORT $LN5@stbtt__ray

; 4420 :             num_s = 1;

  002d9	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR num_s$[rsp], 1
$LN5@stbtt__ray:

; 4421 :          if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {

  002e1	f3 0f 5a 44 24
	40		 cvtss2sd xmm0, DWORD PTR d$3[rsp]
  002e7	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  002ef	76 41		 jbe	 SHORT $LN6@stbtt__ray
  002f1	f3 0f 5a 44 24
	24		 cvtss2sd xmm0, DWORD PTR s1$[rsp]
  002f7	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  002ff	72 31		 jb	 SHORT $LN6@stbtt__ray
  00301	f3 0f 5a 44 24
	24		 cvtss2sd xmm0, DWORD PTR s1$[rsp]
  00307	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0030f	66 0f 2f c8	 comisd	 xmm1, xmm0
  00313	72 1d		 jb	 SHORT $LN6@stbtt__ray

; 4422 :             if (num_s == 0) s0 = s1;

  00315	83 7c 24 28 00	 cmp	 DWORD PTR num_s$[rsp], 0
  0031a	75 0c		 jne	 SHORT $LN7@stbtt__ray
  0031c	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR s1$[rsp]
  00322	f3 0f 11 44 24
	20		 movss	 DWORD PTR s0$[rsp], xmm0
$LN7@stbtt__ray:

; 4423 :             ++num_s;

  00328	8b 44 24 28	 mov	 eax, DWORD PTR num_s$[rsp]
  0032c	ff c0		 inc	 eax
  0032e	89 44 24 28	 mov	 DWORD PTR num_s$[rsp], eax
$LN6@stbtt__ray:
$LN4@stbtt__ray:

; 4424 :          }
; 4425 :       }
; 4426 :    } else {

  00332	eb 4d		 jmp	 SHORT $LN3@stbtt__ray
$LN2@stbtt__ray:

; 4427 :       // 2*b*s + c = 0
; 4428 :       // s = -c / (2*b)
; 4429 :       s0 = c / (-2 * b);

  00334	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0000000
  0033c	f3 0f 59 44 24
	2c		 mulss	 xmm0, DWORD PTR b$[rsp]
  00342	f3 0f 10 4c 24
	54		 movss	 xmm1, DWORD PTR c$[rsp]
  00348	f3 0f 5e c8	 divss	 xmm1, xmm0
  0034c	0f 28 c1	 movaps	 xmm0, xmm1
  0034f	f3 0f 11 44 24
	20		 movss	 DWORD PTR s0$[rsp], xmm0

; 4430 :       if (s0 >= 0.0 && s0 <= 1.0)

  00355	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR s0$[rsp]
  0035b	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00363	72 1c		 jb	 SHORT $LN8@stbtt__ray
  00365	f3 0f 5a 44 24
	20		 cvtss2sd xmm0, DWORD PTR s0$[rsp]
  0036b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00373	66 0f 2f c8	 comisd	 xmm1, xmm0
  00377	72 08		 jb	 SHORT $LN8@stbtt__ray

; 4431 :          num_s = 1;

  00379	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR num_s$[rsp], 1
$LN8@stbtt__ray:
$LN3@stbtt__ray:

; 4432 :    }
; 4433 : 
; 4434 :    if (num_s == 0)

  00381	83 7c 24 28 00	 cmp	 DWORD PTR num_s$[rsp], 0
  00386	75 0c		 jne	 SHORT $LN9@stbtt__ray

; 4435 :       return 0;

  00388	33 c0		 xor	 eax, eax
  0038a	e9 71 03 00 00	 jmp	 $LN1@stbtt__ray
  0038f	e9 6c 03 00 00	 jmp	 $LN10@stbtt__ray
$LN9@stbtt__ray:

; 4436 :    else {
; 4437 :       float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);

  00394	b8 04 00 00 00	 mov	 eax, 4
  00399	48 6b c0 00	 imul	 rax, rax, 0
  0039d	b9 04 00 00 00	 mov	 ecx, 4
  003a2	48 6b c9 00	 imul	 rcx, rcx, 0
  003a6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ray$[rsp]
  003ae	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  003b6	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [rdx+rax]
  003bb	f3 41 0f 59 04
	08		 mulss	 xmm0, DWORD PTR [r8+rcx]
  003c1	b8 04 00 00 00	 mov	 eax, 4
  003c6	48 6b c0 01	 imul	 rax, rax, 1
  003ca	b9 04 00 00 00	 mov	 ecx, 4
  003cf	48 6b c9 01	 imul	 rcx, rcx, 1
  003d3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ray$[rsp]
  003db	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR ray$[rsp]
  003e3	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [rdx+rax]
  003e8	f3 41 0f 59 0c
	08		 mulss	 xmm1, DWORD PTR [r8+rcx]
  003ee	f3 0f 58 c1	 addss	 xmm0, xmm1
  003f2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  003fa	f3 0f 5e c8	 divss	 xmm1, xmm0
  003fe	0f 28 c1	 movaps	 xmm0, xmm1
  00401	f3 0f 11 44 24
	58		 movss	 DWORD PTR rcp_len2$7[rsp], xmm0

; 4438 :       float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

  00407	b8 04 00 00 00	 mov	 eax, 4
  0040c	48 6b c0 00	 imul	 rax, rax, 0
  00410	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ray$[rsp]
  00418	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  0041d	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR rcp_len2$7[rsp]
  00423	f3 0f 11 44 24
	34		 movss	 DWORD PTR rayn_x$1[rsp], xmm0
  00429	b8 04 00 00 00	 mov	 eax, 4
  0042e	48 6b c0 01	 imul	 rax, rax, 1
  00432	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ray$[rsp]
  0043a	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  0043f	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR rcp_len2$7[rsp]
  00445	f3 0f 11 44 24
	38		 movss	 DWORD PTR rayn_y$2[rsp], xmm0

; 4439 : 
; 4440 :       float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;

  0044b	b8 04 00 00 00	 mov	 eax, 4
  00450	48 6b c0 00	 imul	 rax, rax, 0
  00454	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR q0$[rsp]
  0045c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  00461	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR rayn_x$1[rsp]
  00467	b8 04 00 00 00	 mov	 eax, 4
  0046c	48 6b c0 01	 imul	 rax, rax, 1
  00470	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR q0$[rsp]
  00478	f3 0f 10 0c 01	 movss	 xmm1, DWORD PTR [rcx+rax]
  0047d	f3 0f 59 4c 24
	38		 mulss	 xmm1, DWORD PTR rayn_y$2[rsp]
  00483	f3 0f 58 c1	 addss	 xmm0, xmm1
  00487	f3 0f 11 44 24
	44		 movss	 DWORD PTR q0d$4[rsp], xmm0

; 4441 :       float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;

  0048d	b8 04 00 00 00	 mov	 eax, 4
  00492	48 6b c0 00	 imul	 rax, rax, 0
  00496	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR q1$[rsp]
  0049e	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  004a3	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR rayn_x$1[rsp]
  004a9	b8 04 00 00 00	 mov	 eax, 4
  004ae	48 6b c0 01	 imul	 rax, rax, 1
  004b2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR q1$[rsp]
  004ba	f3 0f 10 0c 01	 movss	 xmm1, DWORD PTR [rcx+rax]
  004bf	f3 0f 59 4c 24
	38		 mulss	 xmm1, DWORD PTR rayn_y$2[rsp]
  004c5	f3 0f 58 c1	 addss	 xmm0, xmm1
  004c9	f3 0f 11 44 24
	70		 movss	 DWORD PTR q1d$11[rsp], xmm0

; 4442 :       float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;

  004cf	b8 04 00 00 00	 mov	 eax, 4
  004d4	48 6b c0 00	 imul	 rax, rax, 0
  004d8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR q2$[rsp]
  004e0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  004e5	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR rayn_x$1[rsp]
  004eb	b8 04 00 00 00	 mov	 eax, 4
  004f0	48 6b c0 01	 imul	 rax, rax, 1
  004f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR q2$[rsp]
  004fc	f3 0f 10 0c 01	 movss	 xmm1, DWORD PTR [rcx+rax]
  00501	f3 0f 59 4c 24
	38		 mulss	 xmm1, DWORD PTR rayn_y$2[rsp]
  00507	f3 0f 58 c1	 addss	 xmm0, xmm1
  0050b	f3 0f 11 44 24
	74		 movss	 DWORD PTR q2d$12[rsp], xmm0

; 4443 :       float rod = orig[0]*rayn_x + orig[1]*rayn_y;

  00511	b8 04 00 00 00	 mov	 eax, 4
  00516	48 6b c0 00	 imul	 rax, rax, 0
  0051a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig$[rsp]
  00522	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  00527	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR rayn_x$1[rsp]
  0052d	b8 04 00 00 00	 mov	 eax, 4
  00532	48 6b c0 01	 imul	 rax, rax, 1
  00536	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR orig$[rsp]
  0053e	f3 0f 10 0c 01	 movss	 xmm1, DWORD PTR [rcx+rax]
  00543	f3 0f 59 4c 24
	38		 mulss	 xmm1, DWORD PTR rayn_y$2[rsp]
  00549	f3 0f 58 c1	 addss	 xmm0, xmm1
  0054d	f3 0f 11 44 24
	78		 movss	 DWORD PTR rod$13[rsp], xmm0

; 4444 : 
; 4445 :       float q10d = q1d - q0d;

  00553	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR q1d$11[rsp]
  00559	f3 0f 5c 44 24
	44		 subss	 xmm0, DWORD PTR q0d$4[rsp]
  0055f	f3 0f 11 44 24
	5c		 movss	 DWORD PTR q10d$8[rsp], xmm0

; 4446 :       float q20d = q2d - q0d;

  00565	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR q2d$12[rsp]
  0056b	f3 0f 5c 44 24
	44		 subss	 xmm0, DWORD PTR q0d$4[rsp]
  00571	f3 0f 11 44 24
	64		 movss	 DWORD PTR q20d$10[rsp], xmm0

; 4447 :       float q0rd = q0d - rod;

  00577	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR q0d$4[rsp]
  0057d	f3 0f 5c 44 24
	78		 subss	 xmm0, DWORD PTR rod$13[rsp]
  00583	f3 0f 11 44 24
	60		 movss	 DWORD PTR q0rd$9[rsp], xmm0

; 4448 : 
; 4449 :       hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;

  00589	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00591	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR s0$[rsp]
  00597	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  0059f	f3 0f 5c c8	 subss	 xmm1, xmm0
  005a3	0f 28 c1	 movaps	 xmm0, xmm1
  005a6	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR s0$[rsp]
  005ac	f3 0f 59 c8	 mulss	 xmm1, xmm0
  005b0	0f 28 c1	 movaps	 xmm0, xmm1
  005b3	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR q10d$8[rsp]
  005b9	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR q0rd$9[rsp]
  005bf	f3 0f 58 c8	 addss	 xmm1, xmm0
  005c3	0f 28 c1	 movaps	 xmm0, xmm1
  005c6	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR s0$[rsp]
  005cc	f3 0f 59 4c 24
	20		 mulss	 xmm1, DWORD PTR s0$[rsp]
  005d2	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR q20d$10[rsp]
  005d8	f3 0f 58 c1	 addss	 xmm0, xmm1
  005dc	b8 08 00 00 00	 mov	 eax, 8
  005e1	48 6b c0 00	 imul	 rax, rax, 0
  005e5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR hits$[rsp]
  005ed	48 03 c8	 add	 rcx, rax
  005f0	48 8b c1	 mov	 rax, rcx
  005f3	b9 04 00 00 00	 mov	 ecx, 4
  005f8	48 6b c9 00	 imul	 rcx, rcx, 0
  005fc	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 4450 :       hits[0][1] = a*s0+b;

  00601	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR a$[rsp]
  00607	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR s0$[rsp]
  0060d	f3 0f 58 44 24
	2c		 addss	 xmm0, DWORD PTR b$[rsp]
  00613	b8 08 00 00 00	 mov	 eax, 8
  00618	48 6b c0 00	 imul	 rax, rax, 0
  0061c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR hits$[rsp]
  00624	48 03 c8	 add	 rcx, rax
  00627	48 8b c1	 mov	 rax, rcx
  0062a	b9 04 00 00 00	 mov	 ecx, 4
  0062f	48 6b c9 01	 imul	 rcx, rcx, 1
  00633	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 4451 : 
; 4452 :       if (num_s > 1) {

  00638	83 7c 24 28 01	 cmp	 DWORD PTR num_s$[rsp], 1
  0063d	0f 8e b8 00 00
	00		 jle	 $LN11@stbtt__ray

; 4453 :          hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;

  00643	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0064b	f3 0f 59 44 24
	24		 mulss	 xmm0, DWORD PTR s1$[rsp]
  00651	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  00659	f3 0f 5c c8	 subss	 xmm1, xmm0
  0065d	0f 28 c1	 movaps	 xmm0, xmm1
  00660	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR s1$[rsp]
  00666	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0066a	0f 28 c1	 movaps	 xmm0, xmm1
  0066d	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR q10d$8[rsp]
  00673	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR q0rd$9[rsp]
  00679	f3 0f 58 c8	 addss	 xmm1, xmm0
  0067d	0f 28 c1	 movaps	 xmm0, xmm1
  00680	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR s1$[rsp]
  00686	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR s1$[rsp]
  0068c	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR q20d$10[rsp]
  00692	f3 0f 58 c1	 addss	 xmm0, xmm1
  00696	b8 08 00 00 00	 mov	 eax, 8
  0069b	48 6b c0 01	 imul	 rax, rax, 1
  0069f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR hits$[rsp]
  006a7	48 03 c8	 add	 rcx, rax
  006aa	48 8b c1	 mov	 rax, rcx
  006ad	b9 04 00 00 00	 mov	 ecx, 4
  006b2	48 6b c9 00	 imul	 rcx, rcx, 0
  006b6	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 4454 :          hits[1][1] = a*s1+b;

  006bb	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR a$[rsp]
  006c1	f3 0f 59 44 24
	24		 mulss	 xmm0, DWORD PTR s1$[rsp]
  006c7	f3 0f 58 44 24
	2c		 addss	 xmm0, DWORD PTR b$[rsp]
  006cd	b8 08 00 00 00	 mov	 eax, 8
  006d2	48 6b c0 01	 imul	 rax, rax, 1
  006d6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR hits$[rsp]
  006de	48 03 c8	 add	 rcx, rax
  006e1	48 8b c1	 mov	 rax, rcx
  006e4	b9 04 00 00 00	 mov	 ecx, 4
  006e9	48 6b c9 01	 imul	 rcx, rcx, 1
  006ed	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 4455 :          return 2;

  006f2	b8 02 00 00 00	 mov	 eax, 2
  006f7	eb 07		 jmp	 SHORT $LN1@stbtt__ray

; 4456 :       } else {

  006f9	eb 05		 jmp	 SHORT $LN12@stbtt__ray
$LN11@stbtt__ray:

; 4457 :          return 1;

  006fb	b8 01 00 00 00	 mov	 eax, 1
$LN12@stbtt__ray:
$LN10@stbtt__ray:
$LN1@stbtt__ray:

; 4458 :       }
; 4459 :    }
; 4460 : }

  00700	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00707	c3		 ret	 0
?stbtt__ray_intersect_bezier@@YAHQEAM0000QEAY01M@Z ENDP	; stbtt__ray_intersect_bezier
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
oversample$ = 8
?stbtt__oversample_shift@@YAMH@Z PROC			; stbtt__oversample_shift

; 4137 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4138 :    if (!oversample)

  00004	83 7c 24 08 00	 cmp	 DWORD PTR oversample$[rsp], 0
  00009	75 05		 jne	 SHORT $LN2@stbtt__ove

; 4139 :       return 0.0f;

  0000b	0f 57 c0	 xorps	 xmm0, xmm0
  0000e	eb 25		 jmp	 SHORT $LN1@stbtt__ove
$LN2@stbtt__ove:

; 4140 : 
; 4141 :    // The prefilter is a box filter of width "oversample",
; 4142 :    // which shifts phase by (oversample - 1)/2 pixels in
; 4143 :    // oversampled space. We want to shift in the opposite
; 4144 :    // direction to counter this.
; 4145 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

  00010	8b 44 24 08	 mov	 eax, DWORD PTR oversample$[rsp]
  00014	ff c8		 dec	 eax
  00016	f7 d8		 neg	 eax
  00018	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0001c	f3 0f 2a 4c 24
	08		 cvtsi2ss xmm1, DWORD PTR oversample$[rsp]
  00022	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40000000
  0002a	f3 0f 59 d1	 mulss	 xmm2, xmm1
  0002e	0f 28 ca	 movaps	 xmm1, xmm2
  00031	f3 0f 5e c1	 divss	 xmm0, xmm1
$LN1@stbtt__ove:

; 4146 : }

  00035	c3		 ret	 0
?stbtt__oversample_shift@@YAMH@Z ENDP			; stbtt__oversample_shift
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$1 = 32
total$2 = 36
safe_h$ = 40
tv71 = 44
j$ = 48
tv73 = 56
buffer$ = 64
__$ArrayPad$ = 72
pixels$ = 96
w$ = 104
h$ = 112
stride_in_bytes$ = 120
kernel_width$ = 128
?stbtt__v_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__v_prefilter

; 4075 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4076 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 4077 :    int safe_h = h - kernel_width;

  00027	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kernel_width$[rsp]
  0002e	8b 4c 24 70	 mov	 ecx, DWORD PTR h$[rsp]
  00032	2b c8		 sub	 ecx, eax
  00034	8b c1		 mov	 eax, ecx
  00036	89 44 24 28	 mov	 DWORD PTR safe_h$[rsp], eax

; 4078 :    int j;
; 4079 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

  0003a	48 8d 44 24 40	 lea	 rax, QWORD PTR buffer$[rsp]
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 08 00 00 00	 mov	 ecx, 8
  00049	f3 aa		 rep stosb

; 4080 :    for (j=0; j < w; ++j) {

  0004b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00053	eb 0a		 jmp	 SHORT $LN4@stbtt__v_p
$LN2@stbtt__v_p:
  00055	8b 44 24 30	 mov	 eax, DWORD PTR j$[rsp]
  00059	ff c0		 inc	 eax
  0005b	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbtt__v_p:
  0005f	8b 44 24 68	 mov	 eax, DWORD PTR w$[rsp]
  00063	39 44 24 30	 cmp	 DWORD PTR j$[rsp], eax
  00067	0f 8d 45 04 00
	00		 jge	 $LN3@stbtt__v_p

; 4081 :       int i;
; 4082 :       unsigned int total;
; 4083 :       STBTT_memset(buffer, 0, kernel_width);

  0006d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kernel_width$[rsp]
  00074	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  00079	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0007e	48 8b f9	 mov	 rdi, rcx
  00081	33 c0		 xor	 eax, eax
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv73[rsp]
  00088	f3 aa		 rep stosb

; 4084 : 
; 4085 :       total = 0;

  0008a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR total$2[rsp], 0

; 4086 : 
; 4087 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 4088 :       switch (kernel_width) {

  00092	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kernel_width$[rsp]
  00099	89 44 24 2c	 mov	 DWORD PTR tv71[rsp], eax
  0009d	83 7c 24 2c 02	 cmp	 DWORD PTR tv71[rsp], 2
  000a2	74 26		 je	 SHORT $LN25@stbtt__v_p
  000a4	83 7c 24 2c 03	 cmp	 DWORD PTR tv71[rsp], 3
  000a9	0f 84 c5 00 00
	00		 je	 $LN26@stbtt__v_p
  000af	83 7c 24 2c 04	 cmp	 DWORD PTR tv71[rsp], 4
  000b4	0f 84 64 01 00
	00		 je	 $LN27@stbtt__v_p
  000ba	83 7c 24 2c 05	 cmp	 DWORD PTR tv71[rsp], 5
  000bf	0f 84 03 02 00
	00		 je	 $LN28@stbtt__v_p
  000c5	e9 a8 02 00 00	 jmp	 $LN29@stbtt__v_p
$LN25@stbtt__v_p:

; 4089 :          case 2:
; 4090 :             for (i=0; i <= safe_h; ++i) {

  000ca	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000d2	eb 0a		 jmp	 SHORT $LN9@stbtt__v_p
$LN7@stbtt__v_p:
  000d4	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000d8	ff c0		 inc	 eax
  000da	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN9@stbtt__v_p:
  000de	8b 44 24 28	 mov	 eax, DWORD PTR safe_h$[rsp]
  000e2	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  000e6	0f 8f 83 00 00
	00		 jg	 $LN8@stbtt__v_p

; 4091 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  000ec	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000f0	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  000f5	48 98		 cdqe
  000f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  000fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00100	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00104	83 e1 07	 and	 ecx, 7
  00107	48 63 c9	 movsxd	 rcx, ecx
  0010a	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  0010f	2b c1		 sub	 eax, ecx
  00111	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  00115	03 c8		 add	 ecx, eax
  00117	8b c1		 mov	 eax, ecx
  00119	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4092 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  0011d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00121	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  00126	48 98		 cdqe
  00128	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  0012f	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00133	03 d1		 add	 edx, ecx
  00135	8b ca		 mov	 ecx, edx
  00137	83 e1 07	 and	 ecx, 7
  0013a	8b c9		 mov	 ecx, ecx
  0013c	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00141	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00145	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4093 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 2);

  00149	33 d2		 xor	 edx, edx
  0014b	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  0014f	b9 02 00 00 00	 mov	 ecx, 2
  00154	f7 f1		 div	 ecx
  00156	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  0015a	0f af 4c 24 78	 imul	 ecx, DWORD PTR stride_in_bytes$[rsp]
  0015f	48 63 c9	 movsxd	 rcx, ecx
  00162	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00167	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4094 :             }

  0016a	e9 65 ff ff ff	 jmp	 $LN7@stbtt__v_p
$LN8@stbtt__v_p:

; 4095 :             break;

  0016f	e9 a3 02 00 00	 jmp	 $LN5@stbtt__v_p
$LN26@stbtt__v_p:

; 4096 :          case 3:
; 4097 :             for (i=0; i <= safe_h; ++i) {

  00174	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0017c	eb 0a		 jmp	 SHORT $LN12@stbtt__v_p
$LN10@stbtt__v_p:
  0017e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00182	ff c0		 inc	 eax
  00184	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN12@stbtt__v_p:
  00188	8b 44 24 28	 mov	 eax, DWORD PTR safe_h$[rsp]
  0018c	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00190	0f 8f 83 00 00
	00		 jg	 $LN11@stbtt__v_p

; 4098 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00196	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0019a	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  0019f	48 98		 cdqe
  001a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  001a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001aa	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  001ae	83 e1 07	 and	 ecx, 7
  001b1	48 63 c9	 movsxd	 rcx, ecx
  001b4	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  001b9	2b c1		 sub	 eax, ecx
  001bb	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  001bf	03 c8		 add	 ecx, eax
  001c1	8b c1		 mov	 eax, ecx
  001c3	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4099 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  001c7	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  001cb	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  001d0	48 98		 cdqe
  001d2	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  001d9	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  001dd	03 d1		 add	 edx, ecx
  001df	8b ca		 mov	 ecx, edx
  001e1	83 e1 07	 and	 ecx, 7
  001e4	8b c9		 mov	 ecx, ecx
  001e6	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  001eb	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001ef	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4100 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 3);

  001f3	33 d2		 xor	 edx, edx
  001f5	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  001f9	b9 03 00 00 00	 mov	 ecx, 3
  001fe	f7 f1		 div	 ecx
  00200	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00204	0f af 4c 24 78	 imul	 ecx, DWORD PTR stride_in_bytes$[rsp]
  00209	48 63 c9	 movsxd	 rcx, ecx
  0020c	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00211	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4101 :             }

  00214	e9 65 ff ff ff	 jmp	 $LN10@stbtt__v_p
$LN11@stbtt__v_p:

; 4102 :             break;

  00219	e9 f9 01 00 00	 jmp	 $LN5@stbtt__v_p
$LN27@stbtt__v_p:

; 4103 :          case 4:
; 4104 :             for (i=0; i <= safe_h; ++i) {

  0021e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00226	eb 0a		 jmp	 SHORT $LN15@stbtt__v_p
$LN13@stbtt__v_p:
  00228	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0022c	ff c0		 inc	 eax
  0022e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN15@stbtt__v_p:
  00232	8b 44 24 28	 mov	 eax, DWORD PTR safe_h$[rsp]
  00236	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0023a	0f 8f 83 00 00
	00		 jg	 $LN14@stbtt__v_p

; 4105 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00240	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00244	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  00249	48 98		 cdqe
  0024b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  00250	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00254	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00258	83 e1 07	 and	 ecx, 7
  0025b	48 63 c9	 movsxd	 rcx, ecx
  0025e	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  00263	2b c1		 sub	 eax, ecx
  00265	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  00269	03 c8		 add	 ecx, eax
  0026b	8b c1		 mov	 eax, ecx
  0026d	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4106 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  00271	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00275	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  0027a	48 98		 cdqe
  0027c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  00283	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00287	03 d1		 add	 edx, ecx
  00289	8b ca		 mov	 ecx, edx
  0028b	83 e1 07	 and	 ecx, 7
  0028e	8b c9		 mov	 ecx, ecx
  00290	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00295	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00299	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4107 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 4);

  0029d	33 d2		 xor	 edx, edx
  0029f	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  002a3	b9 04 00 00 00	 mov	 ecx, 4
  002a8	f7 f1		 div	 ecx
  002aa	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  002ae	0f af 4c 24 78	 imul	 ecx, DWORD PTR stride_in_bytes$[rsp]
  002b3	48 63 c9	 movsxd	 rcx, ecx
  002b6	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  002bb	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4108 :             }

  002be	e9 65 ff ff ff	 jmp	 $LN13@stbtt__v_p
$LN14@stbtt__v_p:

; 4109 :             break;

  002c3	e9 4f 01 00 00	 jmp	 $LN5@stbtt__v_p
$LN28@stbtt__v_p:

; 4110 :          case 5:
; 4111 :             for (i=0; i <= safe_h; ++i) {

  002c8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  002d0	eb 0a		 jmp	 SHORT $LN18@stbtt__v_p
$LN16@stbtt__v_p:
  002d2	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  002d6	ff c0		 inc	 eax
  002d8	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN18@stbtt__v_p:
  002dc	8b 44 24 28	 mov	 eax, DWORD PTR safe_h$[rsp]
  002e0	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  002e4	0f 8f 83 00 00
	00		 jg	 $LN17@stbtt__v_p

; 4112 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  002ea	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  002ee	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  002f3	48 98		 cdqe
  002f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  002fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002fe	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00302	83 e1 07	 and	 ecx, 7
  00305	48 63 c9	 movsxd	 rcx, ecx
  00308	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  0030d	2b c1		 sub	 eax, ecx
  0030f	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  00313	03 c8		 add	 ecx, eax
  00315	8b c1		 mov	 eax, ecx
  00317	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4113 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  0031b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0031f	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  00324	48 98		 cdqe
  00326	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  0032d	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00331	03 d1		 add	 edx, ecx
  00333	8b ca		 mov	 ecx, edx
  00335	83 e1 07	 and	 ecx, 7
  00338	8b c9		 mov	 ecx, ecx
  0033a	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  0033f	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00343	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4114 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 5);

  00347	33 d2		 xor	 edx, edx
  00349	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  0034d	b9 05 00 00 00	 mov	 ecx, 5
  00352	f7 f1		 div	 ecx
  00354	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00358	0f af 4c 24 78	 imul	 ecx, DWORD PTR stride_in_bytes$[rsp]
  0035d	48 63 c9	 movsxd	 rcx, ecx
  00360	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00365	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4115 :             }

  00368	e9 65 ff ff ff	 jmp	 $LN16@stbtt__v_p
$LN17@stbtt__v_p:

; 4116 :             break;

  0036d	e9 a5 00 00 00	 jmp	 $LN5@stbtt__v_p
$LN29@stbtt__v_p:

; 4117 :          default:
; 4118 :             for (i=0; i <= safe_h; ++i) {

  00372	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0037a	eb 0a		 jmp	 SHORT $LN21@stbtt__v_p
$LN19@stbtt__v_p:
  0037c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00380	ff c0		 inc	 eax
  00382	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN21@stbtt__v_p:
  00386	8b 44 24 28	 mov	 eax, DWORD PTR safe_h$[rsp]
  0038a	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0038e	0f 8f 83 00 00
	00		 jg	 $LN20@stbtt__v_p

; 4119 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00394	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00398	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  0039d	48 98		 cdqe
  0039f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  003a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a8	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  003ac	83 e1 07	 and	 ecx, 7
  003af	48 63 c9	 movsxd	 rcx, ecx
  003b2	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  003b7	2b c1		 sub	 eax, ecx
  003b9	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  003bd	03 c8		 add	 ecx, eax
  003bf	8b c1		 mov	 eax, ecx
  003c1	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4120 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  003c5	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  003c9	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  003ce	48 98		 cdqe
  003d0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  003d7	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  003db	03 d1		 add	 edx, ecx
  003dd	8b ca		 mov	 ecx, edx
  003df	83 e1 07	 and	 ecx, 7
  003e2	8b c9		 mov	 ecx, ecx
  003e4	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  003e9	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  003ed	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4121 :                pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

  003f1	33 d2		 xor	 edx, edx
  003f3	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  003f7	f7 b4 24 80 00
	00 00		 div	 DWORD PTR kernel_width$[rsp]
  003fe	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00402	0f af 4c 24 78	 imul	 ecx, DWORD PTR stride_in_bytes$[rsp]
  00407	48 63 c9	 movsxd	 rcx, ecx
  0040a	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  0040f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4122 :             }

  00412	e9 65 ff ff ff	 jmp	 $LN19@stbtt__v_p
$LN20@stbtt__v_p:
$LN5@stbtt__v_p:

; 4123 :             break;
; 4124 :       }
; 4125 : 
; 4126 :       for (; i < h; ++i) {

  00417	eb 0a		 jmp	 SHORT $LN24@stbtt__v_p
$LN22@stbtt__v_p:
  00419	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0041d	ff c0		 inc	 eax
  0041f	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN24@stbtt__v_p:
  00423	8b 44 24 70	 mov	 eax, DWORD PTR h$[rsp]
  00427	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0042b	7d 73		 jge	 SHORT $LN23@stbtt__v_p

; 4127 :          STBTT_assert(pixels[i*stride_in_bytes] == 0);

  0042d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00431	0f af 44 24 78	 imul	 eax, DWORD PTR stride_in_bytes$[rsp]
  00436	48 98		 cdqe
  00438	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  0043d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00441	85 c0		 test	 eax, eax
  00443	74 1b		 je	 SHORT $LN31@stbtt__v_p
  00445	41 b8 1f 10 00
	00		 mov	 r8d, 4127		; 0000101fH
  0044b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG43533
  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG43534
  00459	e8 00 00 00 00	 call	 _wassert
  0045e	33 c0		 xor	 eax, eax
$LN31@stbtt__v_p:

; 4128 :          total -= buffer[i & STBTT__OVER_MASK];

  00460	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00464	83 e0 07	 and	 eax, 7
  00467	48 98		 cdqe
  00469	0f b6 44 04 40	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  0046e	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  00472	2b c8		 sub	 ecx, eax
  00474	8b c1		 mov	 eax, ecx
  00476	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4129 :          pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

  0047a	33 d2		 xor	 edx, edx
  0047c	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  00480	f7 b4 24 80 00
	00 00		 div	 DWORD PTR kernel_width$[rsp]
  00487	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  0048b	0f af 4c 24 78	 imul	 ecx, DWORD PTR stride_in_bytes$[rsp]
  00490	48 63 c9	 movsxd	 rcx, ecx
  00493	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00498	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4130 :       }

  0049b	e9 79 ff ff ff	 jmp	 $LN22@stbtt__v_p
$LN23@stbtt__v_p:

; 4131 : 
; 4132 :       pixels += 1;

  004a0	48 8b 44 24 60	 mov	 rax, QWORD PTR pixels$[rsp]
  004a5	48 ff c0	 inc	 rax
  004a8	48 89 44 24 60	 mov	 QWORD PTR pixels$[rsp], rax

; 4133 :    }

  004ad	e9 a3 fb ff ff	 jmp	 $LN2@stbtt__v_p
$LN3@stbtt__v_p:

; 4134 : }

  004b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b7	48 33 cc	 xor	 rcx, rsp
  004ba	e8 00 00 00 00	 call	 __security_check_cookie
  004bf	48 83 c4 50	 add	 rsp, 80			; 00000050H
  004c3	5f		 pop	 rdi
  004c4	c3		 ret	 0
?stbtt__v_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__v_prefilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$1 = 32
total$2 = 36
safe_w$ = 40
tv71 = 44
j$ = 48
tv73 = 56
buffer$ = 64
__$ArrayPad$ = 72
pixels$ = 96
w$ = 104
h$ = 112
stride_in_bytes$ = 120
kernel_width$ = 128
?stbtt__h_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__h_prefilter

; 4013 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4014 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 4015 :    int safe_w = w - kernel_width;

  00027	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kernel_width$[rsp]
  0002e	8b 4c 24 68	 mov	 ecx, DWORD PTR w$[rsp]
  00032	2b c8		 sub	 ecx, eax
  00034	8b c1		 mov	 eax, ecx
  00036	89 44 24 28	 mov	 DWORD PTR safe_w$[rsp], eax

; 4016 :    int j;
; 4017 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

  0003a	48 8d 44 24 40	 lea	 rax, QWORD PTR buffer$[rsp]
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 08 00 00 00	 mov	 ecx, 8
  00049	f3 aa		 rep stosb

; 4018 :    for (j=0; j < h; ++j) {

  0004b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00053	eb 0a		 jmp	 SHORT $LN4@stbtt__h_p
$LN2@stbtt__h_p:
  00055	8b 44 24 30	 mov	 eax, DWORD PTR j$[rsp]
  00059	ff c0		 inc	 eax
  0005b	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbtt__h_p:
  0005f	8b 44 24 70	 mov	 eax, DWORD PTR h$[rsp]
  00063	39 44 24 30	 cmp	 DWORD PTR j$[rsp], eax
  00067	0f 8d ca 03 00
	00		 jge	 $LN3@stbtt__h_p

; 4019 :       int i;
; 4020 :       unsigned int total;
; 4021 :       STBTT_memset(buffer, 0, kernel_width);

  0006d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kernel_width$[rsp]
  00074	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  00079	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0007e	48 8b f9	 mov	 rdi, rcx
  00081	33 c0		 xor	 eax, eax
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv73[rsp]
  00088	f3 aa		 rep stosb

; 4022 : 
; 4023 :       total = 0;

  0008a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR total$2[rsp], 0

; 4024 : 
; 4025 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 4026 :       switch (kernel_width) {

  00092	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kernel_width$[rsp]
  00099	89 44 24 2c	 mov	 DWORD PTR tv71[rsp], eax
  0009d	83 7c 24 2c 02	 cmp	 DWORD PTR tv71[rsp], 2
  000a2	74 26		 je	 SHORT $LN25@stbtt__h_p
  000a4	83 7c 24 2c 03	 cmp	 DWORD PTR tv71[rsp], 3
  000a9	0f 84 ae 00 00
	00		 je	 $LN26@stbtt__h_p
  000af	83 7c 24 2c 04	 cmp	 DWORD PTR tv71[rsp], 4
  000b4	0f 84 36 01 00
	00		 je	 $LN27@stbtt__h_p
  000ba	83 7c 24 2c 05	 cmp	 DWORD PTR tv71[rsp], 5
  000bf	0f 84 be 01 00
	00		 je	 $LN28@stbtt__h_p
  000c5	e9 4c 02 00 00	 jmp	 $LN29@stbtt__h_p
$LN25@stbtt__h_p:

; 4027 :          case 2:
; 4028 :             for (i=0; i <= safe_w; ++i) {

  000ca	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000d2	eb 0a		 jmp	 SHORT $LN9@stbtt__h_p
$LN7@stbtt__h_p:
  000d4	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000d8	ff c0		 inc	 eax
  000da	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN9@stbtt__h_p:
  000de	8b 44 24 28	 mov	 eax, DWORD PTR safe_w$[rsp]
  000e2	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  000e6	7f 70		 jg	 SHORT $LN8@stbtt__h_p

; 4029 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  000e8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  000fa	83 e1 07	 and	 ecx, 7
  000fd	48 63 c9	 movsxd	 rcx, ecx
  00100	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  00105	2b c1		 sub	 eax, ecx
  00107	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  0010b	03 c8		 add	 ecx, eax
  0010d	8b c1		 mov	 eax, ecx
  0010f	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4030 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  00113	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00118	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  0011f	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00123	03 d1		 add	 edx, ecx
  00125	8b ca		 mov	 ecx, edx
  00127	83 e1 07	 and	 ecx, 7
  0012a	8b c9		 mov	 ecx, ecx
  0012c	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00131	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00135	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4031 :                pixels[i] = (unsigned char) (total / 2);

  00139	33 d2		 xor	 edx, edx
  0013b	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  0013f	b9 02 00 00 00	 mov	 ecx, 2
  00144	f7 f1		 div	 ecx
  00146	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0014b	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00150	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4032 :             }

  00153	e9 7c ff ff ff	 jmp	 $LN7@stbtt__h_p
$LN8@stbtt__h_p:

; 4033 :             break;

  00158	e9 47 02 00 00	 jmp	 $LN5@stbtt__h_p
$LN26@stbtt__h_p:

; 4034 :          case 3:
; 4035 :             for (i=0; i <= safe_w; ++i) {

  0015d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00165	eb 0a		 jmp	 SHORT $LN12@stbtt__h_p
$LN10@stbtt__h_p:
  00167	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0016b	ff c0		 inc	 eax
  0016d	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN12@stbtt__h_p:
  00171	8b 44 24 28	 mov	 eax, DWORD PTR safe_w$[rsp]
  00175	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00179	7f 70		 jg	 SHORT $LN11@stbtt__h_p

; 4036 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  0017b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00180	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  00185	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00189	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  0018d	83 e1 07	 and	 ecx, 7
  00190	48 63 c9	 movsxd	 rcx, ecx
  00193	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  00198	2b c1		 sub	 eax, ecx
  0019a	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  0019e	03 c8		 add	 ecx, eax
  001a0	8b c1		 mov	 eax, ecx
  001a2	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4037 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  001a6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  001ab	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  001b2	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	83 e1 07	 and	 ecx, 7
  001bd	8b c9		 mov	 ecx, ecx
  001bf	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  001c4	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001c8	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4038 :                pixels[i] = (unsigned char) (total / 3);

  001cc	33 d2		 xor	 edx, edx
  001ce	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  001d2	b9 03 00 00 00	 mov	 ecx, 3
  001d7	f7 f1		 div	 ecx
  001d9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  001de	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  001e3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4039 :             }

  001e6	e9 7c ff ff ff	 jmp	 $LN10@stbtt__h_p
$LN11@stbtt__h_p:

; 4040 :             break;

  001eb	e9 b4 01 00 00	 jmp	 $LN5@stbtt__h_p
$LN27@stbtt__h_p:

; 4041 :          case 4:
; 4042 :             for (i=0; i <= safe_w; ++i) {

  001f0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  001f8	eb 0a		 jmp	 SHORT $LN15@stbtt__h_p
$LN13@stbtt__h_p:
  001fa	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  001fe	ff c0		 inc	 eax
  00200	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN15@stbtt__h_p:
  00204	8b 44 24 28	 mov	 eax, DWORD PTR safe_w$[rsp]
  00208	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0020c	7f 70		 jg	 SHORT $LN14@stbtt__h_p

; 4043 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  0020e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00213	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  00218	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021c	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00220	83 e1 07	 and	 ecx, 7
  00223	48 63 c9	 movsxd	 rcx, ecx
  00226	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  0022b	2b c1		 sub	 eax, ecx
  0022d	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  00231	03 c8		 add	 ecx, eax
  00233	8b c1		 mov	 eax, ecx
  00235	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4044 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  00239	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0023e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  00245	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00249	03 d1		 add	 edx, ecx
  0024b	8b ca		 mov	 ecx, edx
  0024d	83 e1 07	 and	 ecx, 7
  00250	8b c9		 mov	 ecx, ecx
  00252	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00257	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0025b	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4045 :                pixels[i] = (unsigned char) (total / 4);

  0025f	33 d2		 xor	 edx, edx
  00261	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  00265	b9 04 00 00 00	 mov	 ecx, 4
  0026a	f7 f1		 div	 ecx
  0026c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00271	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00276	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4046 :             }

  00279	e9 7c ff ff ff	 jmp	 $LN13@stbtt__h_p
$LN14@stbtt__h_p:

; 4047 :             break;

  0027e	e9 21 01 00 00	 jmp	 $LN5@stbtt__h_p
$LN28@stbtt__h_p:

; 4048 :          case 5:
; 4049 :             for (i=0; i <= safe_w; ++i) {

  00283	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0028b	eb 0a		 jmp	 SHORT $LN18@stbtt__h_p
$LN16@stbtt__h_p:
  0028d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00291	ff c0		 inc	 eax
  00293	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN18@stbtt__h_p:
  00297	8b 44 24 28	 mov	 eax, DWORD PTR safe_w$[rsp]
  0029b	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0029f	7f 70		 jg	 SHORT $LN17@stbtt__h_p

; 4050 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  002a1	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  002a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  002ab	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002af	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  002b3	83 e1 07	 and	 ecx, 7
  002b6	48 63 c9	 movsxd	 rcx, ecx
  002b9	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  002be	2b c1		 sub	 eax, ecx
  002c0	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  002c4	03 c8		 add	 ecx, eax
  002c6	8b c1		 mov	 eax, ecx
  002c8	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4051 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  002cc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  002d1	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  002d8	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  002dc	03 d1		 add	 edx, ecx
  002de	8b ca		 mov	 ecx, edx
  002e0	83 e1 07	 and	 ecx, 7
  002e3	8b c9		 mov	 ecx, ecx
  002e5	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  002ea	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  002ee	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4052 :                pixels[i] = (unsigned char) (total / 5);

  002f2	33 d2		 xor	 edx, edx
  002f4	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  002f8	b9 05 00 00 00	 mov	 ecx, 5
  002fd	f7 f1		 div	 ecx
  002ff	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00304	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00309	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4053 :             }

  0030c	e9 7c ff ff ff	 jmp	 $LN16@stbtt__h_p
$LN17@stbtt__h_p:

; 4054 :             break;

  00311	e9 8e 00 00 00	 jmp	 $LN5@stbtt__h_p
$LN29@stbtt__h_p:

; 4055 :          default:
; 4056 :             for (i=0; i <= safe_w; ++i) {

  00316	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0031e	eb 0a		 jmp	 SHORT $LN21@stbtt__h_p
$LN19@stbtt__h_p:
  00320	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00324	ff c0		 inc	 eax
  00326	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN21@stbtt__h_p:
  0032a	8b 44 24 28	 mov	 eax, DWORD PTR safe_w$[rsp]
  0032e	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00332	7f 70		 jg	 SHORT $LN20@stbtt__h_p

; 4057 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  00334	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00339	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  0033e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00342	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00346	83 e1 07	 and	 ecx, 7
  00349	48 63 c9	 movsxd	 rcx, ecx
  0034c	0f b6 4c 0c 40	 movzx	 ecx, BYTE PTR buffer$[rsp+rcx]
  00351	2b c1		 sub	 eax, ecx
  00353	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  00357	03 c8		 add	 ecx, eax
  00359	8b c1		 mov	 eax, ecx
  0035b	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4058 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  0035f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  00364	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kernel_width$[rsp]
  0036b	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  0036f	03 d1		 add	 edx, ecx
  00371	8b ca		 mov	 ecx, edx
  00373	83 e1 07	 and	 ecx, 7
  00376	8b c9		 mov	 ecx, ecx
  00378	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  0037d	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00381	88 44 0c 40	 mov	 BYTE PTR buffer$[rsp+rcx], al

; 4059 :                pixels[i] = (unsigned char) (total / kernel_width);

  00385	33 d2		 xor	 edx, edx
  00387	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  0038b	f7 b4 24 80 00
	00 00		 div	 DWORD PTR kernel_width$[rsp]
  00392	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00397	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  0039c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4060 :             }

  0039f	e9 7c ff ff ff	 jmp	 $LN19@stbtt__h_p
$LN20@stbtt__h_p:
$LN5@stbtt__h_p:

; 4061 :             break;
; 4062 :       }
; 4063 : 
; 4064 :       for (; i < w; ++i) {

  003a4	eb 0a		 jmp	 SHORT $LN24@stbtt__h_p
$LN22@stbtt__h_p:
  003a6	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  003aa	ff c0		 inc	 eax
  003ac	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN24@stbtt__h_p:
  003b0	8b 44 24 68	 mov	 eax, DWORD PTR w$[rsp]
  003b4	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  003b8	7d 63		 jge	 SHORT $LN23@stbtt__h_p

; 4065 :          STBTT_assert(pixels[i] == 0);

  003ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  003bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  003c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c8	85 c0		 test	 eax, eax
  003ca	74 1b		 je	 SHORT $LN31@stbtt__h_p
  003cc	41 b8 e1 0f 00
	00		 mov	 r8d, 4065		; 00000fe1H
  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG43483
  003d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG43484
  003e0	e8 00 00 00 00	 call	 _wassert
  003e5	33 c0		 xor	 eax, eax
$LN31@stbtt__h_p:

; 4066 :          total -= buffer[i & STBTT__OVER_MASK];

  003e7	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  003eb	83 e0 07	 and	 eax, 7
  003ee	48 98		 cdqe
  003f0	0f b6 44 04 40	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  003f5	8b 4c 24 24	 mov	 ecx, DWORD PTR total$2[rsp]
  003f9	2b c8		 sub	 ecx, eax
  003fb	8b c1		 mov	 eax, ecx
  003fd	89 44 24 24	 mov	 DWORD PTR total$2[rsp], eax

; 4067 :          pixels[i] = (unsigned char) (total / kernel_width);

  00401	33 d2		 xor	 edx, edx
  00403	8b 44 24 24	 mov	 eax, DWORD PTR total$2[rsp]
  00407	f7 b4 24 80 00
	00 00		 div	 DWORD PTR kernel_width$[rsp]
  0040e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00413	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixels$[rsp]
  00418	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4068 :       }

  0041b	eb 89		 jmp	 SHORT $LN22@stbtt__h_p
$LN23@stbtt__h_p:

; 4069 : 
; 4070 :       pixels += stride_in_bytes;

  0041d	48 63 44 24 78	 movsxd	 rax, DWORD PTR stride_in_bytes$[rsp]
  00422	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixels$[rsp]
  00427	48 03 c8	 add	 rcx, rax
  0042a	48 8b c1	 mov	 rax, rcx
  0042d	48 89 44 24 60	 mov	 QWORD PTR pixels$[rsp], rax

; 4071 :    }

  00432	e9 1e fc ff ff	 jmp	 $LN2@stbtt__h_p
$LN3@stbtt__h_p:

; 4072 : }

  00437	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043c	48 33 cc	 xor	 rcx, rsp
  0043f	e8 00 00 00 00	 call	 __security_check_cookie
  00444	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00448	5f		 pop	 rdi
  00449	c3		 ret	 0
?stbtt__h_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__h_prefilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 0
con$ = 32
rects$ = 40
num_rects$ = 48
?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z PROC ; stbrp_pack_rects

; 3929 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 3930 :    int i;
; 3931 :    for (i=0; i < num_rects; ++i) {

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 08		 jmp	 SHORT $LN4@stbrp_pack
$LN2@stbrp_pack:
  0001c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001f	ff c0		 inc	 eax
  00021	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbrp_pack:
  00024	8b 44 24 30	 mov	 eax, DWORD PTR num_rects$[rsp]
  00028	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002b	0f 8d 20 01 00
	00		 jge	 $LN3@stbrp_pack

; 3932 :       if (con->x + rects[i].w > con->width) {

  00031	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 6b c0 18	 imul	 rax, rax, 24
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  0003e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00041	48 8b 54 24 28	 mov	 rdx, QWORD PTR rects$[rsp]
  00046	03 4c 02 0c	 add	 ecx, DWORD PTR [rdx+rax+12]
  0004a	8b c1		 mov	 eax, ecx
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00051	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00053	7e 1c		 jle	 SHORT $LN8@stbrp_pack

; 3933 :          con->x = 0;

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR con$[rsp]
  0005a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 3934 :          con->y = con->bottom_y;

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR con$[rsp]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  0006b	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0006e	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN8@stbrp_pack:

; 3935 :       }
; 3936 :       if (con->y + rects[i].h > con->height)

  00071	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00075	48 6b c0 18	 imul	 rax, rax, 24
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  0007e	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00081	48 8b 54 24 28	 mov	 rdx, QWORD PTR rects$[rsp]
  00086	03 4c 02 10	 add	 ecx, DWORD PTR [rdx+rax+16]
  0008a	8b c1		 mov	 eax, ecx
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00091	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  00094	7e 05		 jle	 SHORT $LN9@stbrp_pack

; 3937 :          break;

  00096	e9 b6 00 00 00	 jmp	 $LN3@stbrp_pack
$LN9@stbrp_pack:

; 3938 :       rects[i].x = con->x;

  0009b	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0009f	48 6b c0 18	 imul	 rax, rax, 24
  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rects$[rsp]
  000a8	48 8b 54 24 20	 mov	 rdx, QWORD PTR con$[rsp]
  000ad	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  000b0	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 3939 :       rects[i].y = con->y;

  000b3	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000b7	48 6b c0 18	 imul	 rax, rax, 24
  000bb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rects$[rsp]
  000c0	48 8b 54 24 20	 mov	 rdx, QWORD PTR con$[rsp]
  000c5	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  000c8	89 54 01 04	 mov	 DWORD PTR [rcx+rax+4], edx

; 3940 :       rects[i].was_packed = 1;

  000cc	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000d0	48 6b c0 18	 imul	 rax, rax, 24
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rects$[rsp]
  000d9	c7 44 01 14 01
	00 00 00	 mov	 DWORD PTR [rcx+rax+20], 1

; 3941 :       con->x += rects[i].w;

  000e1	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000e5	48 6b c0 18	 imul	 rax, rax, 24
  000e9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  000ee	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000f1	48 8b 54 24 28	 mov	 rdx, QWORD PTR rects$[rsp]
  000f6	03 4c 02 0c	 add	 ecx, DWORD PTR [rdx+rax+12]
  000fa	8b c1		 mov	 eax, ecx
  000fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00101	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3942 :       if (con->y + rects[i].h > con->bottom_y)

  00104	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00108	48 6b c0 18	 imul	 rax, rax, 24
  0010c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00111	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00114	48 8b 54 24 28	 mov	 rdx, QWORD PTR rects$[rsp]
  00119	03 4c 02 10	 add	 ecx, DWORD PTR [rdx+rax+16]
  0011d	8b c1		 mov	 eax, ecx
  0011f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00124	3b 41 10	 cmp	 eax, DWORD PTR [rcx+16]
  00127	7e 23		 jle	 SHORT $LN10@stbrp_pack

; 3943 :          con->bottom_y = con->y + rects[i].h;

  00129	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0012d	48 6b c0 18	 imul	 rax, rax, 24
  00131	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00136	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00139	48 8b 54 24 28	 mov	 rdx, QWORD PTR rects$[rsp]
  0013e	03 4c 02 10	 add	 ecx, DWORD PTR [rdx+rax+16]
  00142	8b c1		 mov	 eax, ecx
  00144	48 8b 4c 24 20	 mov	 rcx, QWORD PTR con$[rsp]
  00149	89 41 10	 mov	 DWORD PTR [rcx+16], eax
$LN10@stbrp_pack:

; 3944 :    }

  0014c	e9 cb fe ff ff	 jmp	 $LN2@stbrp_pack
$LN3@stbrp_pack:

; 3945 :    for (   ; i < num_rects; ++i)

  00151	eb 08		 jmp	 SHORT $LN7@stbrp_pack
$LN5@stbrp_pack:
  00153	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00156	ff c0		 inc	 eax
  00158	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbrp_pack:
  0015b	8b 44 24 30	 mov	 eax, DWORD PTR num_rects$[rsp]
  0015f	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00162	7d 17		 jge	 SHORT $LN6@stbrp_pack

; 3946 :       rects[i].was_packed = 0;

  00164	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00168	48 6b c0 18	 imul	 rax, rax, 24
  0016c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR rects$[rsp]
  00171	c7 44 01 14 00
	00 00 00	 mov	 DWORD PTR [rcx+rax+20], 0
  00179	eb d8		 jmp	 SHORT $LN5@stbrp_pack
$LN6@stbrp_pack:

; 3947 : }

  0017b	48 83 c4 18	 add	 rsp, 24
  0017f	c3		 ret	 0
?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z ENDP ; stbrp_pack_rects
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
con$ = 8
pw$ = 16
ph$ = 24
nodes$ = 32
num_nodes$ = 40
?stbrp_init_target@@YAXPEAUstbrp_context@@HHPEAUstbrp_node@@H@Z PROC ; stbrp_init_target

; 3918 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3919 :    con->width  = pw;

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR con$[rsp]
  00018	8b 4c 24 10	 mov	 ecx, DWORD PTR pw$[rsp]
  0001c	89 08		 mov	 DWORD PTR [rax], ecx

; 3920 :    con->height = ph;

  0001e	48 8b 44 24 08	 mov	 rax, QWORD PTR con$[rsp]
  00023	8b 4c 24 18	 mov	 ecx, DWORD PTR ph$[rsp]
  00027	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 3921 :    con->x = 0;

  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR con$[rsp]
  0002f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 3922 :    con->y = 0;

  00036	48 8b 44 24 08	 mov	 rax, QWORD PTR con$[rsp]
  0003b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 3923 :    con->bottom_y = 0;

  00042	48 8b 44 24 08	 mov	 rax, QWORD PTR con$[rsp]
  00047	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 3924 :    STBTT__NOTUSED(nodes);
; 3925 :    STBTT__NOTUSED(num_nodes);
; 3926 : }

  0004e	c3		 ret	 0
?stbrp_init_target@@YAXPEAUstbrp_context@@HHPEAUstbrp_node@@H@Z ENDP ; stbrp_init_target
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 64
y$ = 68
x$ = 72
gh$1 = 76
scale$ = 80
gw$2 = 84
bottom_y$ = 88
g$3 = 92
x0$4 = 96
y0$5 = 100
x1$6 = 104
y1$7 = 108
advance$8 = 112
lsb$9 = 116
tv72 = 120
f$ = 128
data$ = 304
offset$ = 312
pixel_height$ = 320
pixels$ = 328
pw$ = 336
ph$ = 344
first_char$ = 352
num_chars$ = 360
chardata$ = 368
?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z PROC ; stbtt_BakeFontBitmap_internal

; 3818 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 3819 :    float scale;
; 3820 :    int x,y,bottom_y, i;
; 3821 :    stbtt_fontinfo f;
; 3822 :    f.userdata = NULL;

  0001c	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR f$[rsp], 0

; 3823 :    if (!stbtt_InitFont(&f, data, offset))

  00028	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR offset$[rsp]
  00030	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  00038	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR f$[rsp]
  00040	e8 00 00 00 00	 call	 stbtt_InitFont
  00045	85 c0		 test	 eax, eax
  00047	75 0a		 jne	 SHORT $LN5@stbtt_Bake

; 3824 :       return -1;

  00049	b8 ff ff ff ff	 mov	 eax, -1
  0004e	e9 49 03 00 00	 jmp	 $LN1@stbtt_Bake
$LN5@stbtt_Bake:

; 3825 :    STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

  00053	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR pw$[rsp]
  0005a	0f af 84 24 58
	01 00 00	 imul	 eax, DWORD PTR ph$[rsp]
  00062	48 98		 cdqe
  00064	48 89 44 24 78	 mov	 QWORD PTR tv72[rsp], rax
  00069	48 8b bc 24 48
	01 00 00	 mov	 rdi, QWORD PTR pixels$[rsp]
  00071	33 c0		 xor	 eax, eax
  00073	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv72[rsp]
  00078	f3 aa		 rep stosb

; 3826 :    x=y=1;

  0007a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR y$[rsp], 1
  00082	8b 44 24 44	 mov	 eax, DWORD PTR y$[rsp]
  00086	89 44 24 48	 mov	 DWORD PTR x$[rsp], eax

; 3827 :    bottom_y = 1;

  0008a	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR bottom_y$[rsp], 1

; 3828 : 
; 3829 :    scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

  00092	f3 0f 10 8c 24
	40 01 00 00	 movss	 xmm1, DWORD PTR pixel_height$[rsp]
  0009b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR f$[rsp]
  000a3	e8 00 00 00 00	 call	 stbtt_ScaleForPixelHeight
  000a8	f3 0f 11 44 24
	50		 movss	 DWORD PTR scale$[rsp], xmm0

; 3830 : 
; 3831 :    for (i=0; i < num_chars; ++i) {

  000ae	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b6	eb 0a		 jmp	 SHORT $LN4@stbtt_Bake
$LN2@stbtt_Bake:
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000bc	ff c0		 inc	 eax
  000be	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Bake:
  000c2	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR num_chars$[rsp]
  000c9	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  000cd	0f 8d c5 02 00
	00		 jge	 $LN3@stbtt_Bake

; 3832 :       int advance, lsb, x0,y0,x1,y1,gw,gh;
; 3833 :       int g = stbtt_FindGlyphIndex(&f, first_char + i);

  000d3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000d7	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR first_char$[rsp]
  000de	03 c8		 add	 ecx, eax
  000e0	8b c1		 mov	 eax, ecx
  000e2	8b d0		 mov	 edx, eax
  000e4	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR f$[rsp]
  000ec	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  000f1	89 44 24 5c	 mov	 DWORD PTR g$3[rsp], eax

; 3834 :       stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);

  000f5	4c 8d 4c 24 74	 lea	 r9, QWORD PTR lsb$9[rsp]
  000fa	4c 8d 44 24 70	 lea	 r8, QWORD PTR advance$8[rsp]
  000ff	8b 54 24 5c	 mov	 edx, DWORD PTR g$3[rsp]
  00103	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR f$[rsp]
  0010b	e8 00 00 00 00	 call	 stbtt_GetGlyphHMetrics

; 3835 :       stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);

  00110	48 8d 44 24 6c	 lea	 rax, QWORD PTR y1$7[rsp]
  00115	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0011a	48 8d 44 24 68	 lea	 rax, QWORD PTR x1$6[rsp]
  0011f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00124	48 8d 44 24 64	 lea	 rax, QWORD PTR y0$5[rsp]
  00129	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0012e	48 8d 44 24 60	 lea	 rax, QWORD PTR x0$4[rsp]
  00133	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00138	f3 0f 10 5c 24
	50		 movss	 xmm3, DWORD PTR scale$[rsp]
  0013e	f3 0f 10 54 24
	50		 movss	 xmm2, DWORD PTR scale$[rsp]
  00144	8b 54 24 5c	 mov	 edx, DWORD PTR g$3[rsp]
  00148	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR f$[rsp]
  00150	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBox

; 3836 :       gw = x1-x0;

  00155	8b 44 24 60	 mov	 eax, DWORD PTR x0$4[rsp]
  00159	8b 4c 24 68	 mov	 ecx, DWORD PTR x1$6[rsp]
  0015d	2b c8		 sub	 ecx, eax
  0015f	8b c1		 mov	 eax, ecx
  00161	89 44 24 54	 mov	 DWORD PTR gw$2[rsp], eax

; 3837 :       gh = y1-y0;

  00165	8b 44 24 64	 mov	 eax, DWORD PTR y0$5[rsp]
  00169	8b 4c 24 6c	 mov	 ecx, DWORD PTR y1$7[rsp]
  0016d	2b c8		 sub	 ecx, eax
  0016f	8b c1		 mov	 eax, ecx
  00171	89 44 24 4c	 mov	 DWORD PTR gh$1[rsp], eax

; 3838 :       if (x + gw + 1 >= pw)

  00175	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00179	8b 4c 24 54	 mov	 ecx, DWORD PTR gw$2[rsp]
  0017d	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00181	3b 84 24 50 01
	00 00		 cmp	 eax, DWORD PTR pw$[rsp]
  00188	7c 10		 jl	 SHORT $LN6@stbtt_Bake

; 3839 :          y = bottom_y, x = 1; // advance to next row

  0018a	8b 44 24 58	 mov	 eax, DWORD PTR bottom_y$[rsp]
  0018e	89 44 24 44	 mov	 DWORD PTR y$[rsp], eax
  00192	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR x$[rsp], 1
$LN6@stbtt_Bake:

; 3840 :       if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row

  0019a	8b 44 24 44	 mov	 eax, DWORD PTR y$[rsp]
  0019e	8b 4c 24 4c	 mov	 ecx, DWORD PTR gh$1[rsp]
  001a2	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  001a6	3b 84 24 58 01
	00 00		 cmp	 eax, DWORD PTR ph$[rsp]
  001ad	7c 0b		 jl	 SHORT $LN7@stbtt_Bake

; 3841 :          return -i;

  001af	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  001b3	f7 d8		 neg	 eax
  001b5	e9 e2 01 00 00	 jmp	 $LN1@stbtt_Bake
$LN7@stbtt_Bake:

; 3842 :       STBTT_assert(x+gw < pw);

  001ba	8b 44 24 54	 mov	 eax, DWORD PTR gw$2[rsp]
  001be	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  001c2	03 c8		 add	 ecx, eax
  001c4	8b c1		 mov	 eax, ecx
  001c6	3b 84 24 50 01
	00 00		 cmp	 eax, DWORD PTR pw$[rsp]
  001cd	7c 1b		 jl	 SHORT $LN10@stbtt_Bake
  001cf	41 b8 02 0f 00
	00		 mov	 r8d, 3842		; 00000f02H
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG43294
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG43295
  001e3	e8 00 00 00 00	 call	 _wassert
  001e8	33 c0		 xor	 eax, eax
$LN10@stbtt_Bake:

; 3843 :       STBTT_assert(y+gh < ph);

  001ea	8b 44 24 4c	 mov	 eax, DWORD PTR gh$1[rsp]
  001ee	8b 4c 24 44	 mov	 ecx, DWORD PTR y$[rsp]
  001f2	03 c8		 add	 ecx, eax
  001f4	8b c1		 mov	 eax, ecx
  001f6	3b 84 24 58 01
	00 00		 cmp	 eax, DWORD PTR ph$[rsp]
  001fd	7c 1b		 jl	 SHORT $LN11@stbtt_Bake
  001ff	41 b8 03 0f 00
	00		 mov	 r8d, 3843		; 00000f03H
  00205	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG43296
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG43297
  00213	e8 00 00 00 00	 call	 _wassert
  00218	33 c0		 xor	 eax, eax
$LN11@stbtt_Bake:

; 3844 :       stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);

  0021a	48 63 44 24 48	 movsxd	 rax, DWORD PTR x$[rsp]
  0021f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR pixels$[rsp]
  00227	48 03 c8	 add	 rcx, rax
  0022a	48 8b c1	 mov	 rax, rcx
  0022d	8b 4c 24 44	 mov	 ecx, DWORD PTR y$[rsp]
  00231	0f af 8c 24 50
	01 00 00	 imul	 ecx, DWORD PTR pw$[rsp]
  00239	48 63 c9	 movsxd	 rcx, ecx
  0023c	48 03 c1	 add	 rax, rcx
  0023f	8b 4c 24 5c	 mov	 ecx, DWORD PTR g$3[rsp]
  00243	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00247	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR scale$[rsp]
  0024d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00253	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR scale$[rsp]
  00259	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0025f	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR pw$[rsp]
  00266	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0026a	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR gh$1[rsp]
  0026f	44 8b 44 24 54	 mov	 r8d, DWORD PTR gw$2[rsp]
  00274	48 8b d0	 mov	 rdx, rax
  00277	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR f$[rsp]
  0027f	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmap

; 3845 :       chardata[i].x0 = (stbtt_int16) x;

  00284	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00289	48 6b c0 14	 imul	 rax, rax, 20
  0028d	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR chardata$[rsp]
  00295	0f b7 54 24 48	 movzx	 edx, WORD PTR x$[rsp]
  0029a	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx

; 3846 :       chardata[i].y0 = (stbtt_int16) y;

  0029e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  002a3	48 6b c0 14	 imul	 rax, rax, 20
  002a7	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR chardata$[rsp]
  002af	0f b7 54 24 44	 movzx	 edx, WORD PTR y$[rsp]
  002b4	66 89 54 01 02	 mov	 WORD PTR [rcx+rax+2], dx

; 3847 :       chardata[i].x1 = (stbtt_int16) (x + gw);

  002b9	8b 44 24 54	 mov	 eax, DWORD PTR gw$2[rsp]
  002bd	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  002c1	03 c8		 add	 ecx, eax
  002c3	8b c1		 mov	 eax, ecx
  002c5	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  002ca	48 6b c9 14	 imul	 rcx, rcx, 20
  002ce	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR chardata$[rsp]
  002d6	66 89 44 0a 04	 mov	 WORD PTR [rdx+rcx+4], ax

; 3848 :       chardata[i].y1 = (stbtt_int16) (y + gh);

  002db	8b 44 24 4c	 mov	 eax, DWORD PTR gh$1[rsp]
  002df	8b 4c 24 44	 mov	 ecx, DWORD PTR y$[rsp]
  002e3	03 c8		 add	 ecx, eax
  002e5	8b c1		 mov	 eax, ecx
  002e7	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  002ec	48 6b c9 14	 imul	 rcx, rcx, 20
  002f0	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR chardata$[rsp]
  002f8	66 89 44 0a 06	 mov	 WORD PTR [rdx+rcx+6], ax

; 3849 :       chardata[i].xadvance = scale * advance;

  002fd	f3 0f 2a 44 24
	70		 cvtsi2ss xmm0, DWORD PTR advance$8[rsp]
  00303	f3 0f 10 4c 24
	50		 movss	 xmm1, DWORD PTR scale$[rsp]
  00309	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0030d	0f 28 c1	 movaps	 xmm0, xmm1
  00310	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00315	48 6b c0 14	 imul	 rax, rax, 20
  00319	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR chardata$[rsp]
  00321	f3 0f 11 44 01
	10		 movss	 DWORD PTR [rcx+rax+16], xmm0

; 3850 :       chardata[i].xoff     = (float) x0;

  00327	f3 0f 2a 44 24
	60		 cvtsi2ss xmm0, DWORD PTR x0$4[rsp]
  0032d	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00332	48 6b c0 14	 imul	 rax, rax, 20
  00336	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR chardata$[rsp]
  0033e	f3 0f 11 44 01
	08		 movss	 DWORD PTR [rcx+rax+8], xmm0

; 3851 :       chardata[i].yoff     = (float) y0;

  00344	f3 0f 2a 44 24
	64		 cvtsi2ss xmm0, DWORD PTR y0$5[rsp]
  0034a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0034f	48 6b c0 14	 imul	 rax, rax, 20
  00353	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR chardata$[rsp]
  0035b	f3 0f 11 44 01
	0c		 movss	 DWORD PTR [rcx+rax+12], xmm0

; 3852 :       x = x + gw + 1;

  00361	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00365	8b 4c 24 54	 mov	 ecx, DWORD PTR gw$2[rsp]
  00369	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0036d	89 44 24 48	 mov	 DWORD PTR x$[rsp], eax

; 3853 :       if (y+gh+1 > bottom_y)

  00371	8b 44 24 44	 mov	 eax, DWORD PTR y$[rsp]
  00375	8b 4c 24 4c	 mov	 ecx, DWORD PTR gh$1[rsp]
  00379	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0037d	3b 44 24 58	 cmp	 eax, DWORD PTR bottom_y$[rsp]
  00381	7e 10		 jle	 SHORT $LN8@stbtt_Bake

; 3854 :          bottom_y = y+gh+1;

  00383	8b 44 24 44	 mov	 eax, DWORD PTR y$[rsp]
  00387	8b 4c 24 4c	 mov	 ecx, DWORD PTR gh$1[rsp]
  0038b	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0038f	89 44 24 58	 mov	 DWORD PTR bottom_y$[rsp], eax
$LN8@stbtt_Bake:

; 3855 :    }

  00393	e9 20 fd ff ff	 jmp	 $LN2@stbtt_Bake
$LN3@stbtt_Bake:

; 3856 :    return bottom_y;

  00398	8b 44 24 58	 mov	 eax, DWORD PTR bottom_y$[rsp]
$LN1@stbtt_Bake:

; 3857 : }

  0039c	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  003a3	5f		 pop	 rdi
  003a4	c3		 ret	 0
?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z ENDP ; stbtt_BakeFontBitmap_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 96
num_points$ = 100
n$ = 104
x$1 = 108
y$2 = 112
pass$ = 116
tv133 = 120
points$ = 128
start$ = 136
objspace_flatness_squared$ = 140
tv155 = 144
tv173 = 148
vertices$ = 192
num_verts$ = 200
objspace_flatness$ = 208
contour_lengths$ = 216
num_contours$ = 224
userdata$ = 232
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z PROC ; stbtt_FlattenCurves

; 3619 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	0f 29 b4 24 a0
	00 00 00	 movaps	 XMMWORD PTR [rsp+160], xmm6

; 3620 :    stbtt__point *points=0;

  00023	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR points$[rsp], 0

; 3621 :    int num_points=0;

  0002f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR num_points$[rsp], 0

; 3622 : 
; 3623 :    float objspace_flatness_squared = objspace_flatness * objspace_flatness;

  00037	f3 0f 10 84 24
	d0 00 00 00	 movss	 xmm0, DWORD PTR objspace_flatness$[rsp]
  00040	f3 0f 59 84 24
	d0 00 00 00	 mulss	 xmm0, DWORD PTR objspace_flatness$[rsp]
  00049	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR objspace_flatness_squared$[rsp], xmm0

; 3624 :    int i,n=0,start=0, pass;

  00052	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0005a	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR start$[rsp], 0

; 3625 : 
; 3626 :    // count how many "moves" there are to get the contour count
; 3627 :    for (i=0; i < num_verts; ++i)

  00065	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006d	eb 0a		 jmp	 SHORT $LN4@stbtt_Flat
$LN2@stbtt_Flat:
  0006f	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Flat:
  00079	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR num_verts$[rsp]
  00080	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00084	7d 27		 jge	 SHORT $LN3@stbtt_Flat

; 3628 :       if (vertices[i].type == STBTT_vmove)

  00086	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0008b	48 6b c0 0e	 imul	 rax, rax, 14
  0008f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00097	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	75 0a		 jne	 SHORT $LN13@stbtt_Flat

; 3629 :          ++n;

  000a1	8b 44 24 68	 mov	 eax, DWORD PTR n$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	89 44 24 68	 mov	 DWORD PTR n$[rsp], eax
$LN13@stbtt_Flat:
  000ab	eb c2		 jmp	 SHORT $LN2@stbtt_Flat
$LN3@stbtt_Flat:

; 3630 : 
; 3631 :    *num_contours = n;

  000ad	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR num_contours$[rsp]
  000b5	8b 4c 24 68	 mov	 ecx, DWORD PTR n$[rsp]
  000b9	89 08		 mov	 DWORD PTR [rax], ecx

; 3632 :    if (n == 0) return 0;

  000bb	83 7c 24 68 00	 cmp	 DWORD PTR n$[rsp], 0
  000c0	75 07		 jne	 SHORT $LN14@stbtt_Flat
  000c2	33 c0		 xor	 eax, eax
  000c4	e9 ee 04 00 00	 jmp	 $LN1@stbtt_Flat
$LN14@stbtt_Flat:

; 3633 : 
; 3634 :    *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

  000c9	48 63 44 24 68	 movsxd	 rax, DWORD PTR n$[rsp]
  000ce	48 c1 e0 02	 shl	 rax, 2
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 malloc
  000da	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR contour_lengths$[rsp]
  000e2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3635 : 
; 3636 :    if (*contour_lengths == 0) {

  000e5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR contour_lengths$[rsp]
  000ed	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000f1	75 15		 jne	 SHORT $LN15@stbtt_Flat

; 3637 :       *num_contours = 0;

  000f3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR num_contours$[rsp]
  000fb	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3638 :       return 0;

  00101	33 c0		 xor	 eax, eax
  00103	e9 af 04 00 00	 jmp	 $LN1@stbtt_Flat
$LN15@stbtt_Flat:

; 3639 :    }
; 3640 : 
; 3641 :    // make two passes through the points so we don't need to realloc
; 3642 :    for (pass=0; pass < 2; ++pass) {

  00108	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR pass$[rsp], 0
  00110	eb 0a		 jmp	 SHORT $LN7@stbtt_Flat
$LN5@stbtt_Flat:
  00112	8b 44 24 74	 mov	 eax, DWORD PTR pass$[rsp]
  00116	ff c0		 inc	 eax
  00118	89 44 24 74	 mov	 DWORD PTR pass$[rsp], eax
$LN7@stbtt_Flat:
  0011c	83 7c 24 74 02	 cmp	 DWORD PTR pass$[rsp], 2
  00121	0f 8d 4a 04 00
	00		 jge	 $LN6@stbtt_Flat

; 3643 :       float x=0,y=0;

  00127	0f 57 c0	 xorps	 xmm0, xmm0
  0012a	f3 0f 11 44 24
	6c		 movss	 DWORD PTR x$1[rsp], xmm0
  00130	0f 57 c0	 xorps	 xmm0, xmm0
  00133	f3 0f 11 44 24
	70		 movss	 DWORD PTR y$2[rsp], xmm0

; 3644 :       if (pass == 1) {

  00139	83 7c 24 74 01	 cmp	 DWORD PTR pass$[rsp], 1
  0013e	75 2e		 jne	 SHORT $LN16@stbtt_Flat

; 3645 :          points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);

  00140	48 63 44 24 64	 movsxd	 rax, DWORD PTR num_points$[rsp]
  00145	48 c1 e0 03	 shl	 rax, 3
  00149	48 8b c8	 mov	 rcx, rax
  0014c	e8 00 00 00 00	 call	 malloc
  00151	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR points$[rsp], rax

; 3646 :          if (points == NULL) goto error;

  00159	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR points$[rsp], 0
  00162	75 0a		 jne	 SHORT $LN17@stbtt_Flat
  00164	e9 12 04 00 00	 jmp	 $LN18@stbtt_Flat
  00169	e9 0d 04 00 00	 jmp	 $error$25
$LN17@stbtt_Flat:
$LN16@stbtt_Flat:

; 3647 :       }
; 3648 :       num_points = 0;

  0016e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR num_points$[rsp], 0

; 3649 :       n= -1;

  00176	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR n$[rsp], -1

; 3650 :       for (i=0; i < num_verts; ++i) {

  0017e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00186	eb 0a		 jmp	 SHORT $LN10@stbtt_Flat
$LN8@stbtt_Flat:
  00188	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0018c	ff c0		 inc	 eax
  0018e	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbtt_Flat:
  00192	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR num_verts$[rsp]
  00199	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  0019d	0f 8d a7 03 00
	00		 jge	 $LN9@stbtt_Flat

; 3651 :          switch (vertices[i].type) {

  001a3	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001a8	48 6b c0 0e	 imul	 rax, rax, 14
  001ac	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  001b4	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  001b9	88 44 24 78	 mov	 BYTE PTR tv133[rsp], al
  001bd	80 7c 24 78 01	 cmp	 BYTE PTR tv133[rsp], 1
  001c2	74 26		 je	 SHORT $LN19@stbtt_Flat
  001c4	80 7c 24 78 02	 cmp	 BYTE PTR tv133[rsp], 2
  001c9	0f 84 d2 00 00
	00		 je	 $LN21@stbtt_Flat
  001cf	80 7c 24 78 03	 cmp	 BYTE PTR tv133[rsp], 3
  001d4	0f 84 40 01 00
	00		 je	 $LN22@stbtt_Flat
  001da	80 7c 24 78 04	 cmp	 BYTE PTR tv133[rsp], 4
  001df	0f 84 2d 02 00
	00		 je	 $LN23@stbtt_Flat
  001e5	e9 5b 03 00 00	 jmp	 $LN11@stbtt_Flat
$LN19@stbtt_Flat:

; 3652 :             case STBTT_vmove:
; 3653 :                // start the next contour
; 3654 :                if (n >= 0)

  001ea	83 7c 24 68 00	 cmp	 DWORD PTR n$[rsp], 0
  001ef	7c 22		 jl	 SHORT $LN20@stbtt_Flat

; 3655 :                   (*contour_lengths)[n] = num_points - start;

  001f1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  001f8	8b 4c 24 64	 mov	 ecx, DWORD PTR num_points$[rsp]
  001fc	2b c8		 sub	 ecx, eax
  001fe	8b c1		 mov	 eax, ecx
  00200	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR n$[rsp]
  00205	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR contour_lengths$[rsp]
  0020d	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00210	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN20@stbtt_Flat:

; 3656 :                ++n;

  00213	8b 44 24 68	 mov	 eax, DWORD PTR n$[rsp]
  00217	ff c0		 inc	 eax
  00219	89 44 24 68	 mov	 DWORD PTR n$[rsp], eax

; 3657 :                start = num_points;

  0021d	8b 44 24 64	 mov	 eax, DWORD PTR num_points$[rsp]
  00221	89 84 24 88 00
	00 00		 mov	 DWORD PTR start$[rsp], eax

; 3658 : 
; 3659 :                x = vertices[i].x, y = vertices[i].y;

  00228	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0022d	48 6b c0 0e	 imul	 rax, rax, 14
  00231	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00239	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0023d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00241	f3 0f 11 44 24
	6c		 movss	 DWORD PTR x$1[rsp], xmm0
  00247	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0024c	48 6b c0 0e	 imul	 rax, rax, 14
  00250	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00258	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  0025d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00261	f3 0f 11 44 24
	70		 movss	 DWORD PTR y$2[rsp], xmm0

; 3660 :                stbtt__add_point(points, num_points++, x,y);

  00267	8b 44 24 64	 mov	 eax, DWORD PTR num_points$[rsp]
  0026b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv155[rsp], eax
  00272	8b 44 24 64	 mov	 eax, DWORD PTR num_points$[rsp]
  00276	ff c0		 inc	 eax
  00278	89 44 24 64	 mov	 DWORD PTR num_points$[rsp], eax
  0027c	f3 0f 10 5c 24
	70		 movss	 xmm3, DWORD PTR y$2[rsp]
  00282	f3 0f 10 54 24
	6c		 movss	 xmm2, DWORD PTR x$1[rsp]
  00288	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR tv155[rsp]
  0028f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  00297	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point

; 3661 :                break;

  0029c	e9 a4 02 00 00	 jmp	 $LN11@stbtt_Flat
$LN21@stbtt_Flat:

; 3662 :             case STBTT_vline:
; 3663 :                x = vertices[i].x, y = vertices[i].y;

  002a1	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  002a6	48 6b c0 0e	 imul	 rax, rax, 14
  002aa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  002b2	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  002b6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002ba	f3 0f 11 44 24
	6c		 movss	 DWORD PTR x$1[rsp], xmm0
  002c0	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  002c5	48 6b c0 0e	 imul	 rax, rax, 14
  002c9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  002d1	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  002d6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002da	f3 0f 11 44 24
	70		 movss	 DWORD PTR y$2[rsp], xmm0

; 3664 :                stbtt__add_point(points, num_points++, x, y);

  002e0	8b 44 24 64	 mov	 eax, DWORD PTR num_points$[rsp]
  002e4	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv173[rsp], eax
  002eb	8b 44 24 64	 mov	 eax, DWORD PTR num_points$[rsp]
  002ef	ff c0		 inc	 eax
  002f1	89 44 24 64	 mov	 DWORD PTR num_points$[rsp], eax
  002f5	f3 0f 10 5c 24
	70		 movss	 xmm3, DWORD PTR y$2[rsp]
  002fb	f3 0f 10 54 24
	6c		 movss	 xmm2, DWORD PTR x$1[rsp]
  00301	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR tv173[rsp]
  00308	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  00310	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point

; 3665 :                break;

  00315	e9 2b 02 00 00	 jmp	 $LN11@stbtt_Flat
$LN22@stbtt_Flat:

; 3666 :             case STBTT_vcurve:
; 3667 :                stbtt__tesselate_curve(points, &num_points, x,y,

  0031a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0031f	48 6b c0 0e	 imul	 rax, rax, 14
  00323	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  0032b	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00330	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00334	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00339	48 6b c0 0e	 imul	 rax, rax, 14
  0033d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00345	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00349	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  0034d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00352	48 6b c0 0e	 imul	 rax, rax, 14
  00356	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  0035e	0f bf 44 01 06	 movsx	 eax, WORD PTR [rcx+rax+6]
  00363	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00367	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0036c	48 6b c0 0e	 imul	 rax, rax, 14
  00370	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00378	0f bf 44 01 04	 movsx	 eax, WORD PTR [rcx+rax+4]
  0037d	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00381	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR [rsp+72], 0
  00389	f3 0f 10 a4 24
	8c 00 00 00	 movss	 xmm4, DWORD PTR objspace_flatness_squared$[rsp]
  00392	f3 0f 11 64 24
	40		 movss	 DWORD PTR [rsp+64], xmm4
  00398	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  0039e	f3 0f 11 4c 24
	30		 movss	 DWORD PTR [rsp+48], xmm1
  003a4	f3 0f 11 54 24
	28		 movss	 DWORD PTR [rsp+40], xmm2
  003aa	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  003b0	f3 0f 10 5c 24
	70		 movss	 xmm3, DWORD PTR y$2[rsp]
  003b6	f3 0f 10 54 24
	6c		 movss	 xmm2, DWORD PTR x$1[rsp]
  003bc	48 8d 54 24 64	 lea	 rdx, QWORD PTR num_points$[rsp]
  003c1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  003c9	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3668 :                                         vertices[i].cx, vertices[i].cy,
; 3669 :                                         vertices[i].x,  vertices[i].y,
; 3670 :                                         objspace_flatness_squared, 0);
; 3671 :                x = vertices[i].x, y = vertices[i].y;

  003ce	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  003d3	48 6b c0 0e	 imul	 rax, rax, 14
  003d7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  003df	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  003e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003e7	f3 0f 11 44 24
	6c		 movss	 DWORD PTR x$1[rsp], xmm0
  003ed	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  003f2	48 6b c0 0e	 imul	 rax, rax, 14
  003f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  003fe	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00403	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00407	f3 0f 11 44 24
	70		 movss	 DWORD PTR y$2[rsp], xmm0

; 3672 :                break;

  0040d	e9 33 01 00 00	 jmp	 $LN11@stbtt_Flat
$LN23@stbtt_Flat:

; 3673 :             case STBTT_vcubic:
; 3674 :                stbtt__tesselate_cubic(points, &num_points, x,y,

  00412	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00417	48 6b c0 0e	 imul	 rax, rax, 14
  0041b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00423	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00428	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0042c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00431	48 6b c0 0e	 imul	 rax, rax, 14
  00435	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  0043d	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00441	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00445	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0044a	48 6b c0 0e	 imul	 rax, rax, 14
  0044e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00456	0f bf 44 01 0a	 movsx	 eax, WORD PTR [rcx+rax+10]
  0045b	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  0045f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00464	48 6b c0 0e	 imul	 rax, rax, 14
  00468	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00470	0f bf 44 01 08	 movsx	 eax, WORD PTR [rcx+rax+8]
  00475	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00479	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0047e	48 6b c0 0e	 imul	 rax, rax, 14
  00482	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  0048a	0f bf 44 01 06	 movsx	 eax, WORD PTR [rcx+rax+6]
  0048f	f3 0f 2a e0	 cvtsi2ss xmm4, eax
  00493	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00498	48 6b c0 0e	 imul	 rax, rax, 14
  0049c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  004a4	0f bf 44 01 04	 movsx	 eax, WORD PTR [rcx+rax+4]
  004a9	f3 0f 2a e8	 cvtsi2ss xmm5, eax
  004ad	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  004b5	f3 0f 10 b4 24
	8c 00 00 00	 movss	 xmm6, DWORD PTR objspace_flatness_squared$[rsp]
  004be	f3 0f 11 74 24
	50		 movss	 DWORD PTR [rsp+80], xmm6
  004c4	f3 0f 11 44 24
	48		 movss	 DWORD PTR [rsp+72], xmm0
  004ca	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  004d0	f3 0f 11 54 24
	38		 movss	 DWORD PTR [rsp+56], xmm2
  004d6	f3 0f 11 5c 24
	30		 movss	 DWORD PTR [rsp+48], xmm3
  004dc	f3 0f 11 64 24
	28		 movss	 DWORD PTR [rsp+40], xmm4
  004e2	f3 0f 11 6c 24
	20		 movss	 DWORD PTR [rsp+32], xmm5
  004e8	f3 0f 10 5c 24
	70		 movss	 xmm3, DWORD PTR y$2[rsp]
  004ee	f3 0f 10 54 24
	6c		 movss	 xmm2, DWORD PTR x$1[rsp]
  004f4	48 8d 54 24 64	 lea	 rdx, QWORD PTR num_points$[rsp]
  004f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  00501	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3675 :                                         vertices[i].cx, vertices[i].cy,
; 3676 :                                         vertices[i].cx1, vertices[i].cy1,
; 3677 :                                         vertices[i].x,  vertices[i].y,
; 3678 :                                         objspace_flatness_squared, 0);
; 3679 :                x = vertices[i].x, y = vertices[i].y;

  00506	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0050b	48 6b c0 0e	 imul	 rax, rax, 14
  0050f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00517	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0051b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0051f	f3 0f 11 44 24
	6c		 movss	 DWORD PTR x$1[rsp], xmm0
  00525	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0052a	48 6b c0 0e	 imul	 rax, rax, 14
  0052e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  00536	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  0053b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0053f	f3 0f 11 44 24
	70		 movss	 DWORD PTR y$2[rsp], xmm0
$LN11@stbtt_Flat:

; 3680 :                break;
; 3681 :          }
; 3682 :       }

  00545	e9 3e fc ff ff	 jmp	 $LN8@stbtt_Flat
$LN9@stbtt_Flat:

; 3683 :       (*contour_lengths)[n] = num_points - start;

  0054a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00551	8b 4c 24 64	 mov	 ecx, DWORD PTR num_points$[rsp]
  00555	2b c8		 sub	 ecx, eax
  00557	8b c1		 mov	 eax, ecx
  00559	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR n$[rsp]
  0055e	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR contour_lengths$[rsp]
  00566	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00569	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 3684 :    }

  0056c	e9 a1 fb ff ff	 jmp	 $LN5@stbtt_Flat
$LN6@stbtt_Flat:

; 3685 : 
; 3686 :    return points;

  00571	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR points$[rsp]
  00579	eb 3c		 jmp	 SHORT $LN1@stbtt_Flat
$LN18@stbtt_Flat:
$error$25:

; 3687 : error:
; 3688 :    STBTT_free(points, userdata);

  0057b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  00583	e8 00 00 00 00	 call	 free

; 3689 :    STBTT_free(*contour_lengths, userdata);

  00588	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR contour_lengths$[rsp]
  00590	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00593	e8 00 00 00 00	 call	 free

; 3690 :    *contour_lengths = 0;

  00598	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR contour_lengths$[rsp]
  005a0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3691 :    *num_contours = 0;

  005a7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR num_contours$[rsp]
  005af	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3692 :    return NULL;

  005b5	33 c0		 xor	 eax, eax
$LN1@stbtt_Flat:

; 3693 : }

  005b7	0f 28 b4 24 a0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+160]
  005bf	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  005c6	c3		 ret	 0
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ENDP ; stbtt_FlattenCurves
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
dx0$ = 96
dy0$ = 100
dx1$ = 104
dy1$ = 108
dx2$ = 112
dy2$ = 116
dx$ = 120
dy$ = 124
longlen$ = 128
shortlen$ = 132
x12$1 = 136
y12$2 = 140
ya$3 = 144
xa$4 = 148
y01$5 = 152
x01$6 = 156
y23$7 = 160
x23$8 = 164
yb$9 = 168
xb$10 = 172
my$11 = 176
mx$12 = 180
flatness_squared$ = 184
tv72 = 192
tv84 = 200
points$ = 224
num_points$ = 232
x0$ = 240
y0$ = 248
x1$ = 256
y1$ = 264
x2$ = 272
y2$ = 280
x3$ = 288
y3$ = 296
objspace_flatness_squared$ = 304
n$ = 312
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z PROC ; stbtt__tesselate_cubic

; 3576 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 3577 :    // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
; 3578 :    float dx0 = x1-x0;

  0001d	f3 0f 10 84 24
	00 01 00 00	 movss	 xmm0, DWORD PTR x1$[rsp]
  00026	f3 0f 5c 84 24
	f0 00 00 00	 subss	 xmm0, DWORD PTR x0$[rsp]
  0002f	f3 0f 11 44 24
	60		 movss	 DWORD PTR dx0$[rsp], xmm0

; 3579 :    float dy0 = y1-y0;

  00035	f3 0f 10 84 24
	08 01 00 00	 movss	 xmm0, DWORD PTR y1$[rsp]
  0003e	f3 0f 5c 84 24
	f8 00 00 00	 subss	 xmm0, DWORD PTR y0$[rsp]
  00047	f3 0f 11 44 24
	64		 movss	 DWORD PTR dy0$[rsp], xmm0

; 3580 :    float dx1 = x2-x1;

  0004d	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR x2$[rsp]
  00056	f3 0f 5c 84 24
	00 01 00 00	 subss	 xmm0, DWORD PTR x1$[rsp]
  0005f	f3 0f 11 44 24
	68		 movss	 DWORD PTR dx1$[rsp], xmm0

; 3581 :    float dy1 = y2-y1;

  00065	f3 0f 10 84 24
	18 01 00 00	 movss	 xmm0, DWORD PTR y2$[rsp]
  0006e	f3 0f 5c 84 24
	08 01 00 00	 subss	 xmm0, DWORD PTR y1$[rsp]
  00077	f3 0f 11 44 24
	6c		 movss	 DWORD PTR dy1$[rsp], xmm0

; 3582 :    float dx2 = x3-x2;

  0007d	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR x3$[rsp]
  00086	f3 0f 5c 84 24
	10 01 00 00	 subss	 xmm0, DWORD PTR x2$[rsp]
  0008f	f3 0f 11 44 24
	70		 movss	 DWORD PTR dx2$[rsp], xmm0

; 3583 :    float dy2 = y3-y2;

  00095	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y3$[rsp]
  0009e	f3 0f 5c 84 24
	18 01 00 00	 subss	 xmm0, DWORD PTR y2$[rsp]
  000a7	f3 0f 11 44 24
	74		 movss	 DWORD PTR dy2$[rsp], xmm0

; 3584 :    float dx = x3-x0;

  000ad	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR x3$[rsp]
  000b6	f3 0f 5c 84 24
	f0 00 00 00	 subss	 xmm0, DWORD PTR x0$[rsp]
  000bf	f3 0f 11 44 24
	78		 movss	 DWORD PTR dx$[rsp], xmm0

; 3585 :    float dy = y3-y0;

  000c5	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y3$[rsp]
  000ce	f3 0f 5c 84 24
	f8 00 00 00	 subss	 xmm0, DWORD PTR y0$[rsp]
  000d7	f3 0f 11 44 24
	7c		 movss	 DWORD PTR dy$[rsp], xmm0

; 3586 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

  000dd	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR dx0$[rsp]
  000e3	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR dx0$[rsp]
  000e9	f3 0f 10 4c 24
	64		 movss	 xmm1, DWORD PTR dy0$[rsp]
  000ef	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR dy0$[rsp]
  000f5	f3 0f 58 c1	 addss	 xmm0, xmm1
  000f9	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000fd	e8 00 00 00 00	 call	 sqrt
  00102	f2 0f 11 84 24
	c0 00 00 00	 movsd	 QWORD PTR tv72[rsp], xmm0
  0010b	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR dx1$[rsp]
  00111	f3 0f 59 4c 24
	68		 mulss	 xmm1, DWORD PTR dx1$[rsp]
  00117	f3 0f 10 54 24
	6c		 movss	 xmm2, DWORD PTR dy1$[rsp]
  0011d	f3 0f 59 54 24
	6c		 mulss	 xmm2, DWORD PTR dy1$[rsp]
  00123	f3 0f 58 ca	 addss	 xmm1, xmm2
  00127	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  0012b	0f 28 c1	 movaps	 xmm0, xmm1
  0012e	e8 00 00 00 00	 call	 sqrt
  00133	f2 0f 10 8c 24
	c0 00 00 00	 movsd	 xmm1, QWORD PTR tv72[rsp]
  0013c	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00140	0f 28 c1	 movaps	 xmm0, xmm1
  00143	f2 0f 11 84 24
	c8 00 00 00	 movsd	 QWORD PTR tv84[rsp], xmm0
  0014c	f3 0f 10 4c 24
	70		 movss	 xmm1, DWORD PTR dx2$[rsp]
  00152	f3 0f 59 4c 24
	70		 mulss	 xmm1, DWORD PTR dx2$[rsp]
  00158	f3 0f 10 54 24
	74		 movss	 xmm2, DWORD PTR dy2$[rsp]
  0015e	f3 0f 59 54 24
	74		 mulss	 xmm2, DWORD PTR dy2$[rsp]
  00164	f3 0f 58 ca	 addss	 xmm1, xmm2
  00168	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  0016c	0f 28 c1	 movaps	 xmm0, xmm1
  0016f	e8 00 00 00 00	 call	 sqrt
  00174	f2 0f 10 8c 24
	c8 00 00 00	 movsd	 xmm1, QWORD PTR tv84[rsp]
  0017d	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00181	0f 28 c1	 movaps	 xmm0, xmm1
  00184	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00188	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR longlen$[rsp], xmm0

; 3587 :    float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);

  00191	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR dx$[rsp]
  00197	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR dx$[rsp]
  0019d	f3 0f 10 4c 24
	7c		 movss	 xmm1, DWORD PTR dy$[rsp]
  001a3	f3 0f 59 4c 24
	7c		 mulss	 xmm1, DWORD PTR dy$[rsp]
  001a9	f3 0f 58 c1	 addss	 xmm0, xmm1
  001ad	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  001b1	e8 00 00 00 00	 call	 sqrt
  001b6	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001ba	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR shortlen$[rsp], xmm0

; 3588 :    float flatness_squared = longlen*longlen-shortlen*shortlen;

  001c3	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR longlen$[rsp]
  001cc	f3 0f 59 84 24
	80 00 00 00	 mulss	 xmm0, DWORD PTR longlen$[rsp]
  001d5	f3 0f 10 8c 24
	84 00 00 00	 movss	 xmm1, DWORD PTR shortlen$[rsp]
  001de	f3 0f 59 8c 24
	84 00 00 00	 mulss	 xmm1, DWORD PTR shortlen$[rsp]
  001e7	f3 0f 5c c1	 subss	 xmm0, xmm1
  001eb	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR flatness_squared$[rsp], xmm0

; 3589 : 
; 3590 :    if (n > 16) // 65536 segments on one curve better be enough!

  001f4	83 bc 24 38 01
	00 00 10	 cmp	 DWORD PTR n$[rsp], 16
  001fc	7e 05		 jle	 SHORT $LN2@stbtt__tes

; 3591 :       return;

  001fe	e9 36 03 00 00	 jmp	 $LN1@stbtt__tes
$LN2@stbtt__tes:

; 3592 : 
; 3593 :    if (flatness_squared > objspace_flatness_squared) {

  00203	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR flatness_squared$[rsp]
  0020c	0f 2f 84 24 30
	01 00 00	 comiss	 xmm0, DWORD PTR objspace_flatness_squared$[rsp]
  00214	0f 86 e0 02 00
	00		 jbe	 $LN3@stbtt__tes

; 3594 :       float x01 = (x0+x1)/2;

  0021a	f3 0f 10 84 24
	f0 00 00 00	 movss	 xmm0, DWORD PTR x0$[rsp]
  00223	f3 0f 58 84 24
	00 01 00 00	 addss	 xmm0, DWORD PTR x1$[rsp]
  0022c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00234	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR x01$6[rsp], xmm0

; 3595 :       float y01 = (y0+y1)/2;

  0023d	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR y0$[rsp]
  00246	f3 0f 58 84 24
	08 01 00 00	 addss	 xmm0, DWORD PTR y1$[rsp]
  0024f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00257	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR y01$5[rsp], xmm0

; 3596 :       float x12 = (x1+x2)/2;

  00260	f3 0f 10 84 24
	00 01 00 00	 movss	 xmm0, DWORD PTR x1$[rsp]
  00269	f3 0f 58 84 24
	10 01 00 00	 addss	 xmm0, DWORD PTR x2$[rsp]
  00272	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0027a	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR x12$1[rsp], xmm0

; 3597 :       float y12 = (y1+y2)/2;

  00283	f3 0f 10 84 24
	08 01 00 00	 movss	 xmm0, DWORD PTR y1$[rsp]
  0028c	f3 0f 58 84 24
	18 01 00 00	 addss	 xmm0, DWORD PTR y2$[rsp]
  00295	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0029d	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR y12$2[rsp], xmm0

; 3598 :       float x23 = (x2+x3)/2;

  002a6	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR x2$[rsp]
  002af	f3 0f 58 84 24
	20 01 00 00	 addss	 xmm0, DWORD PTR x3$[rsp]
  002b8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002c0	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR x23$8[rsp], xmm0

; 3599 :       float y23 = (y2+y3)/2;

  002c9	f3 0f 10 84 24
	18 01 00 00	 movss	 xmm0, DWORD PTR y2$[rsp]
  002d2	f3 0f 58 84 24
	28 01 00 00	 addss	 xmm0, DWORD PTR y3$[rsp]
  002db	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002e3	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR y23$7[rsp], xmm0

; 3600 : 
; 3601 :       float xa = (x01+x12)/2;

  002ec	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x01$6[rsp]
  002f5	f3 0f 58 84 24
	88 00 00 00	 addss	 xmm0, DWORD PTR x12$1[rsp]
  002fe	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00306	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR xa$4[rsp], xmm0

; 3602 :       float ya = (y01+y12)/2;

  0030f	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR y01$5[rsp]
  00318	f3 0f 58 84 24
	8c 00 00 00	 addss	 xmm0, DWORD PTR y12$2[rsp]
  00321	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00329	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR ya$3[rsp], xmm0

; 3603 :       float xb = (x12+x23)/2;

  00332	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR x12$1[rsp]
  0033b	f3 0f 58 84 24
	a4 00 00 00	 addss	 xmm0, DWORD PTR x23$8[rsp]
  00344	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0034c	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR xb$10[rsp], xmm0

; 3604 :       float yb = (y12+y23)/2;

  00355	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR y12$2[rsp]
  0035e	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR y23$7[rsp]
  00367	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0036f	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR yb$9[rsp], xmm0

; 3605 : 
; 3606 :       float mx = (xa+xb)/2;

  00378	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR xa$4[rsp]
  00381	f3 0f 58 84 24
	ac 00 00 00	 addss	 xmm0, DWORD PTR xb$10[rsp]
  0038a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00392	f3 0f 11 84 24
	b4 00 00 00	 movss	 DWORD PTR mx$12[rsp], xmm0

; 3607 :       float my = (ya+yb)/2;

  0039b	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR ya$3[rsp]
  003a4	f3 0f 58 84 24
	a8 00 00 00	 addss	 xmm0, DWORD PTR yb$9[rsp]
  003ad	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  003b5	f3 0f 11 84 24
	b0 00 00 00	 movss	 DWORD PTR my$11[rsp], xmm0

; 3608 : 
; 3609 :       stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);

  003be	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  003c5	ff c0		 inc	 eax
  003c7	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  003cb	f3 0f 10 84 24
	30 01 00 00	 movss	 xmm0, DWORD PTR objspace_flatness_squared$[rsp]
  003d4	f3 0f 11 44 24
	50		 movss	 DWORD PTR [rsp+80], xmm0
  003da	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR my$11[rsp]
  003e3	f3 0f 11 44 24
	48		 movss	 DWORD PTR [rsp+72], xmm0
  003e9	f3 0f 10 84 24
	b4 00 00 00	 movss	 xmm0, DWORD PTR mx$12[rsp]
  003f2	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  003f8	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR ya$3[rsp]
  00401	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00407	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR xa$4[rsp]
  00410	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00416	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR y01$5[rsp]
  0041f	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00425	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x01$6[rsp]
  0042e	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00434	f3 0f 10 9c 24
	f8 00 00 00	 movss	 xmm3, DWORD PTR y0$[rsp]
  0043d	f3 0f 10 94 24
	f0 00 00 00	 movss	 xmm2, DWORD PTR x0$[rsp]
  00446	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR num_points$[rsp]
  0044e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  00456	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3610 :       stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);

  0045b	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00462	ff c0		 inc	 eax
  00464	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00468	f3 0f 10 84 24
	30 01 00 00	 movss	 xmm0, DWORD PTR objspace_flatness_squared$[rsp]
  00471	f3 0f 11 44 24
	50		 movss	 DWORD PTR [rsp+80], xmm0
  00477	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y3$[rsp]
  00480	f3 0f 11 44 24
	48		 movss	 DWORD PTR [rsp+72], xmm0
  00486	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR x3$[rsp]
  0048f	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  00495	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y23$7[rsp]
  0049e	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  004a4	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR x23$8[rsp]
  004ad	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  004b3	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR yb$9[rsp]
  004bc	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  004c2	f3 0f 10 84 24
	ac 00 00 00	 movss	 xmm0, DWORD PTR xb$10[rsp]
  004cb	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  004d1	f3 0f 10 9c 24
	b0 00 00 00	 movss	 xmm3, DWORD PTR my$11[rsp]
  004da	f3 0f 10 94 24
	b4 00 00 00	 movss	 xmm2, DWORD PTR mx$12[rsp]
  004e3	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR num_points$[rsp]
  004eb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  004f3	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3611 :    } else {

  004f8	eb 3f		 jmp	 SHORT $LN4@stbtt__tes
$LN3@stbtt__tes:

; 3612 :       stbtt__add_point(points, *num_points,x3,y3);

  004fa	f3 0f 10 9c 24
	28 01 00 00	 movss	 xmm3, DWORD PTR y3$[rsp]
  00503	f3 0f 10 94 24
	20 01 00 00	 movss	 xmm2, DWORD PTR x3$[rsp]
  0050c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR num_points$[rsp]
  00514	8b 10		 mov	 edx, DWORD PTR [rax]
  00516	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR points$[rsp]
  0051e	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point

; 3613 :       *num_points = *num_points+1;

  00523	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR num_points$[rsp]
  0052b	8b 00		 mov	 eax, DWORD PTR [rax]
  0052d	ff c0		 inc	 eax
  0052f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR num_points$[rsp]
  00537	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbtt__tes:
$LN1@stbtt__tes:

; 3614 :    }
; 3615 : }

  00539	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00540	c3		 ret	 0
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ENDP ; stbtt__tesselate_cubic
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
my$ = 80
mx$ = 84
dx$ = 88
dy$ = 92
points$ = 112
num_points$ = 120
x0$ = 128
y0$ = 136
x1$ = 144
y1$ = 152
x2$ = 160
y2$ = 168
objspace_flatness_squared$ = 176
n$ = 184
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z PROC ; stbtt__tesselate_curve

; 3556 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3557 :    // midpoint
; 3558 :    float mx = (x0 + 2*x1 + x2)/4;

  0001a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00022	f3 0f 59 84 24
	90 00 00 00	 mulss	 xmm0, DWORD PTR x1$[rsp]
  0002b	f3 0f 10 8c 24
	80 00 00 00	 movss	 xmm1, DWORD PTR x0$[rsp]
  00034	f3 0f 58 c8	 addss	 xmm1, xmm0
  00038	0f 28 c1	 movaps	 xmm0, xmm1
  0003b	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR x2$[rsp]
  00044	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  0004c	f3 0f 11 44 24
	54		 movss	 DWORD PTR mx$[rsp], xmm0

; 3559 :    float my = (y0 + 2*y1 + y2)/4;

  00052	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0005a	f3 0f 59 84 24
	98 00 00 00	 mulss	 xmm0, DWORD PTR y1$[rsp]
  00063	f3 0f 10 8c 24
	88 00 00 00	 movss	 xmm1, DWORD PTR y0$[rsp]
  0006c	f3 0f 58 c8	 addss	 xmm1, xmm0
  00070	0f 28 c1	 movaps	 xmm0, xmm1
  00073	f3 0f 58 84 24
	a8 00 00 00	 addss	 xmm0, DWORD PTR y2$[rsp]
  0007c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00084	f3 0f 11 44 24
	50		 movss	 DWORD PTR my$[rsp], xmm0

; 3560 :    // versus directly drawn line
; 3561 :    float dx = (x0+x2)/2 - mx;

  0008a	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR x0$[rsp]
  00093	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR x2$[rsp]
  0009c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000a4	f3 0f 5c 44 24
	54		 subss	 xmm0, DWORD PTR mx$[rsp]
  000aa	f3 0f 11 44 24
	58		 movss	 DWORD PTR dx$[rsp], xmm0

; 3562 :    float dy = (y0+y2)/2 - my;

  000b0	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$[rsp]
  000b9	f3 0f 58 84 24
	a8 00 00 00	 addss	 xmm0, DWORD PTR y2$[rsp]
  000c2	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000ca	f3 0f 5c 44 24
	50		 subss	 xmm0, DWORD PTR my$[rsp]
  000d0	f3 0f 11 44 24
	5c		 movss	 DWORD PTR dy$[rsp], xmm0

; 3563 :    if (n > 16) // 65536 segments on one curve better be enough!

  000d6	83 bc 24 b8 00
	00 00 10	 cmp	 DWORD PTR n$[rsp], 16
  000de	7e 0a		 jle	 SHORT $LN2@stbtt__tes

; 3564 :       return 1;

  000e0	b8 01 00 00 00	 mov	 eax, 1
  000e5	e9 8e 01 00 00	 jmp	 $LN1@stbtt__tes
$LN2@stbtt__tes:

; 3565 :    if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA

  000ea	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR dx$[rsp]
  000f0	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR dx$[rsp]
  000f6	f3 0f 10 4c 24
	5c		 movss	 xmm1, DWORD PTR dy$[rsp]
  000fc	f3 0f 59 4c 24
	5c		 mulss	 xmm1, DWORD PTR dy$[rsp]
  00102	f3 0f 58 c1	 addss	 xmm0, xmm1
  00106	0f 2f 84 24 b0
	00 00 00	 comiss	 xmm0, DWORD PTR objspace_flatness_squared$[rsp]
  0010e	0f 86 2c 01 00
	00		 jbe	 $LN3@stbtt__tes

; 3566 :       stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);

  00114	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  0011b	ff c0		 inc	 eax
  0011d	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$[rsp]
  00126	f3 0f 58 84 24
	98 00 00 00	 addss	 xmm0, DWORD PTR y1$[rsp]
  0012f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00137	f3 0f 10 8c 24
	80 00 00 00	 movss	 xmm1, DWORD PTR x0$[rsp]
  00140	f3 0f 58 8c 24
	90 00 00 00	 addss	 xmm1, DWORD PTR x1$[rsp]
  00149	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00151	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00155	f3 0f 10 94 24
	b0 00 00 00	 movss	 xmm2, DWORD PTR objspace_flatness_squared$[rsp]
  0015e	f3 0f 11 54 24
	40		 movss	 DWORD PTR [rsp+64], xmm2
  00164	f3 0f 10 54 24
	50		 movss	 xmm2, DWORD PTR my$[rsp]
  0016a	f3 0f 11 54 24
	38		 movss	 DWORD PTR [rsp+56], xmm2
  00170	f3 0f 10 54 24
	54		 movss	 xmm2, DWORD PTR mx$[rsp]
  00176	f3 0f 11 54 24
	30		 movss	 DWORD PTR [rsp+48], xmm2
  0017c	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00182	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  00188	f3 0f 10 9c 24
	88 00 00 00	 movss	 xmm3, DWORD PTR y0$[rsp]
  00191	f3 0f 10 94 24
	80 00 00 00	 movss	 xmm2, DWORD PTR x0$[rsp]
  0019a	48 8b 54 24 78	 mov	 rdx, QWORD PTR num_points$[rsp]
  0019f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR points$[rsp]
  001a4	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3567 :       stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);

  001a9	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  001b0	ff c0		 inc	 eax
  001b2	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR y1$[rsp]
  001bb	f3 0f 58 84 24
	a8 00 00 00	 addss	 xmm0, DWORD PTR y2$[rsp]
  001c4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  001cc	f3 0f 10 8c 24
	90 00 00 00	 movss	 xmm1, DWORD PTR x1$[rsp]
  001d5	f3 0f 58 8c 24
	a0 00 00 00	 addss	 xmm1, DWORD PTR x2$[rsp]
  001de	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  001e6	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  001ea	f3 0f 10 94 24
	b0 00 00 00	 movss	 xmm2, DWORD PTR objspace_flatness_squared$[rsp]
  001f3	f3 0f 11 54 24
	40		 movss	 DWORD PTR [rsp+64], xmm2
  001f9	f3 0f 10 94 24
	a8 00 00 00	 movss	 xmm2, DWORD PTR y2$[rsp]
  00202	f3 0f 11 54 24
	38		 movss	 DWORD PTR [rsp+56], xmm2
  00208	f3 0f 10 94 24
	a0 00 00 00	 movss	 xmm2, DWORD PTR x2$[rsp]
  00211	f3 0f 11 54 24
	30		 movss	 DWORD PTR [rsp+48], xmm2
  00217	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0021d	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  00223	f3 0f 10 5c 24
	50		 movss	 xmm3, DWORD PTR my$[rsp]
  00229	f3 0f 10 54 24
	54		 movss	 xmm2, DWORD PTR mx$[rsp]
  0022f	48 8b 54 24 78	 mov	 rdx, QWORD PTR num_points$[rsp]
  00234	48 8b 4c 24 70	 mov	 rcx, QWORD PTR points$[rsp]
  00239	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3568 :    } else {

  0023e	eb 33		 jmp	 SHORT $LN4@stbtt__tes
$LN3@stbtt__tes:

; 3569 :       stbtt__add_point(points, *num_points,x2,y2);

  00240	f3 0f 10 9c 24
	a8 00 00 00	 movss	 xmm3, DWORD PTR y2$[rsp]
  00249	f3 0f 10 94 24
	a0 00 00 00	 movss	 xmm2, DWORD PTR x2$[rsp]
  00252	48 8b 44 24 78	 mov	 rax, QWORD PTR num_points$[rsp]
  00257	8b 10		 mov	 edx, DWORD PTR [rax]
  00259	48 8b 4c 24 70	 mov	 rcx, QWORD PTR points$[rsp]
  0025e	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ; stbtt__add_point

; 3570 :       *num_points = *num_points+1;

  00263	48 8b 44 24 78	 mov	 rax, QWORD PTR num_points$[rsp]
  00268	8b 00		 mov	 eax, DWORD PTR [rax]
  0026a	ff c0		 inc	 eax
  0026c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR num_points$[rsp]
  00271	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbtt__tes:

; 3571 :    }
; 3572 :    return 1;

  00273	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt__tes:

; 3573 : }

  00278	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0027c	c3		 ret	 0
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ENDP ; stbtt__tesselate_curve
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
points$ = 8
n$ = 16
x$ = 24
y$ = 32
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z PROC	; stbtt__add_point

; 3548 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3549 :    if (!points) return; // during first pass, it's unallocated

  00015	48 83 7c 24 08
	00		 cmp	 QWORD PTR points$[rsp], 0
  0001b	75 02		 jne	 SHORT $LN2@stbtt__add
  0001d	eb 2b		 jmp	 SHORT $LN1@stbtt__add
$LN2@stbtt__add:

; 3550 :    points[n].x = x;

  0001f	48 63 44 24 10	 movsxd	 rax, DWORD PTR n$[rsp]
  00024	48 8b 4c 24 08	 mov	 rcx, QWORD PTR points$[rsp]
  00029	f3 0f 10 44 24
	18		 movss	 xmm0, DWORD PTR x$[rsp]
  0002f	f3 0f 11 04 c1	 movss	 DWORD PTR [rcx+rax*8], xmm0

; 3551 :    points[n].y = y;

  00034	48 63 44 24 10	 movsxd	 rax, DWORD PTR n$[rsp]
  00039	48 8b 4c 24 08	 mov	 rcx, QWORD PTR points$[rsp]
  0003e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR y$[rsp]
  00044	f3 0f 11 44 c1
	04		 movss	 DWORD PTR [rcx+rax*8+4], xmm0
$LN1@stbtt__add:

; 3552 : }

  0004a	c3		 ret	 0
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ENDP	; stbtt__add_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
n$ = 64
i$ = 68
k$ = 72
j$ = 76
p$1 = 80
e$ = 88
m$ = 96
a$2 = 100
b$3 = 104
vsubsample$ = 108
tv66 = 112
tv164 = 116
tv163 = 120
tv166 = 124
y_scale_inv$ = 128
result$ = 160
pts$ = 168
wcount$ = 176
windings$ = 184
scale_x$ = 192
scale_y$ = 200
shift_x$ = 208
shift_y$ = 216
off_x$ = 224
off_y$ = 232
invert$ = 240
userdata$ = 248
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z PROC ; stbtt__rasterize

; 3491 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3492 :    float y_scale_inv = invert ? -scale_y : scale_y;

  0001b	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR invert$[rsp], 0
  00023	74 18		 je	 SHORT $LN15@stbtt__ras
  00025	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0002e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00035	f3 0f 11 44 24
	70		 movss	 DWORD PTR tv66[rsp], xmm0
  0003b	eb 0f		 jmp	 SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:
  0003d	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00046	f3 0f 11 44 24
	70		 movss	 DWORD PTR tv66[rsp], xmm0
$LN16@stbtt__ras:
  0004c	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR tv66[rsp]
  00052	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR y_scale_inv$[rsp], xmm0

; 3493 :    stbtt__edge *e;
; 3494 :    int n,i,j,k,m;
; 3495 : #if STBTT_RASTERIZER_VERSION == 1
; 3496 :    int vsubsample = result->h < 8 ? 15 : 5;
; 3497 : #elif STBTT_RASTERIZER_VERSION == 2
; 3498 :    int vsubsample = 1;

  0005b	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR vsubsample$[rsp], 1

; 3499 : #else
; 3500 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 3501 : #endif
; 3502 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 3503 : 
; 3504 :    // now we have to blow out the windings into explicit edge lists
; 3505 :    n = 0;

  00063	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 3506 :    for (i=0; i < windings; ++i)

  0006b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00073	eb 0a		 jmp	 SHORT $LN4@stbtt__ras
$LN2@stbtt__ras:
  00075	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00079	ff c0		 inc	 eax
  0007b	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__ras:
  0007f	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR windings$[rsp]
  00086	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  0008a	7d 1e		 jge	 SHORT $LN3@stbtt__ras

; 3507 :       n += wcount[i];

  0008c	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00091	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR wcount$[rsp]
  00099	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0009c	8b 4c 24 40	 mov	 ecx, DWORD PTR n$[rsp]
  000a0	03 c8		 add	 ecx, eax
  000a2	8b c1		 mov	 eax, ecx
  000a4	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax
  000a8	eb cb		 jmp	 SHORT $LN2@stbtt__ras
$LN3@stbtt__ras:

; 3508 : 
; 3509 :    e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel

  000aa	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  000ae	ff c0		 inc	 eax
  000b0	48 98		 cdqe
  000b2	48 6b c0 14	 imul	 rax, rax, 20
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 malloc
  000be	48 89 44 24 58	 mov	 QWORD PTR e$[rsp], rax

; 3510 :    if (e == 0) return;

  000c3	48 83 7c 24 58
	00		 cmp	 QWORD PTR e$[rsp], 0
  000c9	75 05		 jne	 SHORT $LN11@stbtt__ras
  000cb	e9 04 03 00 00	 jmp	 $LN1@stbtt__ras
$LN11@stbtt__ras:

; 3511 :    n = 0;

  000d0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 3512 : 
; 3513 :    m=0;

  000d8	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR m$[rsp], 0

; 3514 :    for (i=0; i < windings; ++i) {

  000e0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e8	eb 0a		 jmp	 SHORT $LN7@stbtt__ras
$LN5@stbtt__ras:
  000ea	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  000ee	ff c0		 inc	 eax
  000f0	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbtt__ras:
  000f4	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR windings$[rsp]
  000fb	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  000ff	0f 8d 78 02 00
	00		 jge	 $LN6@stbtt__ras

; 3515 :       stbtt__point *p = pts + m;

  00105	48 63 44 24 60	 movsxd	 rax, DWORD PTR m$[rsp]
  0010a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pts$[rsp]
  00112	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00116	48 89 44 24 50	 mov	 QWORD PTR p$1[rsp], rax

; 3516 :       m += wcount[i];

  0011b	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00120	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR wcount$[rsp]
  00128	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0012b	8b 4c 24 60	 mov	 ecx, DWORD PTR m$[rsp]
  0012f	03 c8		 add	 ecx, eax
  00131	8b c1		 mov	 eax, ecx
  00133	89 44 24 60	 mov	 DWORD PTR m$[rsp], eax

; 3517 :       j = wcount[i]-1;

  00137	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  0013c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR wcount$[rsp]
  00144	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00147	ff c8		 dec	 eax
  00149	89 44 24 4c	 mov	 DWORD PTR j$[rsp], eax

; 3518 :       for (k=0; k < wcount[i]; j=k++) {

  0014d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00155	eb 12		 jmp	 SHORT $LN10@stbtt__ras
$LN8@stbtt__ras:
  00157	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  0015b	89 44 24 4c	 mov	 DWORD PTR j$[rsp], eax
  0015f	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00163	ff c0		 inc	 eax
  00165	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax
$LN10@stbtt__ras:
  00169	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  0016e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR wcount$[rsp]
  00176	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00179	39 44 24 48	 cmp	 DWORD PTR k$[rsp], eax
  0017d	0f 8d f5 01 00
	00		 jge	 $LN9@stbtt__ras

; 3519 :          int a=k,b=j;

  00183	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00187	89 44 24 64	 mov	 DWORD PTR a$2[rsp], eax
  0018b	8b 44 24 4c	 mov	 eax, DWORD PTR j$[rsp]
  0018f	89 44 24 68	 mov	 DWORD PTR b$3[rsp], eax

; 3520 :          // skip the edge if horizontal
; 3521 :          if (p[j].y == p[k].y)

  00193	48 63 44 24 4c	 movsxd	 rax, DWORD PTR j$[rsp]
  00198	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR k$[rsp]
  0019d	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$1[rsp]
  001a2	4c 8b 44 24 50	 mov	 r8, QWORD PTR p$1[rsp]
  001a7	f3 0f 10 44 c2
	04		 movss	 xmm0, DWORD PTR [rdx+rax*8+4]
  001ad	41 0f 2e 44 c8
	04		 ucomiss xmm0, DWORD PTR [r8+rcx*8+4]
  001b3	7a 04		 jp	 SHORT $LN12@stbtt__ras
  001b5	75 02		 jne	 SHORT $LN12@stbtt__ras

; 3522 :             continue;

  001b7	eb 9e		 jmp	 SHORT $LN8@stbtt__ras
$LN12@stbtt__ras:

; 3523 :          // add edge from j to k to the list
; 3524 :          e[n].invert = 0;

  001b9	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  001be	48 6b c0 14	 imul	 rax, rax, 20
  001c2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  001c7	c7 44 01 10 00
	00 00 00	 mov	 DWORD PTR [rcx+rax+16], 0

; 3525 :          if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {

  001cf	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR invert$[rsp], 0
  001d7	74 3e		 je	 SHORT $LN21@stbtt__ras
  001d9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR j$[rsp]
  001de	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR k$[rsp]
  001e3	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$1[rsp]
  001e8	4c 8b 44 24 50	 mov	 r8, QWORD PTR p$1[rsp]
  001ed	f3 0f 10 44 c2
	04		 movss	 xmm0, DWORD PTR [rdx+rax*8+4]
  001f3	41 0f 2f 44 c8
	04		 comiss	 xmm0, DWORD PTR [r8+rcx*8+4]
  001f9	76 0a		 jbe	 SHORT $LN19@stbtt__ras
  001fb	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  00203	eb 08		 jmp	 SHORT $LN20@stbtt__ras
$LN19@stbtt__ras:
  00205	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN20@stbtt__ras:
  0020d	8b 44 24 74	 mov	 eax, DWORD PTR tv164[rsp]
  00211	89 44 24 7c	 mov	 DWORD PTR tv166[rsp], eax
  00215	eb 3c		 jmp	 SHORT $LN22@stbtt__ras
$LN21@stbtt__ras:
  00217	48 63 44 24 4c	 movsxd	 rax, DWORD PTR j$[rsp]
  0021c	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR k$[rsp]
  00221	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$1[rsp]
  00226	4c 8b 44 24 50	 mov	 r8, QWORD PTR p$1[rsp]
  0022b	f3 0f 10 44 ca
	04		 movss	 xmm0, DWORD PTR [rdx+rcx*8+4]
  00231	41 0f 2f 44 c0
	04		 comiss	 xmm0, DWORD PTR [r8+rax*8+4]
  00237	76 0a		 jbe	 SHORT $LN17@stbtt__ras
  00239	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00241	eb 08		 jmp	 SHORT $LN18@stbtt__ras
$LN17@stbtt__ras:
  00243	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN18@stbtt__ras:
  0024b	8b 44 24 78	 mov	 eax, DWORD PTR tv163[rsp]
  0024f	89 44 24 7c	 mov	 DWORD PTR tv166[rsp], eax
$LN22@stbtt__ras:
  00253	83 7c 24 7c 00	 cmp	 DWORD PTR tv166[rsp], 0
  00258	74 26		 je	 SHORT $LN13@stbtt__ras

; 3526 :             e[n].invert = 1;

  0025a	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0025f	48 6b c0 14	 imul	 rax, rax, 20
  00263	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  00268	c7 44 01 10 01
	00 00 00	 mov	 DWORD PTR [rcx+rax+16], 1

; 3527 :             a=j,b=k;

  00270	8b 44 24 4c	 mov	 eax, DWORD PTR j$[rsp]
  00274	89 44 24 64	 mov	 DWORD PTR a$2[rsp], eax
  00278	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  0027c	89 44 24 68	 mov	 DWORD PTR b$3[rsp], eax
$LN13@stbtt__ras:

; 3528 :          }
; 3529 :          e[n].x0 = p[a].x * scale_x + shift_x;

  00280	48 63 44 24 64	 movsxd	 rax, DWORD PTR a$2[rsp]
  00285	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$1[rsp]
  0028a	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  0028f	f3 0f 59 84 24
	c0 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  00298	f3 0f 58 84 24
	d0 00 00 00	 addss	 xmm0, DWORD PTR shift_x$[rsp]
  002a1	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  002a6	48 6b c0 14	 imul	 rax, rax, 20
  002aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  002af	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 3530 :          e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;

  002b4	48 63 44 24 64	 movsxd	 rax, DWORD PTR a$2[rsp]
  002b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$1[rsp]
  002be	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [rcx+rax*8+4]
  002c4	f3 0f 59 84 24
	80 00 00 00	 mulss	 xmm0, DWORD PTR y_scale_inv$[rsp]
  002cd	f3 0f 58 84 24
	d8 00 00 00	 addss	 xmm0, DWORD PTR shift_y$[rsp]
  002d6	f3 0f 2a 4c 24
	6c		 cvtsi2ss xmm1, DWORD PTR vsubsample$[rsp]
  002dc	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002e0	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  002e5	48 6b c0 14	 imul	 rax, rax, 20
  002e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  002ee	f3 0f 11 44 01
	04		 movss	 DWORD PTR [rcx+rax+4], xmm0

; 3531 :          e[n].x1 = p[b].x * scale_x + shift_x;

  002f4	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$3[rsp]
  002f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$1[rsp]
  002fe	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [rcx+rax*8]
  00303	f3 0f 59 84 24
	c0 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  0030c	f3 0f 58 84 24
	d0 00 00 00	 addss	 xmm0, DWORD PTR shift_x$[rsp]
  00315	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0031a	48 6b c0 14	 imul	 rax, rax, 20
  0031e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  00323	f3 0f 11 44 01
	08		 movss	 DWORD PTR [rcx+rax+8], xmm0

; 3532 :          e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;

  00329	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$3[rsp]
  0032e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$1[rsp]
  00333	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [rcx+rax*8+4]
  00339	f3 0f 59 84 24
	80 00 00 00	 mulss	 xmm0, DWORD PTR y_scale_inv$[rsp]
  00342	f3 0f 58 84 24
	d8 00 00 00	 addss	 xmm0, DWORD PTR shift_y$[rsp]
  0034b	f3 0f 2a 4c 24
	6c		 cvtsi2ss xmm1, DWORD PTR vsubsample$[rsp]
  00351	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00355	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$[rsp]
  0035a	48 6b c0 14	 imul	 rax, rax, 20
  0035e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  00363	f3 0f 11 44 01
	0c		 movss	 DWORD PTR [rcx+rax+12], xmm0

; 3533 :          ++n;

  00369	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  0036d	ff c0		 inc	 eax
  0036f	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 3534 :       }

  00373	e9 df fd ff ff	 jmp	 $LN8@stbtt__ras
$LN9@stbtt__ras:

; 3535 :    }

  00378	e9 6d fd ff ff	 jmp	 $LN5@stbtt__ras
$LN6@stbtt__ras:

; 3536 : 
; 3537 :    // now sort the edges by their highest point (should snap to integer, and then by x)
; 3538 :    //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
; 3539 :    stbtt__sort_edges(e, n);

  0037d	8b 54 24 40	 mov	 edx, DWORD PTR n$[rsp]
  00381	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  00386	e8 00 00 00 00	 call	 ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges

; 3540 : 
; 3541 :    // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
; 3542 :    stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

  0038b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR userdata$[rsp]
  00393	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00398	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR off_y$[rsp]
  0039f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003a3	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR off_x$[rsp]
  003aa	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003ae	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR vsubsample$[rsp]
  003b3	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$[rsp]
  003b8	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$[rsp]
  003bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  003c5	e8 00 00 00 00	 call	 ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ; stbtt__rasterize_sorted_edges

; 3543 : 
; 3544 :    STBTT_free(e, userdata);

  003ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  003cf	e8 00 00 00 00	 call	 free
$LN1@stbtt__ras:

; 3545 : }

  003d4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003db	c3		 ret	 0
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ENDP ; stbtt__rasterize
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
p$ = 48
n$ = 56
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z PROC	; stbtt__sort_edges

; 3480 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3481 :    stbtt__sort_edges_quicksort(p, n);

  0000d	8b 54 24 38	 mov	 edx, DWORD PTR n$[rsp]
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00016	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3482 :    stbtt__sort_edges_ins_sort(p, n);

  0001b	8b 54 24 38	 mov	 edx, DWORD PTR n$[rsp]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_ins_sort

; 3483 : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z ENDP	; stbtt__sort_edges
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
m$3 = 40
tv74 = 44
tv85 = 48
tv128 = 52
c12$4 = 56
tv131 = 60
z$5 = 64
c01$6 = 68
c$7 = 72
tv235 = 80
tv252 = 88
tv279 = 96
t$8 = 104
__$ArrayPad$ = 128
p$ = 176
n$ = 184
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_quicksort

; 3418 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN2@stbtt__sor:

; 3419 :    /* threshold for transitioning to insertion sort */
; 3420 :    while (n > 12) {

  00024	83 bc 24 b8 00
	00 00 0c	 cmp	 DWORD PTR n$[rsp], 12
  0002c	0f 8e 0e 04 00
	00		 jle	 $LN3@stbtt__sor

; 3421 :       stbtt__edge t;
; 3422 :       int c01,c12,c,m,i,j;
; 3423 : 
; 3424 :       /* compute median of three */
; 3425 :       m = n >> 1;

  00032	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00039	d1 f8		 sar	 eax, 1
  0003b	89 44 24 28	 mov	 DWORD PTR m$3[rsp], eax

; 3426 :       c01 = STBTT__COMPARE(&p[0],&p[m]);

  0003f	b8 14 00 00 00	 mov	 eax, 20
  00044	48 6b c0 00	 imul	 rax, rax, 0
  00048	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR m$3[rsp]
  0004d	48 6b c9 14	 imul	 rcx, rcx, 20
  00051	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00059	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR p$[rsp]
  00061	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [rdx+rcx+4]
  00067	41 0f 2f 44 00
	04		 comiss	 xmm0, DWORD PTR [r8+rax+4]
  0006d	76 0a		 jbe	 SHORT $LN20@stbtt__sor
  0006f	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00077	eb 08		 jmp	 SHORT $LN21@stbtt__sor
$LN20@stbtt__sor:
  00079	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN21@stbtt__sor:
  00081	8b 44 24 2c	 mov	 eax, DWORD PTR tv74[rsp]
  00085	89 44 24 44	 mov	 DWORD PTR c01$6[rsp], eax

; 3427 :       c12 = STBTT__COMPARE(&p[m],&p[n-1]);

  00089	48 63 44 24 28	 movsxd	 rax, DWORD PTR m$3[rsp]
  0008e	48 6b c0 14	 imul	 rax, rax, 20
  00092	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  00099	ff c9		 dec	 ecx
  0009b	48 63 c9	 movsxd	 rcx, ecx
  0009e	48 6b c9 14	 imul	 rcx, rcx, 20
  000a2	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000aa	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR p$[rsp]
  000b2	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [rdx+rcx+4]
  000b8	41 0f 2f 44 00
	04		 comiss	 xmm0, DWORD PTR [r8+rax+4]
  000be	76 0a		 jbe	 SHORT $LN22@stbtt__sor
  000c0	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN23@stbtt__sor
$LN22@stbtt__sor:
  000ca	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN23@stbtt__sor:
  000d2	8b 44 24 30	 mov	 eax, DWORD PTR tv85[rsp]
  000d6	89 44 24 38	 mov	 DWORD PTR c12$4[rsp], eax

; 3428 :       /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
; 3429 :       if (c01 != c12) {

  000da	8b 44 24 38	 mov	 eax, DWORD PTR c12$4[rsp]
  000de	39 44 24 44	 cmp	 DWORD PTR c01$6[rsp], eax
  000e2	0f 84 fd 00 00
	00		 je	 $LN13@stbtt__sor

; 3430 :          /* otherwise, we'll need to swap something else to middle */
; 3431 :          int z;
; 3432 :          c = STBTT__COMPARE(&p[0],&p[n-1]);

  000e8	b8 14 00 00 00	 mov	 eax, 20
  000ed	48 6b c0 00	 imul	 rax, rax, 0
  000f1	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  000f8	ff c9		 dec	 ecx
  000fa	48 63 c9	 movsxd	 rcx, ecx
  000fd	48 6b c9 14	 imul	 rcx, rcx, 20
  00101	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00109	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR p$[rsp]
  00111	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [rdx+rcx+4]
  00117	41 0f 2f 44 00
	04		 comiss	 xmm0, DWORD PTR [r8+rax+4]
  0011d	76 0a		 jbe	 SHORT $LN24@stbtt__sor
  0011f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00127	eb 08		 jmp	 SHORT $LN25@stbtt__sor
$LN24@stbtt__sor:
  00129	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN25@stbtt__sor:
  00131	8b 44 24 34	 mov	 eax, DWORD PTR tv128[rsp]
  00135	89 44 24 48	 mov	 DWORD PTR c$7[rsp], eax

; 3433 :          /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
; 3434 :          /* 0<mid && mid>n:  0>n => 0; 0<n => n */
; 3435 :          z = (c == c12) ? 0 : n-1;

  00139	8b 44 24 38	 mov	 eax, DWORD PTR c12$4[rsp]
  0013d	39 44 24 48	 cmp	 DWORD PTR c$7[rsp], eax
  00141	75 0a		 jne	 SHORT $LN26@stbtt__sor
  00143	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
  0014b	eb 0d		 jmp	 SHORT $LN27@stbtt__sor
$LN26@stbtt__sor:
  0014d	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00154	ff c8		 dec	 eax
  00156	89 44 24 3c	 mov	 DWORD PTR tv131[rsp], eax
$LN27@stbtt__sor:
  0015a	8b 44 24 3c	 mov	 eax, DWORD PTR tv131[rsp]
  0015e	89 44 24 40	 mov	 DWORD PTR z$5[rsp], eax

; 3436 :          t = p[z];

  00162	48 63 44 24 40	 movsxd	 rax, DWORD PTR z$5[rsp]
  00167	48 6b c0 14	 imul	 rax, rax, 20
  0016b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR t$8[rsp]
  00170	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00178	48 8b f9	 mov	 rdi, rcx
  0017b	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0017f	b9 14 00 00 00	 mov	 ecx, 20
  00184	f3 a4		 rep movsb

; 3437 :          p[z] = p[m];

  00186	48 63 44 24 28	 movsxd	 rax, DWORD PTR m$3[rsp]
  0018b	48 6b c0 14	 imul	 rax, rax, 20
  0018f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR z$5[rsp]
  00194	48 6b c9 14	 imul	 rcx, rcx, 20
  00198	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  001a0	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR p$[rsp]
  001a8	48 89 7c 24 50	 mov	 QWORD PTR tv235[rsp], rdi
  001ad	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  001b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv235[rsp]
  001b6	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  001ba	b9 14 00 00 00	 mov	 ecx, 20
  001bf	f3 a4		 rep movsb

; 3438 :          p[m] = t;

  001c1	48 63 44 24 28	 movsxd	 rax, DWORD PTR m$3[rsp]
  001c6	48 6b c0 14	 imul	 rax, rax, 20
  001ca	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  001d2	48 8d 54 24 68	 lea	 rdx, QWORD PTR t$8[rsp]
  001d7	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  001db	48 8b f2	 mov	 rsi, rdx
  001de	b9 14 00 00 00	 mov	 ecx, 20
  001e3	f3 a4		 rep movsb
$LN13@stbtt__sor:

; 3439 :       }
; 3440 :       /* now p[m] is the median-of-three */
; 3441 :       /* swap it to the beginning so it won't move around */
; 3442 :       t = p[0];

  001e5	b8 14 00 00 00	 mov	 eax, 20
  001ea	48 6b c0 00	 imul	 rax, rax, 0
  001ee	48 8d 4c 24 68	 lea	 rcx, QWORD PTR t$8[rsp]
  001f3	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  001fb	48 8b f9	 mov	 rdi, rcx
  001fe	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00202	b9 14 00 00 00	 mov	 ecx, 20
  00207	f3 a4		 rep movsb

; 3443 :       p[0] = p[m];

  00209	48 63 44 24 28	 movsxd	 rax, DWORD PTR m$3[rsp]
  0020e	48 6b c0 14	 imul	 rax, rax, 20
  00212	b9 14 00 00 00	 mov	 ecx, 20
  00217	48 6b c9 00	 imul	 rcx, rcx, 0
  0021b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00223	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR p$[rsp]
  0022b	48 89 7c 24 58	 mov	 QWORD PTR tv252[rsp], rdi
  00230	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00234	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv252[rsp]
  00239	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0023d	b9 14 00 00 00	 mov	 ecx, 20
  00242	f3 a4		 rep movsb

; 3444 :       p[m] = t;

  00244	48 63 44 24 28	 movsxd	 rax, DWORD PTR m$3[rsp]
  00249	48 6b c0 14	 imul	 rax, rax, 20
  0024d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00255	48 8d 54 24 68	 lea	 rdx, QWORD PTR t$8[rsp]
  0025a	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  0025e	48 8b f2	 mov	 rsi, rdx
  00261	b9 14 00 00 00	 mov	 ecx, 20
  00266	f3 a4		 rep movsb

; 3445 : 
; 3446 :       /* partition loop */
; 3447 :       i=1;

  00268	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1

; 3448 :       j=n-1;

  00270	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00277	ff c8		 dec	 eax
  00279	89 44 24 24	 mov	 DWORD PTR j$2[rsp], eax
$LN4@stbtt__sor:

; 3449 :       for(;;) {
; 3450 :          /* handling of equality is crucial here */
; 3451 :          /* for sentinels & efficiency with duplicates */
; 3452 :          for (;;++i) {

  0027d	eb 0a		 jmp	 SHORT $LN9@stbtt__sor
$LN7@stbtt__sor:
  0027f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00283	ff c0		 inc	 eax
  00285	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN9@stbtt__sor:

; 3453 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

  00289	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0028e	48 6b c0 14	 imul	 rax, rax, 20
  00292	b9 14 00 00 00	 mov	 ecx, 20
  00297	48 6b c9 00	 imul	 rcx, rcx, 0
  0029b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  002a3	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR p$[rsp]
  002ab	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [rdx+rcx+4]
  002b1	0f 2f 44 07 04	 comiss	 xmm0, DWORD PTR [rdi+rax+4]
  002b6	77 02		 ja	 SHORT $LN14@stbtt__sor
  002b8	eb 02		 jmp	 SHORT $LN8@stbtt__sor
$LN14@stbtt__sor:

; 3454 :          }

  002ba	eb c3		 jmp	 SHORT $LN7@stbtt__sor
$LN8@stbtt__sor:

; 3455 :          for (;;--j) {

  002bc	eb 0a		 jmp	 SHORT $LN12@stbtt__sor
$LN10@stbtt__sor:
  002be	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  002c2	ff c8		 dec	 eax
  002c4	89 44 24 24	 mov	 DWORD PTR j$2[rsp], eax
$LN12@stbtt__sor:

; 3456 :             if (!STBTT__COMPARE(&p[0], &p[j])) break;

  002c8	b8 14 00 00 00	 mov	 eax, 20
  002cd	48 6b c0 00	 imul	 rax, rax, 0
  002d1	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$2[rsp]
  002d6	48 6b c9 14	 imul	 rcx, rcx, 20
  002da	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  002e2	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR p$[rsp]
  002ea	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [rdx+rcx+4]
  002f0	0f 2f 44 07 04	 comiss	 xmm0, DWORD PTR [rdi+rax+4]
  002f5	77 02		 ja	 SHORT $LN15@stbtt__sor
  002f7	eb 02		 jmp	 SHORT $LN11@stbtt__sor
$LN15@stbtt__sor:

; 3457 :          }

  002f9	eb c3		 jmp	 SHORT $LN10@stbtt__sor
$LN11@stbtt__sor:

; 3458 :          /* make sure we haven't crossed */
; 3459 :          if (i >= j) break;

  002fb	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  002ff	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00303	7c 05		 jl	 SHORT $LN16@stbtt__sor
  00305	e9 9c 00 00 00	 jmp	 $LN5@stbtt__sor
$LN16@stbtt__sor:

; 3460 :          t = p[i];

  0030a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  0030f	48 6b c0 14	 imul	 rax, rax, 20
  00313	48 8d 4c 24 68	 lea	 rcx, QWORD PTR t$8[rsp]
  00318	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00320	48 8b f9	 mov	 rdi, rcx
  00323	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00327	b9 14 00 00 00	 mov	 ecx, 20
  0032c	f3 a4		 rep movsb

; 3461 :          p[i] = p[j];

  0032e	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$2[rsp]
  00333	48 6b c0 14	 imul	 rax, rax, 20
  00337	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0033c	48 6b c9 14	 imul	 rcx, rcx, 20
  00340	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00348	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR p$[rsp]
  00350	48 89 7c 24 60	 mov	 QWORD PTR tv279[rsp], rdi
  00355	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00359	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv279[rsp]
  0035e	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00362	b9 14 00 00 00	 mov	 ecx, 20
  00367	f3 a4		 rep movsb

; 3462 :          p[j] = t;

  00369	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$2[rsp]
  0036e	48 6b c0 14	 imul	 rax, rax, 20
  00372	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  0037a	48 8d 54 24 68	 lea	 rdx, QWORD PTR t$8[rsp]
  0037f	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00383	48 8b f2	 mov	 rsi, rdx
  00386	b9 14 00 00 00	 mov	 ecx, 20
  0038b	f3 a4		 rep movsb

; 3463 : 
; 3464 :          ++i;

  0038d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00391	ff c0		 inc	 eax
  00393	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax

; 3465 :          --j;

  00397	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  0039b	ff c8		 dec	 eax
  0039d	89 44 24 24	 mov	 DWORD PTR j$2[rsp], eax

; 3466 :       }

  003a1	e9 d7 fe ff ff	 jmp	 $LN4@stbtt__sor
$LN5@stbtt__sor:

; 3467 :       /* recurse on smaller side, iterate on larger */
; 3468 :       if (j < (n-i)) {

  003a6	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  003aa	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  003b1	2b c8		 sub	 ecx, eax
  003b3	8b c1		 mov	 eax, ecx
  003b5	39 44 24 24	 cmp	 DWORD PTR j$2[rsp], eax
  003b9	7d 48		 jge	 SHORT $LN17@stbtt__sor

; 3469 :          stbtt__sort_edges_quicksort(p,j);

  003bb	8b 54 24 24	 mov	 edx, DWORD PTR j$2[rsp]
  003bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  003c7	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3470 :          p = p+i;

  003cc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$1[rsp]
  003d1	48 6b c0 14	 imul	 rax, rax, 20
  003d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  003dd	48 03 c8	 add	 rcx, rax
  003e0	48 8b c1	 mov	 rax, rcx
  003e3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR p$[rsp], rax

; 3471 :          n = n-i;

  003eb	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  003ef	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  003f6	2b c8		 sub	 ecx, eax
  003f8	8b c1		 mov	 eax, ecx
  003fa	89 84 24 b8 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 3472 :       } else {

  00401	eb 38		 jmp	 SHORT $LN18@stbtt__sor
$LN17@stbtt__sor:

; 3473 :          stbtt__sort_edges_quicksort(p+i, n-i);

  00403	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00407	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  0040e	2b c8		 sub	 ecx, eax
  00410	8b c1		 mov	 eax, ecx
  00412	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00417	48 6b c9 14	 imul	 rcx, rcx, 20
  0041b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00423	48 03 d1	 add	 rdx, rcx
  00426	48 8b ca	 mov	 rcx, rdx
  00429	8b d0		 mov	 edx, eax
  0042b	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3474 :          n = j;

  00430	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  00434	89 84 24 b8 00
	00 00		 mov	 DWORD PTR n$[rsp], eax
$LN18@stbtt__sor:

; 3475 :       }
; 3476 :    }

  0043b	e9 e4 fb ff ff	 jmp	 $LN2@stbtt__sor
$LN3@stbtt__sor:

; 3477 : }

  00440	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00448	48 33 cc	 xor	 rcx, rsp
  0044b	e8 00 00 00 00	 call	 __security_check_cookie
  00450	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00457	5f		 pop	 rdi
  00458	5e		 pop	 rsi
  00459	c3		 ret	 0
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_quicksort
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
j$ = 0
i$ = 4
tv78 = 8
c$1 = 12
b$2 = 16
a$3 = 24
tv142 = 32
t$4 = 40
__$ArrayPad$ = 64
p$ = 112
n$ = 120
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_ins_sort

; 3400 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3401 :    int i,j;
; 3402 :    for (i=1; i < n; ++i) {

  0001e	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00026	eb 0a		 jmp	 SHORT $LN4@stbtt__sor
$LN2@stbtt__sor:
  00028	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  0002c	ff c0		 inc	 eax
  0002e	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__sor:
  00032	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  00036	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  0003a	0f 8d 00 01 00
	00		 jge	 $LN3@stbtt__sor

; 3403 :       stbtt__edge t = p[i], *a = &t;

  00040	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00045	48 6b c0 14	 imul	 rax, rax, 20
  00049	48 8d 4c 24 28	 lea	 rcx, QWORD PTR t$4[rsp]
  0004e	48 8b 54 24 70	 mov	 rdx, QWORD PTR p$[rsp]
  00053	48 8b f9	 mov	 rdi, rcx
  00056	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0005a	b9 14 00 00 00	 mov	 ecx, 20
  0005f	f3 a4		 rep movsb
  00061	48 8d 44 24 28	 lea	 rax, QWORD PTR t$4[rsp]
  00066	48 89 44 24 18	 mov	 QWORD PTR a$3[rsp], rax

; 3404 :       j = i;

  0006b	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  0006f	89 04 24	 mov	 DWORD PTR j$[rsp], eax
$LN5@stbtt__sor:

; 3405 :       while (j > 0) {

  00072	83 3c 24 00	 cmp	 DWORD PTR j$[rsp], 0
  00076	0f 8e 96 00 00
	00		 jle	 $LN6@stbtt__sor

; 3406 :          stbtt__edge *b = &p[j-1];

  0007c	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  0007f	ff c8		 dec	 eax
  00081	48 98		 cdqe
  00083	48 6b c0 14	 imul	 rax, rax, 20
  00087	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  0008c	48 03 c8	 add	 rcx, rax
  0008f	48 8b c1	 mov	 rax, rcx
  00092	48 89 44 24 10	 mov	 QWORD PTR b$2[rsp], rax

; 3407 :          int c = STBTT__COMPARE(a,b);

  00097	48 8b 44 24 10	 mov	 rax, QWORD PTR b$2[rsp]
  0009c	48 8b 4c 24 18	 mov	 rcx, QWORD PTR a$3[rsp]
  000a1	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  000a6	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [rcx+4]
  000aa	76 0a		 jbe	 SHORT $LN10@stbtt__sor
  000ac	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  000b4	eb 08		 jmp	 SHORT $LN11@stbtt__sor
$LN10@stbtt__sor:
  000b6	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN11@stbtt__sor:
  000be	8b 44 24 08	 mov	 eax, DWORD PTR tv78[rsp]
  000c2	89 44 24 0c	 mov	 DWORD PTR c$1[rsp], eax

; 3408 :          if (!c) break;

  000c6	83 7c 24 0c 00	 cmp	 DWORD PTR c$1[rsp], 0
  000cb	75 02		 jne	 SHORT $LN7@stbtt__sor
  000cd	eb 43		 jmp	 SHORT $LN6@stbtt__sor
$LN7@stbtt__sor:

; 3409 :          p[j] = p[j-1];

  000cf	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000d2	ff c8		 dec	 eax
  000d4	48 98		 cdqe
  000d6	48 6b c0 14	 imul	 rax, rax, 20
  000da	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000de	48 6b c9 14	 imul	 rcx, rcx, 20
  000e2	48 8b 54 24 70	 mov	 rdx, QWORD PTR p$[rsp]
  000e7	48 8b 7c 24 70	 mov	 rdi, QWORD PTR p$[rsp]
  000ec	48 89 7c 24 20	 mov	 QWORD PTR tv142[rsp], rdi
  000f1	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  000f5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv142[rsp]
  000fa	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000fe	b9 14 00 00 00	 mov	 ecx, 20
  00103	f3 a4		 rep movsb

; 3410 :          --j;

  00105	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00108	ff c8		 dec	 eax
  0010a	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 3411 :       }

  0010d	e9 60 ff ff ff	 jmp	 $LN5@stbtt__sor
$LN6@stbtt__sor:

; 3412 :       if (i != j)

  00112	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00115	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  00119	74 20		 je	 SHORT $LN8@stbtt__sor

; 3413 :          p[j] = t;

  0011b	48 63 04 24	 movsxd	 rax, DWORD PTR j$[rsp]
  0011f	48 6b c0 14	 imul	 rax, rax, 20
  00123	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00128	48 8d 54 24 28	 lea	 rdx, QWORD PTR t$4[rsp]
  0012d	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00131	48 8b f2	 mov	 rsi, rdx
  00134	b9 14 00 00 00	 mov	 ecx, 20
  00139	f3 a4		 rep movsb
$LN8@stbtt__sor:

; 3414 :    }

  0013b	e9 e8 fe ff ff	 jmp	 $LN2@stbtt__sor
$LN3@stbtt__sor:

; 3415 : }

  00140	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00145	48 33 cc	 xor	 rcx, rsp
  00148	e8 00 00 00 00	 call	 __security_check_cookie
  0014d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00151	5f		 pop	 rdi
  00152	5e		 pop	 rsi
  00153	c3		 ret	 0
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_ins_sort
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
scan_y_top$1 = 48
i$ = 52
j$ = 56
step$2 = 64
y$ = 72
sum$3 = 76
k$4 = 80
m$5 = 84
scanline$ = 88
z$6 = 96
active$ = 104
z$7 = 112
scan_y_bottom$8 = 120
scanline2$ = 128
z$9 = 136
tv130 = 144
tv138 = 152
hh$ = 160
scanline_data$ = 192
__$ArrayPad$ = 720
result$ = 752
e$ = 760
n$ = 768
vsubsample$ = 776
off_x$ = 784
off_y$ = 792
userdata$ = 800
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z PROC ; stbtt__rasterize_sorted_edges

; 3298 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 02
	00 00		 sub	 rsp, 736		; 000002e0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3299 :    stbtt__hheap hh = { 0, 0, 0 };

  0002e	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hh$[rsp], 0
  0003a	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hh$[rsp+8], 0
  00046	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR hh$[rsp+16], 0

; 3300 :    stbtt__active_edge *active = NULL;

  00051	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR active$[rsp], 0

; 3301 :    int y,j=0, i;

  0005a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 3302 :    float scanline_data[129], *scanline, *scanline2;
; 3303 : 
; 3304 :    STBTT__NOTUSED(vsubsample);
; 3305 : 
; 3306 :    if (result->w > 64)

  00062	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  0006a	83 38 40	 cmp	 DWORD PTR [rax], 64	; 00000040H
  0006d	7e 23		 jle	 SHORT $LN13@stbtt__ras

; 3307 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

  0006f	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00077	8b 00		 mov	 eax, DWORD PTR [rax]
  00079	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0007d	48 98		 cdqe
  0007f	48 c1 e0 02	 shl	 rax, 2
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 malloc
  0008b	48 89 44 24 58	 mov	 QWORD PTR scanline$[rsp], rax
  00090	eb 0d		 jmp	 SHORT $LN14@stbtt__ras
$LN13@stbtt__ras:

; 3308 :    else
; 3309 :       scanline = scanline_data;

  00092	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR scanline_data$[rsp]
  0009a	48 89 44 24 58	 mov	 QWORD PTR scanline$[rsp], rax
$LN14@stbtt__ras:

; 3310 : 
; 3311 :    scanline2 = scanline + result->w;

  0009f	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  000a7	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scanline$[rsp]
  000af	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000b3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR scanline2$[rsp], rax

; 3312 : 
; 3313 :    y = off_y;

  000bb	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR off_y$[rsp]
  000c2	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax

; 3314 :    e[n].y0 = (float) (off_y + result->h) + 1;

  000c6	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  000ce	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000d1	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR off_y$[rsp]
  000d8	03 c8		 add	 ecx, eax
  000da	8b c1		 mov	 eax, ecx
  000dc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  000e8	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR n$[rsp]
  000f0	48 6b c0 14	 imul	 rax, rax, 20
  000f4	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  000fc	f3 0f 11 44 01
	04		 movss	 DWORD PTR [rcx+rax+4], xmm0
$LN2@stbtt__ras:

; 3315 : 
; 3316 :    while (j < result->h) {

  00102	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  0010a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0010d	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  00111	0f 8d bb 03 00
	00		 jge	 $LN3@stbtt__ras

; 3317 :       // find center of pixel for this scanline
; 3318 :       float scan_y_top    = y + 0.0f;

  00117	f3 0f 2a 44 24
	48		 cvtsi2ss xmm0, DWORD PTR y$[rsp]
  0011d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@00000000
  00125	f3 0f 11 44 24
	30		 movss	 DWORD PTR scan_y_top$1[rsp], xmm0

; 3319 :       float scan_y_bottom = y + 1.0f;

  0012b	f3 0f 2a 44 24
	48		 cvtsi2ss xmm0, DWORD PTR y$[rsp]
  00131	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00139	f3 0f 11 44 24
	78		 movss	 DWORD PTR scan_y_bottom$8[rsp], xmm0

; 3320 :       stbtt__active_edge **step = &active;

  0013f	48 8d 44 24 68	 lea	 rax, QWORD PTR active$[rsp]
  00144	48 89 44 24 40	 mov	 QWORD PTR step$2[rsp], rax

; 3321 : 
; 3322 :       STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));

  00149	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00151	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00154	48 c1 e0 02	 shl	 rax, 2
  00158	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv130[rsp], rax
  00160	48 8b 7c 24 58	 mov	 rdi, QWORD PTR scanline$[rsp]
  00165	33 c0		 xor	 eax, eax
  00167	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv130[rsp]
  0016f	f3 aa		 rep stosb

; 3323 :       STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

  00171	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00179	8b 00		 mov	 eax, DWORD PTR [rax]
  0017b	ff c0		 inc	 eax
  0017d	48 98		 cdqe
  0017f	48 c1 e0 02	 shl	 rax, 2
  00183	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv138[rsp], rax
  0018b	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR scanline2$[rsp]
  00193	33 c0		 xor	 eax, eax
  00195	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  0019d	f3 aa		 rep stosb
$LN4@stbtt__ras:

; 3324 : 
; 3325 :       // update all active edges;
; 3326 :       // remove all active edges that terminate before the top of this scanline
; 3327 :       while (*step) {

  0019f	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  001a4	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001a8	0f 84 91 00 00
	00		 je	 $LN5@stbtt__ras

; 3328 :          stbtt__active_edge * z = *step;

  001ae	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  001b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b6	48 89 44 24 70	 mov	 QWORD PTR z$7[rsp], rax

; 3329 :          if (z->ey <= scan_y_top) {

  001bb	48 8b 44 24 70	 mov	 rax, QWORD PTR z$7[rsp]
  001c0	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR scan_y_top$1[rsp]
  001c6	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  001ca	72 61		 jb	 SHORT $LN15@stbtt__ras

; 3330 :             *step = z->next; // delete from list

  001cc	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  001d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$7[rsp]
  001d6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001d9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3331 :             STBTT_assert(z->direction);

  001dc	48 8b 44 24 70	 mov	 rax, QWORD PTR z$7[rsp]
  001e1	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  001e6	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001ed	7a 1d		 jp	 SHORT $LN25@stbtt__ras
  001ef	75 1b		 jne	 SHORT $LN25@stbtt__ras
  001f1	41 b8 03 0d 00
	00		 mov	 r8d, 3331		; 00000d03H
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42866
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42867
  00205	e8 00 00 00 00	 call	 _wassert
  0020a	33 c0		 xor	 eax, eax
$LN25@stbtt__ras:

; 3332 :             z->direction = 0;

  0020c	48 8b 44 24 70	 mov	 rax, QWORD PTR z$7[rsp]
  00211	0f 57 c0	 xorps	 xmm0, xmm0
  00214	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 3333 :             stbtt__hheap_free(&hh, z);

  00219	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$7[rsp]
  0021e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR hh$[rsp]
  00226	e8 00 00 00 00	 call	 ?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z ; stbtt__hheap_free

; 3334 :          } else {

  0022b	eb 0d		 jmp	 SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:

; 3335 :             step = &((*step)->next); // advance through list

  0022d	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  00232	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00235	48 89 44 24 40	 mov	 QWORD PTR step$2[rsp], rax
$LN16@stbtt__ras:

; 3336 :          }
; 3337 :       }

  0023a	e9 60 ff ff ff	 jmp	 $LN4@stbtt__ras
$LN5@stbtt__ras:
$LN6@stbtt__ras:

; 3338 : 
; 3339 :       // insert all edges that start before the bottom of this scanline
; 3340 :       while (e->y0 <= scan_y_bottom) {

  0023f	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00247	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR scan_y_bottom$8[rsp]
  0024d	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [rax+4]
  00251	0f 82 ec 00 00
	00		 jb	 $LN7@stbtt__ras

; 3341 :          if (e->y0 != e->y1) {

  00257	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0025f	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR e$[rsp]
  00267	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0026c	0f 2e 41 0c	 ucomiss xmm0, DWORD PTR [rcx+12]
  00270	7a 06		 jp	 SHORT $LN27@stbtt__ras
  00272	0f 84 b2 00 00
	00		 je	 $LN17@stbtt__ras
$LN27@stbtt__ras:

; 3342 :             stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);

  00278	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR userdata$[rsp]
  00280	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00285	f3 0f 10 5c 24
	30		 movss	 xmm3, DWORD PTR scan_y_top$1[rsp]
  0028b	44 8b 84 24 10
	03 00 00	 mov	 r8d, DWORD PTR off_x$[rsp]
  00293	48 8b 94 24 f8
	02 00 00	 mov	 rdx, QWORD PTR e$[rsp]
  0029b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR hh$[rsp]
  002a3	e8 00 00 00 00	 call	 ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z ; stbtt__new_active
  002a8	48 89 44 24 60	 mov	 QWORD PTR z$6[rsp], rax

; 3343 :             if (z != NULL) {

  002ad	48 83 7c 24 60
	00		 cmp	 QWORD PTR z$6[rsp], 0
  002b3	74 75		 je	 SHORT $LN18@stbtt__ras

; 3344 :                if (j == 0 && off_y != 0) {

  002b5	83 7c 24 38 00	 cmp	 DWORD PTR j$[rsp], 0
  002ba	75 2b		 jne	 SHORT $LN19@stbtt__ras
  002bc	83 bc 24 18 03
	00 00 00	 cmp	 DWORD PTR off_y$[rsp], 0
  002c4	74 21		 je	 SHORT $LN19@stbtt__ras

; 3345 :                   if (z->ey < scan_y_top) {

  002c6	48 8b 44 24 60	 mov	 rax, QWORD PTR z$6[rsp]
  002cb	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR scan_y_top$1[rsp]
  002d1	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  002d5	76 10		 jbe	 SHORT $LN20@stbtt__ras

; 3346 :                      // this can happen due to subpixel positioning and some kind of fp rounding error i think
; 3347 :                      z->ey = scan_y_top;

  002d7	48 8b 44 24 60	 mov	 rax, QWORD PTR z$6[rsp]
  002dc	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR scan_y_top$1[rsp]
  002e2	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN20@stbtt__ras:
$LN19@stbtt__ras:

; 3348 :                   }
; 3349 :                }
; 3350 :                STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds

  002e7	48 8b 44 24 60	 mov	 rax, QWORD PTR z$6[rsp]
  002ec	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  002f1	0f 2f 44 24 30	 comiss	 xmm0, DWORD PTR scan_y_top$1[rsp]
  002f6	73 1b		 jae	 SHORT $LN26@stbtt__ras
  002f8	41 b8 16 0d 00
	00		 mov	 r8d, 3350		; 00000d16H
  002fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42872
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42873
  0030c	e8 00 00 00 00	 call	 _wassert
  00311	33 c0		 xor	 eax, eax
$LN26@stbtt__ras:

; 3351 :                // insert at front
; 3352 :                z->next = active;

  00313	48 8b 44 24 60	 mov	 rax, QWORD PTR z$6[rsp]
  00318	48 8b 4c 24 68	 mov	 rcx, QWORD PTR active$[rsp]
  0031d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3353 :                active = z;

  00320	48 8b 44 24 60	 mov	 rax, QWORD PTR z$6[rsp]
  00325	48 89 44 24 68	 mov	 QWORD PTR active$[rsp], rax
$LN18@stbtt__ras:
$LN17@stbtt__ras:

; 3354 :             }
; 3355 :          }
; 3356 :          ++e;

  0032a	48 8b 84 24 f8
	02 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00332	48 83 c0 14	 add	 rax, 20
  00336	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR e$[rsp], rax

; 3357 :       }

  0033e	e9 fc fe ff ff	 jmp	 $LN6@stbtt__ras
$LN7@stbtt__ras:

; 3358 : 
; 3359 :       // now process all active edges
; 3360 :       if (active)

  00343	48 83 7c 24 68
	00		 cmp	 QWORD PTR active$[rsp], 0
  00349	74 35		 je	 SHORT $LN21@stbtt__ras

; 3361 :          stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

  0034b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR scanline2$[rsp]
  00353	48 83 c0 04	 add	 rax, 4
  00357	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR scan_y_top$1[rsp]
  0035d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00363	4c 8b 4c 24 68	 mov	 r9, QWORD PTR active$[rsp]
  00368	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00370	44 8b 01	 mov	 r8d, DWORD PTR [rcx]
  00373	48 8b d0	 mov	 rdx, rax
  00376	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scanline$[rsp]
  0037b	e8 00 00 00 00	 call	 ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ; stbtt__fill_active_edges_new
$LN21@stbtt__ras:

; 3362 : 
; 3363 :       {
; 3364 :          float sum = 0;

  00380	0f 57 c0	 xorps	 xmm0, xmm0
  00383	f3 0f 11 44 24
	4c		 movss	 DWORD PTR sum$3[rsp], xmm0

; 3365 :          for (i=0; i < result->w; ++i) {

  00389	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00391	eb 0a		 jmp	 SHORT $LN10@stbtt__ras
$LN8@stbtt__ras:
  00393	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00397	ff c0		 inc	 eax
  00399	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbtt__ras:
  0039d	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  003a5	8b 00		 mov	 eax, DWORD PTR [rax]
  003a7	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  003ab	0f 8d ad 00 00
	00		 jge	 $LN9@stbtt__ras

; 3366 :             float k;
; 3367 :             int m;
; 3368 :             sum += scanline2[i];

  003b1	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  003b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR scanline2$[rsp]
  003be	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR sum$3[rsp]
  003c4	f3 0f 58 04 81	 addss	 xmm0, DWORD PTR [rcx+rax*4]
  003c9	f3 0f 11 44 24
	4c		 movss	 DWORD PTR sum$3[rsp], xmm0

; 3369 :             k = scanline[i] + sum;

  003cf	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  003d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scanline$[rsp]
  003d9	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  003de	f3 0f 58 44 24
	4c		 addss	 xmm0, DWORD PTR sum$3[rsp]
  003e4	f3 0f 11 44 24
	50		 movss	 DWORD PTR k$4[rsp], xmm0

; 3370 :             k = (float) STBTT_fabs(k)*255 + 0.5f;

  003ea	f3 0f 5a 44 24
	50		 cvtss2sd xmm0, DWORD PTR k$4[rsp]
  003f0	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  003f7	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003fb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00403	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0040b	f3 0f 11 44 24
	50		 movss	 DWORD PTR k$4[rsp], xmm0

; 3371 :             m = (int) k;

  00411	f3 0f 2c 44 24
	50		 cvttss2si eax, DWORD PTR k$4[rsp]
  00417	89 44 24 54	 mov	 DWORD PTR m$5[rsp], eax

; 3372 :             if (m > 255) m = 255;

  0041b	81 7c 24 54 ff
	00 00 00	 cmp	 DWORD PTR m$5[rsp], 255	; 000000ffH
  00423	7e 08		 jle	 SHORT $LN22@stbtt__ras
  00425	c7 44 24 54 ff
	00 00 00	 mov	 DWORD PTR m$5[rsp], 255	; 000000ffH
$LN22@stbtt__ras:

; 3373 :             result->pixels[j*result->stride + i] = (unsigned char) m;

  0042d	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00435	8b 4c 24 38	 mov	 ecx, DWORD PTR j$[rsp]
  00439	0f af 48 08	 imul	 ecx, DWORD PTR [rax+8]
  0043d	8b c1		 mov	 eax, ecx
  0043f	03 44 24 34	 add	 eax, DWORD PTR i$[rsp]
  00443	48 98		 cdqe
  00445	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0044d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00451	0f b6 54 24 54	 movzx	 edx, BYTE PTR m$5[rsp]
  00456	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3374 :          }

  00459	e9 35 ff ff ff	 jmp	 $LN8@stbtt__ras
$LN9@stbtt__ras:

; 3375 :       }
; 3376 :       // advance all the edges
; 3377 :       step = &active;

  0045e	48 8d 44 24 68	 lea	 rax, QWORD PTR active$[rsp]
  00463	48 89 44 24 40	 mov	 QWORD PTR step$2[rsp], rax
$LN11@stbtt__ras:

; 3378 :       while (*step) {

  00468	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  0046d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00471	74 46		 je	 SHORT $LN12@stbtt__ras

; 3379 :          stbtt__active_edge *z = *step;

  00473	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  00478	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0047b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR z$9[rsp], rax

; 3380 :          z->fx += z->fdx; // advance to position for current scanline

  00483	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR z$9[rsp]
  0048b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR z$9[rsp]
  00493	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00498	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [rcx+12]
  0049d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR z$9[rsp]
  004a5	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 3381 :          step = &((*step)->next); // advance through list

  004aa	48 8b 44 24 40	 mov	 rax, QWORD PTR step$2[rsp]
  004af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004b2	48 89 44 24 40	 mov	 QWORD PTR step$2[rsp], rax

; 3382 :       }

  004b7	eb af		 jmp	 SHORT $LN11@stbtt__ras
$LN12@stbtt__ras:

; 3383 : 
; 3384 :       ++y;

  004b9	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  004bd	ff c0		 inc	 eax
  004bf	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax

; 3385 :       ++j;

  004c3	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  004c7	ff c0		 inc	 eax
  004c9	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax

; 3386 :    }

  004cd	e9 30 fc ff ff	 jmp	 $LN2@stbtt__ras
$LN3@stbtt__ras:

; 3387 : 
; 3388 :    stbtt__hheap_cleanup(&hh, userdata);

  004d2	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR userdata$[rsp]
  004da	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR hh$[rsp]
  004e2	e8 00 00 00 00	 call	 ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z ; stbtt__hheap_cleanup

; 3389 : 
; 3390 :    if (scanline != scanline_data)

  004e7	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR scanline_data$[rsp]
  004ef	48 39 44 24 58	 cmp	 QWORD PTR scanline$[rsp], rax
  004f4	74 0a		 je	 SHORT $LN23@stbtt__ras

; 3391 :       STBTT_free(scanline, userdata);

  004f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scanline$[rsp]
  004fb	e8 00 00 00 00	 call	 free
$LN23@stbtt__ras:

; 3392 : }

  00500	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00508	48 33 cc	 xor	 rcx, rsp
  0050b	e8 00 00 00 00	 call	 __security_check_cookie
  00510	48 81 c4 e0 02
	00 00		 add	 rsp, 736		; 000002e0H
  00517	5f		 pop	 rdi
  00518	c3		 ret	 0
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ENDP ; stbtt__rasterize_sorted_edges
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
x0$1 = 64
x$2 = 68
x1$3 = 72
x2$4 = 76
y_bottom$ = 80
x3$5 = 84
x_top$6 = 88
x0$7 = 92
x_bottom$8 = 96
x2$9 = 100
sy1$10 = 104
x$11 = 108
sy0$12 = 112
dx$13 = 116
y1$14 = 120
y2$15 = 124
dy$16 = 128
y3$17 = 132
y0$18 = 136
x1$19 = 140
area$20 = 144
t$21 = 148
x$22 = 152
y_final$23 = 156
y_crossing$24 = 160
sign$25 = 164
xb$26 = 168
height$27 = 172
step$28 = 176
tv296 = 180
tv298 = 184
tv181 = 192
tv237 = 200
tv285 = 208
scanline$ = 240
scanline_fill$ = 248
len$ = 256
e$ = 264
y_top$ = 272
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z PROC ; stbtt__fill_active_edges_new

; 3083 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 3084 :    float y_bottom = y_top+1;

  0001b	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR y_top$[rsp]
  00024	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0002c	f3 0f 11 44 24
	50		 movss	 DWORD PTR y_bottom$[rsp], xmm0
$LN2@stbtt__fil:

; 3085 : 
; 3086 :    while (e) {

  00032	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR e$[rsp], 0
  0003b	0f 84 81 0f 00
	00		 je	 $LN3@stbtt__fil

; 3087 :       // brute force every pixel
; 3088 : 
; 3089 :       // compute intersection points with top & bottom
; 3090 :       STBTT_assert(e->ey >= y_top);

  00041	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00049	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  0004e	0f 2f 84 24 10
	01 00 00	 comiss	 xmm0, DWORD PTR y_top$[rsp]
  00056	73 1b		 jae	 SHORT $LN39@stbtt__fil
  00058	41 b8 12 0c 00
	00		 mov	 r8d, 3090		; 00000c12H
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42770
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42771
  0006c	e8 00 00 00 00	 call	 _wassert
  00071	33 c0		 xor	 eax, eax
$LN39@stbtt__fil:

; 3091 : 
; 3092 :       if (e->fdx == 0) {

  00073	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0007b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00080	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00087	0f 8a 2c 01 00
	00		 jp	 $LN10@stbtt__fil
  0008d	0f 85 26 01 00
	00		 jne	 $LN10@stbtt__fil

; 3093 :          float x0 = e->fx;

  00093	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0009b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  000a0	f3 0f 11 44 24
	5c		 movss	 DWORD PTR x0$7[rsp], xmm0

; 3094 :          if (x0 < len) {

  000a6	f3 0f 2a 84 24
	00 01 00 00	 cvtsi2ss xmm0, DWORD PTR len$[rsp]
  000af	0f 2f 44 24 5c	 comiss	 xmm0, DWORD PTR x0$7[rsp]
  000b4	0f 86 fa 00 00
	00		 jbe	 $LN12@stbtt__fil

; 3095 :             if (x0 >= 0) {

  000ba	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$7[rsp]
  000c0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000c7	0f 82 9c 00 00
	00		 jb	 $LN13@stbtt__fil

; 3096 :                stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);

  000cd	f3 0f 2c 44 24
	5c		 cvttss2si eax, DWORD PTR x0$7[rsp]
  000d3	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  000d9	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  000df	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$7[rsp]
  000e5	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  000eb	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR y_top$[rsp]
  000f4	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000fa	f3 0f 10 5c 24
	5c		 movss	 xmm3, DWORD PTR x0$7[rsp]
  00100	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00108	8b d0		 mov	 edx, eax
  0010a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00112	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3097 :                stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);

  00117	f3 0f 2c 44 24
	5c		 cvttss2si eax, DWORD PTR x0$7[rsp]
  0011d	ff c0		 inc	 eax
  0011f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR scanline_fill$[rsp]
  00127	48 83 e9 04	 sub	 rcx, 4
  0012b	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  00131	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00137	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$7[rsp]
  0013d	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00143	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR y_top$[rsp]
  0014c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00152	f3 0f 10 5c 24
	5c		 movss	 xmm3, DWORD PTR x0$7[rsp]
  00158	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00160	8b d0		 mov	 edx, eax
  00162	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3098 :             } else {

  00167	eb 4b		 jmp	 SHORT $LN14@stbtt__fil
$LN13@stbtt__fil:

; 3099 :                stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);

  00169	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR scanline_fill$[rsp]
  00171	48 83 e8 04	 sub	 rax, 4
  00175	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  0017b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00181	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$7[rsp]
  00187	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0018d	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR y_top$[rsp]
  00196	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0019c	f3 0f 10 5c 24
	5c		 movss	 xmm3, DWORD PTR x0$7[rsp]
  001a2	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  001aa	33 d2		 xor	 edx, edx
  001ac	48 8b c8	 mov	 rcx, rax
  001af	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
$LN14@stbtt__fil:
$LN12@stbtt__fil:

; 3100 :             }
; 3101 :          }
; 3102 :       } else {

  001b4	e9 f1 0d 00 00	 jmp	 $LN11@stbtt__fil
$LN10@stbtt__fil:

; 3103 :          float x0 = e->fx;

  001b9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001c1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  001c6	f3 0f 11 44 24
	40		 movss	 DWORD PTR x0$1[rsp], xmm0

; 3104 :          float dx = e->fdx;

  001cc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001d4	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  001d9	f3 0f 11 44 24
	74		 movss	 DWORD PTR dx$13[rsp], xmm0

; 3105 :          float xb = x0 + dx;

  001df	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR x0$1[rsp]
  001e5	f3 0f 58 44 24
	74		 addss	 xmm0, DWORD PTR dx$13[rsp]
  001eb	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR xb$26[rsp], xmm0

; 3106 :          float x_top, x_bottom;
; 3107 :          float sy0,sy1;
; 3108 :          float dy = e->fdy;

  001f4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001fc	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00201	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR dy$16[rsp], xmm0

; 3109 :          STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

  0020a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00212	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  00218	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [rax+24]
  0021c	72 17		 jb	 SHORT $LN40@stbtt__fil
  0021e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00226	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  0022b	0f 2f 84 24 10
	01 00 00	 comiss	 xmm0, DWORD PTR y_top$[rsp]
  00233	73 1b		 jae	 SHORT $LN41@stbtt__fil
$LN40@stbtt__fil:
  00235	41 b8 25 0c 00
	00		 mov	 r8d, 3109		; 00000c25H
  0023b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42777
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42778
  00249	e8 00 00 00 00	 call	 _wassert
  0024e	33 c0		 xor	 eax, eax
$LN41@stbtt__fil:

; 3110 : 
; 3111 :          // compute endpoints of line segment clipped to this scanline (if the
; 3112 :          // line segment starts on this scanline. x0 is the intersection of the
; 3113 :          // line with y_top, but that may be off the line segment.
; 3114 :          if (e->sy > y_top) {

  00250	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00258	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  0025d	0f 2f 84 24 10
	01 00 00	 comiss	 xmm0, DWORD PTR y_top$[rsp]
  00265	76 4b		 jbe	 SHORT $LN15@stbtt__fil

; 3115 :             x_top = x0 + dx * (e->sy - y_top);

  00267	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0026f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  00274	f3 0f 5c 84 24
	10 01 00 00	 subss	 xmm0, DWORD PTR y_top$[rsp]
  0027d	f3 0f 10 4c 24
	74		 movss	 xmm1, DWORD PTR dx$13[rsp]
  00283	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00287	0f 28 c1	 movaps	 xmm0, xmm1
  0028a	f3 0f 10 4c 24
	40		 movss	 xmm1, DWORD PTR x0$1[rsp]
  00290	f3 0f 58 c8	 addss	 xmm1, xmm0
  00294	0f 28 c1	 movaps	 xmm0, xmm1
  00297	f3 0f 11 44 24
	58		 movss	 DWORD PTR x_top$6[rsp], xmm0

; 3116 :             sy0 = e->sy;

  0029d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  002a5	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  002aa	f3 0f 11 44 24
	70		 movss	 DWORD PTR sy0$12[rsp], xmm0

; 3117 :          } else {

  002b0	eb 1b		 jmp	 SHORT $LN16@stbtt__fil
$LN15@stbtt__fil:

; 3118 :             x_top = x0;

  002b2	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR x0$1[rsp]
  002b8	f3 0f 11 44 24
	58		 movss	 DWORD PTR x_top$6[rsp], xmm0

; 3119 :             sy0 = y_top;

  002be	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR y_top$[rsp]
  002c7	f3 0f 11 44 24
	70		 movss	 DWORD PTR sy0$12[rsp], xmm0
$LN16@stbtt__fil:

; 3120 :          }
; 3121 :          if (e->ey < y_bottom) {

  002cd	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  002d5	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  002db	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  002df	76 4b		 jbe	 SHORT $LN17@stbtt__fil

; 3122 :             x_bottom = x0 + dx * (e->ey - y_top);

  002e1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  002e9	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  002ee	f3 0f 5c 84 24
	10 01 00 00	 subss	 xmm0, DWORD PTR y_top$[rsp]
  002f7	f3 0f 10 4c 24
	74		 movss	 xmm1, DWORD PTR dx$13[rsp]
  002fd	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00301	0f 28 c1	 movaps	 xmm0, xmm1
  00304	f3 0f 10 4c 24
	40		 movss	 xmm1, DWORD PTR x0$1[rsp]
  0030a	f3 0f 58 c8	 addss	 xmm1, xmm0
  0030e	0f 28 c1	 movaps	 xmm0, xmm1
  00311	f3 0f 11 44 24
	60		 movss	 DWORD PTR x_bottom$8[rsp], xmm0

; 3123 :             sy1 = e->ey;

  00317	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0031f	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  00324	f3 0f 11 44 24
	68		 movss	 DWORD PTR sy1$10[rsp], xmm0

; 3124 :          } else {

  0032a	eb 1b		 jmp	 SHORT $LN18@stbtt__fil
$LN17@stbtt__fil:

; 3125 :             x_bottom = xb;

  0032c	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR xb$26[rsp]
  00335	f3 0f 11 44 24
	60		 movss	 DWORD PTR x_bottom$8[rsp], xmm0

; 3126 :             sy1 = y_bottom;

  0033b	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  00341	f3 0f 11 44 24
	68		 movss	 DWORD PTR sy1$10[rsp], xmm0
$LN18@stbtt__fil:

; 3127 :          }
; 3128 : 
; 3129 :          if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {

  00347	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR x_top$6[rsp]
  0034d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00354	0f 82 96 06 00
	00		 jb	 $LN19@stbtt__fil
  0035a	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR x_bottom$8[rsp]
  00360	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00367	0f 82 83 06 00
	00		 jb	 $LN19@stbtt__fil
  0036d	f3 0f 2a 84 24
	00 01 00 00	 cvtsi2ss xmm0, DWORD PTR len$[rsp]
  00376	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR x_top$6[rsp]
  0037b	0f 86 6f 06 00
	00		 jbe	 $LN19@stbtt__fil
  00381	f3 0f 2a 84 24
	00 01 00 00	 cvtsi2ss xmm0, DWORD PTR len$[rsp]
  0038a	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR x_bottom$8[rsp]
  0038f	0f 86 5b 06 00
	00		 jbe	 $LN19@stbtt__fil

; 3130 :             // from here on, we don't have to range check x values
; 3131 : 
; 3132 :             if ((int) x_top == (int) x_bottom) {

  00395	f3 0f 2c 44 24
	58		 cvttss2si eax, DWORD PTR x_top$6[rsp]
  0039b	f3 0f 2c 4c 24
	60		 cvttss2si ecx, DWORD PTR x_bottom$8[rsp]
  003a1	3b c1		 cmp	 eax, ecx
  003a3	0f 85 07 01 00
	00		 jne	 $LN21@stbtt__fil

; 3133 :                float height;
; 3134 :                // simple case, only spans one pixel
; 3135 :                int x = (int) x_top;

  003a9	f3 0f 2c 44 24
	58		 cvttss2si eax, DWORD PTR x_top$6[rsp]
  003af	89 44 24 6c	 mov	 DWORD PTR x$11[rsp], eax

; 3136 :                height = (sy1 - sy0) * e->direction;

  003b3	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR sy1$10[rsp]
  003b9	f3 0f 5c 44 24
	70		 subss	 xmm0, DWORD PTR sy0$12[rsp]
  003bf	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  003c7	f3 0f 59 40 14	 mulss	 xmm0, DWORD PTR [rax+20]
  003cc	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR height$27[rsp], xmm0

; 3137 :                STBTT_assert(x >= 0 && x < len);

  003d5	83 7c 24 6c 00	 cmp	 DWORD PTR x$11[rsp], 0
  003da	7c 0d		 jl	 SHORT $LN42@stbtt__fil
  003dc	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  003e3	39 44 24 6c	 cmp	 DWORD PTR x$11[rsp], eax
  003e7	7c 1b		 jl	 SHORT $LN43@stbtt__fil
$LN42@stbtt__fil:
  003e9	41 b8 41 0c 00
	00		 mov	 r8d, 3137		; 00000c41H
  003ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42787
  003f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42788
  003fd	e8 00 00 00 00	 call	 _wassert
  00402	33 c0		 xor	 eax, eax
$LN43@stbtt__fil:

; 3138 :                scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);

  00404	48 63 44 24 6c	 movsxd	 rax, DWORD PTR x$11[rsp]
  00409	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv181[rsp], rax
  00411	f3 0f 2a 44 24
	6c		 cvtsi2ss xmm0, DWORD PTR x$11[rsp]
  00417	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0041f	f3 0f 2a 4c 24
	6c		 cvtsi2ss xmm1, DWORD PTR x$11[rsp]
  00425	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
  0042d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00433	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR x_bottom$8[rsp]
  00439	0f 28 d1	 movaps	 xmm2, xmm1
  0043c	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x_top$6[rsp]
  00442	f3 0f 10 84 24
	ac 00 00 00	 movss	 xmm0, DWORD PTR height$27[rsp]
  0044b	e8 00 00 00 00	 call	 ?stbtt__position_trapezoid_area@@YAMMMMMM@Z ; stbtt__position_trapezoid_area
  00450	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR scanline$[rsp]
  00458	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv181[rsp]
  00460	f3 0f 10 0c 88	 movss	 xmm1, DWORD PTR [rax+rcx*4]
  00465	f3 0f 58 c8	 addss	 xmm1, xmm0
  00469	0f 28 c1	 movaps	 xmm0, xmm1
  0046c	48 63 44 24 6c	 movsxd	 rax, DWORD PTR x$11[rsp]
  00471	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00479	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 3139 :                scanline_fill[x] += height; // everything right of this pixel is filled

  0047e	48 63 44 24 6c	 movsxd	 rax, DWORD PTR x$11[rsp]
  00483	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR scanline_fill$[rsp]
  0048b	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00490	f3 0f 58 84 24
	ac 00 00 00	 addss	 xmm0, DWORD PTR height$27[rsp]
  00499	48 63 44 24 6c	 movsxd	 rax, DWORD PTR x$11[rsp]
  0049e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR scanline_fill$[rsp]
  004a6	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 3140 :             } else {

  004ab	e9 3b 05 00 00	 jmp	 $LN22@stbtt__fil
$LN21@stbtt__fil:

; 3141 :                int x,x1,x2;
; 3142 :                float y_crossing, y_final, step, sign, area;
; 3143 :                // covers 2+ pixels
; 3144 :                if (x_top > x_bottom) {

  004b0	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR x_top$6[rsp]
  004b6	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR x_bottom$8[rsp]
  004bb	0f 86 f4 00 00
	00		 jbe	 $LN23@stbtt__fil

; 3145 :                   // flip scanline vertically; signed area is the same
; 3146 :                   float t;
; 3147 :                   sy0 = y_bottom - (sy0 - y_top);

  004c1	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR sy0$12[rsp]
  004c7	f3 0f 5c 84 24
	10 01 00 00	 subss	 xmm0, DWORD PTR y_top$[rsp]
  004d0	f3 0f 10 4c 24
	50		 movss	 xmm1, DWORD PTR y_bottom$[rsp]
  004d6	f3 0f 5c c8	 subss	 xmm1, xmm0
  004da	0f 28 c1	 movaps	 xmm0, xmm1
  004dd	f3 0f 11 44 24
	70		 movss	 DWORD PTR sy0$12[rsp], xmm0

; 3148 :                   sy1 = y_bottom - (sy1 - y_top);

  004e3	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR sy1$10[rsp]
  004e9	f3 0f 5c 84 24
	10 01 00 00	 subss	 xmm0, DWORD PTR y_top$[rsp]
  004f2	f3 0f 10 4c 24
	50		 movss	 xmm1, DWORD PTR y_bottom$[rsp]
  004f8	f3 0f 5c c8	 subss	 xmm1, xmm0
  004fc	0f 28 c1	 movaps	 xmm0, xmm1
  004ff	f3 0f 11 44 24
	68		 movss	 DWORD PTR sy1$10[rsp], xmm0

; 3149 :                   t = sy0, sy0 = sy1, sy1 = t;

  00505	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR sy0$12[rsp]
  0050b	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR t$21[rsp], xmm0
  00514	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR sy1$10[rsp]
  0051a	f3 0f 11 44 24
	70		 movss	 DWORD PTR sy0$12[rsp], xmm0
  00520	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR t$21[rsp]
  00529	f3 0f 11 44 24
	68		 movss	 DWORD PTR sy1$10[rsp], xmm0

; 3150 :                   t = x_bottom, x_bottom = x_top, x_top = t;

  0052f	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR x_bottom$8[rsp]
  00535	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR t$21[rsp], xmm0
  0053e	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR x_top$6[rsp]
  00544	f3 0f 11 44 24
	60		 movss	 DWORD PTR x_bottom$8[rsp], xmm0
  0054a	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR t$21[rsp]
  00553	f3 0f 11 44 24
	58		 movss	 DWORD PTR x_top$6[rsp], xmm0

; 3151 :                   dx = -dx;

  00559	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR dx$13[rsp]
  0055f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00566	f3 0f 11 44 24
	74		 movss	 DWORD PTR dx$13[rsp], xmm0

; 3152 :                   dy = -dy;

  0056c	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR dy$16[rsp]
  00575	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0057c	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR dy$16[rsp], xmm0

; 3153 :                   t = x0, x0 = xb, xb = t;

  00585	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR x0$1[rsp]
  0058b	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR t$21[rsp], xmm0
  00594	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR xb$26[rsp]
  0059d	f3 0f 11 44 24
	40		 movss	 DWORD PTR x0$1[rsp], xmm0
  005a3	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR t$21[rsp]
  005ac	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR xb$26[rsp], xmm0
$LN23@stbtt__fil:

; 3154 :                }
; 3155 :                STBTT_assert(dy >= 0);

  005b5	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR dy$16[rsp]
  005be	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005c5	73 1b		 jae	 SHORT $LN44@stbtt__fil
  005c7	41 b8 53 0c 00
	00		 mov	 r8d, 3155		; 00000c53H
  005cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42790
  005d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42791
  005db	e8 00 00 00 00	 call	 _wassert
  005e0	33 c0		 xor	 eax, eax
$LN44@stbtt__fil:

; 3156 :                STBTT_assert(dx >= 0);

  005e2	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR dx$13[rsp]
  005e8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005ef	73 1b		 jae	 SHORT $LN45@stbtt__fil
  005f1	41 b8 54 0c 00
	00		 mov	 r8d, 3156		; 00000c54H
  005f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42792
  005fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42793
  00605	e8 00 00 00 00	 call	 _wassert
  0060a	33 c0		 xor	 eax, eax
$LN45@stbtt__fil:

; 3157 : 
; 3158 :                x1 = (int) x_top;

  0060c	f3 0f 2c 44 24
	58		 cvttss2si eax, DWORD PTR x_top$6[rsp]
  00612	89 84 24 8c 00
	00 00		 mov	 DWORD PTR x1$19[rsp], eax

; 3159 :                x2 = (int) x_bottom;

  00619	f3 0f 2c 44 24
	60		 cvttss2si eax, DWORD PTR x_bottom$8[rsp]
  0061f	89 44 24 64	 mov	 DWORD PTR x2$9[rsp], eax

; 3160 :                // compute intersection with y axis at x1+1
; 3161 :                y_crossing = y_top + dy * (x1+1 - x0);

  00623	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x1$19[rsp]
  0062a	ff c0		 inc	 eax
  0062c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00630	f3 0f 5c 44 24
	40		 subss	 xmm0, DWORD PTR x0$1[rsp]
  00636	f3 0f 10 8c 24
	80 00 00 00	 movss	 xmm1, DWORD PTR dy$16[rsp]
  0063f	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00643	0f 28 c1	 movaps	 xmm0, xmm1
  00646	f3 0f 10 8c 24
	10 01 00 00	 movss	 xmm1, DWORD PTR y_top$[rsp]
  0064f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00653	0f 28 c1	 movaps	 xmm0, xmm1
  00656	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR y_crossing$24[rsp], xmm0

; 3162 : 
; 3163 :                // compute intersection with y axis at x2
; 3164 :                y_final = y_top + dy * (x2 - x0);

  0065f	f3 0f 2a 44 24
	64		 cvtsi2ss xmm0, DWORD PTR x2$9[rsp]
  00665	f3 0f 5c 44 24
	40		 subss	 xmm0, DWORD PTR x0$1[rsp]
  0066b	f3 0f 10 8c 24
	80 00 00 00	 movss	 xmm1, DWORD PTR dy$16[rsp]
  00674	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00678	0f 28 c1	 movaps	 xmm0, xmm1
  0067b	f3 0f 10 8c 24
	10 01 00 00	 movss	 xmm1, DWORD PTR y_top$[rsp]
  00684	f3 0f 58 c8	 addss	 xmm1, xmm0
  00688	0f 28 c1	 movaps	 xmm0, xmm1
  0068b	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR y_final$23[rsp], xmm0

; 3165 : 
; 3166 :                //           x1    x_top                            x2    x_bottom
; 3167 :                //     y_top  +------|-----+------------+------------+--------|---+------------+
; 3168 :                //            |            |            |            |            |            |
; 3169 :                //            |            |            |            |            |            |
; 3170 :                //       sy0  |      Txxxxx|............|............|............|............|
; 3171 :                // y_crossing |            *xxxxx.......|............|............|............|
; 3172 :                //            |            |     xxxxx..|............|............|............|
; 3173 :                //            |            |     /-   xx*xxxx........|............|............|
; 3174 :                //            |            | dy <       |    xxxxxx..|............|............|
; 3175 :                //   y_final  |            |     \-     |          xx*xxx.........|............|
; 3176 :                //       sy1  |            |            |            |   xxxxxB...|............|
; 3177 :                //            |            |            |            |            |            |
; 3178 :                //            |            |            |            |            |            |
; 3179 :                //  y_bottom  +------------+------------+------------+------------+------------+
; 3180 :                //
; 3181 :                // goal is to measure the area covered by '.' in each pixel
; 3182 : 
; 3183 :                // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
; 3184 :                // @TODO: maybe test against sy1 rather than y_bottom?
; 3185 :                if (y_crossing > y_bottom)

  00694	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y_crossing$24[rsp]
  0069d	0f 2f 44 24 50	 comiss	 xmm0, DWORD PTR y_bottom$[rsp]
  006a2	76 0f		 jbe	 SHORT $LN24@stbtt__fil

; 3186 :                   y_crossing = y_bottom;

  006a4	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  006aa	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR y_crossing$24[rsp], xmm0
$LN24@stbtt__fil:

; 3187 : 
; 3188 :                sign = e->direction;

  006b3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  006bb	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  006c0	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR sign$25[rsp], xmm0

; 3189 : 
; 3190 :                // area of the rectangle covered from sy0..y_crossing
; 3191 :                area = sign * (y_crossing-sy0);

  006c9	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y_crossing$24[rsp]
  006d2	f3 0f 5c 44 24
	70		 subss	 xmm0, DWORD PTR sy0$12[rsp]
  006d8	f3 0f 10 8c 24
	a4 00 00 00	 movss	 xmm1, DWORD PTR sign$25[rsp]
  006e1	f3 0f 59 c8	 mulss	 xmm1, xmm0
  006e5	0f 28 c1	 movaps	 xmm0, xmm1
  006e8	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR area$20[rsp], xmm0

; 3192 : 
; 3193 :                // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
; 3194 :                scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);

  006f1	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR x1$19[rsp]
  006f9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv237[rsp], rax
  00701	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR x1$19[rsp]
  00708	ff c1		 inc	 ecx
  0070a	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0070e	f3 0f 5c 44 24
	58		 subss	 xmm0, DWORD PTR x_top$6[rsp]
  00714	0f 28 c8	 movaps	 xmm1, xmm0
  00717	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR area$20[rsp]
  00720	e8 00 00 00 00	 call	 ?stbtt__sized_triangle_area@@YAMMM@Z ; stbtt__sized_triangle_area
  00725	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR scanline$[rsp]
  0072d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv237[rsp]
  00735	f3 0f 10 0c 88	 movss	 xmm1, DWORD PTR [rax+rcx*4]
  0073a	f3 0f 58 c8	 addss	 xmm1, xmm0
  0073e	0f 28 c1	 movaps	 xmm0, xmm1
  00741	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR x1$19[rsp]
  00749	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00751	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 3195 : 
; 3196 :                // check if final y_crossing is blown up; no test case for this
; 3197 :                if (y_final > y_bottom) {

  00756	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR y_final$23[rsp]
  0075f	0f 2f 44 24 50	 comiss	 xmm0, DWORD PTR y_bottom$[rsp]
  00764	76 43		 jbe	 SHORT $LN25@stbtt__fil

; 3198 :                   y_final = y_bottom;

  00766	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  0076c	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR y_final$23[rsp], xmm0

; 3199 :                   dy = (y_final - y_crossing ) / (x2 - (x1+1)); // if denom=0, y_final = y_crossing, so y_final <= y_bottom

  00775	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR y_final$23[rsp]
  0077e	f3 0f 5c 84 24
	a0 00 00 00	 subss	 xmm0, DWORD PTR y_crossing$24[rsp]
  00787	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x1$19[rsp]
  0078e	ff c0		 inc	 eax
  00790	8b 4c 24 64	 mov	 ecx, DWORD PTR x2$9[rsp]
  00794	2b c8		 sub	 ecx, eax
  00796	8b c1		 mov	 eax, ecx
  00798	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  0079c	f3 0f 5e c1	 divss	 xmm0, xmm1
  007a0	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR dy$16[rsp], xmm0
$LN25@stbtt__fil:

; 3200 :                }
; 3201 : 
; 3202 :                // in second pixel, area covered by line segment found in first pixel
; 3203 :                // is always a rectangle 1 wide * the height of that line segment; this
; 3204 :                // is exactly what the variable 'area' stores. it also gets a contribution
; 3205 :                // from the line segment within it. the THIRD pixel will get the first
; 3206 :                // pixel's rectangle contribution, the second pixel's rectangle contribution,
; 3207 :                // and its own contribution. the 'own contribution' is the same in every pixel except
; 3208 :                // the leftmost and rightmost, a trapezoid that slides down in each pixel.
; 3209 :                // the second pixel's contribution to the third pixel will be the
; 3210 :                // rectangle 1 wide times the height change in the second pixel, which is dy.
; 3211 : 
; 3212 :                step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,

  007a9	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR sign$25[rsp]
  007b2	f3 0f 59 84 24
	80 00 00 00	 mulss	 xmm0, DWORD PTR dy$16[rsp]
  007bb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  007c3	f3 0f 11 84 24
	b0 00 00 00	 movss	 DWORD PTR step$28[rsp], xmm0

; 3213 :                // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
; 3214 :                // so the area advances by 'step' every time
; 3215 : 
; 3216 :                for (x = x1+1; x < x2; ++x) {

  007cc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x1$19[rsp]
  007d3	ff c0		 inc	 eax
  007d5	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$22[rsp], eax
  007dc	eb 10		 jmp	 SHORT $LN6@stbtt__fil
$LN4@stbtt__fil:
  007de	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x$22[rsp]
  007e5	ff c0		 inc	 eax
  007e7	89 84 24 98 00
	00 00		 mov	 DWORD PTR x$22[rsp], eax
$LN6@stbtt__fil:
  007ee	8b 44 24 64	 mov	 eax, DWORD PTR x2$9[rsp]
  007f2	39 84 24 98 00
	00 00		 cmp	 DWORD PTR x$22[rsp], eax
  007f9	7d 72		 jge	 SHORT $LN5@stbtt__fil

; 3217 :                   scanline[x] += area + step/2; // area of trapezoid is 1*step/2

  007fb	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR x$22[rsp]
  00803	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR step$28[rsp]
  0080c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00814	f3 0f 10 8c 24
	90 00 00 00	 movss	 xmm1, DWORD PTR area$20[rsp]
  0081d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00821	0f 28 c1	 movaps	 xmm0, xmm1
  00824	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  0082c	f3 0f 10 0c 81	 movss	 xmm1, DWORD PTR [rcx+rax*4]
  00831	f3 0f 58 c8	 addss	 xmm1, xmm0
  00835	0f 28 c1	 movaps	 xmm0, xmm1
  00838	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR x$22[rsp]
  00840	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00848	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 3218 :                   area += step;

  0084d	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR area$20[rsp]
  00856	f3 0f 58 84 24
	b0 00 00 00	 addss	 xmm0, DWORD PTR step$28[rsp]
  0085f	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR area$20[rsp], xmm0

; 3219 :                }

  00868	e9 71 ff ff ff	 jmp	 $LN4@stbtt__fil
$LN5@stbtt__fil:

; 3220 :                STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down

  0086d	f3 0f 5a 84 24
	90 00 00 00	 cvtss2sd xmm0, DWORD PTR area$20[rsp]
  00876	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  0087d	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff028f5c0000000
  00885	66 0f 2f c8	 comisd	 xmm1, xmm0
  00889	73 1b		 jae	 SHORT $LN46@stbtt__fil
  0088b	41 b8 94 0c 00
	00		 mov	 r8d, 3220		; 00000c94H
  00891	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42796
  00898	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42797
  0089f	e8 00 00 00 00	 call	 _wassert
  008a4	33 c0		 xor	 eax, eax
$LN46@stbtt__fil:

; 3221 :                STBTT_assert(sy1 > y_final-0.01f);

  008a6	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR y_final$23[rsp]
  008af	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3c23d70a
  008b7	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR sy1$10[rsp]
  008bd	0f 2f c8	 comiss	 xmm1, xmm0
  008c0	77 1b		 ja	 SHORT $LN47@stbtt__fil
  008c2	41 b8 95 0c 00
	00		 mov	 r8d, 3221		; 00000c95H
  008c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42798
  008cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42799
  008d6	e8 00 00 00 00	 call	 _wassert
  008db	33 c0		 xor	 eax, eax
$LN47@stbtt__fil:

; 3222 : 
; 3223 :                // area covered in the last pixel is the rectangle from all the pixels to the left,
; 3224 :                // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
; 3225 :                scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

  008dd	48 63 44 24 64	 movsxd	 rax, DWORD PTR x2$9[rsp]
  008e2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv285[rsp], rax
  008ea	f3 0f 2a 44 24
	64		 cvtsi2ss xmm0, DWORD PTR x2$9[rsp]
  008f0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  008f8	f3 0f 2a 4c 24
	64		 cvtsi2ss xmm1, DWORD PTR x2$9[rsp]
  008fe	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
  00906	f3 0f 2a 54 24
	64		 cvtsi2ss xmm2, DWORD PTR x2$9[rsp]
  0090c	f3 0f 11 94 24
	b4 00 00 00	 movss	 DWORD PTR tv296[rsp], xmm2
  00915	f3 0f 10 5c 24
	68		 movss	 xmm3, DWORD PTR sy1$10[rsp]
  0091b	f3 0f 5c 9c 24
	9c 00 00 00	 subss	 xmm3, DWORD PTR y_final$23[rsp]
  00924	f3 0f 11 9c 24
	b8 00 00 00	 movss	 DWORD PTR tv298[rsp], xmm3
  0092d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00933	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR x_bottom$8[rsp]
  00939	0f 28 d1	 movaps	 xmm2, xmm1
  0093c	f3 0f 10 84 24
	b4 00 00 00	 movss	 xmm0, DWORD PTR tv296[rsp]
  00945	0f 28 c8	 movaps	 xmm1, xmm0
  00948	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR tv298[rsp]
  00951	e8 00 00 00 00	 call	 ?stbtt__position_trapezoid_area@@YAMMMMMM@Z ; stbtt__position_trapezoid_area
  00956	f3 0f 10 8c 24
	a4 00 00 00	 movss	 xmm1, DWORD PTR sign$25[rsp]
  0095f	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00963	0f 28 c1	 movaps	 xmm0, xmm1
  00966	f3 0f 10 8c 24
	90 00 00 00	 movss	 xmm1, DWORD PTR area$20[rsp]
  0096f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00973	0f 28 c1	 movaps	 xmm0, xmm1
  00976	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR scanline$[rsp]
  0097e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv285[rsp]
  00986	f3 0f 10 0c 88	 movss	 xmm1, DWORD PTR [rax+rcx*4]
  0098b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0098f	0f 28 c1	 movaps	 xmm0, xmm1
  00992	48 63 44 24 64	 movsxd	 rax, DWORD PTR x2$9[rsp]
  00997	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  0099f	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 3226 : 
; 3227 :                // the rest of the line is filled based on the total height of the line segment in this pixel
; 3228 :                scanline_fill[x2] += sign * (sy1-sy0);

  009a4	48 63 44 24 64	 movsxd	 rax, DWORD PTR x2$9[rsp]
  009a9	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR sy1$10[rsp]
  009af	f3 0f 5c 44 24
	70		 subss	 xmm0, DWORD PTR sy0$12[rsp]
  009b5	f3 0f 10 8c 24
	a4 00 00 00	 movss	 xmm1, DWORD PTR sign$25[rsp]
  009be	f3 0f 59 c8	 mulss	 xmm1, xmm0
  009c2	0f 28 c1	 movaps	 xmm0, xmm1
  009c5	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR scanline_fill$[rsp]
  009cd	f3 0f 10 0c 81	 movss	 xmm1, DWORD PTR [rcx+rax*4]
  009d2	f3 0f 58 c8	 addss	 xmm1, xmm0
  009d6	0f 28 c1	 movaps	 xmm0, xmm1
  009d9	48 63 44 24 64	 movsxd	 rax, DWORD PTR x2$9[rsp]
  009de	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR scanline_fill$[rsp]
  009e6	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
$LN22@stbtt__fil:

; 3229 :             }
; 3230 :          } else {

  009eb	e9 ba 05 00 00	 jmp	 $LN20@stbtt__fil
$LN19@stbtt__fil:

; 3231 :             // if edge goes outside of box we're drawing, we require
; 3232 :             // clipping logic. since this does not match the intended use
; 3233 :             // of this library, we use a different, very slow brute
; 3234 :             // force implementation
; 3235 :             // note though that this does happen some of the time because
; 3236 :             // x_top and x_bottom can be extrapolated at the top & bottom of
; 3237 :             // the shape and actually lie outside the bounding box
; 3238 :             int x;
; 3239 :             for (x=0; x < len; ++x) {

  009f0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR x$2[rsp], 0
  009f8	eb 0a		 jmp	 SHORT $LN9@stbtt__fil
$LN7@stbtt__fil:
  009fa	8b 44 24 44	 mov	 eax, DWORD PTR x$2[rsp]
  009fe	ff c0		 inc	 eax
  00a00	89 44 24 44	 mov	 DWORD PTR x$2[rsp], eax
$LN9@stbtt__fil:
  00a04	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00a0b	39 44 24 44	 cmp	 DWORD PTR x$2[rsp], eax
  00a0f	0f 8d 95 05 00
	00		 jge	 $LN8@stbtt__fil

; 3240 :                // cases:
; 3241 :                //
; 3242 :                // there can be up to two intersections with the pixel. any intersection
; 3243 :                // with left or right edges can be handled by splitting into two (or three)
; 3244 :                // regions. intersections with top & bottom do not necessitate case-wise logic.
; 3245 :                //
; 3246 :                // the old way of doing this found the intersections with the left & right edges,
; 3247 :                // then used some simple logic to produce up to three segments in sorted order
; 3248 :                // from top-to-bottom. however, this had a problem: if an x edge was epsilon
; 3249 :                // across the x border, then the corresponding y position might not be distinct
; 3250 :                // from the other y segment, and it might ignored as an empty segment. to avoid
; 3251 :                // that, we need to explicitly produce segments based on x positions.
; 3252 : 
; 3253 :                // rename variables to clearly-defined pairs
; 3254 :                float y0 = y_top;

  00a15	f3 0f 10 84 24
	10 01 00 00	 movss	 xmm0, DWORD PTR y_top$[rsp]
  00a1e	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR y0$18[rsp], xmm0

; 3255 :                float x1 = (float) (x);

  00a27	f3 0f 2a 44 24
	44		 cvtsi2ss xmm0, DWORD PTR x$2[rsp]
  00a2d	f3 0f 11 44 24
	48		 movss	 DWORD PTR x1$3[rsp], xmm0

; 3256 :                float x2 = (float) (x+1);

  00a33	8b 44 24 44	 mov	 eax, DWORD PTR x$2[rsp]
  00a37	ff c0		 inc	 eax
  00a39	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a3d	f3 0f 11 44 24
	4c		 movss	 DWORD PTR x2$4[rsp], xmm0

; 3257 :                float x3 = xb;

  00a43	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR xb$26[rsp]
  00a4c	f3 0f 11 44 24
	54		 movss	 DWORD PTR x3$5[rsp], xmm0

; 3258 :                float y3 = y_bottom;

  00a52	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y_bottom$[rsp]
  00a58	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR y3$17[rsp], xmm0

; 3259 : 
; 3260 :                // x = e->x + e->dx * (y-y_top)
; 3261 :                // (y-y_top) = (x - e->x) / e->dx
; 3262 :                // y = (x - e->x) / e->dx + y_top
; 3263 :                float y1 = (x - x0) / dx + y_top;

  00a61	f3 0f 2a 44 24
	44		 cvtsi2ss xmm0, DWORD PTR x$2[rsp]
  00a67	f3 0f 5c 44 24
	40		 subss	 xmm0, DWORD PTR x0$1[rsp]
  00a6d	f3 0f 5e 44 24
	74		 divss	 xmm0, DWORD PTR dx$13[rsp]
  00a73	f3 0f 58 84 24
	10 01 00 00	 addss	 xmm0, DWORD PTR y_top$[rsp]
  00a7c	f3 0f 11 44 24
	78		 movss	 DWORD PTR y1$14[rsp], xmm0

; 3264 :                float y2 = (x+1 - x0) / dx + y_top;

  00a82	8b 44 24 44	 mov	 eax, DWORD PTR x$2[rsp]
  00a86	ff c0		 inc	 eax
  00a88	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a8c	f3 0f 5c 44 24
	40		 subss	 xmm0, DWORD PTR x0$1[rsp]
  00a92	f3 0f 5e 44 24
	74		 divss	 xmm0, DWORD PTR dx$13[rsp]
  00a98	f3 0f 58 84 24
	10 01 00 00	 addss	 xmm0, DWORD PTR y_top$[rsp]
  00aa1	f3 0f 11 44 24
	7c		 movss	 DWORD PTR y2$15[rsp], xmm0

; 3265 : 
; 3266 :                if (x0 < x1 && x3 > x2) {         // three segments descending down-right

  00aa7	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00aad	0f 2f 44 24 40	 comiss	 xmm0, DWORD PTR x0$1[rsp]
  00ab2	0f 86 e5 00 00
	00		 jbe	 $LN26@stbtt__fil
  00ab8	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00abe	0f 2f 44 24 4c	 comiss	 xmm0, DWORD PTR x2$4[rsp]
  00ac3	0f 86 d4 00 00
	00		 jbe	 $LN26@stbtt__fil

; 3267 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

  00ac9	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00acf	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00ad5	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00adb	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00ae1	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00aea	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00af0	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00af6	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00afe	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00b02	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00b0a	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3268 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);

  00b0f	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00b15	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00b1b	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR x2$4[rsp]
  00b21	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00b27	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00b2d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00b33	f3 0f 10 5c 24
	48		 movss	 xmm3, DWORD PTR x1$3[rsp]
  00b39	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00b41	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00b45	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00b4d	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3269 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

  00b52	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00b5b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00b61	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00b67	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00b6d	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00b73	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00b79	f3 0f 10 5c 24
	4c		 movss	 xmm3, DWORD PTR x2$4[rsp]
  00b7f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00b87	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00b8b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00b93	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00b98	e9 08 04 00 00	 jmp	 $LN27@stbtt__fil
$LN26@stbtt__fil:

; 3270 :                } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left

  00b9d	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00ba3	0f 2f 44 24 54	 comiss	 xmm0, DWORD PTR x3$5[rsp]
  00ba8	0f 86 e5 00 00
	00		 jbe	 $LN28@stbtt__fil
  00bae	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR x0$1[rsp]
  00bb4	0f 2f 44 24 4c	 comiss	 xmm0, DWORD PTR x2$4[rsp]
  00bb9	0f 86 d4 00 00
	00		 jbe	 $LN28@stbtt__fil

; 3271 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

  00bbf	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00bc5	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00bcb	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR x2$4[rsp]
  00bd1	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00bd7	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00be0	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00be6	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00bec	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00bf4	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00bf8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00c00	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3272 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);

  00c05	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00c0b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00c11	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00c17	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00c1d	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00c23	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00c29	f3 0f 10 5c 24
	4c		 movss	 xmm3, DWORD PTR x2$4[rsp]
  00c2f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00c37	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00c3b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00c43	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3273 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

  00c48	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00c51	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00c57	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00c5d	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00c63	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00c69	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00c6f	f3 0f 10 5c 24
	48		 movss	 xmm3, DWORD PTR x1$3[rsp]
  00c75	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00c7d	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00c81	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00c89	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00c8e	e9 12 03 00 00	 jmp	 $LN29@stbtt__fil
$LN28@stbtt__fil:

; 3274 :                } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right

  00c93	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00c99	0f 2f 44 24 40	 comiss	 xmm0, DWORD PTR x0$1[rsp]
  00c9e	0f 86 a2 00 00
	00		 jbe	 $LN30@stbtt__fil
  00ca4	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00caa	0f 2f 44 24 48	 comiss	 xmm0, DWORD PTR x1$3[rsp]
  00caf	0f 86 91 00 00
	00		 jbe	 $LN30@stbtt__fil

; 3275 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

  00cb5	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00cbb	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00cc1	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00cc7	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00ccd	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00cd6	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00cdc	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00ce2	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00cea	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00cee	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00cf6	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3276 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

  00cfb	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00d04	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00d0a	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00d10	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00d16	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00d1c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00d22	f3 0f 10 5c 24
	48		 movss	 xmm3, DWORD PTR x1$3[rsp]
  00d28	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00d30	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00d34	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00d3c	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00d41	e9 5f 02 00 00	 jmp	 $LN31@stbtt__fil
$LN30@stbtt__fil:

; 3277 :                } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left

  00d46	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00d4c	0f 2f 44 24 54	 comiss	 xmm0, DWORD PTR x3$5[rsp]
  00d51	0f 86 a2 00 00
	00		 jbe	 $LN32@stbtt__fil
  00d57	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR x0$1[rsp]
  00d5d	0f 2f 44 24 48	 comiss	 xmm0, DWORD PTR x1$3[rsp]
  00d62	0f 86 91 00 00
	00		 jbe	 $LN32@stbtt__fil

; 3278 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

  00d68	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00d6e	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00d74	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x1$3[rsp]
  00d7a	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00d80	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00d89	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00d8f	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00d95	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00d9d	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00da1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00da9	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3279 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

  00dae	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00db7	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00dbd	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00dc3	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00dc9	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR y1$14[rsp]
  00dcf	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00dd5	f3 0f 10 5c 24
	48		 movss	 xmm3, DWORD PTR x1$3[rsp]
  00ddb	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00de3	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00de7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00def	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00df4	e9 ac 01 00 00	 jmp	 $LN33@stbtt__fil
$LN32@stbtt__fil:

; 3280 :                } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right

  00df9	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR x2$4[rsp]
  00dff	0f 2f 44 24 40	 comiss	 xmm0, DWORD PTR x0$1[rsp]
  00e04	0f 86 a2 00 00
	00		 jbe	 $LN34@stbtt__fil
  00e0a	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00e10	0f 2f 44 24 4c	 comiss	 xmm0, DWORD PTR x2$4[rsp]
  00e15	0f 86 91 00 00
	00		 jbe	 $LN34@stbtt__fil

; 3281 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

  00e1b	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00e21	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00e27	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR x2$4[rsp]
  00e2d	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00e33	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00e3c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00e42	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00e48	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00e50	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00e54	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00e5c	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3282 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

  00e61	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00e6a	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00e70	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00e76	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00e7c	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00e82	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00e88	f3 0f 10 5c 24
	4c		 movss	 xmm3, DWORD PTR x2$4[rsp]
  00e8e	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00e96	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00e9a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00ea2	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00ea7	e9 f9 00 00 00	 jmp	 $LN35@stbtt__fil
$LN34@stbtt__fil:

; 3283 :                } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left

  00eac	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR x2$4[rsp]
  00eb2	0f 2f 44 24 54	 comiss	 xmm0, DWORD PTR x3$5[rsp]
  00eb7	0f 86 9f 00 00
	00		 jbe	 $LN36@stbtt__fil
  00ebd	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR x0$1[rsp]
  00ec3	0f 2f 44 24 4c	 comiss	 xmm0, DWORD PTR x2$4[rsp]
  00ec8	0f 86 8e 00 00
	00		 jbe	 $LN36@stbtt__fil

; 3284 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

  00ece	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00ed4	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00eda	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR x2$4[rsp]
  00ee0	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00ee6	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00eef	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00ef5	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00efb	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00f03	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00f07	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00f0f	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3285 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

  00f14	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00f1d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00f23	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00f29	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00f2f	f3 0f 10 44 24
	7c		 movss	 xmm0, DWORD PTR y2$15[rsp]
  00f35	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00f3b	f3 0f 10 5c 24
	4c		 movss	 xmm3, DWORD PTR x2$4[rsp]
  00f41	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00f49	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00f4d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00f55	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3286 :                } else {  // one segment

  00f5a	eb 49		 jmp	 SHORT $LN37@stbtt__fil
$LN36@stbtt__fil:

; 3287 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);

  00f5c	f3 0f 10 84 24
	84 00 00 00	 movss	 xmm0, DWORD PTR y3$17[rsp]
  00f65	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00f6b	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR x3$5[rsp]
  00f71	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00f77	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR y0$18[rsp]
  00f80	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00f86	f3 0f 10 5c 24
	40		 movss	 xmm3, DWORD PTR x0$1[rsp]
  00f8c	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR e$[rsp]
  00f94	8b 54 24 44	 mov	 edx, DWORD PTR x$2[rsp]
  00f98	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR scanline$[rsp]
  00fa0	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
$LN37@stbtt__fil:
$LN35@stbtt__fil:
$LN33@stbtt__fil:
$LN31@stbtt__fil:
$LN29@stbtt__fil:
$LN27@stbtt__fil:

; 3288 :                }
; 3289 :             }

  00fa5	e9 50 fa ff ff	 jmp	 $LN7@stbtt__fil
$LN8@stbtt__fil:
$LN20@stbtt__fil:
$LN11@stbtt__fil:

; 3290 :          }
; 3291 :       }
; 3292 :       e = e->next;

  00faa	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00fb2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00fb5	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR e$[rsp], rax

; 3293 :    }

  00fbd	e9 70 f0 ff ff	 jmp	 $LN2@stbtt__fil
$LN3@stbtt__fil:

; 3294 : }

  00fc2	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00fc9	c3		 ret	 0
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ENDP ; stbtt__fill_active_edges_new
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
height$ = 8
width$ = 16
?stbtt__sized_triangle_area@@YAMMM@Z PROC		; stbtt__sized_triangle_area

; 3078 : {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0

; 3079 :    return height * width / 2;

  0000c	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR height$[rsp]
  00012	f3 0f 59 44 24
	10		 mulss	 xmm0, DWORD PTR width$[rsp]
  00018	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000

; 3080 : }

  00020	c3		 ret	 0
?stbtt__sized_triangle_area@@YAMMM@Z ENDP		; stbtt__sized_triangle_area
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
height$ = 48
tx0$ = 56
tx1$ = 64
bx0$ = 72
bx1$ = 80
?stbtt__position_trapezoid_area@@YAMMMMMM@Z PROC	; stbtt__position_trapezoid_area

; 3073 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00018	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3074 :    return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);

  0001c	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR bx1$[rsp]
  00022	f3 0f 5c 44 24
	48		 subss	 xmm0, DWORD PTR bx0$[rsp]
  00028	f3 0f 10 4c 24
	40		 movss	 xmm1, DWORD PTR tx1$[rsp]
  0002e	f3 0f 5c 4c 24
	38		 subss	 xmm1, DWORD PTR tx0$[rsp]
  00034	0f 28 d0	 movaps	 xmm2, xmm0
  00037	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR height$[rsp]
  0003d	e8 00 00 00 00	 call	 ?stbtt__sized_trapezoid_area@@YAMMMM@Z ; stbtt__sized_trapezoid_area

; 3075 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
?stbtt__position_trapezoid_area@@YAMMMMMM@Z ENDP	; stbtt__position_trapezoid_area
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
height$ = 48
top_width$ = 56
bottom_width$ = 64
?stbtt__sized_trapezoid_area@@YAMMMM@Z PROC		; stbtt__sized_trapezoid_area

; 3066 : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3067 :    STBTT_assert(top_width >= 0);

  00016	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR top_width$[rsp]
  0001c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00023	73 1b		 jae	 SHORT $LN3@stbtt__siz
  00025	41 b8 fb 0b 00
	00		 mov	 r8d, 3067		; 00000bfbH
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42687
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42688
  00039	e8 00 00 00 00	 call	 _wassert
  0003e	33 c0		 xor	 eax, eax
$LN3@stbtt__siz:

; 3068 :    STBTT_assert(bottom_width >= 0);

  00040	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR bottom_width$[rsp]
  00046	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0004d	73 1b		 jae	 SHORT $LN4@stbtt__siz
  0004f	41 b8 fc 0b 00
	00		 mov	 r8d, 3068		; 00000bfcH
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42689
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42690
  00063	e8 00 00 00 00	 call	 _wassert
  00068	33 c0		 xor	 eax, eax
$LN4@stbtt__siz:

; 3069 :    return (top_width + bottom_width) / 2.0f * height;

  0006a	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR top_width$[rsp]
  00070	f3 0f 58 44 24
	40		 addss	 xmm0, DWORD PTR bottom_width$[rsp]
  00076	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0007e	f3 0f 59 44 24
	30		 mulss	 xmm0, DWORD PTR height$[rsp]

; 3070 : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
?stbtt__sized_trapezoid_area@@YAMMMM@Z ENDP		; stbtt__sized_trapezoid_area
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
scanline$ = 48
x$ = 56
e$ = 64
x0$ = 72
y0$ = 80
x1$ = 88
y1$ = 96
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z PROC ; stbtt__handle_clipped_edge

; 3029 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3030 :    if (y0 == y1) return;

  00018	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y0$[rsp]
  0001e	0f 2e 44 24 60	 ucomiss xmm0, DWORD PTR y1$[rsp]
  00023	7a 07		 jp	 SHORT $LN2@stbtt__han
  00025	75 05		 jne	 SHORT $LN2@stbtt__han
  00027	e9 0c 04 00 00	 jmp	 $LN1@stbtt__han
$LN2@stbtt__han:

; 3031 :    STBTT_assert(y0 < y1);

  0002c	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y1$[rsp]
  00032	0f 2f 44 24 50	 comiss	 xmm0, DWORD PTR y0$[rsp]
  00037	77 1b		 ja	 SHORT $LN20@stbtt__han
  00039	41 b8 d7 0b 00
	00		 mov	 r8d, 3031		; 00000bd7H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42646
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42647
  0004d	e8 00 00 00 00	 call	 _wassert
  00052	33 c0		 xor	 eax, eax
$LN20@stbtt__han:

; 3032 :    STBTT_assert(e->sy <= e->ey);

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR e$[rsp]
  0005e	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  00063	0f 2f 41 18	 comiss	 xmm0, DWORD PTR [rcx+24]
  00067	73 1b		 jae	 SHORT $LN21@stbtt__han
  00069	41 b8 d8 0b 00
	00		 mov	 r8d, 3032		; 00000bd8H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42648
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42649
  0007d	e8 00 00 00 00	 call	 _wassert
  00082	33 c0		 xor	 eax, eax
$LN21@stbtt__han:

; 3033 :    if (y0 > e->ey) return;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  00089	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR y0$[rsp]
  0008f	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  00093	76 05		 jbe	 SHORT $LN3@stbtt__han
  00095	e9 9e 03 00 00	 jmp	 $LN1@stbtt__han
$LN3@stbtt__han:

; 3034 :    if (y1 < e->sy) return;

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  0009f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  000a4	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR y1$[rsp]
  000a9	76 05		 jbe	 SHORT $LN4@stbtt__han
  000ab	e9 88 03 00 00	 jmp	 $LN1@stbtt__han
$LN4@stbtt__han:

; 3035 :    if (y0 < e->sy) {

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  000b5	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  000ba	0f 2f 44 24 50	 comiss	 xmm0, DWORD PTR y0$[rsp]
  000bf	76 53		 jbe	 SHORT $LN5@stbtt__han

; 3036 :       x0 += (x1-x0) * (e->sy - y0) / (y1-y0);

  000c1	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR x1$[rsp]
  000c7	f3 0f 5c 44 24
	48		 subss	 xmm0, DWORD PTR x0$[rsp]
  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  000d2	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [rax+24]
  000d7	f3 0f 5c 4c 24
	50		 subss	 xmm1, DWORD PTR y0$[rsp]
  000dd	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000e1	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR y1$[rsp]
  000e7	f3 0f 5c 4c 24
	50		 subss	 xmm1, DWORD PTR y0$[rsp]
  000ed	f3 0f 5e c1	 divss	 xmm0, xmm1
  000f1	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR x0$[rsp]
  000f7	f3 0f 58 c8	 addss	 xmm1, xmm0
  000fb	0f 28 c1	 movaps	 xmm0, xmm1
  000fe	f3 0f 11 44 24
	48		 movss	 DWORD PTR x0$[rsp], xmm0

; 3037 :       y0 = e->sy;

  00104	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  00109	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  0010e	f3 0f 11 44 24
	50		 movss	 DWORD PTR y0$[rsp], xmm0
$LN5@stbtt__han:

; 3038 :    }
; 3039 :    if (y1 > e->ey) {

  00114	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  00119	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y1$[rsp]
  0011f	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [rax+28]
  00123	76 53		 jbe	 SHORT $LN6@stbtt__han

; 3040 :       x1 += (x1-x0) * (e->ey - y1) / (y1-y0);

  00125	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR x1$[rsp]
  0012b	f3 0f 5c 44 24
	48		 subss	 xmm0, DWORD PTR x0$[rsp]
  00131	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  00136	f3 0f 10 48 1c	 movss	 xmm1, DWORD PTR [rax+28]
  0013b	f3 0f 5c 4c 24
	60		 subss	 xmm1, DWORD PTR y1$[rsp]
  00141	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00145	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR y1$[rsp]
  0014b	f3 0f 5c 4c 24
	50		 subss	 xmm1, DWORD PTR y0$[rsp]
  00151	f3 0f 5e c1	 divss	 xmm0, xmm1
  00155	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x1$[rsp]
  0015b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0015f	0f 28 c1	 movaps	 xmm0, xmm1
  00162	f3 0f 11 44 24
	58		 movss	 DWORD PTR x1$[rsp], xmm0

; 3041 :       y1 = e->ey;

  00168	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  0016d	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  00172	f3 0f 11 44 24
	60		 movss	 DWORD PTR y1$[rsp], xmm0
$LN6@stbtt__han:

; 3042 :    }
; 3043 : 
; 3044 :    if (x0 == x)

  00178	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  0017e	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR x0$[rsp]
  00184	0f 2e c8	 ucomiss xmm1, xmm0
  00187	7a 33		 jp	 SHORT $LN7@stbtt__han
  00189	75 31		 jne	 SHORT $LN7@stbtt__han

; 3045 :       STBTT_assert(x1 <= x+1);

  0018b	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  0018f	ff c0		 inc	 eax
  00191	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00195	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR x1$[rsp]
  0019a	73 1b		 jae	 SHORT $LN22@stbtt__han
  0019c	41 b8 e5 0b 00
	00		 mov	 r8d, 3045		; 00000be5H
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42656
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42657
  001b0	e8 00 00 00 00	 call	 _wassert
  001b5	33 c0		 xor	 eax, eax
$LN22@stbtt__han:
  001b7	e9 06 01 00 00	 jmp	 $LN8@stbtt__han
$LN7@stbtt__han:

; 3046 :    else if (x0 == x+1)

  001bc	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  001c0	ff c0		 inc	 eax
  001c2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001c6	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR x0$[rsp]
  001cc	0f 2e c8	 ucomiss xmm1, xmm0
  001cf	7a 33		 jp	 SHORT $LN9@stbtt__han
  001d1	75 31		 jne	 SHORT $LN9@stbtt__han

; 3047 :       STBTT_assert(x1 >= x);

  001d3	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  001d9	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x1$[rsp]
  001df	0f 2f c8	 comiss	 xmm1, xmm0
  001e2	73 1b		 jae	 SHORT $LN23@stbtt__han
  001e4	41 b8 e7 0b 00
	00		 mov	 r8d, 3047		; 00000be7H
  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42660
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42661
  001f8	e8 00 00 00 00	 call	 _wassert
  001fd	33 c0		 xor	 eax, eax
$LN23@stbtt__han:
  001ff	e9 be 00 00 00	 jmp	 $LN10@stbtt__han
$LN9@stbtt__han:

; 3048 :    else if (x0 <= x)

  00204	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  0020a	0f 2f 44 24 48	 comiss	 xmm0, DWORD PTR x0$[rsp]
  0020f	72 2d		 jb	 SHORT $LN11@stbtt__han

; 3049 :       STBTT_assert(x1 <= x);

  00211	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  00217	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR x1$[rsp]
  0021c	73 1b		 jae	 SHORT $LN24@stbtt__han
  0021e	41 b8 e9 0b 00
	00		 mov	 r8d, 3049		; 00000be9H
  00224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42664
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42665
  00232	e8 00 00 00 00	 call	 _wassert
  00237	33 c0		 xor	 eax, eax
$LN24@stbtt__han:
  00239	e9 84 00 00 00	 jmp	 $LN12@stbtt__han
$LN11@stbtt__han:

; 3050 :    else if (x0 >= x+1)

  0023e	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  00242	ff c0		 inc	 eax
  00244	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00248	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR x0$[rsp]
  0024e	0f 2f c8	 comiss	 xmm1, xmm0
  00251	72 32		 jb	 SHORT $LN13@stbtt__han

; 3051 :       STBTT_assert(x1 >= x+1);

  00253	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  00257	ff c0		 inc	 eax
  00259	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0025d	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x1$[rsp]
  00263	0f 2f c8	 comiss	 xmm1, xmm0
  00266	73 1b		 jae	 SHORT $LN25@stbtt__han
  00268	41 b8 eb 0b 00
	00		 mov	 r8d, 3051		; 00000bebH
  0026e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42668
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42669
  0027c	e8 00 00 00 00	 call	 _wassert
  00281	33 c0		 xor	 eax, eax
$LN25@stbtt__han:
  00283	eb 3d		 jmp	 SHORT $LN14@stbtt__han
$LN13@stbtt__han:

; 3052 :    else
; 3053 :       STBTT_assert(x1 >= x && x1 <= x+1);

  00285	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  0028b	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x1$[rsp]
  00291	0f 2f c8	 comiss	 xmm1, xmm0
  00294	72 11		 jb	 SHORT $LN26@stbtt__han
  00296	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  0029a	ff c0		 inc	 eax
  0029c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002a0	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR x1$[rsp]
  002a5	73 1b		 jae	 SHORT $LN27@stbtt__han
$LN26@stbtt__han:
  002a7	41 b8 ed 0b 00
	00		 mov	 r8d, 3053		; 00000bedH
  002ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42670
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42671
  002bb	e8 00 00 00 00	 call	 _wassert
  002c0	33 c0		 xor	 eax, eax
$LN27@stbtt__han:
$LN14@stbtt__han:
$LN12@stbtt__han:
$LN10@stbtt__han:
$LN8@stbtt__han:

; 3054 : 
; 3055 :    if (x0 <= x && x1 <= x)

  002c2	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  002c8	0f 2f 44 24 48	 comiss	 xmm0, DWORD PTR x0$[rsp]
  002cd	72 54		 jb	 SHORT $LN15@stbtt__han
  002cf	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  002d5	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR x1$[rsp]
  002da	72 47		 jb	 SHORT $LN15@stbtt__han

; 3056 :       scanline[x] += e->direction * (y1-y0);

  002dc	48 63 44 24 38	 movsxd	 rax, DWORD PTR x$[rsp]
  002e1	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y1$[rsp]
  002e7	f3 0f 5c 44 24
	50		 subss	 xmm0, DWORD PTR y0$[rsp]
  002ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR e$[rsp]
  002f2	f3 0f 10 49 14	 movss	 xmm1, DWORD PTR [rcx+20]
  002f7	f3 0f 59 c8	 mulss	 xmm1, xmm0
  002fb	0f 28 c1	 movaps	 xmm0, xmm1
  002fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scanline$[rsp]
  00303	f3 0f 10 0c 81	 movss	 xmm1, DWORD PTR [rcx+rax*4]
  00308	f3 0f 58 c8	 addss	 xmm1, xmm0
  0030c	0f 28 c1	 movaps	 xmm0, xmm1
  0030f	48 63 44 24 38	 movsxd	 rax, DWORD PTR x$[rsp]
  00314	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scanline$[rsp]
  00319	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
  0031e	e9 15 01 00 00	 jmp	 $LN16@stbtt__han
$LN15@stbtt__han:

; 3057 :    else if (x0 >= x+1 && x1 >= x+1)

  00323	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  00327	ff c0		 inc	 eax
  00329	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0032d	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR x0$[rsp]
  00333	0f 2f c8	 comiss	 xmm1, xmm0
  00336	72 1a		 jb	 SHORT $LN17@stbtt__han
  00338	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  0033c	ff c0		 inc	 eax
  0033e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00342	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x1$[rsp]
  00348	0f 2f c8	 comiss	 xmm1, xmm0
  0034b	72 05		 jb	 SHORT $LN17@stbtt__han

; 3058 :       ;

  0034d	e9 e6 00 00 00	 jmp	 $LN18@stbtt__han
$LN17@stbtt__han:

; 3059 :    else {
; 3060 :       STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);

  00352	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  00358	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR x0$[rsp]
  0035e	0f 2f c8	 comiss	 xmm1, xmm0
  00361	72 33		 jb	 SHORT $LN28@stbtt__han
  00363	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  00367	ff c0		 inc	 eax
  00369	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0036d	0f 2f 44 24 48	 comiss	 xmm0, DWORD PTR x0$[rsp]
  00372	72 22		 jb	 SHORT $LN28@stbtt__han
  00374	f3 0f 2a 44 24
	38		 cvtsi2ss xmm0, DWORD PTR x$[rsp]
  0037a	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR x1$[rsp]
  00380	0f 2f c8	 comiss	 xmm1, xmm0
  00383	72 11		 jb	 SHORT $LN28@stbtt__han
  00385	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  00389	ff c0		 inc	 eax
  0038b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0038f	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR x1$[rsp]
  00394	73 1b		 jae	 SHORT $LN29@stbtt__han
$LN28@stbtt__han:
  00396	41 b8 f4 0b 00
	00		 mov	 r8d, 3060		; 00000bf4H
  0039c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42676
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42677
  003aa	e8 00 00 00 00	 call	 _wassert
  003af	33 c0		 xor	 eax, eax
$LN29@stbtt__han:

; 3061 :       scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position

  003b1	48 63 44 24 38	 movsxd	 rax, DWORD PTR x$[rsp]
  003b6	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y1$[rsp]
  003bc	f3 0f 5c 44 24
	50		 subss	 xmm0, DWORD PTR y0$[rsp]
  003c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR e$[rsp]
  003c7	f3 0f 10 49 14	 movss	 xmm1, DWORD PTR [rcx+20]
  003cc	f3 0f 59 c8	 mulss	 xmm1, xmm0
  003d0	0f 28 c1	 movaps	 xmm0, xmm1
  003d3	f3 0f 2a 4c 24
	38		 cvtsi2ss xmm1, DWORD PTR x$[rsp]
  003d9	f3 0f 10 54 24
	48		 movss	 xmm2, DWORD PTR x0$[rsp]
  003df	f3 0f 5c d1	 subss	 xmm2, xmm1
  003e3	0f 28 ca	 movaps	 xmm1, xmm2
  003e6	f3 0f 2a 54 24
	38		 cvtsi2ss xmm2, DWORD PTR x$[rsp]
  003ec	f3 0f 10 5c 24
	58		 movss	 xmm3, DWORD PTR x1$[rsp]
  003f2	f3 0f 5c da	 subss	 xmm3, xmm2
  003f6	0f 28 d3	 movaps	 xmm2, xmm3
  003f9	f3 0f 58 ca	 addss	 xmm1, xmm2
  003fd	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00405	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  0040d	f3 0f 5c d1	 subss	 xmm2, xmm1
  00411	0f 28 ca	 movaps	 xmm1, xmm2
  00414	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00418	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scanline$[rsp]
  0041d	f3 0f 10 0c 81	 movss	 xmm1, DWORD PTR [rcx+rax*4]
  00422	f3 0f 58 c8	 addss	 xmm1, xmm0
  00426	0f 28 c1	 movaps	 xmm0, xmm1
  00429	48 63 44 24 38	 movsxd	 rax, DWORD PTR x$[rsp]
  0042e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scanline$[rsp]
  00433	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
$LN18@stbtt__han:
$LN16@stbtt__han:
$LN1@stbtt__han:

; 3062 :    }
; 3063 : }

  00438	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0043c	c3		 ret	 0
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ENDP ; stbtt__handle_clipped_edge
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
dxdy$ = 32
tv85 = 36
tv131 = 40
z$ = 48
hh$ = 80
e$ = 88
off_x$ = 96
start_point$ = 104
userdata$ = 112
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z PROC ; stbtt__new_active

; 2858 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2859 :    stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);

  00019	4c 8b 44 24 70	 mov	 r8, QWORD PTR userdata$[rsp]
  0001e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hh$[rsp]
  00028	e8 00 00 00 00	 call	 ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z ; stbtt__hheap_alloc
  0002d	48 89 44 24 30	 mov	 QWORD PTR z$[rsp], rax

; 2860 :    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00037	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  0003c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00041	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [rcx]
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  0004f	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [rax+12]
  00054	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [rcx+4]
  00059	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005d	f3 0f 11 44 24
	20		 movss	 DWORD PTR dxdy$[rsp], xmm0

; 2861 :    STBTT_assert(z != NULL);

  00063	48 83 7c 24 30
	00		 cmp	 QWORD PTR z$[rsp], 0
  00069	75 1b		 jne	 SHORT $LN4@stbtt__new
  0006b	41 b8 2d 0b 00
	00		 mov	 r8d, 2861		; 00000b2dH
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42617
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42618
  0007f	e8 00 00 00 00	 call	 _wassert
  00084	33 c0		 xor	 eax, eax
$LN4@stbtt__new:

; 2862 :    //STBTT_assert(e->y0 <= start_point);
; 2863 :    if (!z) return z;

  00086	48 83 7c 24 30
	00		 cmp	 QWORD PTR z$[rsp], 0
  0008c	75 0a		 jne	 SHORT $LN2@stbtt__new
  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  00093	e9 1a 01 00 00	 jmp	 $LN1@stbtt__new
$LN2@stbtt__new:

; 2864 :    z->fdx = dxdy;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  0009d	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR dxdy$[rsp]
  000a3	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 2865 :    z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;

  000a8	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR dxdy$[rsp]
  000ae	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000b5	7a 02		 jp	 SHORT $LN9@stbtt__new
  000b7	74 16		 je	 SHORT $LN5@stbtt__new
$LN9@stbtt__new:
  000b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c1	f3 0f 5e 44 24
	20		 divss	 xmm0, DWORD PTR dxdy$[rsp]
  000c7	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv85[rsp], xmm0
  000cd	eb 09		 jmp	 SHORT $LN6@stbtt__new
$LN5@stbtt__new:
  000cf	0f 57 c0	 xorps	 xmm0, xmm0
  000d2	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv85[rsp], xmm0
$LN6@stbtt__new:
  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  000dd	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR tv85[rsp]
  000e3	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 2866 :    z->fx = e->x0 + dxdy * (start_point - e->y0);

  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  000ed	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR start_point$[rsp]
  000f3	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [rax+4]
  000f8	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR dxdy$[rsp]
  000fe	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00102	0f 28 c1	 movaps	 xmm0, xmm1
  00105	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  0010a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  0010e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00112	0f 28 c1	 movaps	 xmm0, xmm1
  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  0011a	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 2867 :    z->fx -= off_x;

  0011f	f3 0f 2a 44 24
	60		 cvtsi2ss xmm0, DWORD PTR off_x$[rsp]
  00125	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  0012a	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  0012f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00133	0f 28 c1	 movaps	 xmm0, xmm1
  00136	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  0013b	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 2868 :    z->direction = e->invert ? 1.0f : -1.0f;

  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR e$[rsp]
  00145	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00149	74 10		 je	 SHORT $LN7@stbtt__new
  0014b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00153	f3 0f 11 44 24
	28		 movss	 DWORD PTR tv131[rsp], xmm0
  00159	eb 0e		 jmp	 SHORT $LN8@stbtt__new
$LN7@stbtt__new:
  0015b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00163	f3 0f 11 44 24
	28		 movss	 DWORD PTR tv131[rsp], xmm0
$LN8@stbtt__new:
  00169	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  0016e	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR tv131[rsp]
  00174	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 2869 :    z->sy = e->y0;

  00179	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  0017e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  00183	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [rcx+4]
  00188	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 2870 :    z->ey = e->y1;

  0018d	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  00192	48 8b 4c 24 58	 mov	 rcx, QWORD PTR e$[rsp]
  00197	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [rcx+12]
  0019c	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0

; 2871 :    z->next = 0;

  001a1	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  001a6	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2872 :    return z;

  001ad	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
$LN1@stbtt__new:

; 2873 : }

  001b2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b6	c3		 ret	 0
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z ENDP ; stbtt__new_active
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
c$ = 32
n$1 = 40
hh$ = 64
userdata$ = 72
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_cleanup

; 2798 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2799 :    stbtt__hheap_chunk *c = hh->head;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR hh$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 20	 mov	 QWORD PTR c$[rsp], rax
$LN2@stbtt__hhe:

; 2800 :    while (c) {

  0001b	48 83 7c 24 20
	00		 cmp	 QWORD PTR c$[rsp], 0
  00021	74 23		 je	 SHORT $LN3@stbtt__hhe

; 2801 :       stbtt__hheap_chunk *n = c->next;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 89 44 24 28	 mov	 QWORD PTR n$1[rsp], rax

; 2802 :       STBTT_free(c, userdata);

  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR c$[rsp]
  00035	e8 00 00 00 00	 call	 free

; 2803 :       c = n;

  0003a	48 8b 44 24 28	 mov	 rax, QWORD PTR n$1[rsp]
  0003f	48 89 44 24 20	 mov	 QWORD PTR c$[rsp], rax

; 2804 :    }

  00044	eb d5		 jmp	 SHORT $LN2@stbtt__hhe
$LN3@stbtt__hhe:

; 2805 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
hh$ = 8
p$ = 16
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_free

; 2792 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2793 :    *(void **) p = hh->first_free;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR p$[rsp]
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR hh$[rsp]
  00014	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00018	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2794 :    hh->first_free = p;

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR hh$[rsp]
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00025	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2795 : }

  00029	c3		 ret	 0
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_free
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv72 = 32
tv73 = 36
count$1 = 40
c$2 = 48
p$3 = 56
hh$ = 80
size$ = 88
userdata$ = 96
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z PROC ; stbtt__hheap_alloc

; 2771 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2772 :    if (hh->first_free) {

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  00018	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0001d	74 2e		 je	 SHORT $LN2@stbtt__hhe

; 2773 :       void *p = hh->first_free;

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 89 44 24 38	 mov	 QWORD PTR p$3[rsp], rax

; 2774 :       hh->first_free = * (void **) p;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  00032	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$3[rsp]
  00037	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2775 :       return p;

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR p$3[rsp]
  00043	e9 de 00 00 00	 jmp	 $LN1@stbtt__hhe

; 2776 :    } else {

  00048	e9 d9 00 00 00	 jmp	 $LN3@stbtt__hhe
$LN2@stbtt__hhe:

; 2777 :       if (hh->num_remaining_in_head_chunk == 0) {

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  00052	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00056	0f 85 96 00 00
	00		 jne	 $LN4@stbtt__hhe

; 2778 :          int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);

  0005c	48 83 7c 24 58
	20		 cmp	 QWORD PTR size$[rsp], 32 ; 00000020H
  00062	73 0a		 jae	 SHORT $LN9@stbtt__hhe
  00064	c7 44 24 24 d0
	07 00 00	 mov	 DWORD PTR tv73[rsp], 2000 ; 000007d0H
  0006c	eb 25		 jmp	 SHORT $LN10@stbtt__hhe
$LN9@stbtt__hhe:
  0006e	48 81 7c 24 58
	80 00 00 00	 cmp	 QWORD PTR size$[rsp], 128 ; 00000080H
  00077	73 0a		 jae	 SHORT $LN7@stbtt__hhe
  00079	c7 44 24 20 20
	03 00 00	 mov	 DWORD PTR tv72[rsp], 800 ; 00000320H
  00081	eb 08		 jmp	 SHORT $LN8@stbtt__hhe
$LN7@stbtt__hhe:
  00083	c7 44 24 20 64
	00 00 00	 mov	 DWORD PTR tv72[rsp], 100 ; 00000064H
$LN8@stbtt__hhe:
  0008b	8b 44 24 20	 mov	 eax, DWORD PTR tv72[rsp]
  0008f	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
$LN10@stbtt__hhe:
  00093	8b 44 24 24	 mov	 eax, DWORD PTR tv73[rsp]
  00097	89 44 24 28	 mov	 DWORD PTR count$1[rsp], eax

; 2779 :          stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);

  0009b	48 63 44 24 28	 movsxd	 rax, DWORD PTR count$1[rsp]
  000a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  000a5	48 0f af c8	 imul	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	48 83 c0 08	 add	 rax, 8
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	e8 00 00 00 00	 call	 malloc
  000b8	48 89 44 24 30	 mov	 QWORD PTR c$2[rsp], rax

; 2780 :          if (c == NULL)

  000bd	48 83 7c 24 30
	00		 cmp	 QWORD PTR c$2[rsp], 0
  000c3	75 04		 jne	 SHORT $LN5@stbtt__hhe

; 2781 :             return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	eb 5d		 jmp	 SHORT $LN1@stbtt__hhe
$LN5@stbtt__hhe:

; 2782 :          c->next = hh->head;

  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR c$2[rsp]
  000ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hh$[rsp]
  000d3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2783 :          hh->head = c;

  000d9	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$2[rsp]
  000e3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2784 :          hh->num_remaining_in_head_chunk = count;

  000e6	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  000eb	8b 4c 24 28	 mov	 ecx, DWORD PTR count$1[rsp]
  000ef	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN4@stbtt__hhe:

; 2785 :       }
; 2786 :       --hh->num_remaining_in_head_chunk;

  000f2	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  000f7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000fa	ff c8		 dec	 eax
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hh$[rsp]
  00101	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2787 :       return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR hh$[rsp]
  00109	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hh$[rsp]
  00111	48 63 49 10	 movsxd	 rcx, DWORD PTR [rcx+16]
  00115	48 8b 54 24 58	 mov	 rdx, QWORD PTR size$[rsp]
  0011a	48 0f af d1	 imul	 rdx, rcx
  0011e	48 8b ca	 mov	 rcx, rdx
  00121	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
$LN3@stbtt__hhe:
$LN1@stbtt__hhe:

; 2788 :    }
; 2789 : }

  00126	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012a	c3		 ret	 0
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z ENDP ; stbtt__hheap_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
table$1 = 32
class2Count$2 = 40
i$ = 44
sti$ = 48
lookupOffset$3 = 52
lookupType$4 = 56
subTableCount$5 = 60
subtableOffset$6 = 64
coverageOffset$7 = 68
posFormat$8 = 72
valueFormat1$9 = 76
valueFormat2$10 = 80
pairPosOffset$11 = 84
pairSetCount$12 = 88
pairValueCount$13 = 92
secondGlyph$14 = 96
xAdvance$15 = 100
valueFormat1$16 = 104
classDef1Offset$17 = 108
classDef2Offset$18 = 112
class1Count$19 = 116
xAdvance$20 = 120
valueFormat2$21 = 124
lookupListOffset$ = 128
coverageIndex$22 = 132
r$23 = 136
m$24 = 140
l$25 = 144
glyph1class$26 = 148
glyph2class$27 = 152
lookupCount$ = 156
straw$28 = 160
needle$29 = 164
tv159 = 168
data$ = 176
lookupTable$30 = 184
valueRecordPairSizeInBytes$31 = 192
lookupList$ = 200
pairValueTable$32 = 208
pairValue$33 = 216
subTableOffsets$34 = 224
pairValueArray$35 = 232
class1Records$36 = 240
class2Records$37 = 248
info$ = 272
glyph1$ = 280
glyph2$ = 288
?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z PROC ; stbtt__GetGlyphGPOSInfoAdvance

; 2497 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 2498 :    stbtt_uint16 lookupListOffset;
; 2499 :    stbtt_uint8 *lookupList;
; 2500 :    stbtt_uint16 lookupCount;
; 2501 :    stbtt_uint8 *data;
; 2502 :    stbtt_int32 i, sti;
; 2503 : 
; 2504 :    if (!info->gpos) return 0;

  00015	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0001d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00021	75 07		 jne	 SHORT $LN12@stbtt__Get
  00023	33 c0		 xor	 eax, eax
  00025	e9 de 05 00 00	 jmp	 $LN1@stbtt__Get
$LN12@stbtt__Get:

; 2505 : 
; 2506 :    data = info->data + info->gpos;

  0002a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00032	48 63 40 30	 movsxd	 rax, DWORD PTR [rax+48]
  00036	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0003e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00042	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR data$[rsp], rax

; 2507 : 
; 2508 :    if (ttUSHORT(data+0) != 1) return 0; // Major version 1

  0004a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00052	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00057	0f b7 c0	 movzx	 eax, ax
  0005a	83 f8 01	 cmp	 eax, 1
  0005d	74 07		 je	 SHORT $LN13@stbtt__Get
  0005f	33 c0		 xor	 eax, eax
  00061	e9 a2 05 00 00	 jmp	 $LN1@stbtt__Get
$LN13@stbtt__Get:

; 2509 :    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

  00066	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0006e	48 83 c0 02	 add	 rax, 2
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0007a	0f b7 c0	 movzx	 eax, ax
  0007d	85 c0		 test	 eax, eax
  0007f	74 07		 je	 SHORT $LN14@stbtt__Get
  00081	33 c0		 xor	 eax, eax
  00083	e9 80 05 00 00	 jmp	 $LN1@stbtt__Get
$LN14@stbtt__Get:

; 2510 : 
; 2511 :    lookupListOffset = ttUSHORT(data+8);

  00088	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00090	48 83 c0 08	 add	 rax, 8
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0009c	66 89 84 24 80
	00 00 00	 mov	 WORD PTR lookupListOffset$[rsp], ax

; 2512 :    lookupList = data + lookupListOffset;

  000a4	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR lookupListOffset$[rsp]
  000ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000b4	48 03 c8	 add	 rcx, rax
  000b7	48 8b c1	 mov	 rax, rcx
  000ba	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR lookupList$[rsp], rax

; 2513 :    lookupCount = ttUSHORT(lookupList);

  000c2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR lookupList$[rsp]
  000ca	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000cf	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR lookupCount$[rsp], ax

; 2514 : 
; 2515 :    for (i=0; i<lookupCount; ++i) {

  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000df	eb 0a		 jmp	 SHORT $LN4@stbtt__Get
$LN2@stbtt__Get:
  000e1	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  000e5	ff c0		 inc	 eax
  000e7	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__Get:
  000eb	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR lookupCount$[rsp]
  000f3	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  000f7	0f 8d 09 05 00
	00		 jge	 $LN3@stbtt__Get

; 2516 :       stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);

  000fd	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  00101	d1 e0		 shl	 eax, 1
  00103	48 98		 cdqe
  00105	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR lookupList$[rsp]
  0010d	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00112	48 8b c8	 mov	 rcx, rax
  00115	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0011a	66 89 44 24 34	 mov	 WORD PTR lookupOffset$3[rsp], ax

; 2517 :       stbtt_uint8 *lookupTable = lookupList + lookupOffset;

  0011f	0f b7 44 24 34	 movzx	 eax, WORD PTR lookupOffset$3[rsp]
  00124	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR lookupList$[rsp]
  0012c	48 03 c8	 add	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR lookupTable$30[rsp], rax

; 2518 : 
; 2519 :       stbtt_uint16 lookupType = ttUSHORT(lookupTable);

  0013a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR lookupTable$30[rsp]
  00142	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00147	66 89 44 24 38	 mov	 WORD PTR lookupType$4[rsp], ax

; 2520 :       stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);

  0014c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lookupTable$30[rsp]
  00154	48 83 c0 04	 add	 rax, 4
  00158	48 8b c8	 mov	 rcx, rax
  0015b	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00160	66 89 44 24 3c	 mov	 WORD PTR subTableCount$5[rsp], ax

; 2521 :       stbtt_uint8 *subTableOffsets = lookupTable + 6;

  00165	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lookupTable$30[rsp]
  0016d	48 83 c0 06	 add	 rax, 6
  00171	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR subTableOffsets$34[rsp], rax

; 2522 :       if (lookupType != 2) // Pair Adjustment Positioning Subtable

  00179	0f b7 44 24 38	 movzx	 eax, WORD PTR lookupType$4[rsp]
  0017e	83 f8 02	 cmp	 eax, 2
  00181	74 05		 je	 SHORT $LN15@stbtt__Get

; 2523 :          continue;

  00183	e9 59 ff ff ff	 jmp	 $LN2@stbtt__Get
$LN15@stbtt__Get:

; 2524 : 
; 2525 :       for (sti=0; sti<subTableCount; sti++) {

  00188	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR sti$[rsp], 0
  00190	eb 0a		 jmp	 SHORT $LN7@stbtt__Get
$LN5@stbtt__Get:
  00192	8b 44 24 30	 mov	 eax, DWORD PTR sti$[rsp]
  00196	ff c0		 inc	 eax
  00198	89 44 24 30	 mov	 DWORD PTR sti$[rsp], eax
$LN7@stbtt__Get:
  0019c	0f b7 44 24 3c	 movzx	 eax, WORD PTR subTableCount$5[rsp]
  001a1	39 44 24 30	 cmp	 DWORD PTR sti$[rsp], eax
  001a5	0f 8d 56 04 00
	00		 jge	 $LN6@stbtt__Get

; 2526 :          stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);

  001ab	8b 44 24 30	 mov	 eax, DWORD PTR sti$[rsp]
  001af	d1 e0		 shl	 eax, 1
  001b1	48 98		 cdqe
  001b3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR subTableOffsets$34[rsp]
  001bb	48 03 c8	 add	 rcx, rax
  001be	48 8b c1	 mov	 rax, rcx
  001c1	48 8b c8	 mov	 rcx, rax
  001c4	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001c9	66 89 44 24 40	 mov	 WORD PTR subtableOffset$6[rsp], ax

; 2527 :          stbtt_uint8 *table = lookupTable + subtableOffset;

  001ce	0f b7 44 24 40	 movzx	 eax, WORD PTR subtableOffset$6[rsp]
  001d3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR lookupTable$30[rsp]
  001db	48 03 c8	 add	 rcx, rax
  001de	48 8b c1	 mov	 rax, rcx
  001e1	48 89 44 24 20	 mov	 QWORD PTR table$1[rsp], rax

; 2528 :          stbtt_uint16 posFormat = ttUSHORT(table);

  001e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$1[rsp]
  001eb	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001f0	66 89 44 24 48	 mov	 WORD PTR posFormat$8[rsp], ax

; 2529 :          stbtt_uint16 coverageOffset = ttUSHORT(table + 2);

  001f5	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  001fa	48 83 c0 02	 add	 rax, 2
  001fe	48 8b c8	 mov	 rcx, rax
  00201	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00206	66 89 44 24 44	 mov	 WORD PTR coverageOffset$7[rsp], ax

; 2530 :          stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);

  0020b	0f b7 44 24 44	 movzx	 eax, WORD PTR coverageOffset$7[rsp]
  00210	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$1[rsp]
  00215	48 03 c8	 add	 rcx, rax
  00218	48 8b c1	 mov	 rax, rcx
  0021b	8b 94 24 18 01
	00 00		 mov	 edx, DWORD PTR glyph1$[rsp]
  00222	48 8b c8	 mov	 rcx, rax
  00225	e8 00 00 00 00	 call	 ?stbtt__GetCoverageIndex@@YAHPEAEH@Z ; stbtt__GetCoverageIndex
  0022a	89 84 24 84 00
	00 00		 mov	 DWORD PTR coverageIndex$22[rsp], eax

; 2531 :          if (coverageIndex == -1) continue;

  00231	83 bc 24 84 00
	00 00 ff	 cmp	 DWORD PTR coverageIndex$22[rsp], -1
  00239	75 05		 jne	 SHORT $LN16@stbtt__Get
  0023b	e9 52 ff ff ff	 jmp	 $LN5@stbtt__Get
$LN16@stbtt__Get:

; 2532 : 
; 2533 :          switch (posFormat) {

  00240	0f b7 44 24 48	 movzx	 eax, WORD PTR posFormat$8[rsp]
  00245	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv159[rsp], eax
  0024c	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR tv159[rsp], 1
  00254	74 13		 je	 SHORT $LN17@stbtt__Get
  00256	83 bc 24 a8 00
	00 00 02	 cmp	 DWORD PTR tv159[rsp], 2
  0025e	0f 84 fa 01 00
	00		 je	 $LN25@stbtt__Get
  00264	e9 8f 03 00 00	 jmp	 $LN32@stbtt__Get
$LN17@stbtt__Get:

; 2534 :             case 1: {
; 2535 :                stbtt_int32 l, r, m;
; 2536 :                int straw, needle;
; 2537 :                stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);

  00269	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  0026e	48 83 c0 04	 add	 rax, 4
  00272	48 8b c8	 mov	 rcx, rax
  00275	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0027a	66 89 44 24 4c	 mov	 WORD PTR valueFormat1$9[rsp], ax

; 2538 :                stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

  0027f	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  00284	48 83 c0 06	 add	 rax, 6
  00288	48 8b c8	 mov	 rcx, rax
  0028b	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00290	66 89 44 24 50	 mov	 WORD PTR valueFormat2$10[rsp], ax

; 2539 :                if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?

  00295	0f b7 44 24 4c	 movzx	 eax, WORD PTR valueFormat1$9[rsp]
  0029a	83 f8 04	 cmp	 eax, 4
  0029d	0f 85 af 01 00
	00		 jne	 $LN18@stbtt__Get
  002a3	0f b7 44 24 50	 movzx	 eax, WORD PTR valueFormat2$10[rsp]
  002a8	85 c0		 test	 eax, eax
  002aa	0f 85 a2 01 00
	00		 jne	 $LN18@stbtt__Get

; 2540 :                   stbtt_int32 valueRecordPairSizeInBytes = 2;

  002b0	c7 84 24 c0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR valueRecordPairSizeInBytes$31[rsp], 2

; 2541 :                   stbtt_uint16 pairSetCount = ttUSHORT(table + 8);

  002bb	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  002c0	48 83 c0 08	 add	 rax, 8
  002c4	48 8b c8	 mov	 rcx, rax
  002c7	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  002cc	66 89 44 24 58	 mov	 WORD PTR pairSetCount$12[rsp], ax

; 2542 :                   stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);

  002d1	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR coverageIndex$22[rsp]
  002d8	d1 e0		 shl	 eax, 1
  002da	48 98		 cdqe
  002dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$1[rsp]
  002e1	48 8d 44 01 0a	 lea	 rax, QWORD PTR [rcx+rax+10]
  002e6	48 8b c8	 mov	 rcx, rax
  002e9	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  002ee	66 89 44 24 54	 mov	 WORD PTR pairPosOffset$11[rsp], ax

; 2543 :                   stbtt_uint8 *pairValueTable = table + pairPosOffset;

  002f3	0f b7 44 24 54	 movzx	 eax, WORD PTR pairPosOffset$11[rsp]
  002f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$1[rsp]
  002fd	48 03 c8	 add	 rcx, rax
  00300	48 8b c1	 mov	 rax, rcx
  00303	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pairValueTable$32[rsp], rax

; 2544 :                   stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);

  0030b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pairValueTable$32[rsp]
  00313	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00318	66 89 44 24 5c	 mov	 WORD PTR pairValueCount$13[rsp], ax

; 2545 :                   stbtt_uint8 *pairValueArray = pairValueTable + 2;

  0031d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pairValueTable$32[rsp]
  00325	48 83 c0 02	 add	 rax, 2
  00329	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pairValueArray$35[rsp], rax

; 2546 : 
; 2547 :                   if (coverageIndex >= pairSetCount) return 0;

  00331	0f b7 44 24 58	 movzx	 eax, WORD PTR pairSetCount$12[rsp]
  00336	39 84 24 84 00
	00 00		 cmp	 DWORD PTR coverageIndex$22[rsp], eax
  0033d	7c 07		 jl	 SHORT $LN20@stbtt__Get
  0033f	33 c0		 xor	 eax, eax
  00341	e9 c2 02 00 00	 jmp	 $LN1@stbtt__Get
$LN20@stbtt__Get:

; 2548 : 
; 2549 :                   needle=glyph2;

  00346	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR glyph2$[rsp]
  0034d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR needle$29[rsp], eax

; 2550 :                   r=pairValueCount-1;

  00354	0f b7 44 24 5c	 movzx	 eax, WORD PTR pairValueCount$13[rsp]
  00359	ff c8		 dec	 eax
  0035b	89 84 24 88 00
	00 00		 mov	 DWORD PTR r$23[rsp], eax

; 2551 :                   l=0;

  00362	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l$25[rsp], 0
$LN10@stbtt__Get:

; 2552 : 
; 2553 :                   // Binary search.
; 2554 :                   while (l <= r) {

  0036d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r$23[rsp]
  00374	39 84 24 90 00
	00 00		 cmp	 DWORD PTR l$25[rsp], eax
  0037b	0f 8f cf 00 00
	00		 jg	 $LN11@stbtt__Get

; 2555 :                      stbtt_uint16 secondGlyph;
; 2556 :                      stbtt_uint8 *pairValue;
; 2557 :                      m = (l + r) >> 1;

  00381	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r$23[rsp]
  00388	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR l$25[rsp]
  0038f	03 c8		 add	 ecx, eax
  00391	8b c1		 mov	 eax, ecx
  00393	d1 f8		 sar	 eax, 1
  00395	89 84 24 8c 00
	00 00		 mov	 DWORD PTR m$24[rsp], eax

; 2558 :                      pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;

  0039c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR valueRecordPairSizeInBytes$31[rsp]
  003a3	83 c0 02	 add	 eax, 2
  003a6	0f af 84 24 8c
	00 00 00	 imul	 eax, DWORD PTR m$24[rsp]
  003ae	48 98		 cdqe
  003b0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pairValueArray$35[rsp]
  003b8	48 03 c8	 add	 rcx, rax
  003bb	48 8b c1	 mov	 rax, rcx
  003be	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pairValue$33[rsp], rax

; 2559 :                      secondGlyph = ttUSHORT(pairValue);

  003c6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR pairValue$33[rsp]
  003ce	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  003d3	66 89 44 24 60	 mov	 WORD PTR secondGlyph$14[rsp], ax

; 2560 :                      straw = secondGlyph;

  003d8	0f b7 44 24 60	 movzx	 eax, WORD PTR secondGlyph$14[rsp]
  003dd	89 84 24 a0 00
	00 00		 mov	 DWORD PTR straw$28[rsp], eax

; 2561 :                      if (needle < straw)

  003e4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR straw$28[rsp]
  003eb	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR needle$29[rsp], eax
  003f2	7d 12		 jge	 SHORT $LN21@stbtt__Get

; 2562 :                         r = m - 1;

  003f4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR m$24[rsp]
  003fb	ff c8		 dec	 eax
  003fd	89 84 24 88 00
	00 00		 mov	 DWORD PTR r$23[rsp], eax
  00404	eb 45		 jmp	 SHORT $LN22@stbtt__Get
$LN21@stbtt__Get:

; 2563 :                      else if (needle > straw)

  00406	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR straw$28[rsp]
  0040d	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR needle$29[rsp], eax
  00414	7e 12		 jle	 SHORT $LN23@stbtt__Get

; 2564 :                         l = m + 1;

  00416	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR m$24[rsp]
  0041d	ff c0		 inc	 eax
  0041f	89 84 24 90 00
	00 00		 mov	 DWORD PTR l$25[rsp], eax
  00426	eb 23		 jmp	 SHORT $LN24@stbtt__Get
$LN23@stbtt__Get:

; 2565 :                      else {
; 2566 :                         stbtt_int16 xAdvance = ttSHORT(pairValue + 2);

  00428	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR pairValue$33[rsp]
  00430	48 83 c0 02	 add	 rax, 2
  00434	48 8b c8	 mov	 rcx, rax
  00437	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0043c	66 89 44 24 64	 mov	 WORD PTR xAdvance$15[rsp], ax

; 2567 :                         return xAdvance;

  00441	0f bf 44 24 64	 movsx	 eax, WORD PTR xAdvance$15[rsp]
  00446	e9 bd 01 00 00	 jmp	 $LN1@stbtt__Get
$LN24@stbtt__Get:
$LN22@stbtt__Get:

; 2568 :                      }
; 2569 :                   }

  0044b	e9 1d ff ff ff	 jmp	 $LN10@stbtt__Get
$LN11@stbtt__Get:

; 2570 :                } else

  00450	eb 07		 jmp	 SHORT $LN19@stbtt__Get
$LN18@stbtt__Get:

; 2571 :                   return 0;

  00452	33 c0		 xor	 eax, eax
  00454	e9 af 01 00 00	 jmp	 $LN1@stbtt__Get
$LN19@stbtt__Get:

; 2572 :                break;

  00459	e9 9e 01 00 00	 jmp	 $LN8@stbtt__Get
$LN25@stbtt__Get:

; 2573 :             }
; 2574 : 
; 2575 :             case 2: {
; 2576 :                stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);

  0045e	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  00463	48 83 c0 04	 add	 rax, 4
  00467	48 8b c8	 mov	 rcx, rax
  0046a	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0046f	66 89 44 24 68	 mov	 WORD PTR valueFormat1$16[rsp], ax

; 2577 :                stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

  00474	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  00479	48 83 c0 06	 add	 rax, 6
  0047d	48 8b c8	 mov	 rcx, rax
  00480	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00485	66 89 44 24 7c	 mov	 WORD PTR valueFormat2$21[rsp], ax

; 2578 :                if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?

  0048a	0f b7 44 24 68	 movzx	 eax, WORD PTR valueFormat1$16[rsp]
  0048f	83 f8 04	 cmp	 eax, 4
  00492	0f 85 5a 01 00
	00		 jne	 $LN26@stbtt__Get
  00498	0f b7 44 24 7c	 movzx	 eax, WORD PTR valueFormat2$21[rsp]
  0049d	85 c0		 test	 eax, eax
  0049f	0f 85 4d 01 00
	00		 jne	 $LN26@stbtt__Get

; 2579 :                   stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);

  004a5	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  004aa	48 83 c0 08	 add	 rax, 8
  004ae	48 8b c8	 mov	 rcx, rax
  004b1	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  004b6	66 89 44 24 6c	 mov	 WORD PTR classDef1Offset$17[rsp], ax

; 2580 :                   stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);

  004bb	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  004c0	48 83 c0 0a	 add	 rax, 10
  004c4	48 8b c8	 mov	 rcx, rax
  004c7	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  004cc	66 89 44 24 70	 mov	 WORD PTR classDef2Offset$18[rsp], ax

; 2581 :                   int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);

  004d1	0f b7 44 24 6c	 movzx	 eax, WORD PTR classDef1Offset$17[rsp]
  004d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$1[rsp]
  004db	48 03 c8	 add	 rcx, rax
  004de	48 8b c1	 mov	 rax, rcx
  004e1	8b 94 24 18 01
	00 00		 mov	 edx, DWORD PTR glyph1$[rsp]
  004e8	48 8b c8	 mov	 rcx, rax
  004eb	e8 00 00 00 00	 call	 ?stbtt__GetGlyphClass@@YAHPEAEH@Z ; stbtt__GetGlyphClass
  004f0	89 84 24 94 00
	00 00		 mov	 DWORD PTR glyph1class$26[rsp], eax

; 2582 :                   int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

  004f7	0f b7 44 24 70	 movzx	 eax, WORD PTR classDef2Offset$18[rsp]
  004fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR table$1[rsp]
  00501	48 03 c8	 add	 rcx, rax
  00504	48 8b c1	 mov	 rax, rcx
  00507	8b 94 24 20 01
	00 00		 mov	 edx, DWORD PTR glyph2$[rsp]
  0050e	48 8b c8	 mov	 rcx, rax
  00511	e8 00 00 00 00	 call	 ?stbtt__GetGlyphClass@@YAHPEAEH@Z ; stbtt__GetGlyphClass
  00516	89 84 24 98 00
	00 00		 mov	 DWORD PTR glyph2class$27[rsp], eax

; 2583 : 
; 2584 :                   stbtt_uint16 class1Count = ttUSHORT(table + 12);

  0051d	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  00522	48 83 c0 0c	 add	 rax, 12
  00526	48 8b c8	 mov	 rcx, rax
  00529	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0052e	66 89 44 24 74	 mov	 WORD PTR class1Count$19[rsp], ax

; 2585 :                   stbtt_uint16 class2Count = ttUSHORT(table + 14);

  00533	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  00538	48 83 c0 0e	 add	 rax, 14
  0053c	48 8b c8	 mov	 rcx, rax
  0053f	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00544	66 89 44 24 28	 mov	 WORD PTR class2Count$2[rsp], ax

; 2586 :                   stbtt_uint8 *class1Records, *class2Records;
; 2587 :                   stbtt_int16 xAdvance;
; 2588 : 
; 2589 :                   if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed

  00549	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR glyph1class$26[rsp], 0
  00551	7c 0e		 jl	 SHORT $LN29@stbtt__Get
  00553	0f b7 44 24 74	 movzx	 eax, WORD PTR class1Count$19[rsp]
  00558	39 84 24 94 00
	00 00		 cmp	 DWORD PTR glyph1class$26[rsp], eax
  0055f	7c 07		 jl	 SHORT $LN28@stbtt__Get
$LN29@stbtt__Get:
  00561	33 c0		 xor	 eax, eax
  00563	e9 a0 00 00 00	 jmp	 $LN1@stbtt__Get
$LN28@stbtt__Get:

; 2590 :                   if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed

  00568	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR glyph2class$27[rsp], 0
  00570	7c 0e		 jl	 SHORT $LN31@stbtt__Get
  00572	0f b7 44 24 28	 movzx	 eax, WORD PTR class2Count$2[rsp]
  00577	39 84 24 98 00
	00 00		 cmp	 DWORD PTR glyph2class$27[rsp], eax
  0057e	7c 07		 jl	 SHORT $LN30@stbtt__Get
$LN31@stbtt__Get:
  00580	33 c0		 xor	 eax, eax
  00582	e9 81 00 00 00	 jmp	 $LN1@stbtt__Get
$LN30@stbtt__Get:

; 2591 : 
; 2592 :                   class1Records = table + 16;

  00587	48 8b 44 24 20	 mov	 rax, QWORD PTR table$1[rsp]
  0058c	48 83 c0 10	 add	 rax, 16
  00590	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR class1Records$36[rsp], rax

; 2593 :                   class2Records = class1Records + 2 * (glyph1class * class2Count);

  00598	0f b7 44 24 28	 movzx	 eax, WORD PTR class2Count$2[rsp]
  0059d	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR glyph1class$26[rsp]
  005a4	0f af c8	 imul	 ecx, eax
  005a7	8b c1		 mov	 eax, ecx
  005a9	d1 e0		 shl	 eax, 1
  005ab	48 98		 cdqe
  005ad	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR class1Records$36[rsp]
  005b5	48 03 c8	 add	 rcx, rax
  005b8	48 8b c1	 mov	 rax, rcx
  005bb	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR class2Records$37[rsp], rax

; 2594 :                   xAdvance = ttSHORT(class2Records + 2 * glyph2class);

  005c3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR glyph2class$27[rsp]
  005ca	d1 e0		 shl	 eax, 1
  005cc	48 98		 cdqe
  005ce	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR class2Records$37[rsp]
  005d6	48 03 c8	 add	 rcx, rax
  005d9	48 8b c1	 mov	 rax, rcx
  005dc	48 8b c8	 mov	 rcx, rax
  005df	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  005e4	66 89 44 24 78	 mov	 WORD PTR xAdvance$20[rsp], ax

; 2595 :                   return xAdvance;

  005e9	0f bf 44 24 78	 movsx	 eax, WORD PTR xAdvance$20[rsp]
  005ee	eb 18		 jmp	 SHORT $LN1@stbtt__Get

; 2596 :                } else

  005f0	eb 04		 jmp	 SHORT $LN27@stbtt__Get
$LN26@stbtt__Get:

; 2597 :                   return 0;

  005f2	33 c0		 xor	 eax, eax
  005f4	eb 12		 jmp	 SHORT $LN1@stbtt__Get
$LN27@stbtt__Get:

; 2598 :                break;

  005f6	eb 04		 jmp	 SHORT $LN8@stbtt__Get
$LN32@stbtt__Get:

; 2599 :             }
; 2600 : 
; 2601 :             default:
; 2602 :                return 0; // Unsupported position format

  005f8	33 c0		 xor	 eax, eax
  005fa	eb 0c		 jmp	 SHORT $LN1@stbtt__Get
$LN8@stbtt__Get:

; 2603 :          }
; 2604 :       }

  005fc	e9 91 fb ff ff	 jmp	 $LN5@stbtt__Get
$LN6@stbtt__Get:

; 2605 :    }

  00601	e9 db fa ff ff	 jmp	 $LN2@stbtt__Get
$LN3@stbtt__Get:

; 2606 : 
; 2607 :    return 0;

  00606	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 2608 : }

  00608	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0060f	c3		 ret	 0
?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z ENDP ; stbtt__GetGlyphGPOSInfoAdvance
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
startGlyphID$1 = 32
classDefFormat$ = 36
glyphCount$2 = 40
classRangeCount$3 = 44
r$4 = 48
m$5 = 52
l$6 = 56
tv67 = 60
needle$7 = 64
strawStart$8 = 68
strawEnd$9 = 72
classRangeRecord$10 = 80
classDef1ValueArray$11 = 88
classRangeRecords$12 = 96
classDefTable$ = 128
glyph$ = 136
?stbtt__GetGlyphClass@@YAHPEAEH@Z PROC			; stbtt__GetGlyphClass

; 2448 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2449 :    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);

  0000d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR classDefTable$[rsp]
  00015	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0001a	66 89 44 24 24	 mov	 WORD PTR classDefFormat$[rsp], ax

; 2450 :    switch (classDefFormat)

  0001f	0f b7 44 24 24	 movzx	 eax, WORD PTR classDefFormat$[rsp]
  00024	89 44 24 3c	 mov	 DWORD PTR tv67[rsp], eax
  00028	83 7c 24 3c 01	 cmp	 DWORD PTR tv67[rsp], 1
  0002d	74 10		 je	 SHORT $LN6@stbtt__Get
  0002f	83 7c 24 3c 02	 cmp	 DWORD PTR tv67[rsp], 2
  00034	0f 84 9f 00 00
	00		 je	 $LN8@stbtt__Get
  0003a	e9 8b 01 00 00	 jmp	 $LN13@stbtt__Get
$LN6@stbtt__Get:

; 2451 :    {
; 2452 :       case 1: {
; 2453 :          stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);

  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR classDefTable$[rsp]
  00047	48 83 c0 02	 add	 rax, 2
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00053	66 89 44 24 20	 mov	 WORD PTR startGlyphID$1[rsp], ax

; 2454 :          stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);

  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR classDefTable$[rsp]
  00060	48 83 c0 04	 add	 rax, 4
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0006c	66 89 44 24 28	 mov	 WORD PTR glyphCount$2[rsp], ax

; 2455 :          stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

  00071	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR classDefTable$[rsp]
  00079	48 83 c0 06	 add	 rax, 6
  0007d	48 89 44 24 58	 mov	 QWORD PTR classDef1ValueArray$11[rsp], rax

; 2456 : 
; 2457 :          if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)

  00082	0f b7 44 24 20	 movzx	 eax, WORD PTR startGlyphID$1[rsp]
  00087	39 84 24 88 00
	00 00		 cmp	 DWORD PTR glyph$[rsp], eax
  0008e	7c 44		 jl	 SHORT $LN7@stbtt__Get
  00090	0f b7 44 24 20	 movzx	 eax, WORD PTR startGlyphID$1[rsp]
  00095	0f b7 4c 24 28	 movzx	 ecx, WORD PTR glyphCount$2[rsp]
  0009a	03 c1		 add	 eax, ecx
  0009c	39 84 24 88 00
	00 00		 cmp	 DWORD PTR glyph$[rsp], eax
  000a3	7d 2f		 jge	 SHORT $LN7@stbtt__Get

; 2458 :             return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

  000a5	0f b7 44 24 20	 movzx	 eax, WORD PTR startGlyphID$1[rsp]
  000aa	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR glyph$[rsp]
  000b1	2b c8		 sub	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	d1 e0		 shl	 eax, 1
  000b7	48 98		 cdqe
  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR classDef1ValueArray$11[rsp]
  000be	48 03 c8	 add	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000cc	0f b7 c0	 movzx	 eax, ax
  000cf	e9 ff 00 00 00	 jmp	 $LN1@stbtt__Get
$LN7@stbtt__Get:

; 2459 :          break;

  000d4	e9 f8 00 00 00	 jmp	 $LN2@stbtt__Get
$LN8@stbtt__Get:

; 2460 :       }
; 2461 : 
; 2462 :       case 2: {
; 2463 :          stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);

  000d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR classDefTable$[rsp]
  000e1	48 83 c0 02	 add	 rax, 2
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000ed	66 89 44 24 2c	 mov	 WORD PTR classRangeCount$3[rsp], ax

; 2464 :          stbtt_uint8 *classRangeRecords = classDefTable + 4;

  000f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR classDefTable$[rsp]
  000fa	48 83 c0 04	 add	 rax, 4
  000fe	48 89 44 24 60	 mov	 QWORD PTR classRangeRecords$12[rsp], rax

; 2465 : 
; 2466 :          // Binary search.
; 2467 :          stbtt_int32 l=0, r=classRangeCount-1, m;

  00103	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR l$6[rsp], 0
  0010b	0f b7 44 24 2c	 movzx	 eax, WORD PTR classRangeCount$3[rsp]
  00110	ff c8		 dec	 eax
  00112	89 44 24 30	 mov	 DWORD PTR r$4[rsp], eax

; 2468 :          int strawStart, strawEnd, needle=glyph;

  00116	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR glyph$[rsp]
  0011d	89 44 24 40	 mov	 DWORD PTR needle$7[rsp], eax
$LN4@stbtt__Get:

; 2469 :          while (l <= r) {

  00121	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  00125	39 44 24 38	 cmp	 DWORD PTR l$6[rsp], eax
  00129	0f 8f 99 00 00
	00		 jg	 $LN5@stbtt__Get

; 2470 :             stbtt_uint8 *classRangeRecord;
; 2471 :             m = (l + r) >> 1;

  0012f	8b 44 24 30	 mov	 eax, DWORD PTR r$4[rsp]
  00133	8b 4c 24 38	 mov	 ecx, DWORD PTR l$6[rsp]
  00137	03 c8		 add	 ecx, eax
  00139	8b c1		 mov	 eax, ecx
  0013b	d1 f8		 sar	 eax, 1
  0013d	89 44 24 34	 mov	 DWORD PTR m$5[rsp], eax

; 2472 :             classRangeRecord = classRangeRecords + 6 * m;

  00141	6b 44 24 34 06	 imul	 eax, DWORD PTR m$5[rsp], 6
  00146	48 98		 cdqe
  00148	48 8b 4c 24 60	 mov	 rcx, QWORD PTR classRangeRecords$12[rsp]
  0014d	48 03 c8	 add	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	48 89 44 24 50	 mov	 QWORD PTR classRangeRecord$10[rsp], rax

; 2473 :             strawStart = ttUSHORT(classRangeRecord);

  00158	48 8b 4c 24 50	 mov	 rcx, QWORD PTR classRangeRecord$10[rsp]
  0015d	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00162	0f b7 c0	 movzx	 eax, ax
  00165	89 44 24 44	 mov	 DWORD PTR strawStart$8[rsp], eax

; 2474 :             strawEnd = ttUSHORT(classRangeRecord + 2);

  00169	48 8b 44 24 50	 mov	 rax, QWORD PTR classRangeRecord$10[rsp]
  0016e	48 83 c0 02	 add	 rax, 2
  00172	48 8b c8	 mov	 rcx, rax
  00175	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0017a	0f b7 c0	 movzx	 eax, ax
  0017d	89 44 24 48	 mov	 DWORD PTR strawEnd$9[rsp], eax

; 2475 :             if (needle < strawStart)

  00181	8b 44 24 44	 mov	 eax, DWORD PTR strawStart$8[rsp]
  00185	39 44 24 40	 cmp	 DWORD PTR needle$7[rsp], eax
  00189	7d 0c		 jge	 SHORT $LN9@stbtt__Get

; 2476 :                r = m - 1;

  0018b	8b 44 24 34	 mov	 eax, DWORD PTR m$5[rsp]
  0018f	ff c8		 dec	 eax
  00191	89 44 24 30	 mov	 DWORD PTR r$4[rsp], eax
  00195	eb 2c		 jmp	 SHORT $LN10@stbtt__Get
$LN9@stbtt__Get:

; 2477 :             else if (needle > strawEnd)

  00197	8b 44 24 48	 mov	 eax, DWORD PTR strawEnd$9[rsp]
  0019b	39 44 24 40	 cmp	 DWORD PTR needle$7[rsp], eax
  0019f	7e 0c		 jle	 SHORT $LN11@stbtt__Get

; 2478 :                l = m + 1;

  001a1	8b 44 24 34	 mov	 eax, DWORD PTR m$5[rsp]
  001a5	ff c0		 inc	 eax
  001a7	89 44 24 38	 mov	 DWORD PTR l$6[rsp], eax
  001ab	eb 16		 jmp	 SHORT $LN12@stbtt__Get
$LN11@stbtt__Get:

; 2479 :             else
; 2480 :                return (stbtt_int32)ttUSHORT(classRangeRecord + 4);

  001ad	48 8b 44 24 50	 mov	 rax, QWORD PTR classRangeRecord$10[rsp]
  001b2	48 83 c0 04	 add	 rax, 4
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001be	0f b7 c0	 movzx	 eax, ax
  001c1	eb 10		 jmp	 SHORT $LN1@stbtt__Get
$LN12@stbtt__Get:
$LN10@stbtt__Get:

; 2481 :          }

  001c3	e9 59 ff ff ff	 jmp	 $LN4@stbtt__Get
$LN5@stbtt__Get:

; 2482 :          break;

  001c8	eb 07		 jmp	 SHORT $LN2@stbtt__Get
$LN13@stbtt__Get:

; 2483 :       }
; 2484 : 
; 2485 :       default:
; 2486 :          return -1; // Unsupported definition type, return an error.

  001ca	b8 ff ff ff ff	 mov	 eax, -1
  001cf	eb 02		 jmp	 SHORT $LN1@stbtt__Get
$LN2@stbtt__Get:

; 2487 :    }
; 2488 : 
; 2489 :    // "All glyphs not assigned to a class fall into class 0". (OpenType spec)
; 2490 :    return 0;

  001d1	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 2491 : }

  001d3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001d7	c3		 ret	 0
?stbtt__GetGlyphClass@@YAHPEAEH@Z ENDP			; stbtt__GetGlyphClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
m$1 = 32
coverageFormat$ = 36
glyphCount$2 = 40
glyphID$3 = 44
rangeCount$4 = 48
startCoverageIndex$5 = 52
r$6 = 56
l$7 = 60
r$8 = 64
m$9 = 68
l$10 = 72
tv67 = 76
straw$11 = 80
needle$12 = 84
needle$13 = 88
strawStart$14 = 92
strawEnd$15 = 96
rangeRecord$16 = 104
glyphArray$17 = 112
rangeArray$18 = 120
coverageTable$ = 144
glyph$ = 152
?stbtt__GetCoverageIndex@@YAHPEAEH@Z PROC		; stbtt__GetCoverageIndex

; 2390 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2391 :    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);

  00010	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR coverageTable$[rsp]
  00018	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0001d	66 89 44 24 24	 mov	 WORD PTR coverageFormat$[rsp], ax

; 2392 :    switch (coverageFormat) {

  00022	0f b7 44 24 24	 movzx	 eax, WORD PTR coverageFormat$[rsp]
  00027	89 44 24 4c	 mov	 DWORD PTR tv67[rsp], eax
  0002b	83 7c 24 4c 01	 cmp	 DWORD PTR tv67[rsp], 1
  00030	74 10		 je	 SHORT $LN8@stbtt__Get
  00032	83 7c 24 4c 02	 cmp	 DWORD PTR tv67[rsp], 2
  00037	0f 84 d5 00 00
	00		 je	 $LN13@stbtt__Get
  0003d	e9 d3 01 00 00	 jmp	 $LN18@stbtt__Get
$LN8@stbtt__Get:

; 2393 :       case 1: {
; 2394 :          stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

  00042	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coverageTable$[rsp]
  0004a	48 83 c0 02	 add	 rax, 2
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00056	66 89 44 24 28	 mov	 WORD PTR glyphCount$2[rsp], ax

; 2395 : 
; 2396 :          // Binary search.
; 2397 :          stbtt_int32 l=0, r=glyphCount-1, m;

  0005b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR l$7[rsp], 0
  00063	0f b7 44 24 28	 movzx	 eax, WORD PTR glyphCount$2[rsp]
  00068	ff c8		 dec	 eax
  0006a	89 44 24 38	 mov	 DWORD PTR r$6[rsp], eax

; 2398 :          int straw, needle=glyph;

  0006e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR glyph$[rsp]
  00075	89 44 24 54	 mov	 DWORD PTR needle$12[rsp], eax
$LN4@stbtt__Get:

; 2399 :          while (l <= r) {

  00079	8b 44 24 38	 mov	 eax, DWORD PTR r$6[rsp]
  0007d	39 44 24 3c	 cmp	 DWORD PTR l$7[rsp], eax
  00081	0f 8f 86 00 00
	00		 jg	 $LN5@stbtt__Get

; 2400 :             stbtt_uint8 *glyphArray = coverageTable + 4;

  00087	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coverageTable$[rsp]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 89 44 24 70	 mov	 QWORD PTR glyphArray$17[rsp], rax

; 2401 :             stbtt_uint16 glyphID;
; 2402 :             m = (l + r) >> 1;

  00098	8b 44 24 38	 mov	 eax, DWORD PTR r$6[rsp]
  0009c	8b 4c 24 3c	 mov	 ecx, DWORD PTR l$7[rsp]
  000a0	03 c8		 add	 ecx, eax
  000a2	8b c1		 mov	 eax, ecx
  000a4	d1 f8		 sar	 eax, 1
  000a6	89 44 24 20	 mov	 DWORD PTR m$1[rsp], eax

; 2403 :             glyphID = ttUSHORT(glyphArray + 2 * m);

  000aa	8b 44 24 20	 mov	 eax, DWORD PTR m$1[rsp]
  000ae	d1 e0		 shl	 eax, 1
  000b0	48 98		 cdqe
  000b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR glyphArray$17[rsp]
  000b7	48 03 c8	 add	 rcx, rax
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 8b c8	 mov	 rcx, rax
  000c0	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000c5	66 89 44 24 2c	 mov	 WORD PTR glyphID$3[rsp], ax

; 2404 :             straw = glyphID;

  000ca	0f b7 44 24 2c	 movzx	 eax, WORD PTR glyphID$3[rsp]
  000cf	89 44 24 50	 mov	 DWORD PTR straw$11[rsp], eax

; 2405 :             if (needle < straw)

  000d3	8b 44 24 50	 mov	 eax, DWORD PTR straw$11[rsp]
  000d7	39 44 24 54	 cmp	 DWORD PTR needle$12[rsp], eax
  000db	7d 0c		 jge	 SHORT $LN9@stbtt__Get

; 2406 :                r = m - 1;

  000dd	8b 44 24 20	 mov	 eax, DWORD PTR m$1[rsp]
  000e1	ff c8		 dec	 eax
  000e3	89 44 24 38	 mov	 DWORD PTR r$6[rsp], eax
  000e7	eb 1f		 jmp	 SHORT $LN10@stbtt__Get
$LN9@stbtt__Get:

; 2407 :             else if (needle > straw)

  000e9	8b 44 24 50	 mov	 eax, DWORD PTR straw$11[rsp]
  000ed	39 44 24 54	 cmp	 DWORD PTR needle$12[rsp], eax
  000f1	7e 0c		 jle	 SHORT $LN11@stbtt__Get

; 2408 :                l = m + 1;

  000f3	8b 44 24 20	 mov	 eax, DWORD PTR m$1[rsp]
  000f7	ff c0		 inc	 eax
  000f9	89 44 24 3c	 mov	 DWORD PTR l$7[rsp], eax
  000fd	eb 09		 jmp	 SHORT $LN12@stbtt__Get
$LN11@stbtt__Get:

; 2409 :             else {
; 2410 :                return m;

  000ff	8b 44 24 20	 mov	 eax, DWORD PTR m$1[rsp]
  00103	e9 19 01 00 00	 jmp	 $LN1@stbtt__Get
$LN12@stbtt__Get:
$LN10@stbtt__Get:

; 2411 :             }
; 2412 :          }

  00108	e9 6c ff ff ff	 jmp	 $LN4@stbtt__Get
$LN5@stbtt__Get:

; 2413 :          break;

  0010d	e9 0a 01 00 00	 jmp	 $LN2@stbtt__Get
$LN13@stbtt__Get:

; 2414 :       }
; 2415 : 
; 2416 :       case 2: {
; 2417 :          stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);

  00112	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coverageTable$[rsp]
  0011a	48 83 c0 02	 add	 rax, 2
  0011e	48 8b c8	 mov	 rcx, rax
  00121	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00126	66 89 44 24 30	 mov	 WORD PTR rangeCount$4[rsp], ax

; 2418 :          stbtt_uint8 *rangeArray = coverageTable + 4;

  0012b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR coverageTable$[rsp]
  00133	48 83 c0 04	 add	 rax, 4
  00137	48 89 44 24 78	 mov	 QWORD PTR rangeArray$18[rsp], rax

; 2419 : 
; 2420 :          // Binary search.
; 2421 :          stbtt_int32 l=0, r=rangeCount-1, m;

  0013c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR l$10[rsp], 0
  00144	0f b7 44 24 30	 movzx	 eax, WORD PTR rangeCount$4[rsp]
  00149	ff c8		 dec	 eax
  0014b	89 44 24 40	 mov	 DWORD PTR r$8[rsp], eax

; 2422 :          int strawStart, strawEnd, needle=glyph;

  0014f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR glyph$[rsp]
  00156	89 44 24 58	 mov	 DWORD PTR needle$13[rsp], eax
$LN6@stbtt__Get:

; 2423 :          while (l <= r) {

  0015a	8b 44 24 40	 mov	 eax, DWORD PTR r$8[rsp]
  0015e	39 44 24 48	 cmp	 DWORD PTR l$10[rsp], eax
  00162	0f 8f ab 00 00
	00		 jg	 $LN7@stbtt__Get

; 2424 :             stbtt_uint8 *rangeRecord;
; 2425 :             m = (l + r) >> 1;

  00168	8b 44 24 40	 mov	 eax, DWORD PTR r$8[rsp]
  0016c	8b 4c 24 48	 mov	 ecx, DWORD PTR l$10[rsp]
  00170	03 c8		 add	 ecx, eax
  00172	8b c1		 mov	 eax, ecx
  00174	d1 f8		 sar	 eax, 1
  00176	89 44 24 44	 mov	 DWORD PTR m$9[rsp], eax

; 2426 :             rangeRecord = rangeArray + 6 * m;

  0017a	6b 44 24 44 06	 imul	 eax, DWORD PTR m$9[rsp], 6
  0017f	48 98		 cdqe
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rangeArray$18[rsp]
  00186	48 03 c8	 add	 rcx, rax
  00189	48 8b c1	 mov	 rax, rcx
  0018c	48 89 44 24 68	 mov	 QWORD PTR rangeRecord$16[rsp], rax

; 2427 :             strawStart = ttUSHORT(rangeRecord);

  00191	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rangeRecord$16[rsp]
  00196	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0019b	0f b7 c0	 movzx	 eax, ax
  0019e	89 44 24 5c	 mov	 DWORD PTR strawStart$14[rsp], eax

; 2428 :             strawEnd = ttUSHORT(rangeRecord + 2);

  001a2	48 8b 44 24 68	 mov	 rax, QWORD PTR rangeRecord$16[rsp]
  001a7	48 83 c0 02	 add	 rax, 2
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001b3	0f b7 c0	 movzx	 eax, ax
  001b6	89 44 24 60	 mov	 DWORD PTR strawEnd$15[rsp], eax

; 2429 :             if (needle < strawStart)

  001ba	8b 44 24 5c	 mov	 eax, DWORD PTR strawStart$14[rsp]
  001be	39 44 24 58	 cmp	 DWORD PTR needle$13[rsp], eax
  001c2	7d 0c		 jge	 SHORT $LN14@stbtt__Get

; 2430 :                r = m - 1;

  001c4	8b 44 24 44	 mov	 eax, DWORD PTR m$9[rsp]
  001c8	ff c8		 dec	 eax
  001ca	89 44 24 40	 mov	 DWORD PTR r$8[rsp], eax
  001ce	eb 3e		 jmp	 SHORT $LN15@stbtt__Get
$LN14@stbtt__Get:

; 2431 :             else if (needle > strawEnd)

  001d0	8b 44 24 60	 mov	 eax, DWORD PTR strawEnd$15[rsp]
  001d4	39 44 24 58	 cmp	 DWORD PTR needle$13[rsp], eax
  001d8	7e 0c		 jle	 SHORT $LN16@stbtt__Get

; 2432 :                l = m + 1;

  001da	8b 44 24 44	 mov	 eax, DWORD PTR m$9[rsp]
  001de	ff c0		 inc	 eax
  001e0	89 44 24 48	 mov	 DWORD PTR l$10[rsp], eax
  001e4	eb 28		 jmp	 SHORT $LN17@stbtt__Get
$LN16@stbtt__Get:

; 2433 :             else {
; 2434 :                stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);

  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR rangeRecord$16[rsp]
  001eb	48 83 c0 04	 add	 rax, 4
  001ef	48 8b c8	 mov	 rcx, rax
  001f2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001f7	66 89 44 24 34	 mov	 WORD PTR startCoverageIndex$5[rsp], ax

; 2435 :                return startCoverageIndex + glyph - strawStart;

  001fc	0f b7 44 24 34	 movzx	 eax, WORD PTR startCoverageIndex$5[rsp]
  00201	03 84 24 98 00
	00 00		 add	 eax, DWORD PTR glyph$[rsp]
  00208	2b 44 24 5c	 sub	 eax, DWORD PTR strawStart$14[rsp]
  0020c	eb 13		 jmp	 SHORT $LN1@stbtt__Get
$LN17@stbtt__Get:
$LN15@stbtt__Get:

; 2436 :             }
; 2437 :          }

  0020e	e9 47 ff ff ff	 jmp	 $LN6@stbtt__Get
$LN7@stbtt__Get:

; 2438 :          break;

  00213	eb 07		 jmp	 SHORT $LN2@stbtt__Get
$LN18@stbtt__Get:

; 2439 :       }
; 2440 : 
; 2441 :       default: return -1; // unsupported

  00215	b8 ff ff ff ff	 mov	 eax, -1
  0021a	eb 05		 jmp	 SHORT $LN1@stbtt__Get
$LN2@stbtt__Get:

; 2442 :    }
; 2443 : 
; 2444 :    return -1;

  0021c	b8 ff ff ff ff	 mov	 eax, -1
$LN1@stbtt__Get:

; 2445 : }

  00221	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00228	c3		 ret	 0
?stbtt__GetCoverageIndex@@YAHPEAEH@Z ENDP		; stbtt__GetCoverageIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
m$ = 32
r$ = 36
l$ = 40
straw$ = 44
needle$ = 48
data$ = 56
info$ = 80
glyph1$ = 88
glyph2$ = 96
?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z PROC ; stbtt__GetGlyphKernInfoAdvance

; 2360 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2361 :    stbtt_uint8 *data = info->data + info->kern;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  00017	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00020	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00024	48 89 44 24 38	 mov	 QWORD PTR data$[rsp], rax

; 2362 :    stbtt_uint32 needle, straw;
; 2363 :    int l, r, m;
; 2364 : 
; 2365 :    // we only look at the first table. it must be 'horizontal' and format 0.
; 2366 :    if (!info->kern)

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  0002e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00032	75 07		 jne	 SHORT $LN4@stbtt__Get

; 2367 :       return 0;

  00034	33 c0		 xor	 eax, eax
  00036	e9 f9 00 00 00	 jmp	 $LN1@stbtt__Get
$LN4@stbtt__Get:

; 2368 :    if (ttUSHORT(data+2) < 1) // number of tables, need at least 1

  0003b	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00040	48 83 c0 02	 add	 rax, 2
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0004c	0f b7 c0	 movzx	 eax, ax
  0004f	83 f8 01	 cmp	 eax, 1
  00052	7d 07		 jge	 SHORT $LN5@stbtt__Get

; 2369 :       return 0;

  00054	33 c0		 xor	 eax, eax
  00056	e9 d9 00 00 00	 jmp	 $LN1@stbtt__Get
$LN5@stbtt__Get:

; 2370 :    if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format

  0005b	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00060	48 83 c0 08	 add	 rax, 8
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0006c	0f b7 c0	 movzx	 eax, ax
  0006f	83 f8 01	 cmp	 eax, 1
  00072	74 07		 je	 SHORT $LN6@stbtt__Get

; 2371 :       return 0;

  00074	33 c0		 xor	 eax, eax
  00076	e9 b9 00 00 00	 jmp	 $LN1@stbtt__Get
$LN6@stbtt__Get:

; 2372 : 
; 2373 :    l = 0;

  0007b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR l$[rsp], 0

; 2374 :    r = ttUSHORT(data+10) - 1;

  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR data$[rsp]
  00088	48 83 c0 0a	 add	 rax, 10
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00094	0f b7 c0	 movzx	 eax, ax
  00097	ff c8		 dec	 eax
  00099	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 2375 :    needle = glyph1 << 16 | glyph2;

  0009d	8b 44 24 58	 mov	 eax, DWORD PTR glyph1$[rsp]
  000a1	c1 e0 10	 shl	 eax, 16
  000a4	0b 44 24 60	 or	 eax, DWORD PTR glyph2$[rsp]
  000a8	89 44 24 30	 mov	 DWORD PTR needle$[rsp], eax
$LN2@stbtt__Get:

; 2376 :    while (l <= r) {

  000ac	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]
  000b0	39 44 24 28	 cmp	 DWORD PTR l$[rsp], eax
  000b4	7f 7c		 jg	 SHORT $LN3@stbtt__Get

; 2377 :       m = (l + r) >> 1;

  000b6	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]
  000ba	8b 4c 24 28	 mov	 ecx, DWORD PTR l$[rsp]
  000be	03 c8		 add	 ecx, eax
  000c0	8b c1		 mov	 eax, ecx
  000c2	d1 f8		 sar	 eax, 1
  000c4	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 2378 :       straw = ttULONG(data+18+(m*6)); // note: unaligned read

  000c8	6b 44 24 20 06	 imul	 eax, DWORD PTR m$[rsp], 6
  000cd	48 98		 cdqe
  000cf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  000d4	48 8d 44 01 12	 lea	 rax, QWORD PTR [rcx+rax+18]
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  000e1	89 44 24 2c	 mov	 DWORD PTR straw$[rsp], eax

; 2379 :       if (needle < straw)

  000e5	8b 44 24 2c	 mov	 eax, DWORD PTR straw$[rsp]
  000e9	39 44 24 30	 cmp	 DWORD PTR needle$[rsp], eax
  000ed	73 0c		 jae	 SHORT $LN7@stbtt__Get

; 2380 :          r = m - 1;

  000ef	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  000f3	ff c8		 dec	 eax
  000f5	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax
  000f9	eb 32		 jmp	 SHORT $LN8@stbtt__Get
$LN7@stbtt__Get:

; 2381 :       else if (needle > straw)

  000fb	8b 44 24 2c	 mov	 eax, DWORD PTR straw$[rsp]
  000ff	39 44 24 30	 cmp	 DWORD PTR needle$[rsp], eax
  00103	76 0c		 jbe	 SHORT $LN9@stbtt__Get

; 2382 :          l = m + 1;

  00105	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  00109	ff c0		 inc	 eax
  0010b	89 44 24 28	 mov	 DWORD PTR l$[rsp], eax
  0010f	eb 1c		 jmp	 SHORT $LN10@stbtt__Get
$LN9@stbtt__Get:

; 2383 :       else
; 2384 :          return ttSHORT(data+22+(m*6));

  00111	6b 44 24 20 06	 imul	 eax, DWORD PTR m$[rsp], 6
  00116	48 98		 cdqe
  00118	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0011d	48 8d 44 01 16	 lea	 rax, QWORD PTR [rcx+rax+22]
  00122	48 8b c8	 mov	 rcx, rax
  00125	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0012a	98		 cwde
  0012b	eb 07		 jmp	 SHORT $LN1@stbtt__Get
$LN10@stbtt__Get:
$LN8@stbtt__Get:

; 2385 :    }

  0012d	e9 7a ff ff ff	 jmp	 $LN2@stbtt__Get
$LN3@stbtt__Get:

; 2386 :    return 0;

  00132	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 2387 : }

  00134	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00138	c3		 ret	 0
?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z ENDP ; stbtt__GetGlyphKernInfoAdvance
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
output_ctx$ = 32
count_ctx$ = 88
info$ = 160
glyph_index$ = 168
pvertices$ = 176
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeT2

; 2270 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2271 :    // runs the charstring twice, once to count and once to output (to avoid realloc)
; 2272 :    stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

  00015	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR count_ctx$[rsp], 1
  0001d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR count_ctx$[rsp+4], 0
  00025	0f 57 c0	 xorps	 xmm0, xmm0
  00028	f3 0f 11 44 24
	60		 movss	 DWORD PTR count_ctx$[rsp+8], xmm0
  0002e	0f 57 c0	 xorps	 xmm0, xmm0
  00031	f3 0f 11 44 24
	64		 movss	 DWORD PTR count_ctx$[rsp+12], xmm0
  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	f3 0f 11 44 24
	68		 movss	 DWORD PTR count_ctx$[rsp+16], xmm0
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 44 24
	6c		 movss	 DWORD PTR count_ctx$[rsp+20], xmm0
  00049	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR count_ctx$[rsp+24], 0
  00051	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR count_ctx$[rsp+28], 0
  00059	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR count_ctx$[rsp+32], 0
  00061	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR count_ctx$[rsp+36], 0
  00069	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR count_ctx$[rsp+40], 0
  00075	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count_ctx$[rsp+48], 0

; 2273 :    stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);

  00080	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp], 0
  00088	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp+4], 0
  00090	0f 57 c0	 xorps	 xmm0, xmm0
  00093	f3 0f 11 44 24
	28		 movss	 DWORD PTR output_ctx$[rsp+8], xmm0
  00099	0f 57 c0	 xorps	 xmm0, xmm0
  0009c	f3 0f 11 44 24
	2c		 movss	 DWORD PTR output_ctx$[rsp+12], xmm0
  000a2	0f 57 c0	 xorps	 xmm0, xmm0
  000a5	f3 0f 11 44 24
	30		 movss	 DWORD PTR output_ctx$[rsp+16], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	f3 0f 11 44 24
	34		 movss	 DWORD PTR output_ctx$[rsp+20], xmm0
  000b4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp+24], 0
  000bc	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp+28], 0
  000c4	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp+32], 0
  000cc	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp+36], 0
  000d4	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR output_ctx$[rsp+40], 0
  000dd	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR output_ctx$[rsp+48], 0

; 2274 :    if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

  000e5	4c 8d 44 24 58	 lea	 r8, QWORD PTR count_ctx$[rsp]
  000ea	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR glyph_index$[rsp]
  000f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000f9	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  000fe	85 c0		 test	 eax, eax
  00100	74 7a		 je	 SHORT $LN2@stbtt__Get

; 2275 :       *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);

  00102	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR count_ctx$[rsp+48]
  0010a	48 6b c0 0e	 imul	 rax, rax, 14
  0010e	48 8b c8	 mov	 rcx, rax
  00111	e8 00 00 00 00	 call	 malloc
  00116	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pvertices$[rsp]
  0011e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2276 :       output_ctx.pvertices = *pvertices;

  00121	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pvertices$[rsp]
  00129	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012c	48 89 44 24 48	 mov	 QWORD PTR output_ctx$[rsp+40], rax

; 2277 :       if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

  00131	4c 8d 44 24 20	 lea	 r8, QWORD PTR output_ctx$[rsp]
  00136	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR glyph_index$[rsp]
  0013d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00145	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  0014a	85 c0		 test	 eax, eax
  0014c	74 2e		 je	 SHORT $LN3@stbtt__Get

; 2278 :          STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);

  0014e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR count_ctx$[rsp+48]
  00155	39 44 24 50	 cmp	 DWORD PTR output_ctx$[rsp+48], eax
  00159	74 1b		 je	 SHORT $LN5@stbtt__Get
  0015b	41 b8 e6 08 00
	00		 mov	 r8d, 2278		; 000008e6H
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG42127
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG42128
  0016f	e8 00 00 00 00	 call	 _wassert
  00174	33 c0		 xor	 eax, eax
$LN5@stbtt__Get:

; 2279 :          return output_ctx.num_vertices;

  00176	8b 44 24 50	 mov	 eax, DWORD PTR output_ctx$[rsp+48]
  0017a	eb 11		 jmp	 SHORT $LN1@stbtt__Get
$LN3@stbtt__Get:
$LN2@stbtt__Get:

; 2280 :       }
; 2281 :    }
; 2282 :    *pvertices = NULL;

  0017c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pvertices$[rsp]
  00184	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2283 :    return 0;

  0018b	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 2284 : }

  0018d	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00194	c3		 ret	 0
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeT2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 64
sp$ = 68
dy2$1 = 72
subr_stack_height$ = 76
dx3$2 = 80
dx2$3 = 84
dx1$4 = 88
dx6$5 = 92
dx5$6 = 96
dx4$7 = 100
dy1$8 = 104
dy5$9 = 108
b0$ = 112
f$ = 116
maskbits$ = 120
in_header$ = 124
dy6$10 = 128
tv76 = 132
tv466 = 136
dy3$11 = 140
dy4$12 = 144
clear_stack$ = 148
b$ = 152
tv188 = 168
tv225 = 172
has_subrs$ = 176
dy$13 = 180
dx$14 = 184
v$ = 188
b1$15 = 192
tv451 = 200
subrs$ = 208
$T16 = 224
$T17 = 240
$T18 = 256
$T19 = 272
$T20 = 288
$T21 = 304
$T22 = 320
$T23 = 336
s$ = 352
subr_stack$ = 544
__$ArrayPad$ = 704
info$ = 752
glyph_index$ = 760
c$ = 768
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z PROC ; stbtt__run_charstring

; 2011 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2012 :    int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;

  00029	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR in_header$[rsp], 1
  00031	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR maskbits$[rsp], 0
  00039	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR subr_stack_height$[rsp], 0
  00041	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sp$[rsp], 0

; 2013 :    int has_subrs = 0, clear_stack;

  00049	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR has_subrs$[rsp], 0

; 2014 :    float s[48];
; 2015 :    stbtt__buf subr_stack[10], subrs = info->subrs, b;

  00054	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR subrs$[rsp]
  0005c	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00064	48 8b f8	 mov	 rdi, rax
  00067	48 8d 71 70	 lea	 rsi, QWORD PTR [rcx+112]
  0006b	b9 10 00 00 00	 mov	 ecx, 16
  00070	f3 a4		 rep movsb

; 2016 :    float f;
; 2017 : 
; 2018 : #define STBTT__CSERR(s) (0)
; 2019 : 
; 2020 :    // this currently ignores the initial width value, which isn't needed if we have hmtx
; 2021 :    b = stbtt__cff_index_get(info->charstrings, glyph_index);

  00072	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T16[rsp]
  0007a	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00082	48 8b f8	 mov	 rdi, rax
  00085	48 8d 71 50	 lea	 rsi, QWORD PTR [rcx+80]
  00089	b9 10 00 00 00	 mov	 ecx, 16
  0008e	f3 a4		 rep movsb
  00090	44 8b 84 24 f8
	02 00 00	 mov	 r8d, DWORD PTR glyph_index$[rsp]
  00098	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T16[rsp]
  000a0	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  000a8	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  000ad	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  000b5	48 8b f9	 mov	 rdi, rcx
  000b8	48 8b f0	 mov	 rsi, rax
  000bb	b9 10 00 00 00	 mov	 ecx, 16
  000c0	f3 a4		 rep movsb
  000c2	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR b$[rsp]
  000ca	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  000d2	48 8b f8	 mov	 rdi, rax
  000d5	48 8b f1	 mov	 rsi, rcx
  000d8	b9 10 00 00 00	 mov	 ecx, 16
  000dd	f3 a4		 rep movsb
$LN2@stbtt__run:

; 2022 :    while (b.cursor < b.size) {

  000df	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR b$[rsp+12]
  000e6	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR b$[rsp+8], eax
  000ed	0f 8d 6e 12 00
	00		 jge	 $LN3@stbtt__run

; 2023 :       i = 0;

  000f3	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 2024 :       clear_stack = 1;

  000fb	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR clear_stack$[rsp], 1

; 2025 :       b0 = stbtt__buf_get8(&b);

  00106	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  0010e	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00113	0f b6 c0	 movzx	 eax, al
  00116	89 44 24 70	 mov	 DWORD PTR b0$[rsp], eax

; 2026 :       switch (b0) {

  0011a	8b 44 24 70	 mov	 eax, DWORD PTR b0$[rsp]
  0011e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00125	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv76[rsp]
  0012c	ff c8		 dec	 eax
  0012e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00135	83 bc 24 84 00
	00 00 1e	 cmp	 DWORD PTR tv76[rsp], 30
  0013d	0f 87 5a 11 00
	00		 ja	 $LN94@stbtt__run
  00143	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv76[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00152	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN107@stbtt__run[rcx+rax*4]
  00159	48 03 c1	 add	 rax, rcx
  0015c	ff e0		 jmp	 rax
$LN29@stbtt__run:
$LN30@stbtt__run:

; 2027 :       // @TODO implement hinting
; 2028 :       case 0x13: // hintmask
; 2029 :       case 0x14: // cntrmask
; 2030 :          if (in_header)

  0015e	83 7c 24 7c 00	 cmp	 DWORD PTR in_header$[rsp], 0
  00163	74 15		 je	 SHORT $LN31@stbtt__run

; 2031 :             maskbits += (sp / 2); // implicit "vstem"

  00165	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  00169	99		 cdq
  0016a	2b c2		 sub	 eax, edx
  0016c	d1 f8		 sar	 eax, 1
  0016e	8b 4c 24 78	 mov	 ecx, DWORD PTR maskbits$[rsp]
  00172	03 c8		 add	 ecx, eax
  00174	8b c1		 mov	 eax, ecx
  00176	89 44 24 78	 mov	 DWORD PTR maskbits$[rsp], eax
$LN31@stbtt__run:

; 2032 :          in_header = 0;

  0017a	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR in_header$[rsp], 0

; 2033 :          stbtt__buf_skip(&b, (maskbits + 7) / 8);

  00182	8b 44 24 78	 mov	 eax, DWORD PTR maskbits$[rsp]
  00186	83 c0 07	 add	 eax, 7
  00189	99		 cdq
  0018a	83 e2 07	 and	 edx, 7
  0018d	03 c2		 add	 eax, edx
  0018f	c1 f8 03	 sar	 eax, 3
  00192	8b d0		 mov	 edx, eax
  00194	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  0019c	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 2034 :          break;

  001a1	e9 a4 11 00 00	 jmp	 $LN4@stbtt__run
$LN32@stbtt__run:
$LN33@stbtt__run:
$LN34@stbtt__run:
$LN35@stbtt__run:

; 2035 : 
; 2036 :       case 0x01: // hstem
; 2037 :       case 0x03: // vstem
; 2038 :       case 0x12: // hstemhm
; 2039 :       case 0x17: // vstemhm
; 2040 :          maskbits += (sp / 2);

  001a6	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  001aa	99		 cdq
  001ab	2b c2		 sub	 eax, edx
  001ad	d1 f8		 sar	 eax, 1
  001af	8b 4c 24 78	 mov	 ecx, DWORD PTR maskbits$[rsp]
  001b3	03 c8		 add	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	89 44 24 78	 mov	 DWORD PTR maskbits$[rsp], eax

; 2041 :          break;

  001bb	e9 8a 11 00 00	 jmp	 $LN4@stbtt__run
$LN36@stbtt__run:

; 2042 : 
; 2043 :       case 0x15: // rmoveto
; 2044 :          in_header = 0;

  001c0	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR in_header$[rsp], 0

; 2045 :          if (sp < 2) return STBTT__CSERR("rmoveto stack");

  001c8	83 7c 24 44 02	 cmp	 DWORD PTR sp$[rsp], 2
  001cd	7d 07		 jge	 SHORT $LN37@stbtt__run
  001cf	33 c0		 xor	 eax, eax
  001d1	e9 8d 11 00 00	 jmp	 $LN1@stbtt__run
$LN37@stbtt__run:

; 2046 :          stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);

  001d6	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  001da	ff c8		 dec	 eax
  001dc	48 98		 cdqe
  001de	8b 4c 24 44	 mov	 ecx, DWORD PTR sp$[rsp]
  001e2	83 e9 02	 sub	 ecx, 2
  001e5	48 63 c9	 movsxd	 rcx, ecx
  001e8	f3 0f 10 94 84
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rax*4]
  001f1	f3 0f 10 8c 8c
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rcx*4]
  001fa	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00202	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 2047 :          break;

  00207	e9 3e 11 00 00	 jmp	 $LN4@stbtt__run
$LN38@stbtt__run:

; 2048 :       case 0x04: // vmoveto
; 2049 :          in_header = 0;

  0020c	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR in_header$[rsp], 0

; 2050 :          if (sp < 1) return STBTT__CSERR("vmoveto stack");

  00214	83 7c 24 44 01	 cmp	 DWORD PTR sp$[rsp], 1
  00219	7d 07		 jge	 SHORT $LN39@stbtt__run
  0021b	33 c0		 xor	 eax, eax
  0021d	e9 41 11 00 00	 jmp	 $LN1@stbtt__run
$LN39@stbtt__run:

; 2051 :          stbtt__csctx_rmove_to(c, 0, s[sp-1]);

  00222	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  00226	ff c8		 dec	 eax
  00228	48 98		 cdqe
  0022a	f3 0f 10 94 84
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rax*4]
  00233	0f 57 c9	 xorps	 xmm1, xmm1
  00236	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0023e	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 2052 :          break;

  00243	e9 02 11 00 00	 jmp	 $LN4@stbtt__run
$LN40@stbtt__run:

; 2053 :       case 0x16: // hmoveto
; 2054 :          in_header = 0;

  00248	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR in_header$[rsp], 0

; 2055 :          if (sp < 1) return STBTT__CSERR("hmoveto stack");

  00250	83 7c 24 44 01	 cmp	 DWORD PTR sp$[rsp], 1
  00255	7d 07		 jge	 SHORT $LN41@stbtt__run
  00257	33 c0		 xor	 eax, eax
  00259	e9 05 11 00 00	 jmp	 $LN1@stbtt__run
$LN41@stbtt__run:

; 2056 :          stbtt__csctx_rmove_to(c, s[sp-1], 0);

  0025e	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  00262	ff c8		 dec	 eax
  00264	48 98		 cdqe
  00266	0f 57 d2	 xorps	 xmm2, xmm2
  00269	f3 0f 10 8c 84
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rax*4]
  00272	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0027a	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 2057 :          break;

  0027f	e9 c6 10 00 00	 jmp	 $LN4@stbtt__run
$LN42@stbtt__run:

; 2058 : 
; 2059 :       case 0x05: // rlineto
; 2060 :          if (sp < 2) return STBTT__CSERR("rlineto stack");

  00284	83 7c 24 44 02	 cmp	 DWORD PTR sp$[rsp], 2
  00289	7d 07		 jge	 SHORT $LN43@stbtt__run
  0028b	33 c0		 xor	 eax, eax
  0028d	e9 d1 10 00 00	 jmp	 $LN1@stbtt__run
$LN43@stbtt__run:

; 2061 :          for (; i + 1 < sp; i += 2)

  00292	eb 0b		 jmp	 SHORT $LN8@stbtt__run
$LN6@stbtt__run:
  00294	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00298	83 c0 02	 add	 eax, 2
  0029b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN8@stbtt__run:
  0029f	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002a3	ff c0		 inc	 eax
  002a5	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  002a9	7d 2e		 jge	 SHORT $LN7@stbtt__run

; 2062 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

  002ab	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002af	ff c0		 inc	 eax
  002b1	48 98		 cdqe
  002b3	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  002b8	f3 0f 10 94 84
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rax*4]
  002c1	f3 0f 10 8c 8c
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rcx*4]
  002ca	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d2	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  002d7	eb bb		 jmp	 SHORT $LN6@stbtt__run
$LN7@stbtt__run:

; 2063 :          break;

  002d9	e9 6c 10 00 00	 jmp	 $LN4@stbtt__run
$LN44@stbtt__run:

; 2064 : 
; 2065 :       // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
; 2066 :       // starting from a different place.
; 2067 : 
; 2068 :       case 0x07: // vlineto
; 2069 :          if (sp < 1) return STBTT__CSERR("vlineto stack");

  002de	83 7c 24 44 01	 cmp	 DWORD PTR sp$[rsp], 1
  002e3	7d 07		 jge	 SHORT $LN45@stbtt__run
  002e5	33 c0		 xor	 eax, eax
  002e7	e9 77 10 00 00	 jmp	 $LN1@stbtt__run
$LN45@stbtt__run:

; 2070 :          goto vlineto;

  002ec	eb 44		 jmp	 SHORT $LN46@stbtt__run
  002ee	eb 42		 jmp	 SHORT $vlineto$108
$LN47@stbtt__run:

; 2071 :       case 0x06: // hlineto
; 2072 :          if (sp < 1) return STBTT__CSERR("hlineto stack");

  002f0	83 7c 24 44 01	 cmp	 DWORD PTR sp$[rsp], 1
  002f5	7d 07		 jge	 SHORT $LN48@stbtt__run
  002f7	33 c0		 xor	 eax, eax
  002f9	e9 65 10 00 00	 jmp	 $LN1@stbtt__run
$LN48@stbtt__run:
$LN9@stbtt__run:

; 2073 :          for (;;) {
; 2074 :             if (i >= sp) break;

  002fe	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  00302	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00306	7c 02		 jl	 SHORT $LN49@stbtt__run
  00308	eb 5e		 jmp	 SHORT $LN10@stbtt__run
$LN49@stbtt__run:

; 2075 :             stbtt__csctx_rline_to(c, s[i], 0);

  0030a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0030f	0f 57 d2	 xorps	 xmm2, xmm2
  00312	f3 0f 10 8c 84
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rax*4]
  0031b	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00323	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2076 :             i++;

  00328	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0032c	ff c0		 inc	 eax
  0032e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN46@stbtt__run:
$vlineto$108:

; 2077 :       vlineto:
; 2078 :             if (i >= sp) break;

  00332	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  00336	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0033a	7c 02		 jl	 SHORT $LN50@stbtt__run
  0033c	eb 2a		 jmp	 SHORT $LN10@stbtt__run
$LN50@stbtt__run:

; 2079 :             stbtt__csctx_rline_to(c, 0, s[i]);

  0033e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00343	f3 0f 10 94 84
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rax*4]
  0034c	0f 57 c9	 xorps	 xmm1, xmm1
  0034f	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00357	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2080 :             i++;

  0035c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00360	ff c0		 inc	 eax
  00362	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 2081 :          }

  00366	eb 96		 jmp	 SHORT $LN9@stbtt__run
$LN10@stbtt__run:

; 2082 :          break;

  00368	e9 dd 0f 00 00	 jmp	 $LN4@stbtt__run
$LN51@stbtt__run:

; 2083 : 
; 2084 :       case 0x1F: // hvcurveto
; 2085 :          if (sp < 4) return STBTT__CSERR("hvcurveto stack");

  0036d	83 7c 24 44 04	 cmp	 DWORD PTR sp$[rsp], 4
  00372	7d 07		 jge	 SHORT $LN52@stbtt__run
  00374	33 c0		 xor	 eax, eax
  00376	e9 e8 0f 00 00	 jmp	 $LN1@stbtt__run
$LN52@stbtt__run:

; 2086 :          goto hvcurveto;

  0037b	e9 da 00 00 00	 jmp	 $LN53@stbtt__run
  00380	e9 d5 00 00 00	 jmp	 $hvcurveto$109
$LN54@stbtt__run:

; 2087 :       case 0x1E: // vhcurveto
; 2088 :          if (sp < 4) return STBTT__CSERR("vhcurveto stack");

  00385	83 7c 24 44 04	 cmp	 DWORD PTR sp$[rsp], 4
  0038a	7d 07		 jge	 SHORT $LN55@stbtt__run
  0038c	33 c0		 xor	 eax, eax
  0038e	e9 d0 0f 00 00	 jmp	 $LN1@stbtt__run
$LN55@stbtt__run:
$LN12@stbtt__run:

; 2089 :          for (;;) {
; 2090 :             if (i + 3 >= sp) break;

  00393	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00397	83 c0 03	 add	 eax, 3
  0039a	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  0039e	7c 05		 jl	 SHORT $LN56@stbtt__run
  003a0	e9 81 01 00 00	 jmp	 $LN13@stbtt__run
$LN56@stbtt__run:

; 2091 :             stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);

  003a5	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003a9	8b 4c 24 44	 mov	 ecx, DWORD PTR sp$[rsp]
  003ad	2b c8		 sub	 ecx, eax
  003af	8b c1		 mov	 eax, ecx
  003b1	83 f8 05	 cmp	 eax, 5
  003b4	75 1d		 jne	 SHORT $LN101@stbtt__run
  003b6	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003ba	83 c0 04	 add	 eax, 4
  003bd	48 98		 cdqe
  003bf	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  003c8	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR tv188[rsp], xmm0
  003d1	eb 0c		 jmp	 SHORT $LN102@stbtt__run
$LN101@stbtt__run:
  003d3	0f 57 c0	 xorps	 xmm0, xmm0
  003d6	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR tv188[rsp], xmm0
$LN102@stbtt__run:
  003df	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003e3	83 c0 03	 add	 eax, 3
  003e6	48 98		 cdqe
  003e8	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  003ec	83 c1 02	 add	 ecx, 2
  003ef	48 63 c9	 movsxd	 rcx, ecx
  003f2	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  003f6	ff c2		 inc	 edx
  003f8	48 63 d2	 movsxd	 rdx, edx
  003fb	48 63 7c 24 40	 movsxd	 rdi, DWORD PTR i$[rsp]
  00400	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR tv188[rsp]
  00409	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0040f	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  00418	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0041e	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  00427	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0042d	f3 0f 10 9c 94
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdx*4]
  00436	f3 0f 10 94 bc
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rdi*4]
  0043f	0f 57 c9	 xorps	 xmm1, xmm1
  00442	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0044a	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2092 :             i += 4;

  0044f	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00453	83 c0 04	 add	 eax, 4
  00456	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN53@stbtt__run:
$hvcurveto$109:

; 2093 :       hvcurveto:
; 2094 :             if (i + 3 >= sp) break;

  0045a	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0045e	83 c0 03	 add	 eax, 3
  00461	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  00465	7c 05		 jl	 SHORT $LN57@stbtt__run
  00467	e9 ba 00 00 00	 jmp	 $LN13@stbtt__run
$LN57@stbtt__run:

; 2095 :             stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);

  0046c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00470	8b 4c 24 44	 mov	 ecx, DWORD PTR sp$[rsp]
  00474	2b c8		 sub	 ecx, eax
  00476	8b c1		 mov	 eax, ecx
  00478	83 f8 05	 cmp	 eax, 5
  0047b	75 1d		 jne	 SHORT $LN103@stbtt__run
  0047d	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00481	83 c0 04	 add	 eax, 4
  00484	48 98		 cdqe
  00486	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  0048f	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR tv225[rsp], xmm0
  00498	eb 0c		 jmp	 SHORT $LN104@stbtt__run
$LN103@stbtt__run:
  0049a	0f 57 c0	 xorps	 xmm0, xmm0
  0049d	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR tv225[rsp], xmm0
$LN104@stbtt__run:
  004a6	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  004aa	83 c0 03	 add	 eax, 3
  004ad	48 98		 cdqe
  004af	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  004b3	83 c1 02	 add	 ecx, 2
  004b6	48 63 c9	 movsxd	 rcx, ecx
  004b9	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  004bd	ff c2		 inc	 edx
  004bf	48 63 d2	 movsxd	 rdx, edx
  004c2	48 63 7c 24 40	 movsxd	 rdi, DWORD PTR i$[rsp]
  004c7	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  004d0	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  004d6	f3 0f 10 84 24
	ac 00 00 00	 movss	 xmm0, DWORD PTR tv225[rsp]
  004df	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  004e5	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  004ee	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  004f4	f3 0f 10 9c 94
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdx*4]
  004fd	0f 57 d2	 xorps	 xmm2, xmm2
  00500	f3 0f 10 8c bc
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rdi*4]
  00509	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00511	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2096 :             i += 4;

  00516	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0051a	83 c0 04	 add	 eax, 4
  0051d	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 2097 :          }

  00521	e9 6d fe ff ff	 jmp	 $LN12@stbtt__run
$LN13@stbtt__run:

; 2098 :          break;

  00526	e9 1f 0e 00 00	 jmp	 $LN4@stbtt__run
$LN58@stbtt__run:

; 2099 : 
; 2100 :       case 0x08: // rrcurveto
; 2101 :          if (sp < 6) return STBTT__CSERR("rcurveline stack");

  0052b	83 7c 24 44 06	 cmp	 DWORD PTR sp$[rsp], 6
  00530	7d 07		 jge	 SHORT $LN59@stbtt__run
  00532	33 c0		 xor	 eax, eax
  00534	e9 2a 0e 00 00	 jmp	 $LN1@stbtt__run
$LN59@stbtt__run:

; 2102 :          for (; i + 5 < sp; i += 6)

  00539	eb 0b		 jmp	 SHORT $LN17@stbtt__run
$LN15@stbtt__run:
  0053b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0053f	83 c0 06	 add	 eax, 6
  00542	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN17@stbtt__run:
  00546	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0054a	83 c0 05	 add	 eax, 5
  0054d	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  00551	0f 8d 90 00 00
	00		 jge	 $LN16@stbtt__run

; 2103 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

  00557	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0055b	83 c0 05	 add	 eax, 5
  0055e	48 98		 cdqe
  00560	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00564	83 c1 04	 add	 ecx, 4
  00567	48 63 c9	 movsxd	 rcx, ecx
  0056a	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  0056e	83 c2 03	 add	 edx, 3
  00571	48 63 d2	 movsxd	 rdx, edx
  00574	8b 7c 24 40	 mov	 edi, DWORD PTR i$[rsp]
  00578	83 c7 02	 add	 edi, 2
  0057b	48 63 ff	 movsxd	 rdi, edi
  0057e	8b 74 24 40	 mov	 esi, DWORD PTR i$[rsp]
  00582	ff c6		 inc	 esi
  00584	48 63 f6	 movsxd	 rsi, esi
  00587	4c 63 44 24 40	 movsxd	 r8, DWORD PTR i$[rsp]
  0058c	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  00595	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0059b	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  005a4	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  005aa	f3 0f 10 84 94
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rdx*4]
  005b3	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  005b9	f3 0f 10 9c bc
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdi*4]
  005c2	f3 0f 10 94 b4
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rsi*4]
  005cb	f3 42 0f 10 8c
	84 60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+r8*4]
  005d5	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005dd	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  005e2	e9 54 ff ff ff	 jmp	 $LN15@stbtt__run
$LN16@stbtt__run:

; 2104 :          break;

  005e7	e9 5e 0d 00 00	 jmp	 $LN4@stbtt__run
$LN60@stbtt__run:

; 2105 : 
; 2106 :       case 0x18: // rcurveline
; 2107 :          if (sp < 8) return STBTT__CSERR("rcurveline stack");

  005ec	83 7c 24 44 08	 cmp	 DWORD PTR sp$[rsp], 8
  005f1	7d 07		 jge	 SHORT $LN61@stbtt__run
  005f3	33 c0		 xor	 eax, eax
  005f5	e9 69 0d 00 00	 jmp	 $LN1@stbtt__run
$LN61@stbtt__run:

; 2108 :          for (; i + 5 < sp - 2; i += 6)

  005fa	eb 0b		 jmp	 SHORT $LN20@stbtt__run
$LN18@stbtt__run:
  005fc	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00600	83 c0 06	 add	 eax, 6
  00603	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN20@stbtt__run:
  00607	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0060b	83 c0 05	 add	 eax, 5
  0060e	8b 4c 24 44	 mov	 ecx, DWORD PTR sp$[rsp]
  00612	83 e9 02	 sub	 ecx, 2
  00615	3b c1		 cmp	 eax, ecx
  00617	0f 8d 90 00 00
	00		 jge	 $LN19@stbtt__run

; 2109 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

  0061d	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00621	83 c0 05	 add	 eax, 5
  00624	48 98		 cdqe
  00626	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  0062a	83 c1 04	 add	 ecx, 4
  0062d	48 63 c9	 movsxd	 rcx, ecx
  00630	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00634	83 c2 03	 add	 edx, 3
  00637	48 63 d2	 movsxd	 rdx, edx
  0063a	8b 7c 24 40	 mov	 edi, DWORD PTR i$[rsp]
  0063e	83 c7 02	 add	 edi, 2
  00641	48 63 ff	 movsxd	 rdi, edi
  00644	8b 74 24 40	 mov	 esi, DWORD PTR i$[rsp]
  00648	ff c6		 inc	 esi
  0064a	48 63 f6	 movsxd	 rsi, esi
  0064d	4c 63 44 24 40	 movsxd	 r8, DWORD PTR i$[rsp]
  00652	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  0065b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00661	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  0066a	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00670	f3 0f 10 84 94
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rdx*4]
  00679	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0067f	f3 0f 10 9c bc
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdi*4]
  00688	f3 0f 10 94 b4
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rsi*4]
  00691	f3 42 0f 10 8c
	84 60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+r8*4]
  0069b	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006a3	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  006a8	e9 4f ff ff ff	 jmp	 $LN18@stbtt__run
$LN19@stbtt__run:

; 2110 :          if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");

  006ad	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  006b1	ff c0		 inc	 eax
  006b3	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  006b7	7c 07		 jl	 SHORT $LN62@stbtt__run
  006b9	33 c0		 xor	 eax, eax
  006bb	e9 a3 0c 00 00	 jmp	 $LN1@stbtt__run
$LN62@stbtt__run:

; 2111 :          stbtt__csctx_rline_to(c, s[i], s[i+1]);

  006c0	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  006c4	ff c0		 inc	 eax
  006c6	48 98		 cdqe
  006c8	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  006cd	f3 0f 10 94 84
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rax*4]
  006d6	f3 0f 10 8c 8c
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rcx*4]
  006df	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006e7	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2112 :          break;

  006ec	e9 59 0c 00 00	 jmp	 $LN4@stbtt__run
$LN63@stbtt__run:

; 2113 : 
; 2114 :       case 0x19: // rlinecurve
; 2115 :          if (sp < 8) return STBTT__CSERR("rlinecurve stack");

  006f1	83 7c 24 44 08	 cmp	 DWORD PTR sp$[rsp], 8
  006f6	7d 07		 jge	 SHORT $LN64@stbtt__run
  006f8	33 c0		 xor	 eax, eax
  006fa	e9 64 0c 00 00	 jmp	 $LN1@stbtt__run
$LN64@stbtt__run:

; 2116 :          for (; i + 1 < sp - 6; i += 2)

  006ff	eb 0b		 jmp	 SHORT $LN23@stbtt__run
$LN21@stbtt__run:
  00701	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00705	83 c0 02	 add	 eax, 2
  00708	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN23@stbtt__run:
  0070c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00710	ff c0		 inc	 eax
  00712	8b 4c 24 44	 mov	 ecx, DWORD PTR sp$[rsp]
  00716	83 e9 06	 sub	 ecx, 6
  00719	3b c1		 cmp	 eax, ecx
  0071b	7d 2e		 jge	 SHORT $LN22@stbtt__run

; 2117 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

  0071d	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00721	ff c0		 inc	 eax
  00723	48 98		 cdqe
  00725	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0072a	f3 0f 10 94 84
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rax*4]
  00733	f3 0f 10 8c 8c
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rcx*4]
  0073c	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00744	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  00749	eb b6		 jmp	 SHORT $LN21@stbtt__run
$LN22@stbtt__run:

; 2118 :          if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");

  0074b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0074f	83 c0 05	 add	 eax, 5
  00752	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  00756	7c 07		 jl	 SHORT $LN65@stbtt__run
  00758	33 c0		 xor	 eax, eax
  0075a	e9 04 0c 00 00	 jmp	 $LN1@stbtt__run
$LN65@stbtt__run:

; 2119 :          stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

  0075f	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00763	83 c0 05	 add	 eax, 5
  00766	48 98		 cdqe
  00768	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  0076c	83 c1 04	 add	 ecx, 4
  0076f	48 63 c9	 movsxd	 rcx, ecx
  00772	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00776	83 c2 03	 add	 edx, 3
  00779	48 63 d2	 movsxd	 rdx, edx
  0077c	8b 7c 24 40	 mov	 edi, DWORD PTR i$[rsp]
  00780	83 c7 02	 add	 edi, 2
  00783	48 63 ff	 movsxd	 rdi, edi
  00786	8b 74 24 40	 mov	 esi, DWORD PTR i$[rsp]
  0078a	ff c6		 inc	 esi
  0078c	48 63 f6	 movsxd	 rsi, esi
  0078f	4c 63 44 24 40	 movsxd	 r8, DWORD PTR i$[rsp]
  00794	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  0079d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  007a3	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  007ac	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  007b2	f3 0f 10 84 94
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rdx*4]
  007bb	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  007c1	f3 0f 10 9c bc
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdi*4]
  007ca	f3 0f 10 94 b4
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rsi*4]
  007d3	f3 42 0f 10 8c
	84 60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+r8*4]
  007dd	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007e5	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2120 :          break;

  007ea	e9 5b 0b 00 00	 jmp	 $LN4@stbtt__run
$LN66@stbtt__run:
$LN67@stbtt__run:

; 2121 : 
; 2122 :       case 0x1A: // vvcurveto
; 2123 :       case 0x1B: // hhcurveto
; 2124 :          if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");

  007ef	83 7c 24 44 04	 cmp	 DWORD PTR sp$[rsp], 4
  007f4	7d 07		 jge	 SHORT $LN68@stbtt__run
  007f6	33 c0		 xor	 eax, eax
  007f8	e9 66 0b 00 00	 jmp	 $LN1@stbtt__run
$LN68@stbtt__run:

; 2125 :          f = 0.0;

  007fd	0f 57 c0	 xorps	 xmm0, xmm0
  00800	f3 0f 11 44 24
	74		 movss	 DWORD PTR f$[rsp], xmm0

; 2126 :          if (sp & 1) { f = s[i]; i++; }

  00806	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  0080a	83 e0 01	 and	 eax, 1
  0080d	85 c0		 test	 eax, eax
  0080f	74 1e		 je	 SHORT $LN69@stbtt__run
  00811	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00816	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  0081f	f3 0f 11 44 24
	74		 movss	 DWORD PTR f$[rsp], xmm0
  00825	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00829	ff c0		 inc	 eax
  0082b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN69@stbtt__run:

; 2127 :          for (; i + 3 < sp; i += 4) {

  0082f	eb 0b		 jmp	 SHORT $LN26@stbtt__run
$LN24@stbtt__run:
  00831	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00835	83 c0 04	 add	 eax, 4
  00838	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN26@stbtt__run:
  0083c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00840	83 c0 03	 add	 eax, 3
  00843	3b 44 24 44	 cmp	 eax, DWORD PTR sp$[rsp]
  00847	0f 8d f1 00 00
	00		 jge	 $LN25@stbtt__run

; 2128 :             if (b0 == 0x1B)

  0084d	83 7c 24 70 1b	 cmp	 DWORD PTR b0$[rsp], 27
  00852	75 6f		 jne	 SHORT $LN70@stbtt__run

; 2129 :                stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);

  00854	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00858	83 c0 03	 add	 eax, 3
  0085b	48 98		 cdqe
  0085d	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00861	83 c1 02	 add	 ecx, 2
  00864	48 63 c9	 movsxd	 rcx, ecx
  00867	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  0086b	ff c2		 inc	 edx
  0086d	48 63 d2	 movsxd	 rdx, edx
  00870	48 63 7c 24 40	 movsxd	 rdi, DWORD PTR i$[rsp]
  00875	0f 57 c0	 xorps	 xmm0, xmm0
  00878	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0087e	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  00887	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0088d	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  00896	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0089c	f3 0f 10 9c 94
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdx*4]
  008a5	f3 0f 10 54 24
	74		 movss	 xmm2, DWORD PTR f$[rsp]
  008ab	f3 0f 10 8c bc
	60 01 00 00	 movss	 xmm1, DWORD PTR s$[rsp+rdi*4]
  008b4	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  008bc	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  008c1	eb 6d		 jmp	 SHORT $LN71@stbtt__run
$LN70@stbtt__run:

; 2130 :             else
; 2131 :                stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);

  008c3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  008c7	83 c0 03	 add	 eax, 3
  008ca	48 98		 cdqe
  008cc	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  008d0	83 c1 02	 add	 ecx, 2
  008d3	48 63 c9	 movsxd	 rcx, ecx
  008d6	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  008da	ff c2		 inc	 edx
  008dc	48 63 d2	 movsxd	 rdx, edx
  008df	48 63 7c 24 40	 movsxd	 rdi, DWORD PTR i$[rsp]
  008e4	f3 0f 10 84 84
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax*4]
  008ed	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  008f3	0f 57 c0	 xorps	 xmm0, xmm0
  008f6	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  008fc	f3 0f 10 84 8c
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rcx*4]
  00905	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0090b	f3 0f 10 9c 94
	60 01 00 00	 movss	 xmm3, DWORD PTR s$[rsp+rdx*4]
  00914	f3 0f 10 94 bc
	60 01 00 00	 movss	 xmm2, DWORD PTR s$[rsp+rdi*4]
  0091d	f3 0f 10 4c 24
	74		 movss	 xmm1, DWORD PTR f$[rsp]
  00923	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0092b	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
$LN71@stbtt__run:

; 2132 :             f = 0.0;

  00930	0f 57 c0	 xorps	 xmm0, xmm0
  00933	f3 0f 11 44 24
	74		 movss	 DWORD PTR f$[rsp], xmm0

; 2133 :          }

  00939	e9 f3 fe ff ff	 jmp	 $LN24@stbtt__run
$LN25@stbtt__run:

; 2134 :          break;

  0093e	e9 07 0a 00 00	 jmp	 $LN4@stbtt__run
$LN72@stbtt__run:

; 2135 : 
; 2136 :       case 0x0A: // callsubr
; 2137 :          if (!has_subrs) {

  00943	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR has_subrs$[rsp], 0
  0094b	75 6b		 jne	 SHORT $LN73@stbtt__run

; 2138 :             if (info->fdselect.size)

  0094d	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00955	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  0095c	74 4f		 je	 SHORT $LN74@stbtt__run

; 2139 :                subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);

  0095e	44 8b 84 24 f8
	02 00 00	 mov	 r8d, DWORD PTR glyph_index$[rsp]
  00966	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR info$[rsp]
  0096e	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  00976	e8 00 00 00 00	 call	 ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ; stbtt__cid_get_glyph_subrs
  0097b	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00983	48 8b f9	 mov	 rdi, rcx
  00986	48 8b f0	 mov	 rsi, rax
  00989	b9 10 00 00 00	 mov	 ecx, 16
  0098e	f3 a4		 rep movsb
  00990	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR subrs$[rsp]
  00998	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  009a0	48 8b f8	 mov	 rdi, rax
  009a3	48 8b f1	 mov	 rsi, rcx
  009a6	b9 10 00 00 00	 mov	 ecx, 16
  009ab	f3 a4		 rep movsb
$LN74@stbtt__run:

; 2140 :             has_subrs = 1;

  009ad	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR has_subrs$[rsp], 1
$LN73@stbtt__run:
$LN75@stbtt__run:

; 2141 :          }
; 2142 :          // FALLTHROUGH
; 2143 :       case 0x1D: // callgsubr
; 2144 :          if (sp < 1) return STBTT__CSERR("call(g|)subr stack");

  009b8	83 7c 24 44 01	 cmp	 DWORD PTR sp$[rsp], 1
  009bd	7d 07		 jge	 SHORT $LN76@stbtt__run
  009bf	33 c0		 xor	 eax, eax
  009c1	e9 9d 09 00 00	 jmp	 $LN1@stbtt__run
$LN76@stbtt__run:

; 2145 :          v = (int) s[--sp];

  009c6	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  009ca	ff c8		 dec	 eax
  009cc	89 44 24 44	 mov	 DWORD PTR sp$[rsp], eax
  009d0	48 63 44 24 44	 movsxd	 rax, DWORD PTR sp$[rsp]
  009d5	f3 0f 2c 84 84
	60 01 00 00	 cvttss2si eax, DWORD PTR s$[rsp+rax*4]
  009de	89 84 24 bc 00
	00 00		 mov	 DWORD PTR v$[rsp], eax

; 2146 :          if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");

  009e5	83 7c 24 4c 0a	 cmp	 DWORD PTR subr_stack_height$[rsp], 10
  009ea	7c 07		 jl	 SHORT $LN77@stbtt__run
  009ec	33 c0		 xor	 eax, eax
  009ee	e9 70 09 00 00	 jmp	 $LN1@stbtt__run
$LN77@stbtt__run:

; 2147 :          subr_stack[subr_stack_height++] = b;

  009f3	48 63 44 24 4c	 movsxd	 rax, DWORD PTR subr_stack_height$[rsp]
  009f8	48 6b c0 10	 imul	 rax, rax, 16
  009fc	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  00a04	48 8d bc 04 20
	02 00 00	 lea	 rdi, QWORD PTR subr_stack$[rsp+rax]
  00a0c	48 8b f1	 mov	 rsi, rcx
  00a0f	b9 10 00 00 00	 mov	 ecx, 16
  00a14	f3 a4		 rep movsb
  00a16	8b 44 24 4c	 mov	 eax, DWORD PTR subr_stack_height$[rsp]
  00a1a	ff c0		 inc	 eax
  00a1c	89 44 24 4c	 mov	 DWORD PTR subr_stack_height$[rsp], eax

; 2148 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

  00a20	83 7c 24 70 0a	 cmp	 DWORD PTR b0$[rsp], 10
  00a25	75 12		 jne	 SHORT $LN105@stbtt__run
  00a27	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR subrs$[rsp]
  00a2f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv451[rsp], rax
  00a37	eb 14		 jmp	 SHORT $LN106@stbtt__run
$LN105@stbtt__run:
  00a39	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00a41	48 83 c0 60	 add	 rax, 96			; 00000060H
  00a45	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv451[rsp], rax
$LN106@stbtt__run:
  00a4d	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR $T19[rsp]
  00a55	48 8b f8	 mov	 rdi, rax
  00a58	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR tv451[rsp]
  00a60	b9 10 00 00 00	 mov	 ecx, 16
  00a65	f3 a4		 rep movsb
  00a67	44 8b 84 24 bc
	00 00 00	 mov	 r8d, DWORD PTR v$[rsp]
  00a6f	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR $T19[rsp]
  00a77	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  00a7f	e8 00 00 00 00	 call	 ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__get_subr
  00a84	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  00a8c	48 8b f9	 mov	 rdi, rcx
  00a8f	48 8b f0	 mov	 rsi, rax
  00a92	b9 10 00 00 00	 mov	 ecx, 16
  00a97	f3 a4		 rep movsb
  00a99	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR b$[rsp]
  00aa1	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  00aa9	48 8b f8	 mov	 rdi, rax
  00aac	48 8b f1	 mov	 rsi, rcx
  00aaf	b9 10 00 00 00	 mov	 ecx, 16
  00ab4	f3 a4		 rep movsb

; 2149 :          if (b.size == 0) return STBTT__CSERR("subr not found");

  00ab6	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR b$[rsp+12], 0
  00abe	75 07		 jne	 SHORT $LN78@stbtt__run
  00ac0	33 c0		 xor	 eax, eax
  00ac2	e9 9c 08 00 00	 jmp	 $LN1@stbtt__run
$LN78@stbtt__run:

; 2150 :          b.cursor = 0;

  00ac7	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR b$[rsp+8], 0

; 2151 :          clear_stack = 0;

  00ad2	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR clear_stack$[rsp], 0

; 2152 :          break;

  00add	e9 68 08 00 00	 jmp	 $LN4@stbtt__run
$LN79@stbtt__run:

; 2153 : 
; 2154 :       case 0x0B: // return
; 2155 :          if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");

  00ae2	83 7c 24 4c 00	 cmp	 DWORD PTR subr_stack_height$[rsp], 0
  00ae7	7f 07		 jg	 SHORT $LN80@stbtt__run
  00ae9	33 c0		 xor	 eax, eax
  00aeb	e9 73 08 00 00	 jmp	 $LN1@stbtt__run
$LN80@stbtt__run:

; 2156 :          b = subr_stack[--subr_stack_height];

  00af0	8b 44 24 4c	 mov	 eax, DWORD PTR subr_stack_height$[rsp]
  00af4	ff c8		 dec	 eax
  00af6	89 44 24 4c	 mov	 DWORD PTR subr_stack_height$[rsp], eax
  00afa	48 63 44 24 4c	 movsxd	 rax, DWORD PTR subr_stack_height$[rsp]
  00aff	48 6b c0 10	 imul	 rax, rax, 16
  00b03	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  00b0b	48 8b f9	 mov	 rdi, rcx
  00b0e	48 8d b4 04 20
	02 00 00	 lea	 rsi, QWORD PTR subr_stack$[rsp+rax]
  00b16	b9 10 00 00 00	 mov	 ecx, 16
  00b1b	f3 a4		 rep movsb

; 2157 :          clear_stack = 0;

  00b1d	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR clear_stack$[rsp], 0

; 2158 :          break;

  00b28	e9 1d 08 00 00	 jmp	 $LN4@stbtt__run
$LN81@stbtt__run:

; 2159 : 
; 2160 :       case 0x0E: // endchar
; 2161 :          stbtt__csctx_close_shape(c);

  00b2d	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00b35	e8 00 00 00 00	 call	 ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 2162 :          return 1;

  00b3a	b8 01 00 00 00	 mov	 eax, 1
  00b3f	e9 1f 08 00 00	 jmp	 $LN1@stbtt__run
$LN82@stbtt__run:

; 2163 : 
; 2164 :       case 0x0C: { // two-byte escape
; 2165 :          float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
; 2166 :          float dx, dy;
; 2167 :          int b1 = stbtt__buf_get8(&b);

  00b44	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  00b4c	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00b51	0f b6 c0	 movzx	 eax, al
  00b54	89 84 24 c0 00
	00 00		 mov	 DWORD PTR b1$15[rsp], eax

; 2168 :          switch (b1) {

  00b5b	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR b1$15[rsp]
  00b62	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv466[rsp], eax
  00b69	83 bc 24 88 00
	00 00 22	 cmp	 DWORD PTR tv466[rsp], 34 ; 00000022H
  00b71	74 2f		 je	 SHORT $LN83@stbtt__run
  00b73	83 bc 24 88 00
	00 00 23	 cmp	 DWORD PTR tv466[rsp], 35 ; 00000023H
  00b7b	0f 84 5d 01 00
	00		 je	 $LN85@stbtt__run
  00b81	83 bc 24 88 00
	00 00 24	 cmp	 DWORD PTR tv466[rsp], 36 ; 00000024H
  00b89	0f 84 1a 03 00
	00		 je	 $LN87@stbtt__run
  00b8f	83 bc 24 88 00
	00 00 25	 cmp	 DWORD PTR tv466[rsp], 37 ; 00000025H
  00b97	0f 84 8a 04 00
	00		 je	 $LN89@stbtt__run
  00b9d	e9 ef 06 00 00	 jmp	 $LN93@stbtt__run
$LN83@stbtt__run:

; 2169 :          // @TODO These "flex" implementations ignore the flex-depth and resolution,
; 2170 :          // and always draw beziers.
; 2171 :          case 0x22: // hflex
; 2172 :             if (sp < 7) return STBTT__CSERR("hflex stack");

  00ba2	83 7c 24 44 07	 cmp	 DWORD PTR sp$[rsp], 7
  00ba7	7d 07		 jge	 SHORT $LN84@stbtt__run
  00ba9	33 c0		 xor	 eax, eax
  00bab	e9 b3 07 00 00	 jmp	 $LN1@stbtt__run
$LN84@stbtt__run:

; 2173 :             dx1 = s[0];

  00bb0	b8 04 00 00 00	 mov	 eax, 4
  00bb5	48 6b c0 00	 imul	 rax, rax, 0
  00bb9	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00bc2	f3 0f 11 44 24
	58		 movss	 DWORD PTR dx1$4[rsp], xmm0

; 2174 :             dx2 = s[1];

  00bc8	b8 04 00 00 00	 mov	 eax, 4
  00bcd	48 6b c0 01	 imul	 rax, rax, 1
  00bd1	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00bda	f3 0f 11 44 24
	54		 movss	 DWORD PTR dx2$3[rsp], xmm0

; 2175 :             dy2 = s[2];

  00be0	b8 04 00 00 00	 mov	 eax, 4
  00be5	48 6b c0 02	 imul	 rax, rax, 2
  00be9	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00bf2	f3 0f 11 44 24
	48		 movss	 DWORD PTR dy2$1[rsp], xmm0

; 2176 :             dx3 = s[3];

  00bf8	b8 04 00 00 00	 mov	 eax, 4
  00bfd	48 6b c0 03	 imul	 rax, rax, 3
  00c01	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00c0a	f3 0f 11 44 24
	50		 movss	 DWORD PTR dx3$2[rsp], xmm0

; 2177 :             dx4 = s[4];

  00c10	b8 04 00 00 00	 mov	 eax, 4
  00c15	48 6b c0 04	 imul	 rax, rax, 4
  00c19	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00c22	f3 0f 11 44 24
	64		 movss	 DWORD PTR dx4$7[rsp], xmm0

; 2178 :             dx5 = s[5];

  00c28	b8 04 00 00 00	 mov	 eax, 4
  00c2d	48 6b c0 05	 imul	 rax, rax, 5
  00c31	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00c3a	f3 0f 11 44 24
	60		 movss	 DWORD PTR dx5$6[rsp], xmm0

; 2179 :             dx6 = s[6];

  00c40	b8 04 00 00 00	 mov	 eax, 4
  00c45	48 6b c0 06	 imul	 rax, rax, 6
  00c49	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00c52	f3 0f 11 44 24
	5c		 movss	 DWORD PTR dx6$5[rsp], xmm0

; 2180 :             stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);

  00c58	0f 57 c0	 xorps	 xmm0, xmm0
  00c5b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00c61	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR dx3$2[rsp]
  00c67	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00c6d	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR dy2$1[rsp]
  00c73	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00c79	f3 0f 10 5c 24
	54		 movss	 xmm3, DWORD PTR dx2$3[rsp]
  00c7f	0f 57 d2	 xorps	 xmm2, xmm2
  00c82	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR dx1$4[rsp]
  00c88	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00c90	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2181 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);

  00c95	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR dy2$1[rsp]
  00c9b	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00ca2	0f 57 c9	 xorps	 xmm1, xmm1
  00ca5	f3 0f 11 4c 24
	30		 movss	 DWORD PTR [rsp+48], xmm1
  00cab	f3 0f 10 4c 24
	5c		 movss	 xmm1, DWORD PTR dx6$5[rsp]
  00cb1	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  00cb7	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00cbd	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR dx5$6[rsp]
  00cc3	0f 57 d2	 xorps	 xmm2, xmm2
  00cc6	f3 0f 10 4c 24
	64		 movss	 xmm1, DWORD PTR dx4$7[rsp]
  00ccc	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00cd4	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2182 :             break;

  00cd9	e9 ba 05 00 00	 jmp	 $LN27@stbtt__run
$LN85@stbtt__run:

; 2183 : 
; 2184 :          case 0x23: // flex
; 2185 :             if (sp < 13) return STBTT__CSERR("flex stack");

  00cde	83 7c 24 44 0d	 cmp	 DWORD PTR sp$[rsp], 13
  00ce3	7d 07		 jge	 SHORT $LN86@stbtt__run
  00ce5	33 c0		 xor	 eax, eax
  00ce7	e9 77 06 00 00	 jmp	 $LN1@stbtt__run
$LN86@stbtt__run:

; 2186 :             dx1 = s[0];

  00cec	b8 04 00 00 00	 mov	 eax, 4
  00cf1	48 6b c0 00	 imul	 rax, rax, 0
  00cf5	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00cfe	f3 0f 11 44 24
	58		 movss	 DWORD PTR dx1$4[rsp], xmm0

; 2187 :             dy1 = s[1];

  00d04	b8 04 00 00 00	 mov	 eax, 4
  00d09	48 6b c0 01	 imul	 rax, rax, 1
  00d0d	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00d16	f3 0f 11 44 24
	68		 movss	 DWORD PTR dy1$8[rsp], xmm0

; 2188 :             dx2 = s[2];

  00d1c	b8 04 00 00 00	 mov	 eax, 4
  00d21	48 6b c0 02	 imul	 rax, rax, 2
  00d25	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00d2e	f3 0f 11 44 24
	54		 movss	 DWORD PTR dx2$3[rsp], xmm0

; 2189 :             dy2 = s[3];

  00d34	b8 04 00 00 00	 mov	 eax, 4
  00d39	48 6b c0 03	 imul	 rax, rax, 3
  00d3d	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00d46	f3 0f 11 44 24
	48		 movss	 DWORD PTR dy2$1[rsp], xmm0

; 2190 :             dx3 = s[4];

  00d4c	b8 04 00 00 00	 mov	 eax, 4
  00d51	48 6b c0 04	 imul	 rax, rax, 4
  00d55	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00d5e	f3 0f 11 44 24
	50		 movss	 DWORD PTR dx3$2[rsp], xmm0

; 2191 :             dy3 = s[5];

  00d64	b8 04 00 00 00	 mov	 eax, 4
  00d69	48 6b c0 05	 imul	 rax, rax, 5
  00d6d	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00d76	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR dy3$11[rsp], xmm0

; 2192 :             dx4 = s[6];

  00d7f	b8 04 00 00 00	 mov	 eax, 4
  00d84	48 6b c0 06	 imul	 rax, rax, 6
  00d88	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00d91	f3 0f 11 44 24
	64		 movss	 DWORD PTR dx4$7[rsp], xmm0

; 2193 :             dy4 = s[7];

  00d97	b8 04 00 00 00	 mov	 eax, 4
  00d9c	48 6b c0 07	 imul	 rax, rax, 7
  00da0	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00da9	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR dy4$12[rsp], xmm0

; 2194 :             dx5 = s[8];

  00db2	b8 04 00 00 00	 mov	 eax, 4
  00db7	48 6b c0 08	 imul	 rax, rax, 8
  00dbb	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00dc4	f3 0f 11 44 24
	60		 movss	 DWORD PTR dx5$6[rsp], xmm0

; 2195 :             dy5 = s[9];

  00dca	b8 04 00 00 00	 mov	 eax, 4
  00dcf	48 6b c0 09	 imul	 rax, rax, 9
  00dd3	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00ddc	f3 0f 11 44 24
	6c		 movss	 DWORD PTR dy5$9[rsp], xmm0

; 2196 :             dx6 = s[10];

  00de2	b8 04 00 00 00	 mov	 eax, 4
  00de7	48 6b c0 0a	 imul	 rax, rax, 10
  00deb	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00df4	f3 0f 11 44 24
	5c		 movss	 DWORD PTR dx6$5[rsp], xmm0

; 2197 :             dy6 = s[11];

  00dfa	b8 04 00 00 00	 mov	 eax, 4
  00dff	48 6b c0 0b	 imul	 rax, rax, 11
  00e03	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00e0c	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR dy6$10[rsp], xmm0

; 2198 :             //fd is s[12]
; 2199 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

  00e15	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR dy3$11[rsp]
  00e1e	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00e24	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR dx3$2[rsp]
  00e2a	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00e30	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR dy2$1[rsp]
  00e36	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00e3c	f3 0f 10 5c 24
	54		 movss	 xmm3, DWORD PTR dx2$3[rsp]
  00e42	f3 0f 10 54 24
	68		 movss	 xmm2, DWORD PTR dy1$8[rsp]
  00e48	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR dx1$4[rsp]
  00e4e	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00e56	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2200 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

  00e5b	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR dy6$10[rsp]
  00e64	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00e6a	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR dx6$5[rsp]
  00e70	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00e76	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR dy5$9[rsp]
  00e7c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00e82	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR dx5$6[rsp]
  00e88	f3 0f 10 94 24
	90 00 00 00	 movss	 xmm2, DWORD PTR dy4$12[rsp]
  00e91	f3 0f 10 4c 24
	64		 movss	 xmm1, DWORD PTR dx4$7[rsp]
  00e97	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00e9f	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2201 :             break;

  00ea4	e9 ef 03 00 00	 jmp	 $LN27@stbtt__run
$LN87@stbtt__run:

; 2202 : 
; 2203 :          case 0x24: // hflex1
; 2204 :             if (sp < 9) return STBTT__CSERR("hflex1 stack");

  00ea9	83 7c 24 44 09	 cmp	 DWORD PTR sp$[rsp], 9
  00eae	7d 07		 jge	 SHORT $LN88@stbtt__run
  00eb0	33 c0		 xor	 eax, eax
  00eb2	e9 ac 04 00 00	 jmp	 $LN1@stbtt__run
$LN88@stbtt__run:

; 2205 :             dx1 = s[0];

  00eb7	b8 04 00 00 00	 mov	 eax, 4
  00ebc	48 6b c0 00	 imul	 rax, rax, 0
  00ec0	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00ec9	f3 0f 11 44 24
	58		 movss	 DWORD PTR dx1$4[rsp], xmm0

; 2206 :             dy1 = s[1];

  00ecf	b8 04 00 00 00	 mov	 eax, 4
  00ed4	48 6b c0 01	 imul	 rax, rax, 1
  00ed8	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00ee1	f3 0f 11 44 24
	68		 movss	 DWORD PTR dy1$8[rsp], xmm0

; 2207 :             dx2 = s[2];

  00ee7	b8 04 00 00 00	 mov	 eax, 4
  00eec	48 6b c0 02	 imul	 rax, rax, 2
  00ef0	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00ef9	f3 0f 11 44 24
	54		 movss	 DWORD PTR dx2$3[rsp], xmm0

; 2208 :             dy2 = s[3];

  00eff	b8 04 00 00 00	 mov	 eax, 4
  00f04	48 6b c0 03	 imul	 rax, rax, 3
  00f08	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00f11	f3 0f 11 44 24
	48		 movss	 DWORD PTR dy2$1[rsp], xmm0

; 2209 :             dx3 = s[4];

  00f17	b8 04 00 00 00	 mov	 eax, 4
  00f1c	48 6b c0 04	 imul	 rax, rax, 4
  00f20	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00f29	f3 0f 11 44 24
	50		 movss	 DWORD PTR dx3$2[rsp], xmm0

; 2210 :             dx4 = s[5];

  00f2f	b8 04 00 00 00	 mov	 eax, 4
  00f34	48 6b c0 05	 imul	 rax, rax, 5
  00f38	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00f41	f3 0f 11 44 24
	64		 movss	 DWORD PTR dx4$7[rsp], xmm0

; 2211 :             dx5 = s[6];

  00f47	b8 04 00 00 00	 mov	 eax, 4
  00f4c	48 6b c0 06	 imul	 rax, rax, 6
  00f50	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00f59	f3 0f 11 44 24
	60		 movss	 DWORD PTR dx5$6[rsp], xmm0

; 2212 :             dy5 = s[7];

  00f5f	b8 04 00 00 00	 mov	 eax, 4
  00f64	48 6b c0 07	 imul	 rax, rax, 7
  00f68	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00f71	f3 0f 11 44 24
	6c		 movss	 DWORD PTR dy5$9[rsp], xmm0

; 2213 :             dx6 = s[8];

  00f77	b8 04 00 00 00	 mov	 eax, 4
  00f7c	48 6b c0 08	 imul	 rax, rax, 8
  00f80	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  00f89	f3 0f 11 44 24
	5c		 movss	 DWORD PTR dx6$5[rsp], xmm0

; 2214 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);

  00f8f	0f 57 c0	 xorps	 xmm0, xmm0
  00f92	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00f98	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR dx3$2[rsp]
  00f9e	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00fa4	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR dy2$1[rsp]
  00faa	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00fb0	f3 0f 10 5c 24
	54		 movss	 xmm3, DWORD PTR dx2$3[rsp]
  00fb6	f3 0f 10 54 24
	68		 movss	 xmm2, DWORD PTR dy1$8[rsp]
  00fbc	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR dx1$4[rsp]
  00fc2	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00fca	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2215 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));

  00fcf	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR dy1$8[rsp]
  00fd5	f3 0f 58 44 24
	48		 addss	 xmm0, DWORD PTR dy2$1[rsp]
  00fdb	f3 0f 58 44 24
	6c		 addss	 xmm0, DWORD PTR dy5$9[rsp]
  00fe1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00fe8	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00fee	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR dx6$5[rsp]
  00ff4	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00ffa	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR dy5$9[rsp]
  01000	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  01006	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR dx5$6[rsp]
  0100c	0f 57 d2	 xorps	 xmm2, xmm2
  0100f	f3 0f 10 4c 24
	64		 movss	 xmm1, DWORD PTR dx4$7[rsp]
  01015	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0101d	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2216 :             break;

  01022	e9 71 02 00 00	 jmp	 $LN27@stbtt__run
$LN89@stbtt__run:

; 2217 : 
; 2218 :          case 0x25: // flex1
; 2219 :             if (sp < 11) return STBTT__CSERR("flex1 stack");

  01027	83 7c 24 44 0b	 cmp	 DWORD PTR sp$[rsp], 11
  0102c	7d 07		 jge	 SHORT $LN90@stbtt__run
  0102e	33 c0		 xor	 eax, eax
  01030	e9 2e 03 00 00	 jmp	 $LN1@stbtt__run
$LN90@stbtt__run:

; 2220 :             dx1 = s[0];

  01035	b8 04 00 00 00	 mov	 eax, 4
  0103a	48 6b c0 00	 imul	 rax, rax, 0
  0103e	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  01047	f3 0f 11 44 24
	58		 movss	 DWORD PTR dx1$4[rsp], xmm0

; 2221 :             dy1 = s[1];

  0104d	b8 04 00 00 00	 mov	 eax, 4
  01052	48 6b c0 01	 imul	 rax, rax, 1
  01056	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  0105f	f3 0f 11 44 24
	68		 movss	 DWORD PTR dy1$8[rsp], xmm0

; 2222 :             dx2 = s[2];

  01065	b8 04 00 00 00	 mov	 eax, 4
  0106a	48 6b c0 02	 imul	 rax, rax, 2
  0106e	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  01077	f3 0f 11 44 24
	54		 movss	 DWORD PTR dx2$3[rsp], xmm0

; 2223 :             dy2 = s[3];

  0107d	b8 04 00 00 00	 mov	 eax, 4
  01082	48 6b c0 03	 imul	 rax, rax, 3
  01086	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  0108f	f3 0f 11 44 24
	48		 movss	 DWORD PTR dy2$1[rsp], xmm0

; 2224 :             dx3 = s[4];

  01095	b8 04 00 00 00	 mov	 eax, 4
  0109a	48 6b c0 04	 imul	 rax, rax, 4
  0109e	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  010a7	f3 0f 11 44 24
	50		 movss	 DWORD PTR dx3$2[rsp], xmm0

; 2225 :             dy3 = s[5];

  010ad	b8 04 00 00 00	 mov	 eax, 4
  010b2	48 6b c0 05	 imul	 rax, rax, 5
  010b6	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  010bf	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR dy3$11[rsp], xmm0

; 2226 :             dx4 = s[6];

  010c8	b8 04 00 00 00	 mov	 eax, 4
  010cd	48 6b c0 06	 imul	 rax, rax, 6
  010d1	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  010da	f3 0f 11 44 24
	64		 movss	 DWORD PTR dx4$7[rsp], xmm0

; 2227 :             dy4 = s[7];

  010e0	b8 04 00 00 00	 mov	 eax, 4
  010e5	48 6b c0 07	 imul	 rax, rax, 7
  010e9	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  010f2	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR dy4$12[rsp], xmm0

; 2228 :             dx5 = s[8];

  010fb	b8 04 00 00 00	 mov	 eax, 4
  01100	48 6b c0 08	 imul	 rax, rax, 8
  01104	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  0110d	f3 0f 11 44 24
	60		 movss	 DWORD PTR dx5$6[rsp], xmm0

; 2229 :             dy5 = s[9];

  01113	b8 04 00 00 00	 mov	 eax, 4
  01118	48 6b c0 09	 imul	 rax, rax, 9
  0111c	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  01125	f3 0f 11 44 24
	6c		 movss	 DWORD PTR dy5$9[rsp], xmm0

; 2230 :             dx6 = dy6 = s[10];

  0112b	b8 04 00 00 00	 mov	 eax, 4
  01130	48 6b c0 0a	 imul	 rax, rax, 10
  01134	f3 0f 10 84 04
	60 01 00 00	 movss	 xmm0, DWORD PTR s$[rsp+rax]
  0113d	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR dy6$10[rsp], xmm0
  01146	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR dy6$10[rsp]
  0114f	f3 0f 11 44 24
	5c		 movss	 DWORD PTR dx6$5[rsp], xmm0

; 2231 :             dx = dx1+dx2+dx3+dx4+dx5;

  01155	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR dx1$4[rsp]
  0115b	f3 0f 58 44 24
	54		 addss	 xmm0, DWORD PTR dx2$3[rsp]
  01161	f3 0f 58 44 24
	50		 addss	 xmm0, DWORD PTR dx3$2[rsp]
  01167	f3 0f 58 44 24
	64		 addss	 xmm0, DWORD PTR dx4$7[rsp]
  0116d	f3 0f 58 44 24
	60		 addss	 xmm0, DWORD PTR dx5$6[rsp]
  01173	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR dx$14[rsp], xmm0

; 2232 :             dy = dy1+dy2+dy3+dy4+dy5;

  0117c	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR dy1$8[rsp]
  01182	f3 0f 58 44 24
	48		 addss	 xmm0, DWORD PTR dy2$1[rsp]
  01188	f3 0f 58 84 24
	8c 00 00 00	 addss	 xmm0, DWORD PTR dy3$11[rsp]
  01191	f3 0f 58 84 24
	90 00 00 00	 addss	 xmm0, DWORD PTR dy4$12[rsp]
  0119a	f3 0f 58 44 24
	6c		 addss	 xmm0, DWORD PTR dy5$9[rsp]
  011a0	f3 0f 11 84 24
	b4 00 00 00	 movss	 DWORD PTR dy$13[rsp], xmm0

; 2233 :             if (STBTT_fabs(dx) > STBTT_fabs(dy))

  011a9	f3 0f 5a 84 24
	b8 00 00 00	 cvtss2sd xmm0, DWORD PTR dx$14[rsp]
  011b2	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  011b9	f3 0f 5a 8c 24
	b4 00 00 00	 cvtss2sd xmm1, DWORD PTR dy$13[rsp]
  011c2	0f 54 0d 00 00
	00 00		 andps	 xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  011c9	66 0f 2f c1	 comisd	 xmm0, xmm1
  011cd	76 1b		 jbe	 SHORT $LN91@stbtt__run

; 2234 :                dy6 = -dy;

  011cf	f3 0f 10 84 24
	b4 00 00 00	 movss	 xmm0, DWORD PTR dy$13[rsp]
  011d8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  011df	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR dy6$10[rsp], xmm0
  011e8	eb 16		 jmp	 SHORT $LN92@stbtt__run
$LN91@stbtt__run:

; 2235 :             else
; 2236 :                dx6 = -dx;

  011ea	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR dx$14[rsp]
  011f3	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  011fa	f3 0f 11 44 24
	5c		 movss	 DWORD PTR dx6$5[rsp], xmm0
$LN92@stbtt__run:

; 2237 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

  01200	f3 0f 10 84 24
	8c 00 00 00	 movss	 xmm0, DWORD PTR dy3$11[rsp]
  01209	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0120f	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR dx3$2[rsp]
  01215	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0121b	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR dy2$1[rsp]
  01221	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  01227	f3 0f 10 5c 24
	54		 movss	 xmm3, DWORD PTR dx2$3[rsp]
  0122d	f3 0f 10 54 24
	68		 movss	 xmm2, DWORD PTR dy1$8[rsp]
  01233	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR dx1$4[rsp]
  01239	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  01241	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2238 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

  01246	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR dy6$10[rsp]
  0124f	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  01255	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR dx6$5[rsp]
  0125b	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  01261	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR dy5$9[rsp]
  01267	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0126d	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR dx5$6[rsp]
  01273	f3 0f 10 94 24
	90 00 00 00	 movss	 xmm2, DWORD PTR dy4$12[rsp]
  0127c	f3 0f 10 4c 24
	64		 movss	 xmm1, DWORD PTR dx4$7[rsp]
  01282	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0128a	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2239 :             break;

  0128f	eb 07		 jmp	 SHORT $LN27@stbtt__run
$LN93@stbtt__run:

; 2240 : 
; 2241 :          default:
; 2242 :             return STBTT__CSERR("unimplemented");

  01291	33 c0		 xor	 eax, eax
  01293	e9 cb 00 00 00	 jmp	 $LN1@stbtt__run
$LN27@stbtt__run:

; 2243 :          }
; 2244 :       } break;

  01298	e9 ad 00 00 00	 jmp	 $LN4@stbtt__run
$LN94@stbtt__run:

; 2245 : 
; 2246 :       default:
; 2247 :          if (b0 != 255 && b0 != 28 && b0 < 32)

  0129d	81 7c 24 70 ff
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 255	; 000000ffH
  012a5	74 15		 je	 SHORT $LN95@stbtt__run
  012a7	83 7c 24 70 1c	 cmp	 DWORD PTR b0$[rsp], 28
  012ac	74 0e		 je	 SHORT $LN95@stbtt__run
  012ae	83 7c 24 70 20	 cmp	 DWORD PTR b0$[rsp], 32	; 00000020H
  012b3	7d 07		 jge	 SHORT $LN95@stbtt__run

; 2248 :             return STBTT__CSERR("reserved operator");

  012b5	33 c0		 xor	 eax, eax
  012b7	e9 a7 00 00 00	 jmp	 $LN1@stbtt__run
$LN95@stbtt__run:

; 2249 : 
; 2250 :          // push immediate
; 2251 :          if (b0 == 255) {

  012bc	81 7c 24 70 ff
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 255	; 000000ffH
  012c4	75 26		 jne	 SHORT $LN96@stbtt__run

; 2252 :             f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;

  012c6	ba 04 00 00 00	 mov	 edx, 4
  012cb	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  012d3	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  012d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  012dc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  012e4	f3 0f 11 44 24
	74		 movss	 DWORD PTR f$[rsp], xmm0

; 2253 :          } else {

  012ea	eb 2a		 jmp	 SHORT $LN97@stbtt__run
$LN96@stbtt__run:

; 2254 :             stbtt__buf_skip(&b, -1);

  012ec	ba ff ff ff ff	 mov	 edx, -1
  012f1	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  012f9	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 2255 :             f = (float)(stbtt_int16)stbtt__cff_int(&b);

  012fe	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR b$[rsp]
  01306	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  0130b	98		 cwde
  0130c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  01310	f3 0f 11 44 24
	74		 movss	 DWORD PTR f$[rsp], xmm0
$LN97@stbtt__run:

; 2256 :          }
; 2257 :          if (sp >= 48) return STBTT__CSERR("push stack overflow");

  01316	83 7c 24 44 30	 cmp	 DWORD PTR sp$[rsp], 48	; 00000030H
  0131b	7c 04		 jl	 SHORT $LN98@stbtt__run
  0131d	33 c0		 xor	 eax, eax
  0131f	eb 42		 jmp	 SHORT $LN1@stbtt__run
$LN98@stbtt__run:

; 2258 :          s[sp++] = f;

  01321	48 63 44 24 44	 movsxd	 rax, DWORD PTR sp$[rsp]
  01326	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR f$[rsp]
  0132c	f3 0f 11 84 84
	60 01 00 00	 movss	 DWORD PTR s$[rsp+rax*4], xmm0
  01335	8b 44 24 44	 mov	 eax, DWORD PTR sp$[rsp]
  01339	ff c0		 inc	 eax
  0133b	89 44 24 44	 mov	 DWORD PTR sp$[rsp], eax

; 2259 :          clear_stack = 0;

  0133f	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR clear_stack$[rsp], 0
$LN4@stbtt__run:

; 2260 :          break;
; 2261 :       }
; 2262 :       if (clear_stack) sp = 0;

  0134a	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR clear_stack$[rsp], 0
  01352	74 08		 je	 SHORT $LN99@stbtt__run
  01354	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR sp$[rsp], 0
$LN99@stbtt__run:

; 2263 :    }

  0135c	e9 7e ed ff ff	 jmp	 $LN2@stbtt__run
$LN3@stbtt__run:

; 2264 :    return STBTT__CSERR("no endchar");

  01361	33 c0		 xor	 eax, eax
$LN1@stbtt__run:

; 2265 : 
; 2266 : #undef STBTT__CSERR
; 2267 : }

  01363	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0136b	48 33 cc	 xor	 rcx, rsp
  0136e	e8 00 00 00 00	 call	 __security_check_cookie
  01373	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  0137a	5f		 pop	 rdi
  0137b	5e		 pop	 rsi
  0137c	c3		 ret	 0
  0137d	0f 1f 00	 npad	 3
$LN107@stbtt__run:
  01380	00 00 00 00	 DD	 $LN32@stbtt__run
  01384	00 00 00 00	 DD	 $LN94@stbtt__run
  01388	00 00 00 00	 DD	 $LN33@stbtt__run
  0138c	00 00 00 00	 DD	 $LN38@stbtt__run
  01390	00 00 00 00	 DD	 $LN42@stbtt__run
  01394	00 00 00 00	 DD	 $LN47@stbtt__run
  01398	00 00 00 00	 DD	 $LN44@stbtt__run
  0139c	00 00 00 00	 DD	 $LN58@stbtt__run
  013a0	00 00 00 00	 DD	 $LN94@stbtt__run
  013a4	00 00 00 00	 DD	 $LN72@stbtt__run
  013a8	00 00 00 00	 DD	 $LN79@stbtt__run
  013ac	00 00 00 00	 DD	 $LN82@stbtt__run
  013b0	00 00 00 00	 DD	 $LN94@stbtt__run
  013b4	00 00 00 00	 DD	 $LN81@stbtt__run
  013b8	00 00 00 00	 DD	 $LN94@stbtt__run
  013bc	00 00 00 00	 DD	 $LN94@stbtt__run
  013c0	00 00 00 00	 DD	 $LN94@stbtt__run
  013c4	00 00 00 00	 DD	 $LN34@stbtt__run
  013c8	00 00 00 00	 DD	 $LN29@stbtt__run
  013cc	00 00 00 00	 DD	 $LN30@stbtt__run
  013d0	00 00 00 00	 DD	 $LN36@stbtt__run
  013d4	00 00 00 00	 DD	 $LN40@stbtt__run
  013d8	00 00 00 00	 DD	 $LN35@stbtt__run
  013dc	00 00 00 00	 DD	 $LN60@stbtt__run
  013e0	00 00 00 00	 DD	 $LN63@stbtt__run
  013e4	00 00 00 00	 DD	 $LN66@stbtt__run
  013e8	00 00 00 00	 DD	 $LN67@stbtt__run
  013ec	00 00 00 00	 DD	 $LN94@stbtt__run
  013f0	00 00 00 00	 DD	 $LN75@stbtt__run
  013f4	00 00 00 00	 DD	 $LN54@stbtt__run
  013f8	00 00 00 00	 DD	 $LN51@stbtt__run
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ENDP ; stbtt__run_charstring
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
fdselector$ = 32
i$ = 36
fmt$ = 40
end$ = 44
start$ = 48
fdselect$ = 56
nranges$ = 72
v$ = 76
$T1 = 80
$T2 = 96
$T3 = 112
$T4 = 128
$T5 = 144
$T6 = 160
$T7 = 176
$T8 = 192
$T9 = 208
$T10 = 256
info$ = 264
glyph_index$ = 272
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z PROC ; stbtt__cid_get_glyph_subrs

; 1983 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1984 :    stbtt__buf fdselect = info->fdselect;

  00018	48 8d 44 24 38	 lea	 rax, QWORD PTR fdselect$[rsp]
  0001d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00025	48 8b f8	 mov	 rdi, rax
  00028	48 8d b1 90 00
	00 00		 lea	 rsi, QWORD PTR [rcx+144]
  0002f	b9 10 00 00 00	 mov	 ecx, 16
  00034	f3 a4		 rep movsb

; 1985 :    int nranges, start, end, v, fmt, fdselector = -1, i;

  00036	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR fdselector$[rsp], -1

; 1986 : 
; 1987 :    stbtt__buf_seek(&fdselect, 0);

  0003e	33 d2		 xor	 edx, edx
  00040	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  00045	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1988 :    fmt = stbtt__buf_get8(&fdselect);

  0004a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  0004f	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00054	0f b6 c0	 movzx	 eax, al
  00057	89 44 24 28	 mov	 DWORD PTR fmt$[rsp], eax

; 1989 :    if (fmt == 0) {

  0005b	83 7c 24 28 00	 cmp	 DWORD PTR fmt$[rsp], 0
  00060	75 27		 jne	 SHORT $LN5@stbtt__cid

; 1990 :       // untested
; 1991 :       stbtt__buf_skip(&fdselect, glyph_index);

  00062	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR glyph_index$[rsp]
  00069	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1992 :       fdselector = stbtt__buf_get8(&fdselect);

  00073	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  00078	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  0007d	0f b6 c0	 movzx	 eax, al
  00080	89 44 24 20	 mov	 DWORD PTR fdselector$[rsp], eax
  00084	e9 a1 00 00 00	 jmp	 $LN6@stbtt__cid
$LN5@stbtt__cid:

; 1993 :    } else if (fmt == 3) {

  00089	83 7c 24 28 03	 cmp	 DWORD PTR fmt$[rsp], 3
  0008e	0f 85 96 00 00
	00		 jne	 $LN7@stbtt__cid

; 1994 :       nranges = stbtt__buf_get16(&fdselect);

  00094	ba 02 00 00 00	 mov	 edx, 2
  00099	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  0009e	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000a3	89 44 24 48	 mov	 DWORD PTR nranges$[rsp], eax

; 1995 :       start = stbtt__buf_get16(&fdselect);

  000a7	ba 02 00 00 00	 mov	 edx, 2
  000ac	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  000b1	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000b6	89 44 24 30	 mov	 DWORD PTR start$[rsp], eax

; 1996 :       for (i = 0; i < nranges; i++) {

  000ba	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c2	eb 0a		 jmp	 SHORT $LN4@stbtt__cid
$LN2@stbtt__cid:
  000c4	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000c8	ff c0		 inc	 eax
  000ca	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__cid:
  000ce	8b 44 24 48	 mov	 eax, DWORD PTR nranges$[rsp]
  000d2	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000d6	7d 52		 jge	 SHORT $LN3@stbtt__cid

; 1997 :          v = stbtt__buf_get8(&fdselect);

  000d8	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  000dd	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  000e2	0f b6 c0	 movzx	 eax, al
  000e5	89 44 24 4c	 mov	 DWORD PTR v$[rsp], eax

; 1998 :          end = stbtt__buf_get16(&fdselect);

  000e9	ba 02 00 00 00	 mov	 edx, 2
  000ee	48 8d 4c 24 38	 lea	 rcx, QWORD PTR fdselect$[rsp]
  000f3	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000f8	89 44 24 2c	 mov	 DWORD PTR end$[rsp], eax

; 1999 :          if (glyph_index >= start && glyph_index < end) {

  000fc	8b 44 24 30	 mov	 eax, DWORD PTR start$[rsp]
  00100	39 84 24 10 01
	00 00		 cmp	 DWORD PTR glyph_index$[rsp], eax
  00107	7c 17		 jl	 SHORT $LN8@stbtt__cid
  00109	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  0010d	39 84 24 10 01
	00 00		 cmp	 DWORD PTR glyph_index$[rsp], eax
  00114	7d 0a		 jge	 SHORT $LN8@stbtt__cid

; 2000 :             fdselector = v;

  00116	8b 44 24 4c	 mov	 eax, DWORD PTR v$[rsp]
  0011a	89 44 24 20	 mov	 DWORD PTR fdselector$[rsp], eax

; 2001 :             break;

  0011e	eb 0a		 jmp	 SHORT $LN3@stbtt__cid
$LN8@stbtt__cid:

; 2002 :          }
; 2003 :          start = end;

  00120	8b 44 24 2c	 mov	 eax, DWORD PTR end$[rsp]
  00124	89 44 24 30	 mov	 DWORD PTR start$[rsp], eax

; 2004 :       }

  00128	eb 9a		 jmp	 SHORT $LN2@stbtt__cid
$LN3@stbtt__cid:
$LN7@stbtt__cid:
$LN6@stbtt__cid:

; 2005 :    }
; 2006 :    if (fdselector == -1) stbtt__new_buf(NULL, 0);

  0012a	83 7c 24 20 ff	 cmp	 DWORD PTR fdselector$[rsp], -1
  0012f	75 27		 jne	 SHORT $LN9@stbtt__cid
  00131	45 33 c0	 xor	 r8d, r8d
  00134	33 d2		 xor	 edx, edx
  00136	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  0013e	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  00143	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0014b	48 8b f9	 mov	 rdi, rcx
  0014e	48 8b f0	 mov	 rsi, rax
  00151	b9 10 00 00 00	 mov	 ecx, 16
  00156	f3 a4		 rep movsb
$LN9@stbtt__cid:

; 2007 :    return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));

  00158	48 8d 44 24 50	 lea	 rax, QWORD PTR $T1[rsp]
  0015d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00165	48 8b f8	 mov	 rdi, rax
  00168	48 8d b1 80 00
	00 00		 lea	 rsi, QWORD PTR [rcx+128]
  0016f	b9 10 00 00 00	 mov	 ecx, 16
  00174	f3 a4		 rep movsb
  00176	44 8b 44 24 20	 mov	 r8d, DWORD PTR fdselector$[rsp]
  0017b	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T1[rsp]
  00180	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00188	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  0018d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  00192	48 8b f9	 mov	 rdi, rcx
  00195	48 8b f0	 mov	 rsi, rax
  00198	b9 10 00 00 00	 mov	 ecx, 16
  0019d	f3 a4		 rep movsb
  0019f	48 8d 44 24 70	 lea	 rax, QWORD PTR $T3[rsp]
  001a4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  001a9	48 8b f8	 mov	 rdi, rax
  001ac	48 8b f1	 mov	 rsi, rcx
  001af	b9 10 00 00 00	 mov	 ecx, 16
  001b4	f3 a4		 rep movsb
  001b6	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  001be	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  001c6	48 8b f8	 mov	 rdi, rax
  001c9	48 8d 71 40	 lea	 rsi, QWORD PTR [rcx+64]
  001cd	b9 10 00 00 00	 mov	 ecx, 16
  001d2	f3 a4		 rep movsb
  001d4	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T3[rsp]
  001d9	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  001e1	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  001e9	e8 00 00 00 00	 call	 ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
  001ee	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  001f6	48 8b f9	 mov	 rdi, rcx
  001f9	48 8b f0	 mov	 rsi, rax
  001fc	b9 10 00 00 00	 mov	 ecx, 16
  00201	f3 a4		 rep movsb
  00203	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  0020b	48 8b bc 24 00
	01 00 00	 mov	 rdi, QWORD PTR $T10[rsp]
  00213	48 8b f0	 mov	 rsi, rax
  00216	b9 10 00 00 00	 mov	 ecx, 16
  0021b	f3 a4		 rep movsb
  0021d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR $T10[rsp]

; 2008 : }

  00225	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0022c	5f		 pop	 rdi
  0022d	5e		 pop	 rsi
  0022e	c3		 ret	 0
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ENDP ; stbtt__cid_get_glyph_subrs
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
bias$ = 32
count$ = 36
$T1 = 40
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 160
idx$ = 168
n$ = 176
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z PROC		; stbtt__get_subr

; 1969 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1970 :    int count = stbtt__cff_index_count(&idx);

  00018	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR idx$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z ; stbtt__cff_index_count
  00025	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax

; 1971 :    int bias = 107;

  00029	c7 44 24 20 6b
	00 00 00	 mov	 DWORD PTR bias$[rsp], 107 ; 0000006bH

; 1972 :    if (count >= 33900)

  00031	81 7c 24 24 6c
	84 00 00	 cmp	 DWORD PTR count$[rsp], 33900 ; 0000846cH
  00039	7c 0a		 jl	 SHORT $LN2@stbtt__get

; 1973 :       bias = 32768;

  0003b	c7 44 24 20 00
	80 00 00	 mov	 DWORD PTR bias$[rsp], 32768 ; 00008000H
  00043	eb 12		 jmp	 SHORT $LN3@stbtt__get
$LN2@stbtt__get:

; 1974 :    else if (count >= 1240)

  00045	81 7c 24 24 d8
	04 00 00	 cmp	 DWORD PTR count$[rsp], 1240 ; 000004d8H
  0004d	7c 08		 jl	 SHORT $LN4@stbtt__get

; 1975 :       bias = 1131;

  0004f	c7 44 24 20 6b
	04 00 00	 mov	 DWORD PTR bias$[rsp], 1131 ; 0000046bH
$LN4@stbtt__get:
$LN3@stbtt__get:

; 1976 :    n += bias;

  00057	8b 44 24 20	 mov	 eax, DWORD PTR bias$[rsp]
  0005b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR n$[rsp]
  00062	03 c8		 add	 ecx, eax
  00064	8b c1		 mov	 eax, ecx
  00066	89 84 24 b0 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 1977 :    if (n < 0 || n >= count)

  0006d	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR n$[rsp], 0
  00075	7c 0d		 jl	 SHORT $LN6@stbtt__get
  00077	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  0007b	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR n$[rsp], eax
  00082	7c 42		 jl	 SHORT $LN5@stbtt__get
$LN6@stbtt__get:

; 1978 :       return stbtt__new_buf(NULL, 0);

  00084	45 33 c0	 xor	 r8d, r8d
  00087	33 d2		 xor	 edx, edx
  00089	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  0008e	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  00093	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  00098	48 8b f9	 mov	 rdi, rcx
  0009b	48 8b f0	 mov	 rsi, rax
  0009e	b9 10 00 00 00	 mov	 ecx, 16
  000a3	f3 a4		 rep movsb
  000a5	48 8d 44 24 28	 lea	 rax, QWORD PTR $T1[rsp]
  000aa	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR $T6[rsp]
  000b2	48 8b f0	 mov	 rsi, rax
  000b5	b9 10 00 00 00	 mov	 ecx, 16
  000ba	f3 a4		 rep movsb
  000bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  000c4	eb 5f		 jmp	 SHORT $LN1@stbtt__get
$LN5@stbtt__get:

; 1979 :    return stbtt__cff_index_get(idx, n);

  000c6	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  000cb	48 8b f8	 mov	 rdi, rax
  000ce	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR idx$[rsp]
  000d6	b9 10 00 00 00	 mov	 ecx, 16
  000db	f3 a4		 rep movsb
  000dd	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR n$[rsp]
  000e5	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  000ea	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  000f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  000f9	48 8b f9	 mov	 rdi, rcx
  000fc	48 8b f0	 mov	 rsi, rax
  000ff	b9 10 00 00 00	 mov	 ecx, 16
  00104	f3 a4		 rep movsb
  00106	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  0010b	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR $T6[rsp]
  00113	48 8b f0	 mov	 rsi, rax
  00116	b9 10 00 00 00	 mov	 ecx, 16
  0011b	f3 a4		 rep movsb
  0011d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
$LN1@stbtt__get:

; 1980 : }

  00125	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0012c	5f		 pop	 rdi
  0012d	5e		 pop	 rsi
  0012e	c3		 ret	 0
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ENDP		; stbtt__get_subr
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
cy2$ = 64
cx2$ = 68
cy1$ = 72
cx1$ = 76
ctx$ = 96
dx1$ = 104
dy1$ = 112
dx2$ = 120
dy2$ = 128
dx3$ = 136
dy3$ = 144
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z PROC ; stbtt__csctx_rccurve_to

; 1958 : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1959 :    float cx1 = ctx->x + dx1;

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00020	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00025	f3 0f 58 44 24
	68		 addss	 xmm0, DWORD PTR dx1$[rsp]
  0002b	f3 0f 11 44 24
	4c		 movss	 DWORD PTR cx1$[rsp], xmm0

; 1960 :    float cy1 = ctx->y + dy1;

  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00036	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  0003b	f3 0f 58 44 24
	70		 addss	 xmm0, DWORD PTR dy1$[rsp]
  00041	f3 0f 11 44 24
	48		 movss	 DWORD PTR cy1$[rsp], xmm0

; 1961 :    float cx2 = cx1 + dx2;

  00047	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR cx1$[rsp]
  0004d	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR dx2$[rsp]
  00053	f3 0f 11 44 24
	44		 movss	 DWORD PTR cx2$[rsp], xmm0

; 1962 :    float cy2 = cy1 + dy2;

  00059	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR cy1$[rsp]
  0005f	f3 0f 58 84 24
	80 00 00 00	 addss	 xmm0, DWORD PTR dy2$[rsp]
  00068	f3 0f 11 44 24
	40		 movss	 DWORD PTR cy2$[rsp], xmm0

; 1963 :    ctx->x = cx2 + dx3;

  0006e	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR cx2$[rsp]
  00074	f3 0f 58 84 24
	88 00 00 00	 addss	 xmm0, DWORD PTR dx3$[rsp]
  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00082	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 1964 :    ctx->y = cy2 + dy3;

  00087	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR cy2$[rsp]
  0008d	f3 0f 58 84 24
	90 00 00 00	 addss	 xmm0, DWORD PTR dy3$[rsp]
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0009b	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 1965 :    stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

  000a0	f3 0f 2c 44 24
	40		 cvttss2si eax, DWORD PTR cy2$[rsp]
  000a6	f3 0f 2c 4c 24
	44		 cvttss2si ecx, DWORD PTR cx2$[rsp]
  000ac	f3 0f 2c 54 24
	48		 cvttss2si edx, DWORD PTR cy1$[rsp]
  000b2	f3 44 0f 2c 44
	24 4c		 cvttss2si r8d, DWORD PTR cx1$[rsp]
  000b9	4c 8b 4c 24 60	 mov	 r9, QWORD PTR ctx$[rsp]
  000be	f3 45 0f 2c 49
	14		 cvttss2si r9d, DWORD PTR [r9+20]
  000c4	4c 8b 54 24 60	 mov	 r10, QWORD PTR ctx$[rsp]
  000c9	f3 45 0f 2c 52
	10		 cvttss2si r10d, DWORD PTR [r10+16]
  000cf	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000d3	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  000d7	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  000db	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  000e0	45 8b c2	 mov	 r8d, r10d
  000e3	b2 04		 mov	 dl, 4
  000e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  000ea	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 1966 : }

  000ef	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f3	c3		 ret	 0
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ENDP ; stbtt__csctx_rccurve_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
ctx$ = 80
dx$ = 88
dy$ = 96
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rline_to

; 1951 : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1952 :    ctx->x += dx;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  0001a	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  0001f	f3 0f 58 44 24
	58		 addss	 xmm0, DWORD PTR dx$[rsp]
  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  0002a	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 1953 :    ctx->y += dy;

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00034	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  00039	f3 0f 58 44 24
	60		 addss	 xmm0, DWORD PTR dy$[rsp]
  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00044	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 1954 :    stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  0004e	f3 0f 2c 40 14	 cvttss2si eax, DWORD PTR [rax+20]
  00053	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ctx$[rsp]
  00058	f3 0f 2c 49 10	 cvttss2si ecx, DWORD PTR [rcx+16]
  0005d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  00065	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0006d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00075	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0007d	44 8b c8	 mov	 r9d, eax
  00080	44 8b c1	 mov	 r8d, ecx
  00083	b2 02		 mov	 dl, 2
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ctx$[rsp]
  0008a	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 1955 : }

  0008f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00093	c3		 ret	 0
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rline_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv68 = 64
tv72 = 68
ctx$ = 96
dx$ = 104
dy$ = 112
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rmove_to

; 1943 : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1944 :    stbtt__csctx_close_shape(ctx);

  00015	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  0001a	e8 00 00 00 00	 call	 ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 1945 :    ctx->first_x = ctx->x = ctx->x + dx;

  0001f	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00024	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00029	f3 0f 58 44 24
	68		 addss	 xmm0, DWORD PTR dx$[rsp]
  0002f	f3 0f 11 44 24
	40		 movss	 DWORD PTR tv68[rsp], xmm0
  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0003a	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR tv68[rsp]
  00040	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
  00045	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0004a	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR tv68[rsp]
  00050	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 1946 :    ctx->first_y = ctx->y = ctx->y + dy;

  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  0005a	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  0005f	f3 0f 58 44 24
	70		 addss	 xmm0, DWORD PTR dy$[rsp]
  00065	f3 0f 11 44 24
	44		 movss	 DWORD PTR tv72[rsp], xmm0
  0006b	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00070	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR tv72[rsp]
  00076	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00080	f3 0f 10 44 24
	44		 movss	 xmm0, DWORD PTR tv72[rsp]
  00086	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 1947 :    stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

  0008b	48 8b 44 24 60	 mov	 rax, QWORD PTR ctx$[rsp]
  00090	f3 0f 2c 40 14	 cvttss2si eax, DWORD PTR [rax+20]
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  0009a	f3 0f 2c 49 10	 cvttss2si ecx, DWORD PTR [rcx+16]
  0009f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  000a7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  000af	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  000b7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000bf	44 8b c8	 mov	 r9d, eax
  000c2	44 8b c1	 mov	 r8d, ecx
  000c5	b2 01		 mov	 dl, 1
  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ctx$[rsp]
  000cc	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 1948 : }

  000d1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d5	c3		 ret	 0
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rmove_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
ctx$ = 80
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z PROC	; stbtt__csctx_close_shape

; 1937 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1938 :    if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ctx$[rsp]
  00013	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00018	0f 2e 41 10	 ucomiss xmm0, DWORD PTR [rcx+16]
  0001c	7a 19		 jp	 SHORT $LN3@stbtt__csc
  0001e	75 17		 jne	 SHORT $LN3@stbtt__csc
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00025	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ctx$[rsp]
  0002a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0002f	0f 2e 41 14	 ucomiss xmm0, DWORD PTR [rcx+20]
  00033	7a 02		 jp	 SHORT $LN5@stbtt__csc
  00035	74 46		 je	 SHORT $LN2@stbtt__csc
$LN5@stbtt__csc:
$LN3@stbtt__csc:

; 1939 :       stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);

  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  0003c	f3 0f 2c 40 0c	 cvttss2si eax, DWORD PTR [rax+12]
  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ctx$[rsp]
  00046	f3 0f 2c 49 08	 cvttss2si ecx, DWORD PTR [rcx+8]
  0004b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  00053	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0005b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00063	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0006b	44 8b c8	 mov	 r9d, eax
  0006e	44 8b c1	 mov	 r8d, ecx
  00071	b2 02		 mov	 dl, 2
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ctx$[rsp]
  00078	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
$LN2@stbtt__csc:

; 1940 : }

  0007d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00081	c3		 ret	 0
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ENDP	; stbtt__csctx_close_shape
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
c$ = 64
type$ = 72
x$ = 80
y$ = 88
cx$ = 96
cy$ = 104
cx1$ = 112
cy1$ = 120
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z PROC	; stbtt__csctx_v

; 1921 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1922 :    if (c->bounds) {

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0001c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0001f	74 45		 je	 SHORT $LN2@stbtt__csc

; 1923 :       stbtt__track_vertex(c, x, y);

  00021	44 8b 44 24 58	 mov	 r8d, DWORD PTR y$[rsp]
  00026	8b 54 24 50	 mov	 edx, DWORD PTR x$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0002f	e8 00 00 00 00	 call	 ?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ; stbtt__track_vertex

; 1924 :       if (type == STBTT_vcubic) {

  00034	0f b6 44 24 48	 movzx	 eax, BYTE PTR type$[rsp]
  00039	83 f8 04	 cmp	 eax, 4
  0003c	75 26		 jne	 SHORT $LN4@stbtt__csc

; 1925 :          stbtt__track_vertex(c, cx, cy);

  0003e	44 8b 44 24 68	 mov	 r8d, DWORD PTR cy$[rsp]
  00043	8b 54 24 60	 mov	 edx, DWORD PTR cx$[rsp]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0004c	e8 00 00 00 00	 call	 ?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ; stbtt__track_vertex

; 1926 :          stbtt__track_vertex(c, cx1, cy1);

  00051	44 8b 44 24 78	 mov	 r8d, DWORD PTR cy1$[rsp]
  00056	8b 54 24 70	 mov	 edx, DWORD PTR cx1$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0005f	e8 00 00 00 00	 call	 ?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
$LN4@stbtt__csc:

; 1927 :       }
; 1928 :    } else {

  00064	eb 7d		 jmp	 SHORT $LN3@stbtt__csc
$LN2@stbtt__csc:

; 1929 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0006b	48 63 40 30	 movsxd	 rax, DWORD PTR [rax+48]
  0006f	48 6b c0 0e	 imul	 rax, rax, 14
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00078	48 03 41 28	 add	 rax, QWORD PTR [rcx+40]
  0007c	8b 4c 24 68	 mov	 ecx, DWORD PTR cy$[rsp]
  00080	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00084	8b 4c 24 60	 mov	 ecx, DWORD PTR cx$[rsp]
  00088	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0008c	44 8b 4c 24 58	 mov	 r9d, DWORD PTR y$[rsp]
  00091	44 8b 44 24 50	 mov	 r8d, DWORD PTR x$[rsp]
  00096	0f b6 54 24 48	 movzx	 edx, BYTE PTR type$[rsp]
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex

; 1930 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000a8	48 63 40 30	 movsxd	 rax, DWORD PTR [rax+48]
  000ac	48 6b c0 0e	 imul	 rax, rax, 14
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000b5	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000b9	0f b7 54 24 70	 movzx	 edx, WORD PTR cx1$[rsp]
  000be	66 89 54 01 08	 mov	 WORD PTR [rcx+rax+8], dx

; 1931 :       c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;

  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000c8	48 63 40 30	 movsxd	 rax, DWORD PTR [rax+48]
  000cc	48 6b c0 0e	 imul	 rax, rax, 14
  000d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000d5	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000d9	0f b7 54 24 78	 movzx	 edx, WORD PTR cy1$[rsp]
  000de	66 89 54 01 0a	 mov	 WORD PTR [rcx+rax+10], dx
$LN3@stbtt__csc:

; 1932 :    }
; 1933 :    c->num_vertices++;

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000e8	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000eb	ff c0		 inc	 eax
  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000f2	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1934 : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ENDP	; stbtt__csctx_v
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
c$ = 8
x$ = 16
y$ = 24
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z PROC	; stbtt__track_vertex

; 1912 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1913 :    if (x > c->max_x || !c->started) c->max_x = x;

  0000e	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00013	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00016	39 44 24 10	 cmp	 DWORD PTR x$[rsp], eax
  0001a	7f 0b		 jg	 SHORT $LN3@stbtt__tra
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00021	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00025	75 0c		 jne	 SHORT $LN2@stbtt__tra
$LN3@stbtt__tra:
  00027	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  0002c	8b 4c 24 10	 mov	 ecx, DWORD PTR x$[rsp]
  00030	89 48 1c	 mov	 DWORD PTR [rax+28], ecx
$LN2@stbtt__tra:

; 1914 :    if (y > c->max_y || !c->started) c->max_y = y;

  00033	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00038	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0003b	39 44 24 18	 cmp	 DWORD PTR y$[rsp], eax
  0003f	7f 0b		 jg	 SHORT $LN5@stbtt__tra
  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00046	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0004a	75 0c		 jne	 SHORT $LN4@stbtt__tra
$LN5@stbtt__tra:
  0004c	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00051	8b 4c 24 18	 mov	 ecx, DWORD PTR y$[rsp]
  00055	89 48 24	 mov	 DWORD PTR [rax+36], ecx
$LN4@stbtt__tra:

; 1915 :    if (x < c->min_x || !c->started) c->min_x = x;

  00058	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  0005d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00060	39 44 24 10	 cmp	 DWORD PTR x$[rsp], eax
  00064	7c 0b		 jl	 SHORT $LN7@stbtt__tra
  00066	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  0006b	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0006f	75 0c		 jne	 SHORT $LN6@stbtt__tra
$LN7@stbtt__tra:
  00071	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00076	8b 4c 24 10	 mov	 ecx, DWORD PTR x$[rsp]
  0007a	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN6@stbtt__tra:

; 1916 :    if (y < c->min_y || !c->started) c->min_y = y;

  0007d	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00082	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00085	39 44 24 18	 cmp	 DWORD PTR y$[rsp], eax
  00089	7c 0b		 jl	 SHORT $LN9@stbtt__tra
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  00090	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00094	75 0c		 jne	 SHORT $LN8@stbtt__tra
$LN9@stbtt__tra:
  00096	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  0009b	8b 4c 24 18	 mov	 ecx, DWORD PTR y$[rsp]
  0009f	89 48 20	 mov	 DWORD PTR [rax+32], ecx
$LN8@stbtt__tra:

; 1917 :    c->started = 1;

  000a2	48 8b 44 24 08	 mov	 rax, QWORD PTR c$[rsp]
  000a7	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 1918 : }

  000ae	c3		 ret	 0
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ENDP	; stbtt__track_vertex
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
flags$1 = 80
i$2 = 84
num_vertices$ = 88
flagcount$3 = 92
comp$4 = 96
vertices$ = 104
numberOfContours$ = 112
flags$5 = 116
y$6 = 120
off$7 = 124
x$8 = 128
x$9 = 132
y$10 = 136
points$11 = 144
cy$12 = 152
cx$13 = 156
sy$14 = 160
was_off$15 = 164
n$16 = 168
sx$17 = 172
g$ = 176
comp_num_verts$18 = 180
dy$19 = 184
dx$20 = 188
start_off$21 = 192
i$22 = 196
scy$23 = 200
scx$24 = 204
v$25 = 208
gidx$26 = 216
j$27 = 220
comp_verts$28 = 224
tv184 = 232
tv224 = 236
tv313 = 240
next_move$29 = 244
tv487 = 248
m$30 = 252
n$31 = 256
more$32 = 260
m$33 = 264
data$ = 272
tmp$34 = 280
ins$35 = 288
endPtsOfContours$ = 296
tv366 = 304
tv393 = 312
tv405 = 320
tv416 = 328
mtx$36 = 336
__$ArrayPad$ = 360
info$ = 400
glyph_index$ = 408
pvertices$ = 416
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeTT

; 1675 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1676 :    stbtt_int16 numberOfContours;
; 1677 :    stbtt_uint8 *endPtsOfContours;
; 1678 :    stbtt_uint8 *data = info->data;

  00029	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00031	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00035	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR data$[rsp], rax

; 1679 :    stbtt_vertex *vertices=0;

  0003d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vertices$[rsp], 0

; 1680 :    int num_vertices=0;

  00046	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR num_vertices$[rsp], 0

; 1681 :    int g = stbtt__GetGlyfOffset(info, glyph_index);

  0004e	8b 94 24 98 01
	00 00		 mov	 edx, DWORD PTR glyph_index$[rsp]
  00055	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0005d	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
  00062	89 84 24 b0 00
	00 00		 mov	 DWORD PTR g$[rsp], eax

; 1682 : 
; 1683 :    *pvertices = NULL;

  00069	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pvertices$[rsp]
  00071	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1684 : 
; 1685 :    if (g < 0) return 0;

  00078	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR g$[rsp], 0
  00080	7d 07		 jge	 SHORT $LN19@stbtt__Get
  00082	33 c0		 xor	 eax, eax
  00084	e9 d8 12 00 00	 jmp	 $LN1@stbtt__Get
$LN19@stbtt__Get:

; 1686 : 
; 1687 :    numberOfContours = ttSHORT(data + g);

  00089	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR g$[rsp]
  00091	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00099	48 03 c8	 add	 rcx, rax
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  000a7	66 89 44 24 70	 mov	 WORD PTR numberOfContours$[rsp], ax

; 1688 : 
; 1689 :    if (numberOfContours > 0) {

  000ac	0f bf 44 24 70	 movsx	 eax, WORD PTR numberOfContours$[rsp]
  000b1	85 c0		 test	 eax, eax
  000b3	0f 8e af 09 00
	00		 jle	 $LN20@stbtt__Get

; 1690 :       stbtt_uint8 flags=0,flagcount;

  000b9	c6 44 24 50 00	 mov	 BYTE PTR flags$1[rsp], 0

; 1691 :       stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;

  000be	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$27[rsp], 0
  000c9	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR was_off$15[rsp], 0
  000d4	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR start_off$21[rsp], 0

; 1692 :       stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
; 1693 :       stbtt_uint8 *points;
; 1694 :       endPtsOfContours = (data + g + 10);

  000df	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR g$[rsp]
  000e7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000ef	48 8d 44 01 0a	 lea	 rax, QWORD PTR [rcx+rax+10]
  000f4	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR endPtsOfContours$[rsp], rax

; 1695 :       ins = ttUSHORT(data + g + 10 + numberOfContours * 2);

  000fc	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR g$[rsp]
  00104	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	0f bf 4c 24 70	 movsx	 ecx, WORD PTR numberOfContours$[rsp]
  00117	d1 e1		 shl	 ecx, 1
  00119	48 63 c9	 movsxd	 rcx, ecx
  0011c	48 8d 44 08 0a	 lea	 rax, QWORD PTR [rax+rcx+10]
  00121	48 8b c8	 mov	 rcx, rax
  00124	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00129	0f b7 c0	 movzx	 eax, ax
  0012c	89 84 24 20 01
	00 00		 mov	 DWORD PTR ins$35[rsp], eax

; 1696 :       points = data + g + 10 + numberOfContours * 2 + 2 + ins;

  00133	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR g$[rsp]
  0013b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00143	48 03 c8	 add	 rcx, rax
  00146	48 8b c1	 mov	 rax, rcx
  00149	0f bf 4c 24 70	 movsx	 ecx, WORD PTR numberOfContours$[rsp]
  0014e	d1 e1		 shl	 ecx, 1
  00150	48 63 c9	 movsxd	 rcx, ecx
  00153	48 8d 44 08 0a	 lea	 rax, QWORD PTR [rax+rcx+10]
  00158	48 63 8c 24 20
	01 00 00	 movsxd	 rcx, DWORD PTR ins$35[rsp]
  00160	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00165	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax

; 1697 : 
; 1698 :       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

  0016d	0f bf 44 24 70	 movsx	 eax, WORD PTR numberOfContours$[rsp]
  00172	d1 e0		 shl	 eax, 1
  00174	48 98		 cdqe
  00176	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR endPtsOfContours$[rsp]
  0017e	48 8d 44 01 fe	 lea	 rax, QWORD PTR [rcx+rax-2]
  00183	48 8b c8	 mov	 rcx, rax
  00186	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0018b	0f b7 c0	 movzx	 eax, ax
  0018e	ff c0		 inc	 eax
  00190	89 84 24 a8 00
	00 00		 mov	 DWORD PTR n$16[rsp], eax

; 1699 : 
; 1700 :       m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need

  00197	0f bf 44 24 70	 movsx	 eax, WORD PTR numberOfContours$[rsp]
  0019c	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR n$16[rsp]
  001a3	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  001a6	89 84 24 08 01
	00 00		 mov	 DWORD PTR m$33[rsp], eax

; 1701 :       vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);

  001ad	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR m$33[rsp]
  001b5	48 6b c0 0e	 imul	 rax, rax, 14
  001b9	48 8b c8	 mov	 rcx, rax
  001bc	e8 00 00 00 00	 call	 malloc
  001c1	48 89 44 24 68	 mov	 QWORD PTR vertices$[rsp], rax

; 1702 :       if (vertices == 0)

  001c6	48 83 7c 24 68
	00		 cmp	 QWORD PTR vertices$[rsp], 0
  001cc	75 07		 jne	 SHORT $LN22@stbtt__Get

; 1703 :          return 0;

  001ce	33 c0		 xor	 eax, eax
  001d0	e9 8c 11 00 00	 jmp	 $LN1@stbtt__Get
$LN22@stbtt__Get:

; 1704 : 
; 1705 :       next_move = 0;

  001d5	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR next_move$29[rsp], 0

; 1706 :       flagcount=0;

  001e0	c6 44 24 5c 00	 mov	 BYTE PTR flagcount$3[rsp], 0

; 1707 : 
; 1708 :       // in first pass, we load uninterpreted data into the allocated array
; 1709 :       // above, shifted to the end of the array so we won't overwrite it when
; 1710 :       // we create our final data starting from the front
; 1711 : 
; 1712 :       off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

  001e5	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$16[rsp]
  001ec	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR m$33[rsp]
  001f3	2b c8		 sub	 ecx, eax
  001f5	8b c1		 mov	 eax, ecx
  001f7	89 44 24 7c	 mov	 DWORD PTR off$7[rsp], eax

; 1713 : 
; 1714 :       // first load flags
; 1715 : 
; 1716 :       for (i=0; i < n; ++i) {

  001fb	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00203	eb 0a		 jmp	 SHORT $LN4@stbtt__Get
$LN2@stbtt__Get:
  00205	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  00209	ff c0		 inc	 eax
  0020b	89 44 24 54	 mov	 DWORD PTR i$2[rsp], eax
$LN4@stbtt__Get:
  0020f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$16[rsp]
  00216	39 44 24 54	 cmp	 DWORD PTR i$2[rsp], eax
  0021a	0f 8d 8b 00 00
	00		 jge	 $LN3@stbtt__Get

; 1717 :          if (flagcount == 0) {

  00220	0f b6 44 24 5c	 movzx	 eax, BYTE PTR flagcount$3[rsp]
  00225	85 c0		 test	 eax, eax
  00227	75 52		 jne	 SHORT $LN23@stbtt__Get

; 1718 :             flags = *points++;

  00229	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  00231	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00234	88 44 24 50	 mov	 BYTE PTR flags$1[rsp], al
  00238	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  00240	48 ff c0	 inc	 rax
  00243	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax

; 1719 :             if (flags & 8)

  0024b	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  00250	83 e0 08	 and	 eax, 8
  00253	85 c0		 test	 eax, eax
  00255	74 22		 je	 SHORT $LN25@stbtt__Get

; 1720 :                flagcount = *points++;

  00257	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  0025f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00262	88 44 24 5c	 mov	 BYTE PTR flagcount$3[rsp], al
  00266	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  0026e	48 ff c0	 inc	 rax
  00271	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax
$LN25@stbtt__Get:

; 1721 :          } else

  00279	eb 0b		 jmp	 SHORT $LN24@stbtt__Get
$LN23@stbtt__Get:

; 1722 :             --flagcount;

  0027b	0f b6 44 24 5c	 movzx	 eax, BYTE PTR flagcount$3[rsp]
  00280	fe c8		 dec	 al
  00282	88 44 24 5c	 mov	 BYTE PTR flagcount$3[rsp], al
$LN24@stbtt__Get:

; 1723 :          vertices[off+i].type = flags;

  00286	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  0028a	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  0028e	03 c8		 add	 ecx, eax
  00290	8b c1		 mov	 eax, ecx
  00292	48 98		 cdqe
  00294	48 6b c0 0e	 imul	 rax, rax, 14
  00298	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  0029d	0f b6 54 24 50	 movzx	 edx, BYTE PTR flags$1[rsp]
  002a2	88 54 01 0c	 mov	 BYTE PTR [rcx+rax+12], dl

; 1724 :       }

  002a6	e9 5a ff ff ff	 jmp	 $LN2@stbtt__Get
$LN3@stbtt__Get:

; 1725 : 
; 1726 :       // now load x coordinates
; 1727 :       x=0;

  002ab	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR x$8[rsp], 0

; 1728 :       for (i=0; i < n; ++i) {

  002b6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  002be	eb 0a		 jmp	 SHORT $LN7@stbtt__Get
$LN5@stbtt__Get:
  002c0	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  002c4	ff c0		 inc	 eax
  002c6	89 44 24 54	 mov	 DWORD PTR i$2[rsp], eax
$LN7@stbtt__Get:
  002ca	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$16[rsp]
  002d1	39 44 24 54	 cmp	 DWORD PTR i$2[rsp], eax
  002d5	0f 8d 28 01 00
	00		 jge	 $LN6@stbtt__Get

; 1729 :          flags = vertices[off+i].type;

  002db	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  002df	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  002e3	03 c8		 add	 ecx, eax
  002e5	8b c1		 mov	 eax, ecx
  002e7	48 98		 cdqe
  002e9	48 6b c0 0e	 imul	 rax, rax, 14
  002ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  002f2	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  002f7	88 44 24 50	 mov	 BYTE PTR flags$1[rsp], al

; 1730 :          if (flags & 2) {

  002fb	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  00300	83 e0 02	 and	 eax, 2
  00303	85 c0		 test	 eax, eax
  00305	74 6f		 je	 SHORT $LN26@stbtt__Get

; 1731 :             stbtt_int16 dx = *points++;

  00307	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  0030f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00312	66 89 84 24 bc
	00 00 00	 mov	 WORD PTR dx$20[rsp], ax
  0031a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  00322	48 ff c0	 inc	 rax
  00325	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax

; 1732 :             x += (flags & 16) ? dx : -dx; // ???

  0032d	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  00332	83 e0 10	 and	 eax, 16
  00335	85 c0		 test	 eax, eax
  00337	74 11		 je	 SHORT $LN62@stbtt__Get
  00339	0f bf 84 24 bc
	00 00 00	 movsx	 eax, WORD PTR dx$20[rsp]
  00341	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
  00348	eb 11		 jmp	 SHORT $LN63@stbtt__Get
$LN62@stbtt__Get:
  0034a	0f bf 84 24 bc
	00 00 00	 movsx	 eax, WORD PTR dx$20[rsp]
  00352	f7 d8		 neg	 eax
  00354	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
$LN63@stbtt__Get:
  0035b	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv184[rsp]
  00362	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x$8[rsp]
  00369	03 c8		 add	 ecx, eax
  0036b	8b c1		 mov	 eax, ecx
  0036d	89 84 24 80 00
	00 00		 mov	 DWORD PTR x$8[rsp], eax

; 1733 :          } else {

  00374	eb 65		 jmp	 SHORT $LN27@stbtt__Get
$LN26@stbtt__Get:

; 1734 :             if (!(flags & 16)) {

  00376	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  0037b	83 e0 10	 and	 eax, 16
  0037e	85 c0		 test	 eax, eax
  00380	75 59		 jne	 SHORT $LN28@stbtt__Get

; 1735 :                x = x + (stbtt_int16) (points[0]*256 + points[1]);

  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 00	 imul	 rax, rax, 0
  0038b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR points$11[rsp]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0039d	b9 01 00 00 00	 mov	 ecx, 1
  003a2	48 6b c9 01	 imul	 rcx, rcx, 1
  003a6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR points$11[rsp]
  003ae	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003b2	03 c1		 add	 eax, ecx
  003b4	98		 cwde
  003b5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x$8[rsp]
  003bc	03 c8		 add	 ecx, eax
  003be	8b c1		 mov	 eax, ecx
  003c0	89 84 24 80 00
	00 00		 mov	 DWORD PTR x$8[rsp], eax

; 1736 :                points += 2;

  003c7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  003cf	48 83 c0 02	 add	 rax, 2
  003d3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax
$LN28@stbtt__Get:
$LN27@stbtt__Get:

; 1737 :             }
; 1738 :          }
; 1739 :          vertices[off+i].x = (stbtt_int16) x;

  003db	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  003df	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  003e3	03 c8		 add	 ecx, eax
  003e5	8b c1		 mov	 eax, ecx
  003e7	48 98		 cdqe
  003e9	48 6b c0 0e	 imul	 rax, rax, 14
  003ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  003f2	0f b7 94 24 80
	00 00 00	 movzx	 edx, WORD PTR x$8[rsp]
  003fa	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx

; 1740 :       }

  003fe	e9 bd fe ff ff	 jmp	 $LN5@stbtt__Get
$LN6@stbtt__Get:

; 1741 : 
; 1742 :       // now load y coordinates
; 1743 :       y=0;

  00403	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR y$6[rsp], 0

; 1744 :       for (i=0; i < n; ++i) {

  0040b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00413	eb 0a		 jmp	 SHORT $LN10@stbtt__Get
$LN8@stbtt__Get:
  00415	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  00419	ff c0		 inc	 eax
  0041b	89 44 24 54	 mov	 DWORD PTR i$2[rsp], eax
$LN10@stbtt__Get:
  0041f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$16[rsp]
  00426	39 44 24 54	 cmp	 DWORD PTR i$2[rsp], eax
  0042a	0f 8d 1a 01 00
	00		 jge	 $LN9@stbtt__Get

; 1745 :          flags = vertices[off+i].type;

  00430	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  00434	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  00438	03 c8		 add	 ecx, eax
  0043a	8b c1		 mov	 eax, ecx
  0043c	48 98		 cdqe
  0043e	48 6b c0 0e	 imul	 rax, rax, 14
  00442	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00447	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0044c	88 44 24 50	 mov	 BYTE PTR flags$1[rsp], al

; 1746 :          if (flags & 4) {

  00450	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  00455	83 e0 04	 and	 eax, 4
  00458	85 c0		 test	 eax, eax
  0045a	74 69		 je	 SHORT $LN29@stbtt__Get

; 1747 :             stbtt_int16 dy = *points++;

  0045c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  00464	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00467	66 89 84 24 b8
	00 00 00	 mov	 WORD PTR dy$19[rsp], ax
  0046f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  00477	48 ff c0	 inc	 rax
  0047a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax

; 1748 :             y += (flags & 32) ? dy : -dy; // ???

  00482	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  00487	83 e0 20	 and	 eax, 32			; 00000020H
  0048a	85 c0		 test	 eax, eax
  0048c	74 11		 je	 SHORT $LN64@stbtt__Get
  0048e	0f bf 84 24 b8
	00 00 00	 movsx	 eax, WORD PTR dy$19[rsp]
  00496	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  0049d	eb 11		 jmp	 SHORT $LN65@stbtt__Get
$LN64@stbtt__Get:
  0049f	0f bf 84 24 b8
	00 00 00	 movsx	 eax, WORD PTR dy$19[rsp]
  004a7	f7 d8		 neg	 eax
  004a9	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
$LN65@stbtt__Get:
  004b0	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv224[rsp]
  004b7	8b 4c 24 78	 mov	 ecx, DWORD PTR y$6[rsp]
  004bb	03 c8		 add	 ecx, eax
  004bd	8b c1		 mov	 eax, ecx
  004bf	89 44 24 78	 mov	 DWORD PTR y$6[rsp], eax

; 1749 :          } else {

  004c3	eb 5f		 jmp	 SHORT $LN30@stbtt__Get
$LN29@stbtt__Get:

; 1750 :             if (!(flags & 32)) {

  004c5	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  004ca	83 e0 20	 and	 eax, 32			; 00000020H
  004cd	85 c0		 test	 eax, eax
  004cf	75 53		 jne	 SHORT $LN31@stbtt__Get

; 1751 :                y = y + (stbtt_int16) (points[0]*256 + points[1]);

  004d1	b8 01 00 00 00	 mov	 eax, 1
  004d6	48 6b c0 00	 imul	 rax, rax, 0
  004da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR points$11[rsp]
  004e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004e6	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  004ec	b9 01 00 00 00	 mov	 ecx, 1
  004f1	48 6b c9 01	 imul	 rcx, rcx, 1
  004f5	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR points$11[rsp]
  004fd	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00501	03 c1		 add	 eax, ecx
  00503	98		 cwde
  00504	8b 4c 24 78	 mov	 ecx, DWORD PTR y$6[rsp]
  00508	03 c8		 add	 ecx, eax
  0050a	8b c1		 mov	 eax, ecx
  0050c	89 44 24 78	 mov	 DWORD PTR y$6[rsp], eax

; 1752 :                points += 2;

  00510	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR points$11[rsp]
  00518	48 83 c0 02	 add	 rax, 2
  0051c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR points$11[rsp], rax
$LN31@stbtt__Get:
$LN30@stbtt__Get:

; 1753 :             }
; 1754 :          }
; 1755 :          vertices[off+i].y = (stbtt_int16) y;

  00524	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  00528	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  0052c	03 c8		 add	 ecx, eax
  0052e	8b c1		 mov	 eax, ecx
  00530	48 98		 cdqe
  00532	48 6b c0 0e	 imul	 rax, rax, 14
  00536	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  0053b	0f b7 54 24 78	 movzx	 edx, WORD PTR y$6[rsp]
  00540	66 89 54 01 02	 mov	 WORD PTR [rcx+rax+2], dx

; 1756 :       }

  00545	e9 cb fe ff ff	 jmp	 $LN8@stbtt__Get
$LN9@stbtt__Get:

; 1757 : 
; 1758 :       // now convert them to our format
; 1759 :       num_vertices=0;

  0054a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR num_vertices$[rsp], 0

; 1760 :       sx = sy = cx = cy = scx = scy = 0;

  00552	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR scy$23[rsp], 0
  0055d	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR scy$23[rsp]
  00564	89 84 24 cc 00
	00 00		 mov	 DWORD PTR scx$24[rsp], eax
  0056b	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR scx$24[rsp]
  00572	89 84 24 98 00
	00 00		 mov	 DWORD PTR cy$12[rsp], eax
  00579	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cy$12[rsp]
  00580	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cx$13[rsp], eax
  00587	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR cx$13[rsp]
  0058e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sy$14[rsp], eax
  00595	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sy$14[rsp]
  0059c	89 84 24 ac 00
	00 00		 mov	 DWORD PTR sx$17[rsp], eax

; 1761 :       for (i=0; i < n; ++i) {

  005a3	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  005ab	eb 0a		 jmp	 SHORT $LN13@stbtt__Get
$LN11@stbtt__Get:
  005ad	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  005b1	ff c0		 inc	 eax
  005b3	89 44 24 54	 mov	 DWORD PTR i$2[rsp], eax
$LN13@stbtt__Get:
  005b7	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$16[rsp]
  005be	39 44 24 54	 cmp	 DWORD PTR i$2[rsp], eax
  005c2	0f 8d 37 04 00
	00		 jge	 $LN12@stbtt__Get

; 1762 :          flags = vertices[off+i].type;

  005c8	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  005cc	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  005d0	03 c8		 add	 ecx, eax
  005d2	8b c1		 mov	 eax, ecx
  005d4	48 98		 cdqe
  005d6	48 6b c0 0e	 imul	 rax, rax, 14
  005da	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  005df	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  005e4	88 44 24 50	 mov	 BYTE PTR flags$1[rsp], al

; 1763 :          x     = (stbtt_int16) vertices[off+i].x;

  005e8	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  005ec	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  005f0	03 c8		 add	 ecx, eax
  005f2	8b c1		 mov	 eax, ecx
  005f4	48 98		 cdqe
  005f6	48 6b c0 0e	 imul	 rax, rax, 14
  005fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  005ff	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00603	89 84 24 80 00
	00 00		 mov	 DWORD PTR x$8[rsp], eax

; 1764 :          y     = (stbtt_int16) vertices[off+i].y;

  0060a	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  0060e	8b 4c 24 7c	 mov	 ecx, DWORD PTR off$7[rsp]
  00612	03 c8		 add	 ecx, eax
  00614	8b c1		 mov	 eax, ecx
  00616	48 98		 cdqe
  00618	48 6b c0 0e	 imul	 rax, rax, 14
  0061c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00621	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00626	89 44 24 78	 mov	 DWORD PTR y$6[rsp], eax

; 1765 : 
; 1766 :          if (next_move == i) {

  0062a	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  0062e	39 84 24 f4 00
	00 00		 cmp	 DWORD PTR next_move$29[rsp], eax
  00635	0f 85 4e 02 00
	00		 jne	 $LN32@stbtt__Get

; 1767 :             if (i != 0)

  0063b	83 7c 24 54 00	 cmp	 DWORD PTR i$2[rsp], 0
  00640	74 64		 je	 SHORT $LN34@stbtt__Get

; 1768 :                num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

  00642	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cy$12[rsp]
  00649	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0064d	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR cx$13[rsp]
  00654	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00658	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR scy$23[rsp]
  0065f	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00663	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR scx$24[rsp]
  0066a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0066e	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sy$14[rsp]
  00675	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00679	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR sx$17[rsp]
  00680	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00684	44 8b 8c 24 c0
	00 00 00	 mov	 r9d, DWORD PTR start_off$21[rsp]
  0068c	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR was_off$15[rsp]
  00694	8b 54 24 58	 mov	 edx, DWORD PTR num_vertices$[rsp]
  00698	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  0069d	e8 00 00 00 00	 call	 ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
  006a2	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax
$LN34@stbtt__Get:

; 1769 : 
; 1770 :             // now start the new one
; 1771 :             start_off = !(flags & 1);

  006a6	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  006ab	83 e0 01	 and	 eax, 1
  006ae	85 c0		 test	 eax, eax
  006b0	75 0d		 jne	 SHORT $LN66@stbtt__Get
  006b2	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv313[rsp], 1
  006bd	eb 0b		 jmp	 SHORT $LN67@stbtt__Get
$LN66@stbtt__Get:
  006bf	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv313[rsp], 0
$LN67@stbtt__Get:
  006ca	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv313[rsp]
  006d1	89 84 24 c0 00
	00 00		 mov	 DWORD PTR start_off$21[rsp], eax

; 1772 :             if (start_off) {

  006d8	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR start_off$21[rsp], 0
  006e0	0f 84 eb 00 00
	00		 je	 $LN35@stbtt__Get

; 1773 :                // if we start off with an off-curve point, then when we need to find a point on the curve
; 1774 :                // where we can start, and we need to save some state for when we wraparound.
; 1775 :                scx = x;

  006e6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR x$8[rsp]
  006ed	89 84 24 cc 00
	00 00		 mov	 DWORD PTR scx$24[rsp], eax

; 1776 :                scy = y;

  006f4	8b 44 24 78	 mov	 eax, DWORD PTR y$6[rsp]
  006f8	89 84 24 c8 00
	00 00		 mov	 DWORD PTR scy$23[rsp], eax

; 1777 :                if (!(vertices[off+i+1].type & 1)) {

  006ff	8b 44 24 7c	 mov	 eax, DWORD PTR off$7[rsp]
  00703	8b 4c 24 54	 mov	 ecx, DWORD PTR i$2[rsp]
  00707	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0070b	48 98		 cdqe
  0070d	48 6b c0 0e	 imul	 rax, rax, 14
  00711	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00716	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0071b	83 e0 01	 and	 eax, 1
  0071e	85 c0		 test	 eax, eax
  00720	75 5e		 jne	 SHORT $LN37@stbtt__Get

; 1778 :                   // next point is also a curve point, so interpolate an on-point curve
; 1779 :                   sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;

  00722	8b 44 24 7c	 mov	 eax, DWORD PTR off$7[rsp]
  00726	8b 4c 24 54	 mov	 ecx, DWORD PTR i$2[rsp]
  0072a	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0072e	48 98		 cdqe
  00730	48 6b c0 0e	 imul	 rax, rax, 14
  00734	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00739	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0073d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x$8[rsp]
  00744	03 c8		 add	 ecx, eax
  00746	8b c1		 mov	 eax, ecx
  00748	d1 f8		 sar	 eax, 1
  0074a	89 84 24 ac 00
	00 00		 mov	 DWORD PTR sx$17[rsp], eax

; 1780 :                   sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;

  00751	8b 44 24 7c	 mov	 eax, DWORD PTR off$7[rsp]
  00755	8b 4c 24 54	 mov	 ecx, DWORD PTR i$2[rsp]
  00759	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0075d	48 98		 cdqe
  0075f	48 6b c0 0e	 imul	 rax, rax, 14
  00763	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00768	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  0076d	8b 4c 24 78	 mov	 ecx, DWORD PTR y$6[rsp]
  00771	03 c8		 add	 ecx, eax
  00773	8b c1		 mov	 eax, ecx
  00775	d1 f8		 sar	 eax, 1
  00777	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sy$14[rsp], eax

; 1781 :                } else {

  0077e	eb 4f		 jmp	 SHORT $LN38@stbtt__Get
$LN37@stbtt__Get:

; 1782 :                   // otherwise just use the next point as our start point
; 1783 :                   sx = (stbtt_int32) vertices[off+i+1].x;

  00780	8b 44 24 7c	 mov	 eax, DWORD PTR off$7[rsp]
  00784	8b 4c 24 54	 mov	 ecx, DWORD PTR i$2[rsp]
  00788	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0078c	48 98		 cdqe
  0078e	48 6b c0 0e	 imul	 rax, rax, 14
  00792	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00797	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0079b	89 84 24 ac 00
	00 00		 mov	 DWORD PTR sx$17[rsp], eax

; 1784 :                   sy = (stbtt_int32) vertices[off+i+1].y;

  007a2	8b 44 24 7c	 mov	 eax, DWORD PTR off$7[rsp]
  007a6	8b 4c 24 54	 mov	 ecx, DWORD PTR i$2[rsp]
  007aa	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  007ae	48 98		 cdqe
  007b0	48 6b c0 0e	 imul	 rax, rax, 14
  007b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  007b9	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  007be	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sy$14[rsp], eax

; 1785 :                   ++i; // we're using point i+1 as the starting point, so skip it

  007c5	8b 44 24 54	 mov	 eax, DWORD PTR i$2[rsp]
  007c9	ff c0		 inc	 eax
  007cb	89 44 24 54	 mov	 DWORD PTR i$2[rsp], eax
$LN38@stbtt__Get:

; 1786 :                }
; 1787 :             } else {

  007cf	eb 19		 jmp	 SHORT $LN36@stbtt__Get
$LN35@stbtt__Get:

; 1788 :                sx = x;

  007d1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR x$8[rsp]
  007d8	89 84 24 ac 00
	00 00		 mov	 DWORD PTR sx$17[rsp], eax

; 1789 :                sy = y;

  007df	8b 44 24 78	 mov	 eax, DWORD PTR y$6[rsp]
  007e3	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sy$14[rsp], eax
$LN36@stbtt__Get:

; 1790 :             }
; 1791 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);

  007ea	48 63 44 24 58	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  007ef	48 6b c0 0e	 imul	 rax, rax, 14
  007f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  007f8	48 03 c8	 add	 rcx, rax
  007fb	48 89 8c 24 30
	01 00 00	 mov	 QWORD PTR tv366[rsp], rcx
  00803	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0080b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00813	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR sy$14[rsp]
  0081b	44 8b 84 24 ac
	00 00 00	 mov	 r8d, DWORD PTR sx$17[rsp]
  00823	b2 01		 mov	 dl, 1
  00825	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv366[rsp]
  0082d	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00832	8b 44 24 58	 mov	 eax, DWORD PTR num_vertices$[rsp]
  00836	ff c0		 inc	 eax
  00838	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax

; 1792 :             was_off = 0;

  0083c	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR was_off$15[rsp], 0

; 1793 :             next_move = 1 + ttUSHORT(endPtsOfContours+j*2);

  00847	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR j$27[rsp]
  0084e	d1 e0		 shl	 eax, 1
  00850	48 98		 cdqe
  00852	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR endPtsOfContours$[rsp]
  0085a	48 03 c8	 add	 rcx, rax
  0085d	48 8b c1	 mov	 rax, rcx
  00860	48 8b c8	 mov	 rcx, rax
  00863	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00868	0f b7 c0	 movzx	 eax, ax
  0086b	ff c0		 inc	 eax
  0086d	89 84 24 f4 00
	00 00		 mov	 DWORD PTR next_move$29[rsp], eax

; 1794 :             ++j;

  00874	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR j$27[rsp]
  0087b	ff c0		 inc	 eax
  0087d	89 84 24 dc 00
	00 00		 mov	 DWORD PTR j$27[rsp], eax

; 1795 :          } else {

  00884	e9 71 01 00 00	 jmp	 $LN33@stbtt__Get
$LN32@stbtt__Get:

; 1796 :             if (!(flags & 1)) { // if it's a curve

  00889	0f b6 44 24 50	 movzx	 eax, BYTE PTR flags$1[rsp]
  0088e	83 e0 01	 and	 eax, 1
  00891	85 c0		 test	 eax, eax
  00893	0f 85 a6 00 00
	00		 jne	 $LN39@stbtt__Get

; 1797 :                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint

  00899	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR was_off$15[rsp], 0
  008a1	74 73		 je	 SHORT $LN41@stbtt__Get

; 1798 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);

  008a3	48 63 44 24 58	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  008a8	48 6b c0 0e	 imul	 rax, rax, 14
  008ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  008b1	48 03 c8	 add	 rcx, rax
  008b4	48 89 8c 24 38
	01 00 00	 mov	 QWORD PTR tv393[rsp], rcx
  008bc	8b 44 24 78	 mov	 eax, DWORD PTR y$6[rsp]
  008c0	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cy$12[rsp]
  008c7	03 c8		 add	 ecx, eax
  008c9	8b c1		 mov	 eax, ecx
  008cb	d1 f8		 sar	 eax, 1
  008cd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x$8[rsp]
  008d4	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR cx$13[rsp]
  008db	03 d1		 add	 edx, ecx
  008dd	8b ca		 mov	 ecx, edx
  008df	d1 f9		 sar	 ecx, 1
  008e1	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR cy$12[rsp]
  008e8	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  008ec	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR cx$13[rsp]
  008f3	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  008f7	44 8b c8	 mov	 r9d, eax
  008fa	44 8b c1	 mov	 r8d, ecx
  008fd	b2 03		 mov	 dl, 3
  008ff	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv393[rsp]
  00907	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  0090c	8b 44 24 58	 mov	 eax, DWORD PTR num_vertices$[rsp]
  00910	ff c0		 inc	 eax
  00912	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax
$LN41@stbtt__Get:

; 1799 :                cx = x;

  00916	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR x$8[rsp]
  0091d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR cx$13[rsp], eax

; 1800 :                cy = y;

  00924	8b 44 24 78	 mov	 eax, DWORD PTR y$6[rsp]
  00928	89 84 24 98 00
	00 00		 mov	 DWORD PTR cy$12[rsp], eax

; 1801 :                was_off = 1;

  0092f	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR was_off$15[rsp], 1

; 1802 :             } else {

  0093a	e9 bb 00 00 00	 jmp	 $LN40@stbtt__Get
$LN39@stbtt__Get:

; 1803 :                if (was_off)

  0093f	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR was_off$15[rsp], 0
  00947	74 57		 je	 SHORT $LN42@stbtt__Get

; 1804 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);

  00949	48 63 44 24 58	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  0094e	48 6b c0 0e	 imul	 rax, rax, 14
  00952	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00957	48 03 c8	 add	 rcx, rax
  0095a	48 89 8c 24 40
	01 00 00	 mov	 QWORD PTR tv405[rsp], rcx
  00962	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cy$12[rsp]
  00969	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0096d	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR cx$13[rsp]
  00974	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00978	44 8b 4c 24 78	 mov	 r9d, DWORD PTR y$6[rsp]
  0097d	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR x$8[rsp]
  00985	b2 03		 mov	 dl, 3
  00987	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv405[rsp]
  0098f	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00994	8b 44 24 58	 mov	 eax, DWORD PTR num_vertices$[rsp]
  00998	ff c0		 inc	 eax
  0099a	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax
  0099e	eb 4f		 jmp	 SHORT $LN43@stbtt__Get
$LN42@stbtt__Get:

; 1805 :                else
; 1806 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);

  009a0	48 63 44 24 58	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  009a5	48 6b c0 0e	 imul	 rax, rax, 14
  009a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  009ae	48 03 c8	 add	 rcx, rax
  009b1	48 89 8c 24 48
	01 00 00	 mov	 QWORD PTR tv416[rsp], rcx
  009b9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  009c1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  009c9	44 8b 4c 24 78	 mov	 r9d, DWORD PTR y$6[rsp]
  009ce	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR x$8[rsp]
  009d6	b2 02		 mov	 dl, 2
  009d8	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv416[rsp]
  009e0	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  009e5	8b 44 24 58	 mov	 eax, DWORD PTR num_vertices$[rsp]
  009e9	ff c0		 inc	 eax
  009eb	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax
$LN43@stbtt__Get:

; 1807 :                was_off = 0;

  009ef	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR was_off$15[rsp], 0
$LN40@stbtt__Get:
$LN33@stbtt__Get:

; 1808 :             }
; 1809 :          }
; 1810 :       }

  009fa	e9 ae fb ff ff	 jmp	 $LN11@stbtt__Get
$LN12@stbtt__Get:

; 1811 :       num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

  009ff	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cy$12[rsp]
  00a06	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00a0a	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR cx$13[rsp]
  00a11	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00a15	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR scy$23[rsp]
  00a1c	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00a20	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR scx$24[rsp]
  00a27	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a2b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sy$14[rsp]
  00a32	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a36	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR sx$17[rsp]
  00a3d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a41	44 8b 8c 24 c0
	00 00 00	 mov	 r9d, DWORD PTR start_off$21[rsp]
  00a49	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR was_off$15[rsp]
  00a51	8b 54 24 58	 mov	 edx, DWORD PTR num_vertices$[rsp]
  00a55	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  00a5a	e8 00 00 00 00	 call	 ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
  00a5f	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax
  00a63	e9 e5 08 00 00	 jmp	 $LN21@stbtt__Get
$LN20@stbtt__Get:

; 1812 :    } else if (numberOfContours < 0) {

  00a68	0f bf 44 24 70	 movsx	 eax, WORD PTR numberOfContours$[rsp]
  00a6d	85 c0		 test	 eax, eax
  00a6f	0f 8d d8 08 00
	00		 jge	 $LN44@stbtt__Get

; 1813 :       // Compound shapes.
; 1814 :       int more = 1;

  00a75	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR more$32[rsp], 1

; 1815 :       stbtt_uint8 *comp = data + g + 10;

  00a80	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR g$[rsp]
  00a88	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00a90	48 8d 44 01 0a	 lea	 rax, QWORD PTR [rcx+rax+10]
  00a95	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1816 :       num_vertices = 0;

  00a9a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR num_vertices$[rsp], 0

; 1817 :       vertices = 0;

  00aa2	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vertices$[rsp], 0
$LN14@stbtt__Get:

; 1818 :       while (more) {

  00aab	83 bc 24 04 01
	00 00 00	 cmp	 DWORD PTR more$32[rsp], 0
  00ab3	0f 84 94 08 00
	00		 je	 $LN15@stbtt__Get

; 1819 :          stbtt_uint16 flags, gidx;
; 1820 :          int comp_num_verts = 0, i;

  00ab9	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR comp_num_verts$18[rsp], 0

; 1821 :          stbtt_vertex *comp_verts = 0, *tmp = 0;

  00ac4	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR comp_verts$28[rsp], 0
  00ad0	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tmp$34[rsp], 0

; 1822 :          float mtx[6] = {1,0,0,1,0,0}, m, n;

  00adc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ae4	f3 0f 11 84 24
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp], xmm0
  00aed	0f 57 c0	 xorps	 xmm0, xmm0
  00af0	f3 0f 11 84 24
	54 01 00 00	 movss	 DWORD PTR mtx$36[rsp+4], xmm0
  00af9	0f 57 c0	 xorps	 xmm0, xmm0
  00afc	f3 0f 11 84 24
	58 01 00 00	 movss	 DWORD PTR mtx$36[rsp+8], xmm0
  00b05	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b0d	f3 0f 11 84 24
	5c 01 00 00	 movss	 DWORD PTR mtx$36[rsp+12], xmm0
  00b16	0f 57 c0	 xorps	 xmm0, xmm0
  00b19	f3 0f 11 84 24
	60 01 00 00	 movss	 DWORD PTR mtx$36[rsp+16], xmm0
  00b22	0f 57 c0	 xorps	 xmm0, xmm0
  00b25	f3 0f 11 84 24
	64 01 00 00	 movss	 DWORD PTR mtx$36[rsp+20], xmm0

; 1823 : 
; 1824 :          flags = ttSHORT(comp); comp+=2;

  00b2e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00b33	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00b38	66 89 44 24 74	 mov	 WORD PTR flags$5[rsp], ax
  00b3d	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00b42	48 83 c0 02	 add	 rax, 2
  00b46	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1825 :          gidx = ttSHORT(comp); comp+=2;

  00b4b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00b50	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00b55	66 89 84 24 d8
	00 00 00	 mov	 WORD PTR gidx$26[rsp], ax
  00b5d	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00b62	48 83 c0 02	 add	 rax, 2
  00b66	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1826 : 
; 1827 :          if (flags & 2) { // XY values

  00b6b	0f b7 44 24 74	 movzx	 eax, WORD PTR flags$5[rsp]
  00b70	83 e0 02	 and	 eax, 2
  00b73	85 c0		 test	 eax, eax
  00b75	0f 84 c4 00 00
	00		 je	 $LN46@stbtt__Get

; 1828 :             if (flags & 1) { // shorts

  00b7b	0f b7 44 24 74	 movzx	 eax, WORD PTR flags$5[rsp]
  00b80	83 e0 01	 and	 eax, 1
  00b83	85 c0		 test	 eax, eax
  00b85	74 60		 je	 SHORT $LN48@stbtt__Get

; 1829 :                mtx[4] = ttSHORT(comp); comp+=2;

  00b87	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00b8c	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00b91	98		 cwde
  00b92	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b96	b8 04 00 00 00	 mov	 eax, 4
  00b9b	48 6b c0 04	 imul	 rax, rax, 4
  00b9f	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00ba8	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00bad	48 83 c0 02	 add	 rax, 2
  00bb1	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1830 :                mtx[5] = ttSHORT(comp); comp+=2;

  00bb6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00bbb	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00bc0	98		 cwde
  00bc1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00bc5	b8 04 00 00 00	 mov	 eax, 4
  00bca	48 6b c0 05	 imul	 rax, rax, 5
  00bce	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00bd7	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00bdc	48 83 c0 02	 add	 rax, 2
  00be0	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1831 :             } else {

  00be5	eb 56		 jmp	 SHORT $LN49@stbtt__Get
$LN48@stbtt__Get:

; 1832 :                mtx[4] = ttCHAR(comp); comp+=1;

  00be7	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00bec	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00bef	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00bf3	b8 04 00 00 00	 mov	 eax, 4
  00bf8	48 6b c0 04	 imul	 rax, rax, 4
  00bfc	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00c05	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00c0a	48 ff c0	 inc	 rax
  00c0d	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1833 :                mtx[5] = ttCHAR(comp); comp+=1;

  00c12	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00c17	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00c1a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00c1e	b8 04 00 00 00	 mov	 eax, 4
  00c23	48 6b c0 05	 imul	 rax, rax, 5
  00c27	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00c30	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00c35	48 ff c0	 inc	 rax
  00c38	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax
$LN49@stbtt__Get:

; 1834 :             }
; 1835 :          }

  00c3d	eb 21		 jmp	 SHORT $LN47@stbtt__Get
$LN46@stbtt__Get:

; 1836 :          else {
; 1837 :             // @TODO handle matching point
; 1838 :             STBTT_assert(0);

  00c3f	33 c0		 xor	 eax, eax
  00c41	85 c0		 test	 eax, eax
  00c43	75 1b		 jne	 SHORT $LN68@stbtt__Get
  00c45	41 b8 2e 07 00
	00		 mov	 r8d, 1838		; 0000072eH
  00c4b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41824
  00c52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41825
  00c59	e8 00 00 00 00	 call	 _wassert
  00c5e	33 c0		 xor	 eax, eax
$LN68@stbtt__Get:
$LN47@stbtt__Get:

; 1839 :          }
; 1840 :          if (flags & (1<<3)) { // WE_HAVE_A_SCALE

  00c60	0f b7 44 24 74	 movzx	 eax, WORD PTR flags$5[rsp]
  00c65	83 e0 08	 and	 eax, 8
  00c68	85 c0		 test	 eax, eax
  00c6a	0f 84 93 00 00
	00		 je	 $LN50@stbtt__Get

; 1841 :             mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

  00c70	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00c75	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00c7a	98		 cwde
  00c7b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00c7f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00c87	f3 0f 11 84 24
	f8 00 00 00	 movss	 DWORD PTR tv487[rsp], xmm0
  00c90	b8 04 00 00 00	 mov	 eax, 4
  00c95	48 6b c0 03	 imul	 rax, rax, 3
  00c99	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR tv487[rsp]
  00ca2	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00cab	b8 04 00 00 00	 mov	 eax, 4
  00cb0	48 6b c0 00	 imul	 rax, rax, 0
  00cb4	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR tv487[rsp]
  00cbd	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00cc6	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00ccb	48 83 c0 02	 add	 rax, 2
  00ccf	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1842 :             mtx[1] = mtx[2] = 0;

  00cd4	b8 04 00 00 00	 mov	 eax, 4
  00cd9	48 6b c0 02	 imul	 rax, rax, 2
  00cdd	0f 57 c0	 xorps	 xmm0, xmm0
  00ce0	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00ce9	b8 04 00 00 00	 mov	 eax, 4
  00cee	48 6b c0 01	 imul	 rax, rax, 1
  00cf2	0f 57 c0	 xorps	 xmm0, xmm0
  00cf5	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00cfe	e9 9b 01 00 00	 jmp	 $LN51@stbtt__Get
$LN50@stbtt__Get:

; 1843 :          } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE

  00d03	0f b7 44 24 74	 movzx	 eax, WORD PTR flags$5[rsp]
  00d08	83 e0 40	 and	 eax, 64			; 00000040H
  00d0b	85 c0		 test	 eax, eax
  00d0d	0f 84 9d 00 00
	00		 je	 $LN52@stbtt__Get

; 1844 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

  00d13	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00d18	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00d1d	98		 cwde
  00d1e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00d22	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00d2a	b8 04 00 00 00	 mov	 eax, 4
  00d2f	48 6b c0 00	 imul	 rax, rax, 0
  00d33	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00d3c	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00d41	48 83 c0 02	 add	 rax, 2
  00d45	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1845 :             mtx[1] = mtx[2] = 0;

  00d4a	b8 04 00 00 00	 mov	 eax, 4
  00d4f	48 6b c0 02	 imul	 rax, rax, 2
  00d53	0f 57 c0	 xorps	 xmm0, xmm0
  00d56	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00d5f	b8 04 00 00 00	 mov	 eax, 4
  00d64	48 6b c0 01	 imul	 rax, rax, 1
  00d68	0f 57 c0	 xorps	 xmm0, xmm0
  00d6b	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0

; 1846 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

  00d74	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00d79	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00d7e	98		 cwde
  00d7f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00d83	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00d8b	b8 04 00 00 00	 mov	 eax, 4
  00d90	48 6b c0 03	 imul	 rax, rax, 3
  00d94	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00d9d	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00da2	48 83 c0 02	 add	 rax, 2
  00da6	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax
  00dab	e9 ee 00 00 00	 jmp	 $LN53@stbtt__Get
$LN52@stbtt__Get:

; 1847 :          } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO

  00db0	0f b7 44 24 74	 movzx	 eax, WORD PTR flags$5[rsp]
  00db5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00dba	85 c0		 test	 eax, eax
  00dbc	0f 84 dc 00 00
	00		 je	 $LN54@stbtt__Get

; 1848 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

  00dc2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00dc7	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00dcc	98		 cwde
  00dcd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00dd1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00dd9	b8 04 00 00 00	 mov	 eax, 4
  00dde	48 6b c0 00	 imul	 rax, rax, 0
  00de2	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00deb	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00df0	48 83 c0 02	 add	 rax, 2
  00df4	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1849 :             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;

  00df9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00dfe	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00e03	98		 cwde
  00e04	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00e08	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00e10	b8 04 00 00 00	 mov	 eax, 4
  00e15	48 6b c0 01	 imul	 rax, rax, 1
  00e19	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00e22	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00e27	48 83 c0 02	 add	 rax, 2
  00e2b	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1850 :             mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;

  00e30	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00e35	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00e3a	98		 cwde
  00e3b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00e3f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00e47	b8 04 00 00 00	 mov	 eax, 4
  00e4c	48 6b c0 02	 imul	 rax, rax, 2
  00e50	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00e59	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00e5e	48 83 c0 02	 add	 rax, 2
  00e62	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax

; 1851 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

  00e67	48 8b 4c 24 60	 mov	 rcx, QWORD PTR comp$4[rsp]
  00e6c	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00e71	98		 cwde
  00e72	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00e76	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00e7e	b8 04 00 00 00	 mov	 eax, 4
  00e83	48 6b c0 03	 imul	 rax, rax, 3
  00e87	f3 0f 11 84 04
	50 01 00 00	 movss	 DWORD PTR mtx$36[rsp+rax], xmm0
  00e90	48 8b 44 24 60	 mov	 rax, QWORD PTR comp$4[rsp]
  00e95	48 83 c0 02	 add	 rax, 2
  00e99	48 89 44 24 60	 mov	 QWORD PTR comp$4[rsp], rax
$LN54@stbtt__Get:
$LN53@stbtt__Get:
$LN51@stbtt__Get:

; 1852 :          }
; 1853 : 
; 1854 :          // Find transformation scales.
; 1855 :          m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);

  00e9e	b8 04 00 00 00	 mov	 eax, 4
  00ea3	48 6b c0 00	 imul	 rax, rax, 0
  00ea7	b9 04 00 00 00	 mov	 ecx, 4
  00eac	48 6b c9 00	 imul	 rcx, rcx, 0
  00eb0	f3 0f 10 84 04
	50 01 00 00	 movss	 xmm0, DWORD PTR mtx$36[rsp+rax]
  00eb9	f3 0f 59 84 0c
	50 01 00 00	 mulss	 xmm0, DWORD PTR mtx$36[rsp+rcx]
  00ec2	b8 04 00 00 00	 mov	 eax, 4
  00ec7	48 6b c0 01	 imul	 rax, rax, 1
  00ecb	b9 04 00 00 00	 mov	 ecx, 4
  00ed0	48 6b c9 01	 imul	 rcx, rcx, 1
  00ed4	f3 0f 10 8c 04
	50 01 00 00	 movss	 xmm1, DWORD PTR mtx$36[rsp+rax]
  00edd	f3 0f 59 8c 0c
	50 01 00 00	 mulss	 xmm1, DWORD PTR mtx$36[rsp+rcx]
  00ee6	f3 0f 58 c1	 addss	 xmm0, xmm1
  00eea	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00eee	e8 00 00 00 00	 call	 sqrt
  00ef3	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00ef7	f3 0f 11 84 24
	fc 00 00 00	 movss	 DWORD PTR m$30[rsp], xmm0

; 1856 :          n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

  00f00	b8 04 00 00 00	 mov	 eax, 4
  00f05	48 6b c0 02	 imul	 rax, rax, 2
  00f09	b9 04 00 00 00	 mov	 ecx, 4
  00f0e	48 6b c9 02	 imul	 rcx, rcx, 2
  00f12	f3 0f 10 84 04
	50 01 00 00	 movss	 xmm0, DWORD PTR mtx$36[rsp+rax]
  00f1b	f3 0f 59 84 0c
	50 01 00 00	 mulss	 xmm0, DWORD PTR mtx$36[rsp+rcx]
  00f24	b8 04 00 00 00	 mov	 eax, 4
  00f29	48 6b c0 03	 imul	 rax, rax, 3
  00f2d	b9 04 00 00 00	 mov	 ecx, 4
  00f32	48 6b c9 03	 imul	 rcx, rcx, 3
  00f36	f3 0f 10 8c 04
	50 01 00 00	 movss	 xmm1, DWORD PTR mtx$36[rsp+rax]
  00f3f	f3 0f 59 8c 0c
	50 01 00 00	 mulss	 xmm1, DWORD PTR mtx$36[rsp+rcx]
  00f48	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f4c	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00f50	e8 00 00 00 00	 call	 sqrt
  00f55	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00f59	f3 0f 11 84 24
	00 01 00 00	 movss	 DWORD PTR n$31[rsp], xmm0

; 1857 : 
; 1858 :          // Get indexed glyph.
; 1859 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

  00f62	0f b7 84 24 d8
	00 00 00	 movzx	 eax, WORD PTR gidx$26[rsp]
  00f6a	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR comp_verts$28[rsp]
  00f72	8b d0		 mov	 edx, eax
  00f74	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00f7c	e8 00 00 00 00	 call	 stbtt_GetGlyphShape
  00f81	89 84 24 b4 00
	00 00		 mov	 DWORD PTR comp_num_verts$18[rsp], eax

; 1860 :          if (comp_num_verts > 0) {

  00f88	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR comp_num_verts$18[rsp], 0
  00f90	0f 8e a3 03 00
	00		 jle	 $LN55@stbtt__Get

; 1861 :             // Transform vertices.
; 1862 :             for (i = 0; i < comp_num_verts; ++i) {

  00f96	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$22[rsp], 0
  00fa1	eb 10		 jmp	 SHORT $LN18@stbtt__Get
$LN16@stbtt__Get:
  00fa3	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR i$22[rsp]
  00faa	ff c0		 inc	 eax
  00fac	89 84 24 c4 00
	00 00		 mov	 DWORD PTR i$22[rsp], eax
$LN18@stbtt__Get:
  00fb3	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR comp_num_verts$18[rsp]
  00fba	39 84 24 c4 00
	00 00		 cmp	 DWORD PTR i$22[rsp], eax
  00fc1	0f 8d 75 02 00
	00		 jge	 $LN17@stbtt__Get

; 1863 :                stbtt_vertex* v = &comp_verts[i];

  00fc7	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR i$22[rsp]
  00fcf	48 6b c0 0e	 imul	 rax, rax, 14
  00fd3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR comp_verts$28[rsp]
  00fdb	48 03 c8	 add	 rcx, rax
  00fde	48 8b c1	 mov	 rax, rcx
  00fe1	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR v$25[rsp], rax

; 1864 :                stbtt_vertex_type x,y;
; 1865 :                x=v->x; y=v->y;

  00fe9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR v$25[rsp]
  00ff1	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00ff4	66 89 84 24 84
	00 00 00	 mov	 WORD PTR x$9[rsp], ax
  00ffc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR v$25[rsp]
  01004	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  01008	66 89 84 24 88
	00 00 00	 mov	 WORD PTR y$10[rsp], ax

; 1866 :                v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

  01010	b8 04 00 00 00	 mov	 eax, 4
  01015	48 6b c0 00	 imul	 rax, rax, 0
  01019	0f bf 8c 24 84
	00 00 00	 movsx	 ecx, WORD PTR x$9[rsp]
  01021	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  01025	f3 0f 10 8c 04
	50 01 00 00	 movss	 xmm1, DWORD PTR mtx$36[rsp+rax]
  0102e	f3 0f 59 c8	 mulss	 xmm1, xmm0
  01032	0f 28 c1	 movaps	 xmm0, xmm1
  01035	b8 04 00 00 00	 mov	 eax, 4
  0103a	48 6b c0 02	 imul	 rax, rax, 2
  0103e	0f bf 8c 24 88
	00 00 00	 movsx	 ecx, WORD PTR y$10[rsp]
  01046	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  0104a	f3 0f 10 94 04
	50 01 00 00	 movss	 xmm2, DWORD PTR mtx$36[rsp+rax]
  01053	f3 0f 59 d1	 mulss	 xmm2, xmm1
  01057	0f 28 ca	 movaps	 xmm1, xmm2
  0105a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0105e	b8 04 00 00 00	 mov	 eax, 4
  01063	48 6b c0 04	 imul	 rax, rax, 4
  01067	f3 0f 58 84 04
	50 01 00 00	 addss	 xmm0, DWORD PTR mtx$36[rsp+rax]
  01070	f3 0f 10 8c 24
	fc 00 00 00	 movss	 xmm1, DWORD PTR m$30[rsp]
  01079	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0107d	0f 28 c1	 movaps	 xmm0, xmm1
  01080	f3 0f 2c c0	 cvttss2si eax, xmm0
  01084	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR v$25[rsp]
  0108c	66 89 01	 mov	 WORD PTR [rcx], ax

; 1867 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

  0108f	b8 04 00 00 00	 mov	 eax, 4
  01094	48 6b c0 01	 imul	 rax, rax, 1
  01098	0f bf 8c 24 84
	00 00 00	 movsx	 ecx, WORD PTR x$9[rsp]
  010a0	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  010a4	f3 0f 10 8c 04
	50 01 00 00	 movss	 xmm1, DWORD PTR mtx$36[rsp+rax]
  010ad	f3 0f 59 c8	 mulss	 xmm1, xmm0
  010b1	0f 28 c1	 movaps	 xmm0, xmm1
  010b4	b8 04 00 00 00	 mov	 eax, 4
  010b9	48 6b c0 03	 imul	 rax, rax, 3
  010bd	0f bf 8c 24 88
	00 00 00	 movsx	 ecx, WORD PTR y$10[rsp]
  010c5	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  010c9	f3 0f 10 94 04
	50 01 00 00	 movss	 xmm2, DWORD PTR mtx$36[rsp+rax]
  010d2	f3 0f 59 d1	 mulss	 xmm2, xmm1
  010d6	0f 28 ca	 movaps	 xmm1, xmm2
  010d9	f3 0f 58 c1	 addss	 xmm0, xmm1
  010dd	b8 04 00 00 00	 mov	 eax, 4
  010e2	48 6b c0 05	 imul	 rax, rax, 5
  010e6	f3 0f 58 84 04
	50 01 00 00	 addss	 xmm0, DWORD PTR mtx$36[rsp+rax]
  010ef	f3 0f 10 8c 24
	00 01 00 00	 movss	 xmm1, DWORD PTR n$31[rsp]
  010f8	f3 0f 59 c8	 mulss	 xmm1, xmm0
  010fc	0f 28 c1	 movaps	 xmm0, xmm1
  010ff	f3 0f 2c c0	 cvttss2si eax, xmm0
  01103	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR v$25[rsp]
  0110b	66 89 41 02	 mov	 WORD PTR [rcx+2], ax

; 1868 :                x=v->cx; y=v->cy;

  0110f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR v$25[rsp]
  01117	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  0111b	66 89 84 24 84
	00 00 00	 mov	 WORD PTR x$9[rsp], ax
  01123	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR v$25[rsp]
  0112b	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0112f	66 89 84 24 88
	00 00 00	 mov	 WORD PTR y$10[rsp], ax

; 1869 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

  01137	b8 04 00 00 00	 mov	 eax, 4
  0113c	48 6b c0 00	 imul	 rax, rax, 0
  01140	0f bf 8c 24 84
	00 00 00	 movsx	 ecx, WORD PTR x$9[rsp]
  01148	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0114c	f3 0f 10 8c 04
	50 01 00 00	 movss	 xmm1, DWORD PTR mtx$36[rsp+rax]
  01155	f3 0f 59 c8	 mulss	 xmm1, xmm0
  01159	0f 28 c1	 movaps	 xmm0, xmm1
  0115c	b8 04 00 00 00	 mov	 eax, 4
  01161	48 6b c0 02	 imul	 rax, rax, 2
  01165	0f bf 8c 24 88
	00 00 00	 movsx	 ecx, WORD PTR y$10[rsp]
  0116d	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  01171	f3 0f 10 94 04
	50 01 00 00	 movss	 xmm2, DWORD PTR mtx$36[rsp+rax]
  0117a	f3 0f 59 d1	 mulss	 xmm2, xmm1
  0117e	0f 28 ca	 movaps	 xmm1, xmm2
  01181	f3 0f 58 c1	 addss	 xmm0, xmm1
  01185	b8 04 00 00 00	 mov	 eax, 4
  0118a	48 6b c0 04	 imul	 rax, rax, 4
  0118e	f3 0f 58 84 04
	50 01 00 00	 addss	 xmm0, DWORD PTR mtx$36[rsp+rax]
  01197	f3 0f 10 8c 24
	fc 00 00 00	 movss	 xmm1, DWORD PTR m$30[rsp]
  011a0	f3 0f 59 c8	 mulss	 xmm1, xmm0
  011a4	0f 28 c1	 movaps	 xmm0, xmm1
  011a7	f3 0f 2c c0	 cvttss2si eax, xmm0
  011ab	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR v$25[rsp]
  011b3	66 89 41 04	 mov	 WORD PTR [rcx+4], ax

; 1870 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

  011b7	b8 04 00 00 00	 mov	 eax, 4
  011bc	48 6b c0 01	 imul	 rax, rax, 1
  011c0	0f bf 8c 24 84
	00 00 00	 movsx	 ecx, WORD PTR x$9[rsp]
  011c8	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  011cc	f3 0f 10 8c 04
	50 01 00 00	 movss	 xmm1, DWORD PTR mtx$36[rsp+rax]
  011d5	f3 0f 59 c8	 mulss	 xmm1, xmm0
  011d9	0f 28 c1	 movaps	 xmm0, xmm1
  011dc	b8 04 00 00 00	 mov	 eax, 4
  011e1	48 6b c0 03	 imul	 rax, rax, 3
  011e5	0f bf 8c 24 88
	00 00 00	 movsx	 ecx, WORD PTR y$10[rsp]
  011ed	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  011f1	f3 0f 10 94 04
	50 01 00 00	 movss	 xmm2, DWORD PTR mtx$36[rsp+rax]
  011fa	f3 0f 59 d1	 mulss	 xmm2, xmm1
  011fe	0f 28 ca	 movaps	 xmm1, xmm2
  01201	f3 0f 58 c1	 addss	 xmm0, xmm1
  01205	b8 04 00 00 00	 mov	 eax, 4
  0120a	48 6b c0 05	 imul	 rax, rax, 5
  0120e	f3 0f 58 84 04
	50 01 00 00	 addss	 xmm0, DWORD PTR mtx$36[rsp+rax]
  01217	f3 0f 10 8c 24
	00 01 00 00	 movss	 xmm1, DWORD PTR n$31[rsp]
  01220	f3 0f 59 c8	 mulss	 xmm1, xmm0
  01224	0f 28 c1	 movaps	 xmm0, xmm1
  01227	f3 0f 2c c0	 cvttss2si eax, xmm0
  0122b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR v$25[rsp]
  01233	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 1871 :             }

  01237	e9 67 fd ff ff	 jmp	 $LN16@stbtt__Get
$LN17@stbtt__Get:

; 1872 :             // Append vertices.
; 1873 :             tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);

  0123c	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR comp_num_verts$18[rsp]
  01243	8b 4c 24 58	 mov	 ecx, DWORD PTR num_vertices$[rsp]
  01247	03 c8		 add	 ecx, eax
  01249	8b c1		 mov	 eax, ecx
  0124b	48 98		 cdqe
  0124d	48 6b c0 0e	 imul	 rax, rax, 14
  01251	48 8b c8	 mov	 rcx, rax
  01254	e8 00 00 00 00	 call	 malloc
  01259	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tmp$34[rsp], rax

; 1874 :             if (!tmp) {

  01261	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR tmp$34[rsp], 0
  0126a	75 31		 jne	 SHORT $LN56@stbtt__Get

; 1875 :                if (vertices) STBTT_free(vertices, info->userdata);

  0126c	48 83 7c 24 68
	00		 cmp	 QWORD PTR vertices$[rsp], 0
  01272	74 0a		 je	 SHORT $LN57@stbtt__Get
  01274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  01279	e8 00 00 00 00	 call	 free
$LN57@stbtt__Get:

; 1876 :                if (comp_verts) STBTT_free(comp_verts, info->userdata);

  0127e	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR comp_verts$28[rsp], 0
  01287	74 0d		 je	 SHORT $LN58@stbtt__Get
  01289	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR comp_verts$28[rsp]
  01291	e8 00 00 00 00	 call	 free
$LN58@stbtt__Get:

; 1877 :                return 0;

  01296	33 c0		 xor	 eax, eax
  01298	e9 c4 00 00 00	 jmp	 $LN1@stbtt__Get
$LN56@stbtt__Get:

; 1878 :             }
; 1879 :             if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));

  0129d	83 7c 24 58 00	 cmp	 DWORD PTR num_vertices$[rsp], 0
  012a2	7e 23		 jle	 SHORT $LN59@stbtt__Get
  012a4	48 83 7c 24 68
	00		 cmp	 QWORD PTR vertices$[rsp], 0
  012aa	74 1b		 je	 SHORT $LN59@stbtt__Get
  012ac	48 63 44 24 58	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  012b1	48 6b c0 0e	 imul	 rax, rax, 14
  012b5	48 8b bc 24 18
	01 00 00	 mov	 rdi, QWORD PTR tmp$34[rsp]
  012bd	48 8b 74 24 68	 mov	 rsi, QWORD PTR vertices$[rsp]
  012c2	48 8b c8	 mov	 rcx, rax
  012c5	f3 a4		 rep movsb
$LN59@stbtt__Get:

; 1880 :             STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));

  012c7	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR comp_num_verts$18[rsp]
  012cf	48 6b c0 0e	 imul	 rax, rax, 14
  012d3	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR num_vertices$[rsp]
  012d8	48 6b c9 0e	 imul	 rcx, rcx, 14
  012dc	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR tmp$34[rsp]
  012e4	48 03 d1	 add	 rdx, rcx
  012e7	48 8b ca	 mov	 rcx, rdx
  012ea	48 8b f9	 mov	 rdi, rcx
  012ed	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR comp_verts$28[rsp]
  012f5	48 8b c8	 mov	 rcx, rax
  012f8	f3 a4		 rep movsb

; 1881 :             if (vertices) STBTT_free(vertices, info->userdata);

  012fa	48 83 7c 24 68
	00		 cmp	 QWORD PTR vertices$[rsp], 0
  01300	74 0a		 je	 SHORT $LN60@stbtt__Get
  01302	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  01307	e8 00 00 00 00	 call	 free
$LN60@stbtt__Get:

; 1882 :             vertices = tmp;

  0130c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tmp$34[rsp]
  01314	48 89 44 24 68	 mov	 QWORD PTR vertices$[rsp], rax

; 1883 :             STBTT_free(comp_verts, info->userdata);

  01319	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR comp_verts$28[rsp]
  01321	e8 00 00 00 00	 call	 free

; 1884 :             num_vertices += comp_num_verts;

  01326	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR comp_num_verts$18[rsp]
  0132d	8b 4c 24 58	 mov	 ecx, DWORD PTR num_vertices$[rsp]
  01331	03 c8		 add	 ecx, eax
  01333	8b c1		 mov	 eax, ecx
  01335	89 44 24 58	 mov	 DWORD PTR num_vertices$[rsp], eax
$LN55@stbtt__Get:

; 1885 :          }
; 1886 :          // More components ?
; 1887 :          more = flags & (1<<5);

  01339	0f b7 44 24 74	 movzx	 eax, WORD PTR flags$5[rsp]
  0133e	83 e0 20	 and	 eax, 32			; 00000020H
  01341	89 84 24 04 01
	00 00		 mov	 DWORD PTR more$32[rsp], eax

; 1888 :       }

  01348	e9 5e f7 ff ff	 jmp	 $LN14@stbtt__Get
$LN15@stbtt__Get:
$LN44@stbtt__Get:
$LN21@stbtt__Get:

; 1889 :    } else {
; 1890 :       // numberOfCounters == 0, do nothing
; 1891 :    }
; 1892 : 
; 1893 :    *pvertices = vertices;

  0134d	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pvertices$[rsp]
  01355	48 8b 4c 24 68	 mov	 rcx, QWORD PTR vertices$[rsp]
  0135a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1894 :    return num_vertices;

  0135d	8b 44 24 58	 mov	 eax, DWORD PTR num_vertices$[rsp]
$LN1@stbtt__Get:

; 1895 : }

  01361	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01369	48 33 cc	 xor	 rcx, rsp
  0136c	e8 00 00 00 00	 call	 __security_check_cookie
  01371	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  01378	5f		 pop	 rdi
  01379	5e		 pop	 rsi
  0137a	c3		 ret	 0
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeTT
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv79 = 48
tv90 = 56
tv134 = 64
tv145 = 72
vertices$ = 96
num_vertices$ = 104
was_off$ = 112
start_off$ = 120
sx$ = 128
sy$ = 136
scx$ = 144
scy$ = 152
cx$ = 160
cy$ = 168
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z PROC ; stbtt__close_shape

; 1660 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1661 :    if (start_off) {

  00017	83 7c 24 78 00	 cmp	 DWORD PTR start_off$[rsp], 0
  0001c	0f 84 ce 00 00
	00		 je	 $LN2@stbtt__clo

; 1662 :       if (was_off)

  00022	83 7c 24 70 00	 cmp	 DWORD PTR was_off$[rsp], 0
  00027	74 70		 je	 SHORT $LN4@stbtt__clo

; 1663 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

  00029	48 63 44 24 68	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  0002e	48 6b c0 0e	 imul	 rax, rax, 14
  00032	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vertices$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 89 4c 24 30	 mov	 QWORD PTR tv79[rsp], rcx
  0003f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR scy$[rsp]
  00046	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR cy$[rsp]
  0004d	03 c8		 add	 ecx, eax
  0004f	8b c1		 mov	 eax, ecx
  00051	d1 f8		 sar	 eax, 1
  00053	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR scx$[rsp]
  0005a	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR cx$[rsp]
  00061	03 d1		 add	 edx, ecx
  00063	8b ca		 mov	 ecx, edx
  00065	d1 f9		 sar	 ecx, 1
  00067	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR cy$[rsp]
  0006e	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00072	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR cx$[rsp]
  00079	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0007d	44 8b c8	 mov	 r9d, eax
  00080	44 8b c1	 mov	 r8d, ecx
  00083	b2 03		 mov	 dl, 3
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv79[rsp]
  0008a	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  0008f	8b 44 24 68	 mov	 eax, DWORD PTR num_vertices$[rsp]
  00093	ff c0		 inc	 eax
  00095	89 44 24 68	 mov	 DWORD PTR num_vertices$[rsp], eax
$LN4@stbtt__clo:

; 1664 :       stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);

  00099	48 63 44 24 68	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  0009e	48 6b c0 0e	 imul	 rax, rax, 14
  000a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vertices$[rsp]
  000a7	48 03 c8	 add	 rcx, rax
  000aa	48 89 4c 24 38	 mov	 QWORD PTR tv90[rsp], rcx
  000af	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR scy$[rsp]
  000b6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000ba	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR scx$[rsp]
  000c1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c5	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR sy$[rsp]
  000cd	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR sx$[rsp]
  000d5	b2 03		 mov	 dl, 3
  000d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv90[rsp]
  000dc	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  000e1	8b 44 24 68	 mov	 eax, DWORD PTR num_vertices$[rsp]
  000e5	ff c0		 inc	 eax
  000e7	89 44 24 68	 mov	 DWORD PTR num_vertices$[rsp], eax

; 1665 :    } else {

  000eb	e9 a7 00 00 00	 jmp	 $LN3@stbtt__clo
$LN2@stbtt__clo:

; 1666 :       if (was_off)

  000f0	83 7c 24 70 00	 cmp	 DWORD PTR was_off$[rsp], 0
  000f5	74 54		 je	 SHORT $LN5@stbtt__clo

; 1667 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);

  000f7	48 63 44 24 68	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  000fc	48 6b c0 0e	 imul	 rax, rax, 14
  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vertices$[rsp]
  00105	48 03 c8	 add	 rcx, rax
  00108	48 89 4c 24 40	 mov	 QWORD PTR tv134[rsp], rcx
  0010d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR cy$[rsp]
  00114	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00118	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR cx$[rsp]
  0011f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00123	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR sy$[rsp]
  0012b	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR sx$[rsp]
  00133	b2 03		 mov	 dl, 3
  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv134[rsp]
  0013a	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  0013f	8b 44 24 68	 mov	 eax, DWORD PTR num_vertices$[rsp]
  00143	ff c0		 inc	 eax
  00145	89 44 24 68	 mov	 DWORD PTR num_vertices$[rsp], eax
  00149	eb 4c		 jmp	 SHORT $LN6@stbtt__clo
$LN5@stbtt__clo:

; 1668 :       else
; 1669 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);

  0014b	48 63 44 24 68	 movsxd	 rax, DWORD PTR num_vertices$[rsp]
  00150	48 6b c0 0e	 imul	 rax, rax, 14
  00154	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vertices$[rsp]
  00159	48 03 c8	 add	 rcx, rax
  0015c	48 89 4c 24 48	 mov	 QWORD PTR tv145[rsp], rcx
  00161	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00169	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00171	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR sy$[rsp]
  00179	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR sx$[rsp]
  00181	b2 02		 mov	 dl, 2
  00183	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv145[rsp]
  00188	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  0018d	8b 44 24 68	 mov	 eax, DWORD PTR num_vertices$[rsp]
  00191	ff c0		 inc	 eax
  00193	89 44 24 68	 mov	 DWORD PTR num_vertices$[rsp], eax
$LN6@stbtt__clo:
$LN3@stbtt__clo:

; 1670 :    }
; 1671 :    return num_vertices;

  00197	8b 44 24 68	 mov	 eax, DWORD PTR num_vertices$[rsp]

; 1672 : }

  0019b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019f	c3		 ret	 0
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ENDP ; stbtt__close_shape
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
r$ = 32
tv70 = 36
tv73 = 40
tv76 = 44
tv79 = 48
tv81 = 52
c$ = 56
info$ = 128
glyph_index$ = 136
x0$ = 144
y0$ = 152
x1$ = 160
y1$ = 168
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z PROC ; stbtt__GetGlyphInfoT2

; 2287 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2288 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00017	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR c$[rsp], 1
  0001f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR c$[rsp+4], 0
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	f3 0f 11 44 24
	40		 movss	 DWORD PTR c$[rsp+8], xmm0
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 44 24
	44		 movss	 DWORD PTR c$[rsp+12], xmm0
  00039	0f 57 c0	 xorps	 xmm0, xmm0
  0003c	f3 0f 11 44 24
	48		 movss	 DWORD PTR c$[rsp+16], xmm0
  00042	0f 57 c0	 xorps	 xmm0, xmm0
  00045	f3 0f 11 44 24
	4c		 movss	 DWORD PTR c$[rsp+20], xmm0
  0004b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR c$[rsp+24], 0
  00053	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR c$[rsp+28], 0
  0005b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR c$[rsp+32], 0
  00063	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR c$[rsp+36], 0
  0006b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR c$[rsp+40], 0
  00074	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR c$[rsp+48], 0

; 2289 :    int r = stbtt__run_charstring(info, glyph_index, &c);

  0007c	4c 8d 44 24 38	 lea	 r8, QWORD PTR c$[rsp]
  00081	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR glyph_index$[rsp]
  00088	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  00095	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 2290 :    if (x0)  *x0 = r ? c.min_x : 0;

  00099	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR x0$[rsp], 0
  000a2	74 27		 je	 SHORT $LN2@stbtt__Get
  000a4	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  000a9	74 0a		 je	 SHORT $LN7@stbtt__Get
  000ab	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp+24]
  000af	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
  000b3	eb 08		 jmp	 SHORT $LN8@stbtt__Get
$LN7@stbtt__Get:
  000b5	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@stbtt__Get:
  000bd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR x0$[rsp]
  000c5	8b 4c 24 24	 mov	 ecx, DWORD PTR tv70[rsp]
  000c9	89 08		 mov	 DWORD PTR [rax], ecx
$LN2@stbtt__Get:

; 2291 :    if (y0)  *y0 = r ? c.min_y : 0;

  000cb	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR y0$[rsp], 0
  000d4	74 27		 je	 SHORT $LN3@stbtt__Get
  000d6	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  000db	74 0a		 je	 SHORT $LN9@stbtt__Get
  000dd	8b 44 24 58	 mov	 eax, DWORD PTR c$[rsp+32]
  000e1	89 44 24 28	 mov	 DWORD PTR tv73[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN10@stbtt__Get
$LN9@stbtt__Get:
  000e7	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN10@stbtt__Get:
  000ef	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR y0$[rsp]
  000f7	8b 4c 24 28	 mov	 ecx, DWORD PTR tv73[rsp]
  000fb	89 08		 mov	 DWORD PTR [rax], ecx
$LN3@stbtt__Get:

; 2292 :    if (x1)  *x1 = r ? c.max_x : 0;

  000fd	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR x1$[rsp], 0
  00106	74 27		 je	 SHORT $LN4@stbtt__Get
  00108	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  0010d	74 0a		 je	 SHORT $LN11@stbtt__Get
  0010f	8b 44 24 54	 mov	 eax, DWORD PTR c$[rsp+28]
  00113	89 44 24 2c	 mov	 DWORD PTR tv76[rsp], eax
  00117	eb 08		 jmp	 SHORT $LN12@stbtt__Get
$LN11@stbtt__Get:
  00119	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN12@stbtt__Get:
  00121	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR x1$[rsp]
  00129	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv76[rsp]
  0012d	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbtt__Get:

; 2293 :    if (y1)  *y1 = r ? c.max_y : 0;

  0012f	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR y1$[rsp], 0
  00138	74 27		 je	 SHORT $LN5@stbtt__Get
  0013a	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  0013f	74 0a		 je	 SHORT $LN13@stbtt__Get
  00141	8b 44 24 5c	 mov	 eax, DWORD PTR c$[rsp+36]
  00145	89 44 24 30	 mov	 DWORD PTR tv79[rsp], eax
  00149	eb 08		 jmp	 SHORT $LN14@stbtt__Get
$LN13@stbtt__Get:
  0014b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN14@stbtt__Get:
  00153	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR y1$[rsp]
  0015b	8b 4c 24 30	 mov	 ecx, DWORD PTR tv79[rsp]
  0015f	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbtt__Get:

; 2294 :    return r ? c.num_vertices : 0;

  00161	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  00166	74 0a		 je	 SHORT $LN15@stbtt__Get
  00168	8b 44 24 68	 mov	 eax, DWORD PTR c$[rsp+48]
  0016c	89 44 24 34	 mov	 DWORD PTR tv81[rsp], eax
  00170	eb 08		 jmp	 SHORT $LN16@stbtt__Get
$LN15@stbtt__Get:
  00172	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN16@stbtt__Get:
  0017a	8b 44 24 34	 mov	 eax, DWORD PTR tv81[rsp]

; 2295 : }

  0017e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00182	c3		 ret	 0
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ENDP ; stbtt__GetGlyphInfoT2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
g1$ = 32
g2$ = 36
tv160 = 40
info$ = 64
glyph_index$ = 72
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z PROC	; stbtt__GetGlyfOffset

; 1604 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1605 :    int g1,g2;
; 1606 : 
; 1607 :    STBTT_assert(!info->cff.size);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00012	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00016	74 1b		 je	 SHORT $LN7@stbtt__Get
  00018	41 b8 47 06 00
	00		 mov	 r8d, 1607		; 00000647H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41636
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41637
  0002c	e8 00 00 00 00	 call	 _wassert
  00031	33 c0		 xor	 eax, eax
$LN7@stbtt__Get:

; 1608 : 
; 1609 :    if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00038	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0003b	39 44 24 48	 cmp	 DWORD PTR glyph_index$[rsp], eax
  0003f	7c 0a		 jl	 SHORT $LN2@stbtt__Get
  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	e9 38 01 00 00	 jmp	 $LN1@stbtt__Get
$LN2@stbtt__Get:

; 1610 :    if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00050	83 78 3c 02	 cmp	 DWORD PTR [rax+60], 2
  00054	7c 0a		 jl	 SHORT $LN3@stbtt__Get
  00056	b8 ff ff ff ff	 mov	 eax, -1
  0005b	e9 23 01 00 00	 jmp	 $LN1@stbtt__Get
$LN3@stbtt__Get:

; 1611 : 
; 1612 :    if (info->indexToLocFormat == 0) {

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00065	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00069	0f 85 80 00 00
	00		 jne	 $LN4@stbtt__Get

; 1613 :       g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00074	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0007d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	8b 4c 24 48	 mov	 ecx, DWORD PTR glyph_index$[rsp]
  0008b	d1 e1		 shl	 ecx, 1
  0008d	48 63 c9	 movsxd	 rcx, ecx
  00090	48 03 c1	 add	 rax, rcx
  00093	48 8b c8	 mov	 rcx, rax
  00096	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0009b	0f b7 c0	 movzx	 eax, ax
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000a3	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  000a6	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  000a9	89 44 24 20	 mov	 DWORD PTR g1$[rsp], eax

; 1614 :       g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

  000ad	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  000b2	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  000b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000bb	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000bf	48 03 c8	 add	 rcx, rax
  000c2	48 8b c1	 mov	 rax, rcx
  000c5	8b 4c 24 48	 mov	 ecx, DWORD PTR glyph_index$[rsp]
  000c9	d1 e1		 shl	 ecx, 1
  000cb	48 63 c9	 movsxd	 rcx, ecx
  000ce	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000db	0f b7 c0	 movzx	 eax, ax
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000e3	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  000e6	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  000e9	89 44 24 24	 mov	 DWORD PTR g2$[rsp], eax

; 1615 :    } else {

  000ed	eb 74		 jmp	 SHORT $LN5@stbtt__Get
$LN4@stbtt__Get:

; 1616 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  000f4	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000fd	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00101	48 03 c8	 add	 rcx, rax
  00104	48 8b c1	 mov	 rax, rcx
  00107	8b 4c 24 48	 mov	 ecx, DWORD PTR glyph_index$[rsp]
  0010b	c1 e1 02	 shl	 ecx, 2
  0010e	48 63 c9	 movsxd	 rcx, ecx
  00111	48 03 c1	 add	 rax, rcx
  00114	48 8b c8	 mov	 rcx, rax
  00117	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00121	03 41 20	 add	 eax, DWORD PTR [rcx+32]
  00124	89 44 24 20	 mov	 DWORD PTR g1$[rsp], eax

; 1617 :       g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);

  00128	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0012d	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  00131	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00136	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0013a	48 03 c8	 add	 rcx, rax
  0013d	48 8b c1	 mov	 rax, rcx
  00140	8b 4c 24 48	 mov	 ecx, DWORD PTR glyph_index$[rsp]
  00144	c1 e1 02	 shl	 ecx, 2
  00147	48 63 c9	 movsxd	 rcx, ecx
  0014a	48 8d 44 08 04	 lea	 rax, QWORD PTR [rax+rcx+4]
  0014f	48 8b c8	 mov	 rcx, rax
  00152	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00157	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0015c	03 41 20	 add	 eax, DWORD PTR [rcx+32]
  0015f	89 44 24 24	 mov	 DWORD PTR g2$[rsp], eax
$LN5@stbtt__Get:

; 1618 :    }
; 1619 : 
; 1620 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

  00163	8b 44 24 24	 mov	 eax, DWORD PTR g2$[rsp]
  00167	39 44 24 20	 cmp	 DWORD PTR g1$[rsp], eax
  0016b	75 0a		 jne	 SHORT $LN8@stbtt__Get
  0016d	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv160[rsp], -1
  00175	eb 08		 jmp	 SHORT $LN9@stbtt__Get
$LN8@stbtt__Get:
  00177	8b 44 24 20	 mov	 eax, DWORD PTR g1$[rsp]
  0017b	89 44 24 28	 mov	 DWORD PTR tv160[rsp], eax
$LN9@stbtt__Get:
  0017f	8b 44 24 28	 mov	 eax, DWORD PTR tv160[rsp]
$LN1@stbtt__Get:

; 1621 : }

  00183	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00187	c3		 ret	 0
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ENDP	; stbtt__GetGlyfOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
v$ = 8
type$ = 16
x$ = 24
y$ = 32
cx$ = 40
cy$ = 48
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z PROC	; stbtt_setvertex

; 1595 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1596 :    v->type = type;

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR v$[rsp]
  00018	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR type$[rsp]
  0001d	88 48 0c	 mov	 BYTE PTR [rax+12], cl

; 1597 :    v->x = (stbtt_int16) x;

  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR v$[rsp]
  00025	0f b7 4c 24 18	 movzx	 ecx, WORD PTR x$[rsp]
  0002a	66 89 08	 mov	 WORD PTR [rax], cx

; 1598 :    v->y = (stbtt_int16) y;

  0002d	48 8b 44 24 08	 mov	 rax, QWORD PTR v$[rsp]
  00032	0f b7 4c 24 20	 movzx	 ecx, WORD PTR y$[rsp]
  00037	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 1599 :    v->cx = (stbtt_int16) cx;

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR v$[rsp]
  00040	0f b7 4c 24 28	 movzx	 ecx, WORD PTR cx$[rsp]
  00045	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 1600 :    v->cy = (stbtt_int16) cy;

  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR v$[rsp]
  0004e	0f b7 4c 24 30	 movzx	 ecx, WORD PTR cy$[rsp]
  00053	66 89 48 06	 mov	 WORD PTR [rax+6], cx

; 1601 : }

  00057	c3		 ret	 0
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ENDP	; stbtt_setvertex
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
cmap$ = 32
fdselectoff$1 = 36
i$ = 40
encoding_record$2 = 44
fdarrayoff$3 = 48
charstrings$4 = 52
b$5 = 56
cff$6 = 72
cstype$7 = 76
t$ = 80
tv321 = 84
tv328 = 88
numTables$ = 92
topdict$8 = 96
$T9 = 112
$T10 = 128
$T11 = 144
$T12 = 160
$T13 = 176
topdictidx$14 = 192
$T15 = 208
$T16 = 224
$T17 = 240
$T18 = 256
$T19 = 272
$T20 = 288
$T21 = 304
$T22 = 320
$T23 = 336
$T24 = 352
$T25 = 368
$T26 = 384
$T27 = 400
$T28 = 416
$T29 = 432
$T30 = 448
$T31 = 464
$T32 = 480
$T33 = 496
$T34 = 512
$T35 = 528
$T36 = 544
$T37 = 560
$T38 = 576
info$ = 624
data$ = 632
fontstart$ = 640
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z PROC ; stbtt_InitFont_internal

; 1384 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H

; 1385 :    stbtt_uint32 cmap, t;
; 1386 :    stbtt_int32 i,numTables;
; 1387 : 
; 1388 :    info->data = data;

  00018	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00020	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00028	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1389 :    info->fontstart = fontstart;

  0002c	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00034	8b 8c 24 80 02
	00 00		 mov	 ecx, DWORD PTR fontstart$[rsp]
  0003b	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1390 :    info->cff = stbtt__new_buf(NULL, 0);

  0003e	45 33 c0	 xor	 r8d, r8d
  00041	33 d2		 xor	 edx, edx
  00043	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  00050	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T9[rsp]
  00055	48 8b f9	 mov	 rdi, rcx
  00058	48 8b f0	 mov	 rsi, rax
  0005b	b9 10 00 00 00	 mov	 ecx, 16
  00060	f3 a4		 rep movsb
  00062	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0006a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T9[rsp]
  0006f	48 8d 78 40	 lea	 rdi, QWORD PTR [rax+64]
  00073	48 8b f1	 mov	 rsi, rcx
  00076	b9 10 00 00 00	 mov	 ecx, 16
  0007b	f3 a4		 rep movsb

; 1391 : 
; 1392 :    cmap = stbtt__find_table(data, fontstart, "cmap");       // required

  0007d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41512
  00084	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  0008b	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00093	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00098	89 44 24 20	 mov	 DWORD PTR cmap$[rsp], eax

; 1393 :    info->loca = stbtt__find_table(data, fontstart, "loca"); // required

  0009c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41513
  000a3	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  000aa	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000b2	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  000b7	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000bf	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1394 :    info->head = stbtt__find_table(data, fontstart, "head"); // required

  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41514
  000c9	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  000d0	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000d8	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  000dd	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000e5	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1395 :    info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required

  000e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41515
  000ef	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  000f6	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000fe	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00103	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0010b	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 1396 :    info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required

  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41516
  00115	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  0011c	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00124	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00129	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00131	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1397 :    info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required

  00134	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41517
  0013b	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  00142	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0014a	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  0014f	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00157	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1398 :    info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41518
  00161	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  00168	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00170	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00175	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0017d	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 1399 :    info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

  00180	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41519
  00187	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  0018e	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00196	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  0019b	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  001a3	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1400 : 
; 1401 :    if (!cmap || !info->head || !info->hhea || !info->hmtx)

  001a6	83 7c 24 20 00	 cmp	 DWORD PTR cmap$[rsp], 0
  001ab	74 2a		 je	 SHORT $LN10@stbtt_Init
  001ad	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  001b5	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  001b9	74 1c		 je	 SHORT $LN10@stbtt_Init
  001bb	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  001c3	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  001c7	74 0e		 je	 SHORT $LN10@stbtt_Init
  001c9	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  001d1	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  001d5	75 07		 jne	 SHORT $LN9@stbtt_Init
$LN10@stbtt_Init:

; 1402 :       return 0;

  001d7	33 c0		 xor	 eax, eax
  001d9	e9 db 06 00 00	 jmp	 $LN1@stbtt_Init
$LN9@stbtt_Init:

; 1403 :    if (info->glyf) {

  001de	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  001e6	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  001ea	74 1a		 je	 SHORT $LN11@stbtt_Init

; 1404 :       // required for truetype
; 1405 :       if (!info->loca) return 0;

  001ec	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  001f4	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001f8	75 07		 jne	 SHORT $LN13@stbtt_Init
  001fa	33 c0		 xor	 eax, eax
  001fc	e9 b8 06 00 00	 jmp	 $LN1@stbtt_Init
$LN13@stbtt_Init:

; 1406 :    } else {

  00201	e9 dc 04 00 00	 jmp	 $LN12@stbtt_Init
$LN11@stbtt_Init:

; 1407 :       // initialization for CFF / Type2 fonts (OTF)
; 1408 :       stbtt__buf b, topdict, topdictidx;
; 1409 :       stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;

  00206	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR cstype$7[rsp], 2
  0020e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR charstrings$4[rsp], 0
  00216	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR fdarrayoff$3[rsp], 0
  0021e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR fdselectoff$1[rsp], 0

; 1410 :       stbtt_uint32 cff;
; 1411 : 
; 1412 :       cff = stbtt__find_table(data, fontstart, "CFF ");

  00226	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41525
  0022d	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  00234	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0023c	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00241	89 44 24 48	 mov	 DWORD PTR cff$6[rsp], eax

; 1413 :       if (!cff) return 0;

  00245	83 7c 24 48 00	 cmp	 DWORD PTR cff$6[rsp], 0
  0024a	75 07		 jne	 SHORT $LN14@stbtt_Init
  0024c	33 c0		 xor	 eax, eax
  0024e	e9 66 06 00 00	 jmp	 $LN1@stbtt_Init
$LN14@stbtt_Init:

; 1414 : 
; 1415 :       info->fontdicts = stbtt__new_buf(NULL, 0);

  00253	45 33 c0	 xor	 r8d, r8d
  00256	33 d2		 xor	 edx, edx
  00258	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00260	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  00265	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  0026d	48 8b f9	 mov	 rdi, rcx
  00270	48 8b f0	 mov	 rsi, rax
  00273	b9 10 00 00 00	 mov	 ecx, 16
  00278	f3 a4		 rep movsb
  0027a	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00282	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  0028a	48 8d b8 80 00
	00 00		 lea	 rdi, QWORD PTR [rax+128]
  00291	48 8b f1	 mov	 rsi, rcx
  00294	b9 10 00 00 00	 mov	 ecx, 16
  00299	f3 a4		 rep movsb

; 1416 :       info->fdselect = stbtt__new_buf(NULL, 0);

  0029b	45 33 c0	 xor	 r8d, r8d
  0029e	33 d2		 xor	 edx, edx
  002a0	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  002a8	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  002ad	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  002b5	48 8b f9	 mov	 rdi, rcx
  002b8	48 8b f0	 mov	 rsi, rax
  002bb	b9 10 00 00 00	 mov	 ecx, 16
  002c0	f3 a4		 rep movsb
  002c2	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  002ca	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  002d2	48 8d b8 90 00
	00 00		 lea	 rdi, QWORD PTR [rax+144]
  002d9	48 8b f1	 mov	 rsi, rcx
  002dc	b9 10 00 00 00	 mov	 ecx, 16
  002e1	f3 a4		 rep movsb

; 1417 : 
; 1418 :       // @TODO this should use size from table (not 512MB)
; 1419 :       info->cff = stbtt__new_buf(data+cff, 512*1024*1024);

  002e3	8b 44 24 48	 mov	 eax, DWORD PTR cff$6[rsp]
  002e7	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  002ef	48 03 c8	 add	 rcx, rax
  002f2	48 8b c1	 mov	 rax, rcx
  002f5	41 b8 00 00 00
	20		 mov	 r8d, 536870912		; 20000000H
  002fb	48 8b d0	 mov	 rdx, rax
  002fe	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  00306	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  0030b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00313	48 8b f9	 mov	 rdi, rcx
  00316	48 8b f0	 mov	 rsi, rax
  00319	b9 10 00 00 00	 mov	 ecx, 16
  0031e	f3 a4		 rep movsb
  00320	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00328	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00330	48 8d 78 40	 lea	 rdi, QWORD PTR [rax+64]
  00334	48 8b f1	 mov	 rsi, rcx
  00337	b9 10 00 00 00	 mov	 ecx, 16
  0033c	f3 a4		 rep movsb

; 1420 :       b = info->cff;

  0033e	48 8d 44 24 38	 lea	 rax, QWORD PTR b$5[rsp]
  00343	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0034b	48 8b f8	 mov	 rdi, rax
  0034e	48 8d 71 40	 lea	 rsi, QWORD PTR [rcx+64]
  00352	b9 10 00 00 00	 mov	 ecx, 16
  00357	f3 a4		 rep movsb

; 1421 : 
; 1422 :       // read the header
; 1423 :       stbtt__buf_skip(&b, 2);

  00359	ba 02 00 00 00	 mov	 edx, 2
  0035e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR b$5[rsp]
  00363	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1424 :       stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

  00368	48 8d 4c 24 38	 lea	 rcx, QWORD PTR b$5[rsp]
  0036d	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00372	0f b6 c0	 movzx	 eax, al
  00375	8b d0		 mov	 edx, eax
  00377	48 8d 4c 24 38	 lea	 rcx, QWORD PTR b$5[rsp]
  0037c	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1425 : 
; 1426 :       // @TODO the name INDEX could list multiple fonts,
; 1427 :       // but we just use the first one.
; 1428 :       stbtt__cff_get_index(&b);  // name INDEX

  00381	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  00386	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  0038e	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  00393	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR $T29[rsp]
  0039b	48 8b f9	 mov	 rdi, rcx
  0039e	48 8b f0	 mov	 rsi, rax
  003a1	b9 10 00 00 00	 mov	 ecx, 16
  003a6	f3 a4		 rep movsb

; 1429 :       topdictidx = stbtt__cff_get_index(&b);

  003a8	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  003ad	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  003b5	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  003ba	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  003c2	48 8b f9	 mov	 rdi, rcx
  003c5	48 8b f0	 mov	 rsi, rax
  003c8	b9 10 00 00 00	 mov	 ecx, 16
  003cd	f3 a4		 rep movsb
  003cf	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR topdictidx$14[rsp]
  003d7	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  003df	48 8b f8	 mov	 rdi, rax
  003e2	48 8b f1	 mov	 rsi, rcx
  003e5	b9 10 00 00 00	 mov	 ecx, 16
  003ea	f3 a4		 rep movsb

; 1430 :       topdict = stbtt__cff_index_get(topdictidx, 0);

  003ec	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T15[rsp]
  003f4	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR topdictidx$14[rsp]
  003fc	48 8b f8	 mov	 rdi, rax
  003ff	48 8b f1	 mov	 rsi, rcx
  00402	b9 10 00 00 00	 mov	 ecx, 16
  00407	f3 a4		 rep movsb
  00409	45 33 c0	 xor	 r8d, r8d
  0040c	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T15[rsp]
  00414	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0041c	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  00421	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00429	48 8b f9	 mov	 rdi, rcx
  0042c	48 8b f0	 mov	 rsi, rax
  0042f	b9 10 00 00 00	 mov	 ecx, 16
  00434	f3 a4		 rep movsb
  00436	48 8d 44 24 60	 lea	 rax, QWORD PTR topdict$8[rsp]
  0043b	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00443	48 8b f8	 mov	 rdi, rax
  00446	48 8b f1	 mov	 rsi, rcx
  00449	b9 10 00 00 00	 mov	 ecx, 16
  0044e	f3 a4		 rep movsb

; 1431 :       stbtt__cff_get_index(&b);  // string INDEX

  00450	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  00455	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  0045d	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  00462	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  0046a	48 8b f9	 mov	 rdi, rcx
  0046d	48 8b f0	 mov	 rsi, rax
  00470	b9 10 00 00 00	 mov	 ecx, 16
  00475	f3 a4		 rep movsb

; 1432 :       info->gsubrs = stbtt__cff_get_index(&b);

  00477	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  0047c	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  00484	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  00489	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  00491	48 8b f9	 mov	 rdi, rcx
  00494	48 8b f0	 mov	 rsi, rax
  00497	b9 10 00 00 00	 mov	 ecx, 16
  0049c	f3 a4		 rep movsb
  0049e	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  004a6	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  004ae	48 8d 78 60	 lea	 rdi, QWORD PTR [rax+96]
  004b2	48 8b f1	 mov	 rsi, rcx
  004b5	b9 10 00 00 00	 mov	 ecx, 16
  004ba	f3 a4		 rep movsb

; 1433 : 
; 1434 :       stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);

  004bc	4c 8d 4c 24 34	 lea	 r9, QWORD PTR charstrings$4[rsp]
  004c1	41 b8 01 00 00
	00		 mov	 r8d, 1
  004c7	ba 11 00 00 00	 mov	 edx, 17
  004cc	48 8d 4c 24 60	 lea	 rcx, QWORD PTR topdict$8[rsp]
  004d1	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1435 :       stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);

  004d6	4c 8d 4c 24 4c	 lea	 r9, QWORD PTR cstype$7[rsp]
  004db	41 b8 01 00 00
	00		 mov	 r8d, 1
  004e1	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  004e6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR topdict$8[rsp]
  004eb	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1436 :       stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);

  004f0	4c 8d 4c 24 30	 lea	 r9, QWORD PTR fdarrayoff$3[rsp]
  004f5	41 b8 01 00 00
	00		 mov	 r8d, 1
  004fb	ba 24 01 00 00	 mov	 edx, 292		; 00000124H
  00500	48 8d 4c 24 60	 lea	 rcx, QWORD PTR topdict$8[rsp]
  00505	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1437 :       stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);

  0050a	4c 8d 4c 24 24	 lea	 r9, QWORD PTR fdselectoff$1[rsp]
  0050f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00515	ba 25 01 00 00	 mov	 edx, 293		; 00000125H
  0051a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR topdict$8[rsp]
  0051f	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1438 :       info->subrs = stbtt__get_subrs(b, topdict);

  00524	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR $T18[rsp]
  0052c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR topdict$8[rsp]
  00531	48 8b f8	 mov	 rdi, rax
  00534	48 8b f1	 mov	 rsi, rcx
  00537	b9 10 00 00 00	 mov	 ecx, 16
  0053c	f3 a4		 rep movsb
  0053e	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR $T19[rsp]
  00546	48 8d 4c 24 38	 lea	 rcx, QWORD PTR b$5[rsp]
  0054b	48 8b f8	 mov	 rdi, rax
  0054e	48 8b f1	 mov	 rsi, rcx
  00551	b9 10 00 00 00	 mov	 ecx, 16
  00556	f3 a4		 rep movsb
  00558	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR $T18[rsp]
  00560	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR $T19[rsp]
  00568	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  00570	e8 00 00 00 00	 call	 ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
  00575	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  0057d	48 8b f9	 mov	 rdi, rcx
  00580	48 8b f0	 mov	 rsi, rax
  00583	b9 10 00 00 00	 mov	 ecx, 16
  00588	f3 a4		 rep movsb
  0058a	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00592	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  0059a	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
  0059e	48 8b f1	 mov	 rsi, rcx
  005a1	b9 10 00 00 00	 mov	 ecx, 16
  005a6	f3 a4		 rep movsb

; 1439 : 
; 1440 :       // we only support Type 2 charstrings
; 1441 :       if (cstype != 2) return 0;

  005a8	83 7c 24 4c 02	 cmp	 DWORD PTR cstype$7[rsp], 2
  005ad	74 07		 je	 SHORT $LN15@stbtt_Init
  005af	33 c0		 xor	 eax, eax
  005b1	e9 03 03 00 00	 jmp	 $LN1@stbtt_Init
$LN15@stbtt_Init:

; 1442 :       if (charstrings == 0) return 0;

  005b6	83 7c 24 34 00	 cmp	 DWORD PTR charstrings$4[rsp], 0
  005bb	75 07		 jne	 SHORT $LN16@stbtt_Init
  005bd	33 c0		 xor	 eax, eax
  005bf	e9 f5 02 00 00	 jmp	 $LN1@stbtt_Init
$LN16@stbtt_Init:

; 1443 : 
; 1444 :       if (fdarrayoff) {

  005c4	83 7c 24 30 00	 cmp	 DWORD PTR fdarrayoff$3[rsp], 0
  005c9	0f 84 c0 00 00
	00		 je	 $LN17@stbtt_Init

; 1445 :          // looks like a CID font
; 1446 :          if (!fdselectoff) return 0;

  005cf	83 7c 24 24 00	 cmp	 DWORD PTR fdselectoff$1[rsp], 0
  005d4	75 07		 jne	 SHORT $LN18@stbtt_Init
  005d6	33 c0		 xor	 eax, eax
  005d8	e9 dc 02 00 00	 jmp	 $LN1@stbtt_Init
$LN18@stbtt_Init:

; 1447 :          stbtt__buf_seek(&b, fdarrayoff);

  005dd	8b 54 24 30	 mov	 edx, DWORD PTR fdarrayoff$3[rsp]
  005e1	48 8d 4c 24 38	 lea	 rcx, QWORD PTR b$5[rsp]
  005e6	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1448 :          info->fontdicts = stbtt__cff_get_index(&b);

  005eb	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  005f0	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  005f8	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  005fd	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00605	48 8b f9	 mov	 rdi, rcx
  00608	48 8b f0	 mov	 rsi, rax
  0060b	b9 10 00 00 00	 mov	 ecx, 16
  00610	f3 a4		 rep movsb
  00612	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0061a	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00622	48 8d b8 80 00
	00 00		 lea	 rdi, QWORD PTR [rax+128]
  00629	48 8b f1	 mov	 rsi, rcx
  0062c	b9 10 00 00 00	 mov	 ecx, 16
  00631	f3 a4		 rep movsb

; 1449 :          info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);

  00633	8b 44 24 24	 mov	 eax, DWORD PTR fdselectoff$1[rsp]
  00637	8b 4c 24 44	 mov	 ecx, DWORD PTR b$5[rsp+12]
  0063b	2b c8		 sub	 ecx, eax
  0063d	8b c1		 mov	 eax, ecx
  0063f	44 8b c8	 mov	 r9d, eax
  00642	44 8b 44 24 24	 mov	 r8d, DWORD PTR fdselectoff$1[rsp]
  00647	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  0064c	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR $T37[rsp]
  00654	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
  00659	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  00661	48 8b f9	 mov	 rdi, rcx
  00664	48 8b f0	 mov	 rsi, rax
  00667	b9 10 00 00 00	 mov	 ecx, 16
  0066c	f3 a4		 rep movsb
  0066e	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00676	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0067e	48 8d b8 90 00
	00 00		 lea	 rdi, QWORD PTR [rax+144]
  00685	48 8b f1	 mov	 rsi, rcx
  00688	b9 10 00 00 00	 mov	 ecx, 16
  0068d	f3 a4		 rep movsb
$LN17@stbtt_Init:

; 1450 :       }
; 1451 : 
; 1452 :       stbtt__buf_seek(&b, charstrings);

  0068f	8b 54 24 34	 mov	 edx, DWORD PTR charstrings$4[rsp]
  00693	48 8d 4c 24 38	 lea	 rcx, QWORD PTR b$5[rsp]
  00698	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1453 :       info->charstrings = stbtt__cff_get_index(&b);

  0069d	48 8d 54 24 38	 lea	 rdx, QWORD PTR b$5[rsp]
  006a2	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  006aa	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  006af	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  006b7	48 8b f9	 mov	 rdi, rcx
  006ba	48 8b f0	 mov	 rsi, rax
  006bd	b9 10 00 00 00	 mov	 ecx, 16
  006c2	f3 a4		 rep movsb
  006c4	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  006cc	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  006d4	48 8d 78 50	 lea	 rdi, QWORD PTR [rax+80]
  006d8	48 8b f1	 mov	 rsi, rcx
  006db	b9 10 00 00 00	 mov	 ecx, 16
  006e0	f3 a4		 rep movsb
$LN12@stbtt_Init:

; 1454 :    }
; 1455 : 
; 1456 :    t = stbtt__find_table(data, fontstart, "maxp");

  006e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41531
  006e9	8b 94 24 80 02
	00 00		 mov	 edx, DWORD PTR fontstart$[rsp]
  006f0	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  006f8	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  006fd	89 44 24 50	 mov	 DWORD PTR t$[rsp], eax

; 1457 :    if (t)

  00701	83 7c 24 50 00	 cmp	 DWORD PTR t$[rsp], 0
  00706	74 29		 je	 SHORT $LN19@stbtt_Init

; 1458 :       info->numGlyphs = ttUSHORT(data+t+4);

  00708	8b 44 24 50	 mov	 eax, DWORD PTR t$[rsp]
  0070c	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00714	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00719	48 8b c8	 mov	 rcx, rax
  0071c	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00721	0f b7 c0	 movzx	 eax, ax
  00724	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0072c	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  0072f	eb 0f		 jmp	 SHORT $LN20@stbtt_Init
$LN19@stbtt_Init:

; 1459 :    else
; 1460 :       info->numGlyphs = 0xffff;

  00731	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00739	c7 40 14 ff ff
	00 00		 mov	 DWORD PTR [rax+20], 65535 ; 0000ffffH
$LN20@stbtt_Init:

; 1461 : 
; 1462 :    info->svg = -1;

  00740	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00748	c7 40 34 ff ff
	ff ff		 mov	 DWORD PTR [rax+52], -1

; 1463 : 
; 1464 :    // find a cmap encoding table we understand *now* to avoid searching
; 1465 :    // later. (todo: could make this installable)
; 1466 :    // the same regardless of glyph.
; 1467 :    numTables = ttUSHORT(data + cmap + 2);

  0074f	8b 44 24 20	 mov	 eax, DWORD PTR cmap$[rsp]
  00753	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0075b	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00760	48 8b c8	 mov	 rcx, rax
  00763	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00768	0f b7 c0	 movzx	 eax, ax
  0076b	89 44 24 5c	 mov	 DWORD PTR numTables$[rsp], eax

; 1468 :    info->index_map = 0;

  0076f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00777	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 1469 :    for (i=0; i < numTables; ++i) {

  0077e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00786	eb 0a		 jmp	 SHORT $LN4@stbtt_Init
$LN2@stbtt_Init:
  00788	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0078c	ff c0		 inc	 eax
  0078e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Init:
  00792	8b 44 24 5c	 mov	 eax, DWORD PTR numTables$[rsp]
  00796	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0079a	0f 8d d3 00 00
	00		 jge	 $LN3@stbtt_Init

; 1470 :       stbtt_uint32 encoding_record = cmap + 4 + 8 * i;

  007a0	8b 44 24 20	 mov	 eax, DWORD PTR cmap$[rsp]
  007a4	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  007a8	8d 44 c8 04	 lea	 eax, DWORD PTR [rax+rcx*8+4]
  007ac	89 44 24 2c	 mov	 DWORD PTR encoding_record$2[rsp], eax

; 1471 :       // find an encoding we understand:
; 1472 :       switch(ttUSHORT(data+encoding_record)) {

  007b0	8b 44 24 2c	 mov	 eax, DWORD PTR encoding_record$2[rsp]
  007b4	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  007bc	48 03 c8	 add	 rcx, rax
  007bf	48 8b c1	 mov	 rax, rcx
  007c2	48 8b c8	 mov	 rcx, rax
  007c5	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  007ca	0f b7 c0	 movzx	 eax, ax
  007cd	89 44 24 54	 mov	 DWORD PTR tv321[rsp], eax
  007d1	83 7c 24 54 00	 cmp	 DWORD PTR tv321[rsp], 0
  007d6	74 6a		 je	 SHORT $LN24@stbtt_Init
  007d8	83 7c 24 54 03	 cmp	 DWORD PTR tv321[rsp], 3
  007dd	74 05		 je	 SHORT $LN21@stbtt_Init
  007df	e9 8a 00 00 00	 jmp	 $LN5@stbtt_Init
$LN21@stbtt_Init:

; 1473 :          case STBTT_PLATFORM_ID_MICROSOFT:
; 1474 :             switch (ttUSHORT(data+encoding_record+2)) {

  007e4	8b 44 24 2c	 mov	 eax, DWORD PTR encoding_record$2[rsp]
  007e8	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  007f0	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  007f5	48 8b c8	 mov	 rcx, rax
  007f8	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  007fd	0f b7 c0	 movzx	 eax, ax
  00800	89 44 24 58	 mov	 DWORD PTR tv328[rsp], eax
  00804	83 7c 24 58 01	 cmp	 DWORD PTR tv328[rsp], 1
  00809	74 09		 je	 SHORT $LN22@stbtt_Init
  0080b	83 7c 24 58 0a	 cmp	 DWORD PTR tv328[rsp], 10
  00810	74 02		 je	 SHORT $LN23@stbtt_Init
  00812	eb 2c		 jmp	 SHORT $LN7@stbtt_Init
$LN22@stbtt_Init:
$LN23@stbtt_Init:

; 1475 :                case STBTT_MS_EID_UNICODE_BMP:
; 1476 :                case STBTT_MS_EID_UNICODE_FULL:
; 1477 :                   // MS/Unicode
; 1478 :                   info->index_map = cmap + ttULONG(data+encoding_record+4);

  00814	8b 44 24 2c	 mov	 eax, DWORD PTR encoding_record$2[rsp]
  00818	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00820	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00825	48 8b c8	 mov	 rcx, rax
  00828	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  0082d	8b 4c 24 20	 mov	 ecx, DWORD PTR cmap$[rsp]
  00831	03 c8		 add	 ecx, eax
  00833	8b c1		 mov	 eax, ecx
  00835	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0083d	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN7@stbtt_Init:

; 1479 :                   break;
; 1480 :             }
; 1481 :             break;

  00840	eb 2c		 jmp	 SHORT $LN5@stbtt_Init
$LN24@stbtt_Init:

; 1482 :         case STBTT_PLATFORM_ID_UNICODE:
; 1483 :             // Mac/iOS has these
; 1484 :             // all the encodingIDs are unicode, so we don't bother to check it
; 1485 :             info->index_map = cmap + ttULONG(data+encoding_record+4);

  00842	8b 44 24 2c	 mov	 eax, DWORD PTR encoding_record$2[rsp]
  00846	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0084e	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00853	48 8b c8	 mov	 rcx, rax
  00856	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  0085b	8b 4c 24 20	 mov	 ecx, DWORD PTR cmap$[rsp]
  0085f	03 c8		 add	 ecx, eax
  00861	8b c1		 mov	 eax, ecx
  00863	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0086b	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN5@stbtt_Init:

; 1486 :             break;
; 1487 :       }
; 1488 :    }

  0086e	e9 15 ff ff ff	 jmp	 $LN2@stbtt_Init
$LN3@stbtt_Init:

; 1489 :    if (info->index_map == 0)

  00873	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0087b	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0087f	75 04		 jne	 SHORT $LN25@stbtt_Init

; 1490 :       return 0;

  00881	33 c0		 xor	 eax, eax
  00883	eb 34		 jmp	 SHORT $LN1@stbtt_Init
$LN25@stbtt_Init:

; 1491 : 
; 1492 :    info->indexToLocFormat = ttUSHORT(data+info->head + 50);

  00885	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  0088d	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00891	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00899	48 8d 44 01 32	 lea	 rax, QWORD PTR [rcx+rax+50]
  0089e	48 8b c8	 mov	 rcx, rax
  008a1	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  008a6	0f b7 c0	 movzx	 eax, ax
  008a9	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  008b1	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 1493 :    return 1;

  008b4	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_Init:

; 1494 : }

  008b9	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  008c0	5f		 pop	 rdi
  008c1	5e		 pop	 rsi
  008c2	c3		 ret	 0
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ENDP ; stbtt_InitFont_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
t$ = 32
offset$1 = 36
info$ = 64
?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z PROC		; stbtt__get_svg

; 1369 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1370 :    stbtt_uint32 t;
; 1371 :    if (info->svg < 0) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0000e	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  00012	7d 68		 jge	 SHORT $LN2@stbtt__get

; 1372 :       t = stbtt__find_table(info->data, info->fontstart, "SVG ");

  00014	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG41468
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00020	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00028	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0002c	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00031	89 44 24 20	 mov	 DWORD PTR t$[rsp], eax

; 1373 :       if (t) {

  00035	83 7c 24 20 00	 cmp	 DWORD PTR t$[rsp], 0
  0003a	74 34		 je	 SHORT $LN3@stbtt__get

; 1374 :          stbtt_uint32 offset = ttULONG(info->data + t + 2);

  0003c	8b 44 24 20	 mov	 eax, DWORD PTR t$[rsp]
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00045	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00049	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00056	89 44 24 24	 mov	 DWORD PTR offset$1[rsp], eax

; 1375 :          info->svg = t + offset;

  0005a	8b 44 24 24	 mov	 eax, DWORD PTR offset$1[rsp]
  0005e	8b 4c 24 20	 mov	 ecx, DWORD PTR t$[rsp]
  00062	03 c8		 add	 ecx, eax
  00064	8b c1		 mov	 eax, ecx
  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0006b	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1376 :       } else {

  0006e	eb 0c		 jmp	 SHORT $LN4@stbtt__get
$LN3@stbtt__get:

; 1377 :          info->svg = 0;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00075	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0
$LN4@stbtt__get:
$LN2@stbtt__get:

; 1378 :       }
; 1379 :    }
; 1380 :    return info->svg;

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00081	8b 40 34	 mov	 eax, DWORD PTR [rax+52]

; 1381 : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z ENDP		; stbtt__get_svg
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
subrsoff$ = 32
private_loc$ = 40
$T1 = 48
$T2 = 64
pdict$ = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
$T7 = 160
$T8 = 176
$T9 = 224
cff$ = 232
fontdict$ = 240
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z PROC		; stbtt__get_subrs

; 1355 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1356 :    stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR subrsoff$[rsp], 0
  00020	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR private_loc$[rsp], 0
  00028	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR private_loc$[rsp+4], 0

; 1357 :    stbtt__buf pdict;
; 1358 :    stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);

  00030	4c 8d 4c 24 28	 lea	 r9, QWORD PTR private_loc$[rsp]
  00035	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003b	ba 12 00 00 00	 mov	 edx, 18
  00040	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fontdict$[rsp]
  00048	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1359 :    if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	48 6b c0 01	 imul	 rax, rax, 1
  00056	83 7c 04 28 00	 cmp	 DWORD PTR private_loc$[rsp+rax], 0
  0005b	74 10		 je	 SHORT $LN3@stbtt__get
  0005d	b8 04 00 00 00	 mov	 eax, 4
  00062	48 6b c0 00	 imul	 rax, rax, 0
  00066	83 7c 04 28 00	 cmp	 DWORD PTR private_loc$[rsp+rax], 0
  0006b	75 48		 jne	 SHORT $LN2@stbtt__get
$LN3@stbtt__get:
  0006d	45 33 c0	 xor	 r8d, r8d
  00070	33 d2		 xor	 edx, edx
  00072	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  0007f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00084	48 8b f9	 mov	 rdi, rcx
  00087	48 8b f0	 mov	 rsi, rax
  0008a	b9 10 00 00 00	 mov	 ecx, 16
  0008f	f3 a4		 rep movsb
  00091	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00096	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR $T9[rsp]
  0009e	48 8b f0	 mov	 rsi, rax
  000a1	b9 10 00 00 00	 mov	 ecx, 16
  000a6	f3 a4		 rep movsb
  000a8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T9[rsp]
  000b0	e9 26 01 00 00	 jmp	 $LN1@stbtt__get
$LN2@stbtt__get:

; 1360 :    pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	48 6b c0 00	 imul	 rax, rax, 0
  000be	b9 04 00 00 00	 mov	 ecx, 4
  000c3	48 6b c9 01	 imul	 rcx, rcx, 1
  000c7	44 8b 4c 04 28	 mov	 r9d, DWORD PTR private_loc$[rsp+rax]
  000cc	44 8b 44 0c 28	 mov	 r8d, DWORD PTR private_loc$[rsp+rcx]
  000d1	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR cff$[rsp]
  000d9	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  000e1	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
  000e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  000eb	48 8b f9	 mov	 rdi, rcx
  000ee	48 8b f0	 mov	 rsi, rax
  000f1	b9 10 00 00 00	 mov	 ecx, 16
  000f6	f3 a4		 rep movsb
  000f8	48 8d 44 24 50	 lea	 rax, QWORD PTR pdict$[rsp]
  000fd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00102	48 8b f8	 mov	 rdi, rax
  00105	48 8b f1	 mov	 rsi, rcx
  00108	b9 10 00 00 00	 mov	 ecx, 16
  0010d	f3 a4		 rep movsb

; 1361 :    stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);

  0010f	4c 8d 4c 24 20	 lea	 r9, QWORD PTR subrsoff$[rsp]
  00114	41 b8 01 00 00
	00		 mov	 r8d, 1
  0011a	ba 13 00 00 00	 mov	 edx, 19
  0011f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pdict$[rsp]
  00124	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ; stbtt__dict_get_ints

; 1362 :    if (!subrsoff) return stbtt__new_buf(NULL, 0);

  00129	83 7c 24 20 00	 cmp	 DWORD PTR subrsoff$[rsp], 0
  0012e	75 45		 jne	 SHORT $LN4@stbtt__get
  00130	45 33 c0	 xor	 r8d, r8d
  00133	33 d2		 xor	 edx, edx
  00135	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0013d	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  00142	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  00147	48 8b f9	 mov	 rdi, rcx
  0014a	48 8b f0	 mov	 rsi, rax
  0014d	b9 10 00 00 00	 mov	 ecx, 16
  00152	f3 a4		 rep movsb
  00154	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00159	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR $T9[rsp]
  00161	48 8b f0	 mov	 rsi, rax
  00164	b9 10 00 00 00	 mov	 ecx, 16
  00169	f3 a4		 rep movsb
  0016b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T9[rsp]
  00173	eb 66		 jmp	 SHORT $LN1@stbtt__get
$LN4@stbtt__get:

; 1363 :    stbtt__buf_seek(&cff, private_loc[1]+subrsoff);

  00175	b8 04 00 00 00	 mov	 eax, 4
  0017a	48 6b c0 01	 imul	 rax, rax, 1
  0017e	8b 44 04 28	 mov	 eax, DWORD PTR private_loc$[rsp+rax]
  00182	03 44 24 20	 add	 eax, DWORD PTR subrsoff$[rsp]
  00186	8b d0		 mov	 edx, eax
  00188	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR cff$[rsp]
  00190	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1364 :    return stbtt__cff_get_index(&cff);

  00195	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR cff$[rsp]
  0019d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  001a5	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  001aa	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  001af	48 8b f9	 mov	 rdi, rcx
  001b2	48 8b f0	 mov	 rsi, rax
  001b5	b9 10 00 00 00	 mov	 ecx, 16
  001ba	f3 a4		 rep movsb
  001bc	48 8d 44 24 70	 lea	 rax, QWORD PTR $T4[rsp]
  001c1	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR $T9[rsp]
  001c9	48 8b f0	 mov	 rsi, rax
  001cc	b9 10 00 00 00	 mov	 ecx, 16
  001d1	f3 a4		 rep movsb
  001d3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T9[rsp]
$LN1@stbtt__get:

; 1365 : }

  001db	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001e2	5f		 pop	 rdi
  001e3	5e		 pop	 rsi
  001e4	c3		 ret	 0
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ENDP		; stbtt__get_subrs
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
font_collection$ = 48
?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z PROC	; stbtt_GetNumberOfFonts_internal

; 1339 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1340 :    // if it's just a font, there's only one valid font
; 1341 :    if (stbtt__isfont(font_collection))

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR font_collection$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbtt__isfont@@YAHPEAE@Z ; stbtt__isfont
  00013	85 c0		 test	 eax, eax
  00015	74 0a		 je	 SHORT $LN2@stbtt_GetN

; 1342 :       return 1;

  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	e9 f5 00 00 00	 jmp	 $LN1@stbtt_GetN
$LN2@stbtt_GetN:

; 1343 : 
; 1344 :    // check if it's a TTC
; 1345 :    if (stbtt_tag(font_collection, "ttcf")) {

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	48 6b c0 00	 imul	 rax, rax, 0
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR font_collection$[rsp]
  0002f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00033	b9 01 00 00 00	 mov	 ecx, 1
  00038	48 6b c9 00	 imul	 rcx, rcx, 0
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41442
  00043	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00047	3b c1		 cmp	 eax, ecx
  00049	0f 85 c5 00 00
	00		 jne	 $LN3@stbtt_GetN
  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	48 6b c0 01	 imul	 rax, rax, 1
  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR font_collection$[rsp]
  0005d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	48 6b c9 01	 imul	 rcx, rcx, 1
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41443
  00071	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00075	3b c1		 cmp	 eax, ecx
  00077	0f 85 97 00 00
	00		 jne	 $LN3@stbtt_GetN
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 02	 imul	 rax, rax, 2
  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR font_collection$[rsp]
  0008b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008f	b9 01 00 00 00	 mov	 ecx, 1
  00094	48 6b c9 02	 imul	 rcx, rcx, 2
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41444
  0009f	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000a3	3b c1		 cmp	 eax, ecx
  000a5	75 6d		 jne	 SHORT $LN3@stbtt_GetN
  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	48 6b c0 03	 imul	 rax, rax, 3
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR font_collection$[rsp]
  000b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	48 6b c9 03	 imul	 rcx, rcx, 3
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41445
  000c9	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000cd	3b c1		 cmp	 eax, ecx
  000cf	75 43		 jne	 SHORT $LN3@stbtt_GetN

; 1346 :       // version 1?
; 1347 :       if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {

  000d1	48 8b 44 24 30	 mov	 rax, QWORD PTR font_collection$[rsp]
  000d6	48 83 c0 04	 add	 rax, 4
  000da	48 8b c8	 mov	 rcx, rax
  000dd	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  000e2	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  000e7	74 18		 je	 SHORT $LN5@stbtt_GetN
  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR font_collection$[rsp]
  000ee	48 83 c0 04	 add	 rax, 4
  000f2	48 8b c8	 mov	 rcx, rax
  000f5	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  000fa	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  000ff	75 13		 jne	 SHORT $LN4@stbtt_GetN
$LN5@stbtt_GetN:

; 1348 :          return ttLONG(font_collection+8);

  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR font_collection$[rsp]
  00106	48 83 c0 08	 add	 rax, 8
  0010a	48 8b c8	 mov	 rcx, rax
  0010d	e8 00 00 00 00	 call	 ?ttLONG@@YAHPEAE@Z	; ttLONG
  00112	eb 02		 jmp	 SHORT $LN1@stbtt_GetN
$LN4@stbtt_GetN:
$LN3@stbtt_GetN:

; 1349 :       }
; 1350 :    }
; 1351 :    return 0;

  00114	33 c0		 xor	 eax, eax
$LN1@stbtt_GetN:

; 1352 : }

  00116	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011a	c3		 ret	 0
?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z ENDP	; stbtt_GetNumberOfFonts_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv68 = 32
n$1 = 36
font_collection$ = 64
index$ = 72
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z PROC	; stbtt_GetFontOffsetForIndex_internal

; 1320 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1321 :    // if it's just a font, there's only one valid index
; 1322 :    if (stbtt__isfont(font_collection))

  0000d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  00012	e8 00 00 00 00	 call	 ?stbtt__isfont@@YAHPEAE@Z ; stbtt__isfont
  00017	85 c0		 test	 eax, eax
  00019	74 22		 je	 SHORT $LN2@stbtt_GetF

; 1323 :       return index == 0 ? 0 : -1;

  0001b	83 7c 24 48 00	 cmp	 DWORD PTR index$[rsp], 0
  00020	75 0a		 jne	 SHORT $LN8@stbtt_GetF
  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  0002a	eb 08		 jmp	 SHORT $LN9@stbtt_GetF
$LN8@stbtt_GetF:
  0002c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN9@stbtt_GetF:
  00034	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]
  00038	e9 2c 01 00 00	 jmp	 $LN1@stbtt_GetF
$LN2@stbtt_GetF:

; 1324 : 
; 1325 :    // check if it's a TTC
; 1326 :    if (stbtt_tag(font_collection, "ttcf")) {

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	48 6b c0 00	 imul	 rax, rax, 0
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  0004b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004f	b9 01 00 00 00	 mov	 ecx, 1
  00054	48 6b c9 00	 imul	 rcx, rcx, 0
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41430
  0005f	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00063	3b c1		 cmp	 eax, ecx
  00065	0f 85 f9 00 00
	00		 jne	 $LN3@stbtt_GetF
  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	48 6b c0 01	 imul	 rax, rax, 1
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  00079	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007d	b9 01 00 00 00	 mov	 ecx, 1
  00082	48 6b c9 01	 imul	 rcx, rcx, 1
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41431
  0008d	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00091	3b c1		 cmp	 eax, ecx
  00093	0f 85 cb 00 00
	00		 jne	 $LN3@stbtt_GetF
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 02	 imul	 rax, rax, 2
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  000a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	48 6b c9 02	 imul	 rcx, rcx, 2
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41432
  000bb	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000bf	3b c1		 cmp	 eax, ecx
  000c1	0f 85 9d 00 00
	00		 jne	 $LN3@stbtt_GetF
  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	48 6b c0 03	 imul	 rax, rax, 3
  000d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  000d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d9	b9 01 00 00 00	 mov	 ecx, 1
  000de	48 6b c9 03	 imul	 rcx, rcx, 3
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41433
  000e9	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000ed	3b c1		 cmp	 eax, ecx
  000ef	75 73		 jne	 SHORT $LN3@stbtt_GetF

; 1327 :       // version 1?
; 1328 :       if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {

  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR font_collection$[rsp]
  000f6	48 83 c0 04	 add	 rax, 4
  000fa	48 8b c8	 mov	 rcx, rax
  000fd	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00102	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00107	74 18		 je	 SHORT $LN5@stbtt_GetF
  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR font_collection$[rsp]
  0010e	48 83 c0 04	 add	 rax, 4
  00112	48 8b c8	 mov	 rcx, rax
  00115	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  0011a	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  0011f	75 43		 jne	 SHORT $LN4@stbtt_GetF
$LN5@stbtt_GetF:

; 1329 :          stbtt_int32 n = ttLONG(font_collection+8);

  00121	48 8b 44 24 40	 mov	 rax, QWORD PTR font_collection$[rsp]
  00126	48 83 c0 08	 add	 rax, 8
  0012a	48 8b c8	 mov	 rcx, rax
  0012d	e8 00 00 00 00	 call	 ?ttLONG@@YAHPEAE@Z	; ttLONG
  00132	89 44 24 24	 mov	 DWORD PTR n$1[rsp], eax

; 1330 :          if (index >= n)

  00136	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  0013a	39 44 24 48	 cmp	 DWORD PTR index$[rsp], eax
  0013e	7c 07		 jl	 SHORT $LN6@stbtt_GetF

; 1331 :             return -1;

  00140	b8 ff ff ff ff	 mov	 eax, -1
  00145	eb 22		 jmp	 SHORT $LN1@stbtt_GetF
$LN6@stbtt_GetF:

; 1332 :          return ttULONG(font_collection+12+index*4);

  00147	8b 44 24 48	 mov	 eax, DWORD PTR index$[rsp]
  0014b	c1 e0 02	 shl	 eax, 2
  0014e	48 98		 cdqe
  00150	48 8b 4c 24 40	 mov	 rcx, QWORD PTR font_collection$[rsp]
  00155	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00162	eb 05		 jmp	 SHORT $LN1@stbtt_GetF
$LN4@stbtt_GetF:
$LN3@stbtt_GetF:

; 1333 :       }
; 1334 :    }
; 1335 :    return -1;

  00164	b8 ff ff ff ff	 mov	 eax, -1
$LN1@stbtt_GetF:

; 1336 : }

  00169	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016d	c3		 ret	 0
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ENDP	; stbtt_GetFontOffsetForIndex_internal
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
loc$1 = 32
i$ = 36
num_tables$ = 40
tabledir$ = 44
data$ = 64
fontstart$ = 72
tag$ = 80
?stbtt__find_table@@YAIPEAEIPEBD@Z PROC			; stbtt__find_table

; 1307 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1308 :    stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);

  00012	8b 44 24 48	 mov	 eax, DWORD PTR fontstart$[rsp]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0001b	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00020	48 8b c8	 mov	 rcx, rax
  00023	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00028	0f b7 c0	 movzx	 eax, ax
  0002b	89 44 24 28	 mov	 DWORD PTR num_tables$[rsp], eax

; 1309 :    stbtt_uint32 tabledir = fontstart + 12;

  0002f	8b 44 24 48	 mov	 eax, DWORD PTR fontstart$[rsp]
  00033	83 c0 0c	 add	 eax, 12
  00036	89 44 24 2c	 mov	 DWORD PTR tabledir$[rsp], eax

; 1310 :    stbtt_int32 i;
; 1311 :    for (i=0; i < num_tables; ++i) {

  0003a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00042	eb 0a		 jmp	 SHORT $LN4@stbtt__fin
$LN2@stbtt__fin:
  00044	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00048	ff c0		 inc	 eax
  0004a	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__fin:
  0004e	8b 44 24 28	 mov	 eax, DWORD PTR num_tables$[rsp]
  00052	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00056	0f 8d fa 00 00
	00		 jge	 $LN3@stbtt__fin

; 1312 :       stbtt_uint32 loc = tabledir + 16*i;

  0005c	6b 44 24 24 10	 imul	 eax, DWORD PTR i$[rsp], 16
  00061	8b 4c 24 2c	 mov	 ecx, DWORD PTR tabledir$[rsp]
  00065	03 c8		 add	 ecx, eax
  00067	8b c1		 mov	 eax, ecx
  00069	89 44 24 20	 mov	 DWORD PTR loc$1[rsp], eax

; 1313 :       if (stbtt_tag(data+loc+0, tag))

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	48 6b c9 00	 imul	 rcx, rcx, 0
  00085	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	48 6b c9 00	 imul	 rcx, rcx, 0
  00092	48 8b 54 24 50	 mov	 rdx, QWORD PTR tag$[rsp]
  00097	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0009b	3b c1		 cmp	 eax, ecx
  0009d	0f 85 ae 00 00
	00		 jne	 $LN5@stbtt__fin
  000a3	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	b9 01 00 00 00	 mov	 ecx, 1
  000b7	48 6b c9 01	 imul	 rcx, rcx, 1
  000bb	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000bf	b9 01 00 00 00	 mov	 ecx, 1
  000c4	48 6b c9 01	 imul	 rcx, rcx, 1
  000c8	48 8b 54 24 50	 mov	 rdx, QWORD PTR tag$[rsp]
  000cd	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000d1	3b c1		 cmp	 eax, ecx
  000d3	75 7c		 jne	 SHORT $LN5@stbtt__fin
  000d5	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	b9 01 00 00 00	 mov	 ecx, 1
  000e9	48 6b c9 02	 imul	 rcx, rcx, 2
  000ed	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	48 6b c9 02	 imul	 rcx, rcx, 2
  000fa	48 8b 54 24 50	 mov	 rdx, QWORD PTR tag$[rsp]
  000ff	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00103	3b c1		 cmp	 eax, ecx
  00105	75 4a		 jne	 SHORT $LN5@stbtt__fin
  00107	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0010b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00110	48 03 c8	 add	 rcx, rax
  00113	48 8b c1	 mov	 rax, rcx
  00116	b9 01 00 00 00	 mov	 ecx, 1
  0011b	48 6b c9 03	 imul	 rcx, rcx, 3
  0011f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	48 6b c9 03	 imul	 rcx, rcx, 3
  0012c	48 8b 54 24 50	 mov	 rdx, QWORD PTR tag$[rsp]
  00131	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00135	3b c1		 cmp	 eax, ecx
  00137	75 18		 jne	 SHORT $LN5@stbtt__fin

; 1314 :          return ttULONG(data+loc+8);

  00139	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00142	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00147	48 8b c8	 mov	 rcx, rax
  0014a	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  0014f	eb 07		 jmp	 SHORT $LN1@stbtt__fin
$LN5@stbtt__fin:

; 1315 :    }

  00151	e9 ee fe ff ff	 jmp	 $LN2@stbtt__fin
$LN3@stbtt__fin:

; 1316 :    return 0;

  00156	33 c0		 xor	 eax, eax
$LN1@stbtt__fin:

; 1317 : }

  00158	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015c	c3		 ret	 0
?stbtt__find_table@@YAIPEAEIPEBD@Z ENDP			; stbtt__find_table
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
font$ = 8
?stbtt__isfont@@YAHPEAE@Z PROC				; stbtt__isfont

; 1295 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1296 :    // check the version number
; 1297 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 00	 imul	 rax, rax, 0
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00013	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00017	83 f8 31	 cmp	 eax, 49			; 00000031H
  0001a	75 4c		 jne	 SHORT $LN2@stbtt__isf
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	48 6b c0 01	 imul	 rax, rax, 1
  00025	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  0002a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002e	85 c0		 test	 eax, eax
  00030	75 36		 jne	 SHORT $LN2@stbtt__isf
  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	48 6b c0 02	 imul	 rax, rax, 2
  0003b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00040	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00044	85 c0		 test	 eax, eax
  00046	75 20		 jne	 SHORT $LN2@stbtt__isf
  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	48 6b c0 03	 imul	 rax, rax, 3
  00051	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00056	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005a	85 c0		 test	 eax, eax
  0005c	75 0a		 jne	 SHORT $LN2@stbtt__isf
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	e9 84 02 00 00	 jmp	 $LN1@stbtt__isf
$LN2@stbtt__isf:

; 1298 :    if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	48 6b c0 00	 imul	 rax, rax, 0
  00071	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00076	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	48 6b c9 00	 imul	 rcx, rcx, 0
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41395
  0008a	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0008e	3b c1		 cmp	 eax, ecx
  00090	0f 85 88 00 00
	00		 jne	 $LN3@stbtt__isf
  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	48 6b c0 01	 imul	 rax, rax, 1
  0009f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  000a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	48 6b c9 01	 imul	 rcx, rcx, 1
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41396
  000b8	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000bc	3b c1		 cmp	 eax, ecx
  000be	75 5e		 jne	 SHORT $LN3@stbtt__isf
  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	48 6b c0 02	 imul	 rax, rax, 2
  000c9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  000ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	48 6b c9 02	 imul	 rcx, rcx, 2
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41397
  000e2	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000e6	3b c1		 cmp	 eax, ecx
  000e8	75 34		 jne	 SHORT $LN3@stbtt__isf
  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	48 6b c0 03	 imul	 rax, rax, 3
  000f3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  000f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fc	b9 01 00 00 00	 mov	 ecx, 1
  00101	48 6b c9 03	 imul	 rcx, rcx, 3
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41398
  0010c	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00110	3b c1		 cmp	 eax, ecx
  00112	75 0a		 jne	 SHORT $LN3@stbtt__isf
  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	e9 ce 01 00 00	 jmp	 $LN1@stbtt__isf
$LN3@stbtt__isf:

; 1299 :    if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	48 6b c0 00	 imul	 rax, rax, 0
  00127	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  0012c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00130	b9 01 00 00 00	 mov	 ecx, 1
  00135	48 6b c9 00	 imul	 rcx, rcx, 0
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41400
  00140	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00144	3b c1		 cmp	 eax, ecx
  00146	0f 85 88 00 00
	00		 jne	 $LN4@stbtt__isf
  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	48 6b c0 01	 imul	 rax, rax, 1
  00155	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  0015a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015e	b9 01 00 00 00	 mov	 ecx, 1
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41401
  0016e	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00172	3b c1		 cmp	 eax, ecx
  00174	75 5e		 jne	 SHORT $LN4@stbtt__isf
  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 02	 imul	 rax, rax, 2
  0017f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00184	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00188	b9 01 00 00 00	 mov	 ecx, 1
  0018d	48 6b c9 02	 imul	 rcx, rcx, 2
  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41402
  00198	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0019c	3b c1		 cmp	 eax, ecx
  0019e	75 34		 jne	 SHORT $LN4@stbtt__isf
  001a0	b8 01 00 00 00	 mov	 eax, 1
  001a5	48 6b c0 03	 imul	 rax, rax, 3
  001a9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  001ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b2	b9 01 00 00 00	 mov	 ecx, 1
  001b7	48 6b c9 03	 imul	 rcx, rcx, 3
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41403
  001c2	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  001c6	3b c1		 cmp	 eax, ecx
  001c8	75 0a		 jne	 SHORT $LN4@stbtt__isf
  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	e9 18 01 00 00	 jmp	 $LN1@stbtt__isf
$LN4@stbtt__isf:

; 1300 :    if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0

  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	48 6b c0 00	 imul	 rax, rax, 0
  001dd	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  001e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e6	85 c0		 test	 eax, eax
  001e8	75 4d		 jne	 SHORT $LN5@stbtt__isf
  001ea	b8 01 00 00 00	 mov	 eax, 1
  001ef	48 6b c0 01	 imul	 rax, rax, 1
  001f3	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  001f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fc	83 f8 01	 cmp	 eax, 1
  001ff	75 36		 jne	 SHORT $LN5@stbtt__isf
  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	48 6b c0 02	 imul	 rax, rax, 2
  0020a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  0020f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00213	85 c0		 test	 eax, eax
  00215	75 20		 jne	 SHORT $LN5@stbtt__isf
  00217	b8 01 00 00 00	 mov	 eax, 1
  0021c	48 6b c0 03	 imul	 rax, rax, 3
  00220	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00225	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00229	85 c0		 test	 eax, eax
  0022b	75 0a		 jne	 SHORT $LN5@stbtt__isf
  0022d	b8 01 00 00 00	 mov	 eax, 1
  00232	e9 b5 00 00 00	 jmp	 $LN1@stbtt__isf
$LN5@stbtt__isf:

; 1301 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

  00237	b8 01 00 00 00	 mov	 eax, 1
  0023c	48 6b c0 00	 imul	 rax, rax, 0
  00240	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00245	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00249	b9 01 00 00 00	 mov	 ecx, 1
  0024e	48 6b c9 00	 imul	 rcx, rcx, 0
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41406
  00259	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0025d	3b c1		 cmp	 eax, ecx
  0025f	0f 85 85 00 00
	00		 jne	 $LN6@stbtt__isf
  00265	b8 01 00 00 00	 mov	 eax, 1
  0026a	48 6b c0 01	 imul	 rax, rax, 1
  0026e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  00273	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00277	b9 01 00 00 00	 mov	 ecx, 1
  0027c	48 6b c9 01	 imul	 rcx, rcx, 1
  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41407
  00287	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0028b	3b c1		 cmp	 eax, ecx
  0028d	75 5b		 jne	 SHORT $LN6@stbtt__isf
  0028f	b8 01 00 00 00	 mov	 eax, 1
  00294	48 6b c0 02	 imul	 rax, rax, 2
  00298	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  0029d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a1	b9 01 00 00 00	 mov	 ecx, 1
  002a6	48 6b c9 02	 imul	 rcx, rcx, 2
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41408
  002b1	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  002b5	3b c1		 cmp	 eax, ecx
  002b7	75 31		 jne	 SHORT $LN6@stbtt__isf
  002b9	b8 01 00 00 00	 mov	 eax, 1
  002be	48 6b c0 03	 imul	 rax, rax, 3
  002c2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR font$[rsp]
  002c7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002cb	b9 01 00 00 00	 mov	 ecx, 1
  002d0	48 6b c9 03	 imul	 rcx, rcx, 3
  002d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41409
  002db	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  002df	3b c1		 cmp	 eax, ecx
  002e1	75 07		 jne	 SHORT $LN6@stbtt__isf
  002e3	b8 01 00 00 00	 mov	 eax, 1
  002e8	eb 02		 jmp	 SHORT $LN1@stbtt__isf
$LN6@stbtt__isf:

; 1302 :    return 0;

  002ea	33 c0		 xor	 eax, eax
$LN1@stbtt__isf:

; 1303 : }

  002ec	c3		 ret	 0
?stbtt__isfont@@YAHPEAE@Z ENDP				; stbtt__isfont
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttLONG@@YAHPEAE@Z PROC					; ttLONG

; 1289 : static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 00	 imul	 rax, rax, 0
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  00013	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00017	c1 e0 18	 shl	 eax, 24
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	48 6b c9 01	 imul	 rcx, rcx, 1
  00023	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00028	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0002c	c1 e1 10	 shl	 ecx, 16
  0002f	03 c1		 add	 eax, ecx
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	48 6b c9 02	 imul	 rcx, rcx, 2
  0003a	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  0003f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00043	c1 e1 08	 shl	 ecx, 8
  00046	03 c1		 add	 eax, ecx
  00048	b9 01 00 00 00	 mov	 ecx, 1
  0004d	48 6b c9 03	 imul	 rcx, rcx, 3
  00051	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00056	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005a	03 c1		 add	 eax, ecx
  0005c	c3		 ret	 0
?ttLONG@@YAHPEAE@Z ENDP					; ttLONG
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttULONG@@YAIPEAE@Z PROC				; ttULONG

; 1288 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 00	 imul	 rax, rax, 0
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  00013	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00017	c1 e0 18	 shl	 eax, 24
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	48 6b c9 01	 imul	 rcx, rcx, 1
  00023	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00028	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0002c	c1 e1 10	 shl	 ecx, 16
  0002f	03 c1		 add	 eax, ecx
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	48 6b c9 02	 imul	 rcx, rcx, 2
  0003a	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  0003f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00043	c1 e1 08	 shl	 ecx, 8
  00046	03 c1		 add	 eax, ecx
  00048	b9 01 00 00 00	 mov	 ecx, 1
  0004d	48 6b c9 03	 imul	 rcx, rcx, 3
  00051	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00056	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005a	03 c1		 add	 eax, ecx
  0005c	c3		 ret	 0
?ttULONG@@YAIPEAE@Z ENDP				; ttULONG
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttSHORT@@YAFPEAE@Z PROC				; ttSHORT

; 1287 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 00	 imul	 rax, rax, 0
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  00013	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00017	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0001d	b9 01 00 00 00	 mov	 ecx, 1
  00022	48 6b c9 01	 imul	 rcx, rcx, 1
  00026	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  0002b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0002f	03 c1		 add	 eax, ecx
  00031	c3		 ret	 0
?ttSHORT@@YAFPEAE@Z ENDP				; ttSHORT
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttUSHORT@@YAGPEAE@Z PROC				; ttUSHORT

; 1286 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 00	 imul	 rax, rax, 0
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  00013	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00017	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0001d	b9 01 00 00 00	 mov	 ecx, 1
  00022	48 6b c9 01	 imul	 rcx, rcx, 1
  00026	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  0002b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0002f	03 c1		 add	 eax, ecx
  00031	c3		 ret	 0
?ttUSHORT@@YAGPEAE@Z ENDP				; ttUSHORT
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
offsize$ = 32
count$ = 36
start$ = 40
end$ = 44
$T1 = 48
$T2 = 64
$T3 = 112
b$ = 120
i$ = 128
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z PROC	; stbtt__cff_index_get

; 1261 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1262 :    int count, offsize, start, end;
; 1263 :    stbtt__buf_seek(&b, 0);

  00015	33 d2		 xor	 edx, edx
  00017	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1264 :    count = stbtt__buf_get16(&b);

  00021	ba 02 00 00 00	 mov	 edx, 2
  00026	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0002b	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  00030	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax

; 1265 :    offsize = stbtt__buf_get8(&b);

  00034	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  0003e	0f b6 c0	 movzx	 eax, al
  00041	89 44 24 20	 mov	 DWORD PTR offsize$[rsp], eax

; 1266 :    STBTT_assert(i >= 0 && i < count);

  00045	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR i$[rsp], 0
  0004d	7c 0d		 jl	 SHORT $LN3@stbtt__cff
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  00053	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0005a	7c 1b		 jl	 SHORT $LN4@stbtt__cff
$LN3@stbtt__cff:
  0005c	41 b8 f2 04 00
	00		 mov	 r8d, 1266		; 000004f2H
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41374
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41375
  00070	e8 00 00 00 00	 call	 _wassert
  00075	33 c0		 xor	 eax, eax
$LN4@stbtt__cff:

; 1267 :    STBTT_assert(offsize >= 1 && offsize <= 4);

  00077	83 7c 24 20 01	 cmp	 DWORD PTR offsize$[rsp], 1
  0007c	7c 07		 jl	 SHORT $LN5@stbtt__cff
  0007e	83 7c 24 20 04	 cmp	 DWORD PTR offsize$[rsp], 4
  00083	7e 1b		 jle	 SHORT $LN6@stbtt__cff
$LN5@stbtt__cff:
  00085	41 b8 f3 04 00
	00		 mov	 r8d, 1267		; 000004f3H
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41376
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41377
  00099	e8 00 00 00 00	 call	 _wassert
  0009e	33 c0		 xor	 eax, eax
$LN6@stbtt__cff:

; 1268 :    stbtt__buf_skip(&b, i*offsize);

  000a0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  000a7	0f af 44 24 20	 imul	 eax, DWORD PTR offsize$[rsp]
  000ac	8b d0		 mov	 edx, eax
  000ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  000b3	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1269 :    start = stbtt__buf_get(&b, offsize);

  000b8	8b 54 24 20	 mov	 edx, DWORD PTR offsize$[rsp]
  000bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  000c1	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000c6	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 1270 :    end = stbtt__buf_get(&b, offsize);

  000ca	8b 54 24 20	 mov	 edx, DWORD PTR offsize$[rsp]
  000ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  000d3	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000d8	89 44 24 2c	 mov	 DWORD PTR end$[rsp], eax

; 1271 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

  000dc	8b 44 24 28	 mov	 eax, DWORD PTR start$[rsp]
  000e0	8b 4c 24 2c	 mov	 ecx, DWORD PTR end$[rsp]
  000e4	2b c8		 sub	 ecx, eax
  000e6	8b c1		 mov	 eax, ecx
  000e8	8b 4c 24 24	 mov	 ecx, DWORD PTR count$[rsp]
  000ec	ff c1		 inc	 ecx
  000ee	0f af 4c 24 20	 imul	 ecx, DWORD PTR offsize$[rsp]
  000f3	8b 54 24 28	 mov	 edx, DWORD PTR start$[rsp]
  000f7	8d 4c 11 02	 lea	 ecx, DWORD PTR [rcx+rdx+2]
  000fb	44 8b c8	 mov	 r9d, eax
  000fe	44 8b c1	 mov	 r8d, ecx
  00101	48 8b 54 24 78	 mov	 rdx, QWORD PTR b$[rsp]
  00106	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  0010b	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
  00110	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00115	48 8b f9	 mov	 rdi, rcx
  00118	48 8b f0	 mov	 rsi, rax
  0011b	b9 10 00 00 00	 mov	 ecx, 16
  00120	f3 a4		 rep movsb
  00122	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00127	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T3[rsp]
  0012c	48 8b f0	 mov	 rsi, rax
  0012f	b9 10 00 00 00	 mov	 ecx, 16
  00134	f3 a4		 rep movsb
  00136	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]

; 1272 : }

  0013b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013f	5f		 pop	 rdi
  00140	5e		 pop	 rsi
  00141	c3		 ret	 0
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ENDP	; stbtt__cff_index_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
b$ = 48
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z PROC	; stbtt__cff_index_count

; 1255 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1256 :    stbtt__buf_seek(b, 0);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00010	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1257 :    return stbtt__buf_get16(b);

  00015	ba 02 00 00 00	 mov	 edx, 2
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get

; 1258 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_index_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 32
operands$ = 40
$T1 = 56
$T2 = 72
b$ = 128
key$ = 136
outcount$ = 144
out$ = 152
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z PROC	; stbtt__dict_get_ints

; 1247 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1248 :    int i;
; 1249 :    stbtt__buf operands = stbtt__dict_get(b, key);

  00019	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR key$[rsp]
  00021	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00029	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T2[rsp]
  0002e	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  00033	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T1[rsp]
  00038	48 8b f9	 mov	 rdi, rcx
  0003b	48 8b f0	 mov	 rsi, rax
  0003e	b9 10 00 00 00	 mov	 ecx, 16
  00043	f3 a4		 rep movsb
  00045	48 8d 44 24 28	 lea	 rax, QWORD PTR operands$[rsp]
  0004a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T1[rsp]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	48 8b f1	 mov	 rsi, rcx
  00055	b9 10 00 00 00	 mov	 ecx, 16
  0005a	f3 a4		 rep movsb

; 1250 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  0005c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00064	eb 0a		 jmp	 SHORT $LN4@stbtt__dic
$LN2@stbtt__dic:
  00066	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__dic:
  00070	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR outcount$[rsp]
  00077	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0007b	7d 26		 jge	 SHORT $LN3@stbtt__dic
  0007d	8b 44 24 34	 mov	 eax, DWORD PTR operands$[rsp+12]
  00081	39 44 24 30	 cmp	 DWORD PTR operands$[rsp+8], eax
  00085	7d 1c		 jge	 SHORT $LN3@stbtt__dic

; 1251 :       out[i] = stbtt__cff_int(&operands);

  00087	48 8d 4c 24 28	 lea	 rcx, QWORD PTR operands$[rsp]
  0008c	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00091	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00096	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0009e	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  000a1	eb c3		 jmp	 SHORT $LN2@stbtt__dic
$LN3@stbtt__dic:

; 1252 : }

  000a3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000a7	5f		 pop	 rdi
  000a8	5e		 pop	 rsi
  000a9	c3		 ret	 0
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ENDP	; stbtt__dict_get_ints
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
op$1 = 32
start$2 = 36
end$3 = 40
$T4 = 48
$T5 = 64
$T6 = 80
$T7 = 96
$T8 = 144
b$ = 152
key$ = 160
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z PROC	; stbtt__dict_get

; 1232 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1233 :    stbtt__buf_seek(b, 0);

  00015	33 d2		 xor	 edx, edx
  00017	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek
$LN2@stbtt__dic:

; 1234 :    while (b->cursor < b->size) {

  00024	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0002c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00034	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00037	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0003a	0f 8d e0 00 00
	00		 jge	 $LN3@stbtt__dic

; 1235 :       int start = b->cursor, end, op;

  00040	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00048	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004b	89 44 24 24	 mov	 DWORD PTR start$2[rsp], eax
$LN4@stbtt__dic:

; 1236 :       while (stbtt__buf_peek8(b) >= 28)

  0004f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00057	e8 00 00 00 00	 call	 ?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	83 f8 1c	 cmp	 eax, 28
  00062	7c 0f		 jl	 SHORT $LN5@stbtt__dic

; 1237 :          stbtt__cff_skip_operand(b);

  00064	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0006c	e8 00 00 00 00	 call	 ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z ; stbtt__cff_skip_operand
  00071	eb dc		 jmp	 SHORT $LN4@stbtt__dic
$LN5@stbtt__dic:

; 1238 :       end = b->cursor;

  00073	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0007b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007e	89 44 24 28	 mov	 DWORD PTR end$3[rsp], eax

; 1239 :       op = stbtt__buf_get8(b);

  00082	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0008a	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  0008f	0f b6 c0	 movzx	 eax, al
  00092	89 44 24 20	 mov	 DWORD PTR op$1[rsp], eax

; 1240 :       if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

  00096	83 7c 24 20 0c	 cmp	 DWORD PTR op$1[rsp], 12
  0009b	75 18		 jne	 SHORT $LN6@stbtt__dic
  0009d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000a5	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  000aa	0f b6 c0	 movzx	 eax, al
  000ad	0f ba e8 08	 bts	 eax, 8
  000b1	89 44 24 20	 mov	 DWORD PTR op$1[rsp], eax
$LN6@stbtt__dic:

; 1241 :       if (op == key) return stbtt__buf_range(b, start, end-start);

  000b5	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR key$[rsp]
  000bc	39 44 24 20	 cmp	 DWORD PTR op$1[rsp], eax
  000c0	75 59		 jne	 SHORT $LN7@stbtt__dic
  000c2	8b 44 24 24	 mov	 eax, DWORD PTR start$2[rsp]
  000c6	8b 4c 24 28	 mov	 ecx, DWORD PTR end$3[rsp]
  000ca	2b c8		 sub	 ecx, eax
  000cc	8b c1		 mov	 eax, ecx
  000ce	44 8b c8	 mov	 r9d, eax
  000d1	44 8b 44 24 24	 mov	 r8d, DWORD PTR start$2[rsp]
  000d6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000de	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T6[rsp]
  000e3	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
  000e8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T4[rsp]
  000ed	48 8b f9	 mov	 rdi, rcx
  000f0	48 8b f0	 mov	 rsi, rax
  000f3	b9 10 00 00 00	 mov	 ecx, 16
  000f8	f3 a4		 rep movsb
  000fa	48 8d 44 24 30	 lea	 rax, QWORD PTR $T4[rsp]
  000ff	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR $T8[rsp]
  00107	48 8b f0	 mov	 rsi, rax
  0010a	b9 10 00 00 00	 mov	 ecx, 16
  0010f	f3 a4		 rep movsb
  00111	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  00119	eb 4e		 jmp	 SHORT $LN1@stbtt__dic
$LN7@stbtt__dic:

; 1242 :    }

  0011b	e9 04 ff ff ff	 jmp	 $LN2@stbtt__dic
$LN3@stbtt__dic:

; 1243 :    return stbtt__buf_range(b, 0, 0);

  00120	45 33 c9	 xor	 r9d, r9d
  00123	45 33 c0	 xor	 r8d, r8d
  00126	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  0012e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T7[rsp]
  00133	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
  00138	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T5[rsp]
  0013d	48 8b f9	 mov	 rdi, rcx
  00140	48 8b f0	 mov	 rsi, rax
  00143	b9 10 00 00 00	 mov	 ecx, 16
  00148	f3 a4		 rep movsb
  0014a	48 8d 44 24 40	 lea	 rax, QWORD PTR $T5[rsp]
  0014f	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR $T8[rsp]
  00157	48 8b f0	 mov	 rsi, rax
  0015a	b9 10 00 00 00	 mov	 ecx, 16
  0015f	f3 a4		 rep movsb
  00161	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
$LN1@stbtt__dic:

; 1244 : }

  00169	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0016d	5f		 pop	 rdi
  0016e	5e		 pop	 rsi
  0016f	c3		 ret	 0
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ENDP	; stbtt__dict_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
b0$ = 32
v$ = 36
b$ = 64
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z PROC	; stbtt__cff_skip_operand

; 1216 : static void stbtt__cff_skip_operand(stbtt__buf *b) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1217 :    int v, b0 = stbtt__buf_peek8(b);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR b0$[rsp], eax

; 1218 :    STBTT_assert(b0 >= 28);

  0001a	83 7c 24 20 1c	 cmp	 DWORD PTR b0$[rsp], 28
  0001f	7d 1b		 jge	 SHORT $LN9@stbtt__cff
  00021	41 b8 c2 04 00
	00		 mov	 r8d, 1218		; 000004c2H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41325
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41326
  00035	e8 00 00 00 00	 call	 _wassert
  0003a	33 c0		 xor	 eax, eax
$LN9@stbtt__cff:

; 1219 :    if (b0 == 30) {

  0003c	83 7c 24 20 1e	 cmp	 DWORD PTR b0$[rsp], 30
  00041	75 50		 jne	 SHORT $LN4@stbtt__cff

; 1220 :       stbtt__buf_skip(b, 1);

  00043	ba 01 00 00 00	 mov	 edx, 1
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0004d	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip
$LN2@stbtt__cff:

; 1221 :       while (b->cursor < b->size) {

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0005c	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0005f	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00062	7d 2d		 jge	 SHORT $LN3@stbtt__cff

; 1222 :          v = stbtt__buf_get8(b);

  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00069	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  0006e	0f b6 c0	 movzx	 eax, al
  00071	89 44 24 24	 mov	 DWORD PTR v$[rsp], eax

; 1223 :          if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

  00075	8b 44 24 24	 mov	 eax, DWORD PTR v$[rsp]
  00079	83 e0 0f	 and	 eax, 15
  0007c	83 f8 0f	 cmp	 eax, 15
  0007f	74 0c		 je	 SHORT $LN7@stbtt__cff
  00081	8b 44 24 24	 mov	 eax, DWORD PTR v$[rsp]
  00085	c1 f8 04	 sar	 eax, 4
  00088	83 f8 0f	 cmp	 eax, 15
  0008b	75 02		 jne	 SHORT $LN6@stbtt__cff
$LN7@stbtt__cff:

; 1224 :             break;

  0008d	eb 02		 jmp	 SHORT $LN3@stbtt__cff
$LN6@stbtt__cff:

; 1225 :       }

  0008f	eb c1		 jmp	 SHORT $LN2@stbtt__cff
$LN3@stbtt__cff:

; 1226 :    } else {

  00091	eb 0a		 jmp	 SHORT $LN5@stbtt__cff
$LN4@stbtt__cff:

; 1227 :       stbtt__cff_int(b);

  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00098	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
$LN5@stbtt__cff:

; 1228 :    }
; 1229 : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_skip_operand
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
b0$ = 32
tv73 = 36
tv83 = 40
b$ = 64
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z PROC		; stbtt__cff_int

; 1205 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1206 :    int b0 = stbtt__buf_get8(b);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR b0$[rsp], eax

; 1207 :    if (b0 >= 32 && b0 <= 246)       return b0 - 139;

  0001a	83 7c 24 20 20	 cmp	 DWORD PTR b0$[rsp], 32	; 00000020H
  0001f	7c 1d		 jl	 SHORT $LN2@stbtt__cff
  00021	81 7c 24 20 f6
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 246	; 000000f6H
  00029	7f 13		 jg	 SHORT $LN2@stbtt__cff
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR b0$[rsp]
  0002f	2d 8b 00 00 00	 sub	 eax, 139		; 0000008bH
  00034	e9 e2 00 00 00	 jmp	 $LN1@stbtt__cff
  00039	e9 ba 00 00 00	 jmp	 $LN3@stbtt__cff
$LN2@stbtt__cff:

; 1208 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

  0003e	81 7c 24 20 f7
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 247	; 000000f7H
  00046	7c 39		 jl	 SHORT $LN4@stbtt__cff
  00048	81 7c 24 20 fa
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 250	; 000000faH
  00050	7f 2f		 jg	 SHORT $LN4@stbtt__cff
  00052	8b 44 24 20	 mov	 eax, DWORD PTR b0$[rsp]
  00056	2d f7 00 00 00	 sub	 eax, 247		; 000000f7H
  0005b	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00061	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0006a	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  0006f	0f b6 c0	 movzx	 eax, al
  00072	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00076	8d 44 01 6c	 lea	 eax, DWORD PTR [rcx+rax+108]
  0007a	e9 9c 00 00 00	 jmp	 $LN1@stbtt__cff
  0007f	eb 77		 jmp	 SHORT $LN5@stbtt__cff
$LN4@stbtt__cff:

; 1209 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

  00081	81 7c 24 20 fb
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 251	; 000000fbH
  00089	7c 3b		 jl	 SHORT $LN6@stbtt__cff
  0008b	81 7c 24 20 fe
	00 00 00	 cmp	 DWORD PTR b0$[rsp], 254	; 000000feH
  00093	7f 31		 jg	 SHORT $LN6@stbtt__cff
  00095	8b 44 24 20	 mov	 eax, DWORD PTR b0$[rsp]
  00099	2d fb 00 00 00	 sub	 eax, 251		; 000000fbH
  0009e	f7 d8		 neg	 eax
  000a0	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  000a6	89 44 24 28	 mov	 DWORD PTR tv83[rsp], eax
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  000af	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  000b4	0f b6 c0	 movzx	 eax, al
  000b7	8b 4c 24 28	 mov	 ecx, DWORD PTR tv83[rsp]
  000bb	2b c8		 sub	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	83 e8 6c	 sub	 eax, 108		; 0000006cH
  000c2	eb 57		 jmp	 SHORT $LN1@stbtt__cff
  000c4	eb 32		 jmp	 SHORT $LN7@stbtt__cff
$LN6@stbtt__cff:

; 1210 :    else if (b0 == 28)               return stbtt__buf_get16(b);

  000c6	83 7c 24 20 1c	 cmp	 DWORD PTR b0$[rsp], 28
  000cb	75 13		 jne	 SHORT $LN8@stbtt__cff
  000cd	ba 02 00 00 00	 mov	 edx, 2
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  000d7	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000dc	eb 3d		 jmp	 SHORT $LN1@stbtt__cff
  000de	eb 18		 jmp	 SHORT $LN9@stbtt__cff
$LN8@stbtt__cff:

; 1211 :    else if (b0 == 29)               return stbtt__buf_get32(b);

  000e0	83 7c 24 20 1d	 cmp	 DWORD PTR b0$[rsp], 29
  000e5	75 11		 jne	 SHORT $LN10@stbtt__cff
  000e7	ba 04 00 00 00	 mov	 edx, 4
  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  000f6	eb 23		 jmp	 SHORT $LN1@stbtt__cff
$LN10@stbtt__cff:
$LN9@stbtt__cff:
$LN7@stbtt__cff:
$LN5@stbtt__cff:
$LN3@stbtt__cff:

; 1212 :    STBTT_assert(0);

  000f8	33 c0		 xor	 eax, eax
  000fa	85 c0		 test	 eax, eax
  000fc	75 1b		 jne	 SHORT $LN12@stbtt__cff
  000fe	41 b8 bc 04 00
	00		 mov	 r8d, 1212		; 000004bcH
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41314
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41315
  00112	e8 00 00 00 00	 call	 _wassert
  00117	33 c0		 xor	 eax, eax
$LN12@stbtt__cff:

; 1213 :    return 0;

  00119	33 c0		 xor	 eax, eax
$LN1@stbtt__cff:

; 1214 : }

  0011b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011f	c3		 ret	 0
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ENDP		; stbtt__cff_int
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
offsize$ = 32
count$ = 36
start$ = 40
$T1 = 48
$T2 = 64
$T3 = 112
b$ = 120
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z PROC	; stbtt__cff_get_index

; 1191 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1192 :    int count, start, offsize;
; 1193 :    start = b->cursor;

  00010	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00018	89 44 24 28	 mov	 DWORD PTR start$[rsp], eax

; 1194 :    count = stbtt__buf_get16(b);

  0001c	ba 02 00 00 00	 mov	 edx, 2
  00021	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  00026	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  0002b	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax

; 1195 :    if (count) {

  0002f	83 7c 24 24 00	 cmp	 DWORD PTR count$[rsp], 0
  00034	74 6b		 je	 SHORT $LN2@stbtt__cff

; 1196 :       offsize = stbtt__buf_get8(b);

  00036	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00040	0f b6 c0	 movzx	 eax, al
  00043	89 44 24 20	 mov	 DWORD PTR offsize$[rsp], eax

; 1197 :       STBTT_assert(offsize >= 1 && offsize <= 4);

  00047	83 7c 24 20 01	 cmp	 DWORD PTR offsize$[rsp], 1
  0004c	7c 07		 jl	 SHORT $LN4@stbtt__cff
  0004e	83 7c 24 20 04	 cmp	 DWORD PTR offsize$[rsp], 4
  00053	7e 1b		 jle	 SHORT $LN5@stbtt__cff
$LN4@stbtt__cff:
  00055	41 b8 ad 04 00
	00		 mov	 r8d, 1197		; 000004adH
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41297
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41298
  00069	e8 00 00 00 00	 call	 _wassert
  0006e	33 c0		 xor	 eax, eax
$LN5@stbtt__cff:

; 1198 :       stbtt__buf_skip(b, offsize * count);

  00070	8b 44 24 20	 mov	 eax, DWORD PTR offsize$[rsp]
  00074	0f af 44 24 24	 imul	 eax, DWORD PTR count$[rsp]
  00079	8b d0		 mov	 edx, eax
  0007b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  00080	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip

; 1199 :       stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

  00085	8b 54 24 20	 mov	 edx, DWORD PTR offsize$[rsp]
  00089	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0008e	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  00093	ff c8		 dec	 eax
  00095	8b d0		 mov	 edx, eax
  00097	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0009c	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_skip
$LN2@stbtt__cff:

; 1200 :    }
; 1201 :    return stbtt__buf_range(b, start, b->cursor - start);

  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  000a6	8b 4c 24 28	 mov	 ecx, DWORD PTR start$[rsp]
  000aa	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ad	2b c1		 sub	 eax, ecx
  000af	44 8b c8	 mov	 r9d, eax
  000b2	44 8b 44 24 28	 mov	 r8d, DWORD PTR start$[rsp]
  000b7	48 8b 54 24 78	 mov	 rdx, QWORD PTR b$[rsp]
  000bc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  000c1	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ; stbtt__buf_range
  000c6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  000cb	48 8b f9	 mov	 rdi, rcx
  000ce	48 8b f0	 mov	 rsi, rax
  000d1	b9 10 00 00 00	 mov	 ecx, 16
  000d6	f3 a4		 rep movsb
  000d8	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  000dd	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T3[rsp]
  000e2	48 8b f0	 mov	 rsi, rax
  000e5	b9 10 00 00 00	 mov	 ecx, 16
  000ea	f3 a4		 rep movsb
  000ec	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]

; 1202 : }

  000f1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f5	5f		 pop	 rdi
  000f6	5e		 pop	 rsi
  000f7	c3		 ret	 0
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ENDP	; stbtt__cff_get_index
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
r$ = 32
$T1 = 48
$T2 = 64
$T3 = 112
b$ = 120
o$ = 128
s$ = 136
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z PROC	; stbtt__buf_range

; 1182 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1183 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	33 d2		 xor	 edx, edx
  0001f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00024	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ; stbtt__new_buf
  00029	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0002e	48 8b f9	 mov	 rdi, rcx
  00031	48 8b f0	 mov	 rsi, rax
  00034	b9 10 00 00 00	 mov	 ecx, 16
  00039	f3 a4		 rep movsb
  0003b	48 8d 44 24 20	 lea	 rax, QWORD PTR r$[rsp]
  00040	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00045	48 8b f8	 mov	 rdi, rax
  00048	48 8b f1	 mov	 rsi, rcx
  0004b	b9 10 00 00 00	 mov	 ecx, 16
  00050	f3 a4		 rep movsb

; 1184 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  00052	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR o$[rsp], 0
  0005a	7c 35		 jl	 SHORT $LN3@stbtt__buf
  0005c	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR s$[rsp], 0
  00064	7c 2b		 jl	 SHORT $LN3@stbtt__buf
  00066	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  0006b	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0006e	39 84 24 80 00
	00 00		 cmp	 DWORD PTR o$[rsp], eax
  00075	7f 1a		 jg	 SHORT $LN3@stbtt__buf
  00077	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR o$[rsp]
  00083	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00086	2b c1		 sub	 eax, ecx
  00088	39 84 24 88 00
	00 00		 cmp	 DWORD PTR s$[rsp], eax
  0008f	7e 1b		 jle	 SHORT $LN2@stbtt__buf
$LN3@stbtt__buf:
  00091	48 8d 44 24 20	 lea	 rax, QWORD PTR r$[rsp]
  00096	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T3[rsp]
  0009b	48 8b f0	 mov	 rsi, rax
  0009e	b9 10 00 00 00	 mov	 ecx, 16
  000a3	f3 a4		 rep movsb
  000a5	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  000aa	eb 39		 jmp	 SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1185 :    r.data = b->data + o;

  000ac	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR o$[rsp]
  000b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  000b9	48 03 01	 add	 rax, QWORD PTR [rcx]
  000bc	48 89 44 24 20	 mov	 QWORD PTR r$[rsp], rax

; 1186 :    r.size = s;

  000c1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR s$[rsp]
  000c8	89 44 24 2c	 mov	 DWORD PTR r$[rsp+12], eax

; 1187 :    return r;

  000cc	48 8d 44 24 20	 lea	 rax, QWORD PTR r$[rsp]
  000d1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T3[rsp]
  000d6	48 8b f0	 mov	 rsi, rax
  000d9	b9 10 00 00 00	 mov	 ecx, 16
  000de	f3 a4		 rep movsb
  000e0	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
$LN1@stbtt__buf:

; 1188 : }

  000e5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e9	5f		 pop	 rdi
  000ea	5e		 pop	 rsi
  000eb	c3		 ret	 0
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ENDP	; stbtt__buf_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
r$ = 32
$T1 = 80
p$ = 88
size$ = 96
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z PROC		; stbtt__new_buf

; 1169 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1170 :    stbtt__buf r;
; 1171 :    STBTT_assert(size < 0x40000000);

  00015	48 81 7c 24 60
	00 00 00 40	 cmp	 QWORD PTR size$[rsp], 1073741824 ; 40000000H
  0001e	72 1b		 jb	 SHORT $LN3@stbtt__new
  00020	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41276
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41277
  00034	e8 00 00 00 00	 call	 _wassert
  00039	33 c0		 xor	 eax, eax
$LN3@stbtt__new:

; 1172 :    r.data = (stbtt_uint8*) p;

  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR r$[rsp], rax

; 1173 :    r.size = (int) size;

  00045	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  00049	89 44 24 2c	 mov	 DWORD PTR r$[rsp+12], eax

; 1174 :    r.cursor = 0;

  0004d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR r$[rsp+8], 0

; 1175 :    return r;

  00055	48 8d 44 24 20	 lea	 rax, QWORD PTR r$[rsp]
  0005a	48 8b 7c 24 50	 mov	 rdi, QWORD PTR $T1[rsp]
  0005f	48 8b f0	 mov	 rsi, rax
  00062	b9 10 00 00 00	 mov	 ecx, 16
  00067	f3 a4		 rep movsb
  00069	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]

; 1176 : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	5f		 pop	 rdi
  00073	5e		 pop	 rsi
  00074	c3		 ret	 0
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ENDP		; stbtt__new_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 32
v$ = 36
tv72 = 40
b$ = 64
n$ = 72
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_get

; 1159 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1160 :    stbtt_uint32 v = 0;

  0000d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR v$[rsp], 0

; 1161 :    int i;
; 1162 :    STBTT_assert(n >= 1 && n <= 4);

  00015	83 7c 24 48 01	 cmp	 DWORD PTR n$[rsp], 1
  0001a	7c 07		 jl	 SHORT $LN6@stbtt__buf
  0001c	83 7c 24 48 04	 cmp	 DWORD PTR n$[rsp], 4
  00021	7e 1b		 jle	 SHORT $LN7@stbtt__buf
$LN6@stbtt__buf:
  00023	41 b8 8a 04 00
	00		 mov	 r8d, 1162		; 0000048aH
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41265
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41266
  00037	e8 00 00 00 00	 call	 _wassert
  0003c	33 c0		 xor	 eax, eax
$LN7@stbtt__buf:

; 1163 :    for (i = 0; i < n; i++)

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN4@stbtt__buf
$LN2@stbtt__buf:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt__buf:
  00052	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00056	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0005a	7d 26		 jge	 SHORT $LN3@stbtt__buf

; 1164 :       v = (v << 8) | stbtt__buf_get8(b);

  0005c	8b 44 24 24	 mov	 eax, DWORD PTR v$[rsp]
  00060	c1 e0 08	 shl	 eax, 8
  00063	89 44 24 28	 mov	 DWORD PTR tv72[rsp], eax
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0006c	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_get8
  00071	0f b6 c0	 movzx	 eax, al
  00074	8b 4c 24 28	 mov	 ecx, DWORD PTR tv72[rsp]
  00078	0b c8		 or	 ecx, eax
  0007a	8b c1		 mov	 eax, ecx
  0007c	89 44 24 24	 mov	 DWORD PTR v$[rsp], eax
  00080	eb c6		 jmp	 SHORT $LN2@stbtt__buf
$LN3@stbtt__buf:

; 1165 :    return v;

  00082	8b 44 24 24	 mov	 eax, DWORD PTR v$[rsp]

; 1166 : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
b$ = 48
o$ = 56
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_skip

; 1154 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1155 :    stbtt__buf_seek(b, b->cursor + o);

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00015	03 44 24 38	 add	 eax, DWORD PTR o$[rsp]
  00019	8b d0		 mov	 edx, eax
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ; stbtt__buf_seek

; 1156 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv76 = 32
b$ = 64
o$ = 72
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_seek

; 1148 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1149 :    STBTT_assert(!(o > b->size || o < 0));

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00012	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00015	39 44 24 48	 cmp	 DWORD PTR o$[rsp], eax
  00019	7f 07		 jg	 SHORT $LN3@stbtt__buf
  0001b	83 7c 24 48 00	 cmp	 DWORD PTR o$[rsp], 0
  00020	7d 1b		 jge	 SHORT $LN4@stbtt__buf
$LN3@stbtt__buf:
  00022	41 b8 7d 04 00
	00		 mov	 r8d, 1149		; 0000047dH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41248
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41249
  00036	e8 00 00 00 00	 call	 _wassert
  0003b	33 c0		 xor	 eax, eax
$LN4@stbtt__buf:

; 1150 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00042	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00045	39 44 24 48	 cmp	 DWORD PTR o$[rsp], eax
  00049	7f 11		 jg	 SHORT $LN5@stbtt__buf
  0004b	83 7c 24 48 00	 cmp	 DWORD PTR o$[rsp], 0
  00050	7c 0a		 jl	 SHORT $LN5@stbtt__buf
  00052	8b 44 24 48	 mov	 eax, DWORD PTR o$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR tv76[rsp], eax
  0005a	eb 0c		 jmp	 SHORT $LN6@stbtt__buf
$LN5@stbtt__buf:
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00061	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00064	89 44 24 20	 mov	 DWORD PTR tv76[rsp], eax
$LN6@stbtt__buf:
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  0006d	8b 4c 24 20	 mov	 ecx, DWORD PTR tv76[rsp]
  00071	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1151 : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_seek
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
b$ = 8
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_peek8

; 1141 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1142 :    if (b->cursor >= b->size)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR b$[rsp]
  0000a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR b$[rsp]
  0000f	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00012	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00015	7c 04		 jl	 SHORT $LN2@stbtt__buf

; 1143 :       return 0;

  00017	32 c0		 xor	 al, al
  00019	eb 15		 jmp	 SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1144 :    return b->data[b->cursor];

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR b$[rsp]
  00020	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00024	48 8b 4c 24 08	 mov	 rcx, QWORD PTR b$[rsp]
  00029	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
$LN1@stbtt__buf:

; 1145 : }

  00030	c3		 ret	 0
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_peek8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv75 = 0
b$ = 32
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_get8

; 1134 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1135 :    if (b->cursor >= b->size)

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0000e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00013	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00016	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00019	7c 04		 jl	 SHORT $LN2@stbtt__buf

; 1136 :       return 0;

  0001b	32 c0		 xor	 al, al
  0001d	eb 2e		 jmp	 SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1137 :    return b->data[b->cursor++];

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00024	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00034	88 04 24	 mov	 BYTE PTR tv75[rsp], al
  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0003c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003f	ff c0		 inc	 eax
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00046	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00049	0f b6 04 24	 movzx	 eax, BYTE PTR tv75[rsp]
$LN1@stbtt__buf:

; 1138 : }

  0004d	48 83 c4 18	 add	 rsp, 24
  00051	c3		 ret	 0
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_get8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
?stbi__is_16_main@@YAHPEAUstbi__context@@@Z PROC	; stbi__is_16_main

; 7584 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7585 : #ifndef STBI_NO_PNG
; 7586 :     if (stbi__png_is16(s))  return 1;

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__png_is16@@YAHPEAUstbi__context@@@Z ; stbi__png_is16
  00013	85 c0		 test	 eax, eax
  00015	74 07		 je	 SHORT $LN2@stbi__is_1
  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	eb 2c		 jmp	 SHORT $LN1@stbi__is_1
$LN2@stbi__is_1:

; 7587 : #endif
; 7588 :     
; 7589 : #ifndef STBI_NO_PSD
; 7590 :     if (stbi__psd_is16(s))  return 1;

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__psd_is16@@YAHPEAUstbi__context@@@Z ; stbi__psd_is16
  00028	85 c0		 test	 eax, eax
  0002a	74 07		 je	 SHORT $LN3@stbi__is_1
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	eb 17		 jmp	 SHORT $LN1@stbi__is_1
$LN3@stbi__is_1:

; 7591 : #endif
; 7592 :     
; 7593 : #ifndef STBI_NO_PNM
; 7594 :     if (stbi__pnm_is16(s))  return 1;

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00038	e8 00 00 00 00	 call	 ?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z ; stbi__pnm_is16
  0003d	85 c0		 test	 eax, eax
  0003f	74 07		 je	 SHORT $LN4@stbi__is_1
  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	eb 02		 jmp	 SHORT $LN1@stbi__is_1
$LN4@stbi__is_1:

; 7595 : #endif
; 7596 :     return 0;

  00048	33 c0		 xor	 eax, eax
$LN1@stbi__is_1:

; 7597 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ENDP	; stbi__is_16_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__info_main

; 7542 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7543 : #ifndef STBI_NO_JPEG
; 7544 :     if (stbi__jpeg_info(s, x, y, comp)) return 1;

  00018	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__jpeg_info
  00031	85 c0		 test	 eax, eax
  00033	74 0a		 je	 SHORT $LN2@stbi__info
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	e9 38 01 00 00	 jmp	 $LN1@stbi__info
$LN2@stbi__info:

; 7545 : #endif
; 7546 :     
; 7547 : #ifndef STBI_NO_PNG
; 7548 :     if (stbi__png_info(s, x, y, comp))  return 1;

  0003f	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00044	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00049	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__png_info
  00058	85 c0		 test	 eax, eax
  0005a	74 0a		 je	 SHORT $LN3@stbi__info
  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	e9 11 01 00 00	 jmp	 $LN1@stbi__info
$LN3@stbi__info:

; 7549 : #endif
; 7550 :     
; 7551 : #ifndef STBI_NO_GIF
; 7552 :     if (stbi__gif_info(s, x, y, comp))  return 1;

  00066	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0006b	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00070	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__gif_info
  0007f	85 c0		 test	 eax, eax
  00081	74 0a		 je	 SHORT $LN4@stbi__info
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	e9 ea 00 00 00	 jmp	 $LN1@stbi__info
$LN4@stbi__info:

; 7553 : #endif
; 7554 :     
; 7555 : #ifndef STBI_NO_BMP
; 7556 :     if (stbi__bmp_info(s, x, y, comp))  return 1;

  0008d	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00092	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00097	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	e8 00 00 00 00	 call	 ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__bmp_info
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN5@stbi__info
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	e9 c3 00 00 00	 jmp	 $LN1@stbi__info
$LN5@stbi__info:

; 7557 : #endif
; 7558 :     
; 7559 : #ifndef STBI_NO_PSD
; 7560 :     if (stbi__psd_info(s, x, y, comp))  return 1;

  000b4	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  000b9	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000be	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000c8	e8 00 00 00 00	 call	 ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__psd_info
  000cd	85 c0		 test	 eax, eax
  000cf	74 0a		 je	 SHORT $LN6@stbi__info
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	e9 9c 00 00 00	 jmp	 $LN1@stbi__info
$LN6@stbi__info:

; 7561 : #endif
; 7562 :     
; 7563 : #ifndef STBI_NO_PIC
; 7564 :     if (stbi__pic_info(s, x, y, comp))  return 1;

  000db	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  000e0	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000e5	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pic_info
  000f4	85 c0		 test	 eax, eax
  000f6	74 07		 je	 SHORT $LN7@stbi__info
  000f8	b8 01 00 00 00	 mov	 eax, 1
  000fd	eb 78		 jmp	 SHORT $LN1@stbi__info
$LN7@stbi__info:

; 7565 : #endif
; 7566 :     
; 7567 : #ifndef STBI_NO_PNM
; 7568 :     if (stbi__pnm_info(s, x, y, comp))  return 1;

  000ff	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00104	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00109	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00113	e8 00 00 00 00	 call	 ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
  00118	85 c0		 test	 eax, eax
  0011a	74 07		 je	 SHORT $LN8@stbi__info
  0011c	b8 01 00 00 00	 mov	 eax, 1
  00121	eb 54		 jmp	 SHORT $LN1@stbi__info
$LN8@stbi__info:

; 7569 : #endif
; 7570 :     
; 7571 : #ifndef STBI_NO_HDR
; 7572 :     if (stbi__hdr_info(s, x, y, comp))  return 1;

  00123	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00128	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0012d	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00137	e8 00 00 00 00	 call	 ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__hdr_info
  0013c	85 c0		 test	 eax, eax
  0013e	74 07		 je	 SHORT $LN9@stbi__info
  00140	b8 01 00 00 00	 mov	 eax, 1
  00145	eb 30		 jmp	 SHORT $LN1@stbi__info
$LN9@stbi__info:

; 7573 : #endif
; 7574 :     
; 7575 :     // test tga last because it's a crappy test!
; 7576 : #ifndef STBI_NO_TGA
; 7577 :     if (stbi__tga_info(s, x, y, comp))

  00147	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0014c	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00151	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00156	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0015b	e8 00 00 00 00	 call	 ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__tga_info
  00160	85 c0		 test	 eax, eax
  00162	74 07		 je	 SHORT $LN10@stbi__info

; 7578 :         return 1;

  00164	b8 01 00 00 00	 mov	 eax, 1
  00169	eb 0c		 jmp	 SHORT $LN1@stbi__info
$LN10@stbi__info:

; 7579 : #endif
; 7580 :     return stbi__err("unknown image type", "Image not of any known type, or corrupt");

  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41149
  00172	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
$LN1@stbi__info:

; 7581 : }

  00177	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017b	c3		 ret	 0
?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__info_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
value$ = 32
s$ = 64
c$ = 72
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_getinteger

; 7483 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7484 :     int value = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR value$[rsp], 0
$LN2@stbi__pnm_:

; 7485 :     
; 7486 :     while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00020	85 c0		 test	 eax, eax
  00022	75 39		 jne	 SHORT $LN3@stbi__pnm_
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  00029	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0002c	e8 00 00 00 00	 call	 ?stbi__pnm_isdigit@@YAHD@Z ; stbi__pnm_isdigit
  00031	85 c0		 test	 eax, eax
  00033	74 28		 je	 SHORT $LN3@stbi__pnm_

; 7487 :         value = value*10 + (*c - '0');

  00035	6b 44 24 20 0a	 imul	 eax, DWORD PTR value$[rsp], 10
  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$[rsp]
  0003f	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00042	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00046	89 44 24 20	 mov	 DWORD PTR value$[rsp], eax

; 7488 :         *c = (char) stbi__get8(s);

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00054	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$[rsp]
  00059	88 01		 mov	 BYTE PTR [rcx], al

; 7489 :     }

  0005b	eb b9		 jmp	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7490 :     
; 7491 :     return value;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR value$[rsp]

; 7492 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_getinteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv68 = 0
c$ = 32
?stbi__pnm_isdigit@@YAHD@Z PROC				; stbi__pnm_isdigit

; 7478 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 7479 :     return c >= '0' && c <= '9';

  00008	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0000d	83 f8 30	 cmp	 eax, 48			; 00000030H
  00010	7c 13		 jl	 SHORT $LN3@stbi__pnm_
  00012	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00017	83 f8 39	 cmp	 eax, 57			; 00000039H
  0001a	7f 09		 jg	 SHORT $LN3@stbi__pnm_
  0001c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  00023	eb 07		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  00025	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN4@stbi__pnm_:
  0002c	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]

; 7480 : }

  0002f	48 83 c4 18	 add	 rsp, 24
  00033	c3		 ret	 0
?stbi__pnm_isdigit@@YAHD@Z ENDP				; stbi__pnm_isdigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
c$ = 56
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_skip_whitespace

; 7464 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN2@stbi__pnm_:
$LN5@stbi__pnm_:

; 7465 :     for (;;) {
; 7466 :         while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00018	85 c0		 test	 eax, eax
  0001a	75 24		 jne	 SHORT $LN6@stbi__pnm_
  0001c	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  00021	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00024	e8 00 00 00 00	 call	 ?stbi__pnm_isspace@@YAHD@Z ; stbi__pnm_isspace
  00029	85 c0		 test	 eax, eax
  0002b	74 13		 je	 SHORT $LN6@stbi__pnm_

; 7467 :             *c = (char) stbi__get8(s);

  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00032	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00037	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$[rsp]
  0003c	88 01		 mov	 BYTE PTR [rcx], al
  0003e	eb ce		 jmp	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7468 :         
; 7469 :         if (stbi__at_eof(s) || *c != '#')

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00045	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  0004a	85 c0		 test	 eax, eax
  0004c	75 0d		 jne	 SHORT $LN10@stbi__pnm_
  0004e	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  00053	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00056	83 f8 23	 cmp	 eax, 35			; 00000023H
  00059	74 02		 je	 SHORT $LN9@stbi__pnm_
$LN10@stbi__pnm_:

; 7470 :             break;

  0005b	eb 40		 jmp	 SHORT $LN3@stbi__pnm_
$LN9@stbi__pnm_:
$LN7@stbi__pnm_:

; 7471 :         
; 7472 :         while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )

  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00062	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00067	85 c0		 test	 eax, eax
  00069	75 2d		 jne	 SHORT $LN8@stbi__pnm_
  0006b	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  00070	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00073	83 f8 0a	 cmp	 eax, 10
  00076	74 20		 je	 SHORT $LN8@stbi__pnm_
  00078	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  0007d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00080	83 f8 0d	 cmp	 eax, 13
  00083	74 13		 je	 SHORT $LN8@stbi__pnm_

; 7473 :             *c = (char) stbi__get8(s);

  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0008a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0008f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$[rsp]
  00094	88 01		 mov	 BYTE PTR [rcx], al
  00096	eb c5		 jmp	 SHORT $LN7@stbi__pnm_
$LN8@stbi__pnm_:

; 7474 :     }

  00098	e9 71 ff ff ff	 jmp	 $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7475 : }

  0009d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a1	c3		 ret	 0
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_skip_whitespace
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv76 = 0
c$ = 32
?stbi__pnm_isspace@@YAHD@Z PROC				; stbi__pnm_isspace

; 7459 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 7460 :     return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

  00008	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0000d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00010	74 3b		 je	 SHORT $LN3@stbi__pnm_
  00012	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00017	83 f8 09	 cmp	 eax, 9
  0001a	74 31		 je	 SHORT $LN3@stbi__pnm_
  0001c	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00021	83 f8 0a	 cmp	 eax, 10
  00024	74 27		 je	 SHORT $LN3@stbi__pnm_
  00026	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0002b	83 f8 0b	 cmp	 eax, 11
  0002e	74 1d		 je	 SHORT $LN3@stbi__pnm_
  00030	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00035	83 f8 0c	 cmp	 eax, 12
  00038	74 13		 je	 SHORT $LN3@stbi__pnm_
  0003a	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0003f	83 f8 0d	 cmp	 eax, 13
  00042	74 09		 je	 SHORT $LN3@stbi__pnm_
  00044	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv76[rsp], 0
  0004b	eb 07		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  0004d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv76[rsp], 1
$LN4@stbi__pnm_:
  00054	8b 04 24	 mov	 eax, DWORD PTR tv76[rsp]

; 7461 : }

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
?stbi__pnm_isspace@@YAHD@Z ENDP				; stbi__pnm_isspace
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
f1$1 = 32
tv152 = 36
output$ = 64
input$ = 72
req_comp$ = 80
?stbi__hdr_convert@@YAXPEAMPEAEH@Z PROC			; stbi__hdr_convert

; 7054 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7055 :     if ( input[3] != 0 ) {

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	48 6b c0 03	 imul	 rax, rax, 3
  0001c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	85 c0		 test	 eax, eax
  00027	0f 84 71 01 00
	00		 je	 $LN4@stbi__hdr_

; 7056 :         float f1;
; 7057 :         // Exponent
; 7058 :         f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	2d 88 00 00 00	 sub	 eax, 136		; 00000088H
  00044	8b d0		 mov	 edx, eax
  00046	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0004e	e8 00 00 00 00	 call	 ldexp
  00053	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00057	f3 0f 11 44 24
	20		 movss	 DWORD PTR f1$1[rsp], xmm0

; 7059 :         if (req_comp <= 2)

  0005d	83 7c 24 50 02	 cmp	 DWORD PTR req_comp$[rsp], 2
  00062	7f 64		 jg	 SHORT $LN6@stbi__hdr_

; 7060 :             output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 00	 imul	 rax, rax, 0
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00072	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00076	b9 01 00 00 00	 mov	 ecx, 1
  0007b	48 6b c9 01	 imul	 rcx, rcx, 1
  0007f	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00084	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00088	03 c1		 add	 eax, ecx
  0008a	b9 01 00 00 00	 mov	 ecx, 1
  0008f	48 6b c9 02	 imul	 rcx, rcx, 2
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00098	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0009c	03 c1		 add	 eax, ecx
  0009e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000a2	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  000a8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  000b0	b8 04 00 00 00	 mov	 eax, 4
  000b5	48 6b c0 00	 imul	 rax, rax, 0
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  000be	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  000c3	e9 8d 00 00 00	 jmp	 $LN7@stbi__hdr_
$LN6@stbi__hdr_:

; 7061 :         else {
; 7062 :             output[0] = input[0] * f1;

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	48 6b c0 00	 imul	 rax, rax, 0
  000d1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000d6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000da	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000de	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  000e4	b8 04 00 00 00	 mov	 eax, 4
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  000f2	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7063 :             output[1] = input[1] * f1;

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	48 6b c0 01	 imul	 rax, rax, 1
  00100	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00105	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00109	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0010d	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  00113	b8 04 00 00 00	 mov	 eax, 4
  00118	48 6b c0 01	 imul	 rax, rax, 1
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00121	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7064 :             output[2] = input[2] * f1;

  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	48 6b c0 02	 imul	 rax, rax, 2
  0012f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00134	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00138	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0013c	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  00142	b8 04 00 00 00	 mov	 eax, 4
  00147	48 6b c0 02	 imul	 rax, rax, 2
  0014b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00150	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN7@stbi__hdr_:

; 7065 :         }
; 7066 :         if (req_comp == 2) output[1] = 1;

  00155	83 7c 24 50 02	 cmp	 DWORD PTR req_comp$[rsp], 2
  0015a	75 1b		 jne	 SHORT $LN8@stbi__hdr_
  0015c	b8 04 00 00 00	 mov	 eax, 4
  00161	48 6b c0 01	 imul	 rax, rax, 1
  00165	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0016a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00172	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN8@stbi__hdr_:

; 7067 :         if (req_comp == 4) output[3] = 1;

  00177	83 7c 24 50 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  0017c	75 1b		 jne	 SHORT $LN9@stbi__hdr_
  0017e	b8 04 00 00 00	 mov	 eax, 4
  00183	48 6b c0 03	 imul	 rax, rax, 3
  00187	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0018c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00194	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN9@stbi__hdr_:

; 7068 :     } else {

  00199	e9 bd 00 00 00	 jmp	 $LN5@stbi__hdr_
$LN4@stbi__hdr_:

; 7069 :         switch (req_comp) {

  0019e	8b 44 24 50	 mov	 eax, DWORD PTR req_comp$[rsp]
  001a2	89 44 24 24	 mov	 DWORD PTR tv152[rsp], eax
  001a6	83 7c 24 24 01	 cmp	 DWORD PTR tv152[rsp], 1
  001ab	0f 84 94 00 00
	00		 je	 $LN13@stbi__hdr_
  001b1	83 7c 24 24 02	 cmp	 DWORD PTR tv152[rsp], 2
  001b6	74 72		 je	 SHORT $LN12@stbi__hdr_
  001b8	83 7c 24 24 03	 cmp	 DWORD PTR tv152[rsp], 3
  001bd	74 27		 je	 SHORT $LN11@stbi__hdr_
  001bf	83 7c 24 24 04	 cmp	 DWORD PTR tv152[rsp], 4
  001c4	74 05		 je	 SHORT $LN10@stbi__hdr_
  001c6	e9 90 00 00 00	 jmp	 $LN2@stbi__hdr_
$LN10@stbi__hdr_:

; 7070 :             case 4: output[3] = 1; /* fallthrough */

  001cb	b8 04 00 00 00	 mov	 eax, 4
  001d0	48 6b c0 03	 imul	 rax, rax, 3
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001e1	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN11@stbi__hdr_:

; 7071 :             case 3: output[0] = output[1] = output[2] = 0;

  001e6	b8 04 00 00 00	 mov	 eax, 4
  001eb	48 6b c0 02	 imul	 rax, rax, 2
  001ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001f4	0f 57 c0	 xorps	 xmm0, xmm0
  001f7	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  001fc	b8 04 00 00 00	 mov	 eax, 4
  00201	48 6b c0 01	 imul	 rax, rax, 1
  00205	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0020a	0f 57 c0	 xorps	 xmm0, xmm0
  0020d	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  00212	b8 04 00 00 00	 mov	 eax, 4
  00217	48 6b c0 00	 imul	 rax, rax, 0
  0021b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00220	0f 57 c0	 xorps	 xmm0, xmm0
  00223	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7072 :             break;

  00228	eb 31		 jmp	 SHORT $LN2@stbi__hdr_
$LN12@stbi__hdr_:

; 7073 :             case 2: output[1] = 1; /* fallthrough */

  0022a	b8 04 00 00 00	 mov	 eax, 4
  0022f	48 6b c0 01	 imul	 rax, rax, 1
  00233	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00238	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00240	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN13@stbi__hdr_:

; 7074 :             case 1: output[0] = 0;

  00245	b8 04 00 00 00	 mov	 eax, 4
  0024a	48 6b c0 00	 imul	 rax, rax, 0
  0024e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00253	0f 57 c0	 xorps	 xmm0, xmm0
  00256	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN2@stbi__hdr_:
$LN5@stbi__hdr_:

; 7075 :             break;
; 7076 :         }
; 7077 :     }
; 7078 : }

  0025b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0025f	c3		 ret	 0
?stbi__hdr_convert@@YAXPEAMPEAEH@Z ENDP			; stbi__hdr_convert
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
c$ = 32
len$ = 36
z$ = 64
buffer$ = 72
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z PROC ; stbi__hdr_gettoken

; 7032 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7033 :     int len=0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 7034 :     char c = '\0';

  00016	c6 44 24 20 00	 mov	 BYTE PTR c$[rsp], 0

; 7035 :     
; 7036 :     c = (char) stbi__get8(z);

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00025	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
$LN2@stbi__hdr_:

; 7037 :     
; 7038 :     while (!stbi__at_eof(z) && c != '\n') {

  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0002e	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00033	85 c0		 test	 eax, eax
  00035	75 64		 jne	 SHORT $LN3@stbi__hdr_
  00037	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0003c	83 f8 0a	 cmp	 eax, 10
  0003f	74 5a		 je	 SHORT $LN3@stbi__hdr_

; 7039 :         buffer[len++] = c;

  00041	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  0004b	0f b6 54 24 20	 movzx	 edx, BYTE PTR c$[rsp]
  00050	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00053	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 7040 :         if (len == STBI__HDR_BUFLEN-1) {

  0005d	81 7c 24 24 ff
	03 00 00	 cmp	 DWORD PTR len$[rsp], 1023 ; 000003ffH
  00065	75 24		 jne	 SHORT $LN6@stbi__hdr_
$LN4@stbi__hdr_:

; 7041 :             // flush to end of line
; 7042 :             while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0006c	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00071	85 c0		 test	 eax, eax
  00073	75 14		 jne	 SHORT $LN5@stbi__hdr_
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0007f	0f b6 c0	 movzx	 eax, al
  00082	83 f8 0a	 cmp	 eax, 10
  00085	74 02		 je	 SHORT $LN5@stbi__hdr_

; 7043 :                 ;

  00087	eb de		 jmp	 SHORT $LN4@stbi__hdr_
$LN5@stbi__hdr_:

; 7044 :             break;

  00089	eb 10		 jmp	 SHORT $LN3@stbi__hdr_
$LN6@stbi__hdr_:

; 7045 :         }
; 7046 :         c = (char) stbi__get8(z);

  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00095	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 7047 :     }

  00099	eb 8e		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7048 :     
; 7049 :     buffer[len] = 0;

  0009b	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  000a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  000a5	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 7050 :     return buffer;

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR buffer$[rsp]

; 7051 : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ENDP ; stbi__hdr_gettoken
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
signature$ = 72
?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__hdr_test_core

; 7010 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7011 :     int i;
; 7012 :     for (i=0; signature[i]; ++i)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
  00022	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR signature$[rsp]
  0002c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00030	85 c0		 test	 eax, eax
  00032	74 25		 je	 SHORT $LN3@stbi__hdr_

; 7013 :         if (stbi__get8(s) != signature[i])

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0003e	0f b6 c0	 movzx	 eax, al
  00041	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 54 24 48	 mov	 rdx, QWORD PTR signature$[rsp]
  0004b	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0004f	3b c1		 cmp	 eax, ecx
  00051	74 04		 je	 SHORT $LN5@stbi__hdr_

; 7014 :         return 0;

  00053	33 c0		 xor	 eax, eax
  00055	eb 11		 jmp	 SHORT $LN1@stbi__hdr_
$LN5@stbi__hdr_:
  00057	eb bf		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7015 :     stbi__rewind(s);

  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7016 :     return 1;

  00063	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 7017 : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__hdr_test_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv78 = 32
g$ = 64
out$ = 72
delays$ = 80
?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z PROC ; stbi__load_gif_main_outofmem

; 6875 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6876 :     STBI_FREE(g->out);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00018	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001c	e8 00 00 00 00	 call	 free

; 6877 :     STBI_FREE(g->history);

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00026	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0002a	e8 00 00 00 00	 call	 free

; 6878 :     STBI_FREE(g->background);

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00034	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00038	e8 00 00 00 00	 call	 free

; 6879 :     
; 6880 :     if (out) STBI_FREE(out);

  0003d	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  00043	74 0a		 je	 SHORT $LN2@stbi__load
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  0004a	e8 00 00 00 00	 call	 free
$LN2@stbi__load:

; 6881 :     if (delays && *delays) STBI_FREE(*delays);

  0004f	48 83 7c 24 50
	00		 cmp	 QWORD PTR delays$[rsp], 0
  00055	74 18		 je	 SHORT $LN3@stbi__load
  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR delays$[rsp]
  0005c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00060	74 0d		 je	 SHORT $LN3@stbi__load
  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR delays$[rsp]
  00067	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006a	e8 00 00 00 00	 call	 free
$LN3@stbi__load:

; 6882 :     return stbi__errpuc("outofmem", "Out of memory");

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40675
  00076	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0007b	85 c0		 test	 eax, eax
  0007d	74 0a		 je	 SHORT $LN5@stbi__load
  0007f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  00087	eb 08		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:
  00089	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN6@stbi__load:
  00091	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv78[rsp]

; 6883 : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ENDP ; stbi__load_gif_main_outofmem
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
pi$ = 32
pcount$ = 36
len$1 = 40
dispose$ = 44
tv248 = 48
w$2 = 52
tv83 = 56
tv143 = 60
tv266 = 64
x$3 = 68
y$4 = 72
h$5 = 76
tv313 = 80
tv332 = 84
first_frame$ = 88
tv431 = 92
tag$6 = 96
tv614 = 100
ext$7 = 104
o$8 = 112
tv148 = 120
tv155 = 128
tv161 = 136
tv241 = 144
s$ = 192
g$ = 200
comp$ = 208
req_comp$ = 216
two_back$ = 224
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z PROC ; stbi__gif_load_next

; 6701 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 6702 :     int dispose;
; 6703 :     int first_frame;
; 6704 :     int pi;
; 6705 :     int pcount;
; 6706 :     STBI_NOTUSED(req_comp);
; 6707 :     
; 6708 :     // on first frame, any non-written pixels get the background colour (non-transparent)
; 6709 :     first_frame = 0;

  0001d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR first_frame$[rsp], 0

; 6710 :     if (g->out == 0) {

  00025	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0002d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00032	0f 85 c2 01 00
	00		 jne	 $LN18@stbi__gif_

; 6711 :         if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header

  00038	45 33 c9	 xor	 r9d, r9d
  0003b	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  00043	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  0004b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN20@stbi__gif_
  0005c	33 c0		 xor	 eax, eax
  0005e	e9 5d 09 00 00	 jmp	 $LN1@stbi__gif_
$LN20@stbi__gif_:

; 6712 :         if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

  00063	45 33 c9	 xor	 r9d, r9d
  00066	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0006e	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00072	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0007a	8b 10		 mov	 edx, DWORD PTR [rax]
  0007c	b9 04 00 00 00	 mov	 ecx, 4
  00081	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  00086	85 c0		 test	 eax, eax
  00088	75 2c		 jne	 SHORT $LN21@stbi__gif_

; 6713 :             return stbi__errpuc("too large", "GIF image is too large");

  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40629
  00091	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00096	85 c0		 test	 eax, eax
  00098	74 0a		 je	 SHORT $LN55@stbi__gif_
  0009a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000a2	eb 08		 jmp	 SHORT $LN56@stbi__gif_
$LN55@stbi__gif_:
  000a4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN56@stbi__gif_:
  000ac	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv83[rsp]
  000b1	e9 0a 09 00 00	 jmp	 $LN1@stbi__gif_
$LN21@stbi__gif_:

; 6714 :         pcount = g->w * g->h;

  000b6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  000be	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000c6	8b 00		 mov	 eax, DWORD PTR [rax]
  000c8	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  000cc	89 44 24 24	 mov	 DWORD PTR pcount$[rsp], eax

; 6715 :         g->out = (stbi_uc *) stbi__malloc(4 * pcount);

  000d0	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  000d4	c1 e0 02	 shl	 eax, 2
  000d7	48 98		 cdqe
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  000e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000e9	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 6716 :         g->background = (stbi_uc *) stbi__malloc(4 * pcount);

  000ed	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  000f1	c1 e0 02	 shl	 eax, 2
  000f4	48 98		 cdqe
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  000fe	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00106	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 6717 :         g->history = (stbi_uc *) stbi__malloc(pcount);

  0010a	48 63 44 24 24	 movsxd	 rax, DWORD PTR pcount$[rsp]
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00117	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0011f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 6718 :         if (!g->out || !g->background || !g->history)

  00123	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0012b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00130	74 1e		 je	 SHORT $LN23@stbi__gif_
  00132	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0013a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0013f	74 0f		 je	 SHORT $LN23@stbi__gif_
  00141	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00149	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0014e	75 2c		 jne	 SHORT $LN22@stbi__gif_
$LN23@stbi__gif_:

; 6719 :             return stbi__errpuc("outofmem", "Out of memory");

  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40632
  00157	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015c	85 c0		 test	 eax, eax
  0015e	74 0a		 je	 SHORT $LN57@stbi__gif_
  00160	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
  00168	eb 08		 jmp	 SHORT $LN58@stbi__gif_
$LN57@stbi__gif_:
  0016a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN58@stbi__gif_:
  00172	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv143[rsp]
  00177	e9 44 08 00 00	 jmp	 $LN1@stbi__gif_
$LN22@stbi__gif_:

; 6720 :         
; 6721 :         // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
; 6722 :         // background colour is only used for pixels that are not rendered first frame, after that "background"
; 6723 :         // color refers to the color that was there the previous frame.
; 6724 :         memset(g->out, 0x00, 4 * pcount);

  0017c	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  00180	c1 e0 02	 shl	 eax, 2
  00183	48 98		 cdqe
  00185	48 89 44 24 78	 mov	 QWORD PTR tv148[rsp], rax
  0018a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00192	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00196	33 c0		 xor	 eax, eax
  00198	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv148[rsp]
  0019d	f3 aa		 rep stosb

; 6725 :         memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)

  0019f	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  001a3	c1 e0 02	 shl	 eax, 2
  001a6	48 98		 cdqe
  001a8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  001b0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  001b8	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  001bc	33 c0		 xor	 eax, eax
  001be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv155[rsp]
  001c6	f3 aa		 rep stosb

; 6726 :         memset(g->history, 0x00, pcount);        // pixels that were affected previous frame

  001c8	48 63 44 24 24	 movsxd	 rax, DWORD PTR pcount$[rsp]
  001cd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv161[rsp], rax
  001d5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  001dd	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  001e1	33 c0		 xor	 eax, eax
  001e3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv161[rsp]
  001eb	f3 aa		 rep stosb

; 6727 :         first_frame = 1;

  001ed	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR first_frame$[rsp], 1

; 6728 :     } else {

  001f5	e9 61 01 00 00	 jmp	 $LN19@stbi__gif_
$LN18@stbi__gif_:

; 6729 :         // second frame - how do we dispose of the previous one?
; 6730 :         dispose = (g->eflags & 0x1C) >> 2;

  001fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00202	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00205	83 e0 1c	 and	 eax, 28
  00208	c1 f8 02	 sar	 eax, 2
  0020b	89 44 24 2c	 mov	 DWORD PTR dispose$[rsp], eax

; 6731 :         pcount = g->w * g->h;

  0020f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00217	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0021f	8b 00		 mov	 eax, DWORD PTR [rax]
  00221	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00225	89 44 24 24	 mov	 DWORD PTR pcount$[rsp], eax

; 6732 :         
; 6733 :         if ((dispose == 3) && (two_back == 0)) {

  00229	83 7c 24 2c 03	 cmp	 DWORD PTR dispose$[rsp], 3
  0022e	75 13		 jne	 SHORT $LN24@stbi__gif_
  00230	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR two_back$[rsp], 0
  00239	75 08		 jne	 SHORT $LN24@stbi__gif_

; 6734 :             dispose = 2; // if I don't have an image to revert back to, default to the old background

  0023b	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR dispose$[rsp], 2
$LN24@stbi__gif_:

; 6735 :         }
; 6736 :         
; 6737 :         if (dispose == 3) { // use previous graphic

  00243	83 7c 24 2c 03	 cmp	 DWORD PTR dispose$[rsp], 3
  00248	75 68		 jne	 SHORT $LN25@stbi__gif_

; 6738 :             for (pi = 0; pi < pcount; ++pi) {

  0024a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  00252	eb 0a		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  00254	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  00258	ff c0		 inc	 eax
  0025a	89 44 24 20	 mov	 DWORD PTR pi$[rsp], eax
$LN4@stbi__gif_:
  0025e	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  00262	39 44 24 20	 cmp	 DWORD PTR pi$[rsp], eax
  00266	7d 48		 jge	 SHORT $LN3@stbi__gif_

; 6739 :                 if (g->history[pi]) {

  00268	48 63 44 24 20	 movsxd	 rax, DWORD PTR pi$[rsp]
  0026d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00275	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00279	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027d	85 c0		 test	 eax, eax
  0027f	74 2d		 je	 SHORT $LN27@stbi__gif_

; 6740 :                     memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );

  00281	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  00285	c1 e0 02	 shl	 eax, 2
  00288	48 98		 cdqe
  0028a	8b 4c 24 20	 mov	 ecx, DWORD PTR pi$[rsp]
  0028e	c1 e1 02	 shl	 ecx, 2
  00291	48 63 c9	 movsxd	 rcx, ecx
  00294	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  0029c	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  002a0	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR two_back$[rsp]
  002a8	8b 04 07	 mov	 eax, DWORD PTR [rdi+rax]
  002ab	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN27@stbi__gif_:

; 6741 :                 }
; 6742 :             }

  002ae	eb a4		 jmp	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6743 :         } else if (dispose == 2) {

  002b0	eb 71		 jmp	 SHORT $LN26@stbi__gif_
$LN25@stbi__gif_:
  002b2	83 7c 24 2c 02	 cmp	 DWORD PTR dispose$[rsp], 2
  002b7	75 6a		 jne	 SHORT $LN28@stbi__gif_

; 6744 :             // restore what was changed last frame to background before that frame;
; 6745 :             for (pi = 0; pi < pcount; ++pi) {

  002b9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  002c1	eb 0a		 jmp	 SHORT $LN7@stbi__gif_
$LN5@stbi__gif_:
  002c3	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  002c7	ff c0		 inc	 eax
  002c9	89 44 24 20	 mov	 DWORD PTR pi$[rsp], eax
$LN7@stbi__gif_:
  002cd	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  002d1	39 44 24 20	 cmp	 DWORD PTR pi$[rsp], eax
  002d5	7d 4c		 jge	 SHORT $LN6@stbi__gif_

; 6746 :                 if (g->history[pi]) {

  002d7	48 63 44 24 20	 movsxd	 rax, DWORD PTR pi$[rsp]
  002dc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  002e4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002e8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ec	85 c0		 test	 eax, eax
  002ee	74 31		 je	 SHORT $LN30@stbi__gif_

; 6747 :                     memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );

  002f0	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  002f4	c1 e0 02	 shl	 eax, 2
  002f7	48 98		 cdqe
  002f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00301	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00305	8b 54 24 20	 mov	 edx, DWORD PTR pi$[rsp]
  00309	c1 e2 02	 shl	 edx, 2
  0030c	48 63 d2	 movsxd	 rdx, edx
  0030f	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR g$[rsp]
  00317	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  0031b	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0031e	89 04 17	 mov	 DWORD PTR [rdi+rdx], eax
$LN30@stbi__gif_:

; 6748 :                 }
; 6749 :             }

  00321	eb a0		 jmp	 SHORT $LN5@stbi__gif_
$LN6@stbi__gif_:
$LN28@stbi__gif_:
$LN26@stbi__gif_:

; 6750 :         } else {
; 6751 :             // This is a non-disposal case eithe way, so just
; 6752 :             // leave the pixels as is, and they will become the new background
; 6753 :             // 1: do not dispose
; 6754 :             // 0:  not specified.
; 6755 :         }
; 6756 :         
; 6757 :         // background is what out is after the undoing of the previou frame;
; 6758 :         memcpy( g->background, g->out, 4 * g->w * g->h );

  00323	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0032b	8b 00		 mov	 eax, DWORD PTR [rax]
  0032d	c1 e0 02	 shl	 eax, 2
  00330	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00338	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0033c	48 98		 cdqe
  0033e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00346	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  0034e	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  00352	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  00356	48 8b c8	 mov	 rcx, rax
  00359	f3 a4		 rep movsb
$LN19@stbi__gif_:

; 6759 :     }
; 6760 :     
; 6761 :     // clear my history;
; 6762 :     memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

  0035b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00363	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0036b	8b 00		 mov	 eax, DWORD PTR [rax]
  0036d	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00371	48 98		 cdqe
  00373	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv241[rsp], rax
  0037b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00383	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00387	33 c0		 xor	 eax, eax
  00389	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv241[rsp]
  00391	f3 aa		 rep stosb
$LN8@stbi__gif_:

; 6763 :     
; 6764 :     for (;;) {
; 6765 :         int tag = stbi__get8(s);

  00393	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0039b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  003a0	0f b6 c0	 movzx	 eax, al
  003a3	89 44 24 60	 mov	 DWORD PTR tag$6[rsp], eax

; 6766 :         switch (tag) {

  003a7	8b 44 24 60	 mov	 eax, DWORD PTR tag$6[rsp]
  003ab	89 44 24 30	 mov	 DWORD PTR tv248[rsp], eax
  003af	83 7c 24 30 21	 cmp	 DWORD PTR tv248[rsp], 33 ; 00000021H
  003b4	0f 84 57 04 00
	00		 je	 $LN44@stbi__gif_
  003ba	83 7c 24 30 2c	 cmp	 DWORD PTR tv248[rsp], 44 ; 0000002cH
  003bf	74 10		 je	 SHORT $LN31@stbi__gif_
  003c1	83 7c 24 30 3b	 cmp	 DWORD PTR tv248[rsp], 59 ; 0000003bH
  003c6	0f 84 bc 05 00
	00		 je	 $LN52@stbi__gif_
  003cc	e9 c1 05 00 00	 jmp	 $LN53@stbi__gif_
$LN31@stbi__gif_:

; 6767 :             case 0x2C: /* Image Descriptor */
; 6768 :             {
; 6769 :                 stbi__int32 x, y, w, h;
; 6770 :                 stbi_uc *o;
; 6771 :                 
; 6772 :                 x = stbi__get16le(s);

  003d1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003d9	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  003de	89 44 24 44	 mov	 DWORD PTR x$3[rsp], eax

; 6773 :                 y = stbi__get16le(s);

  003e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ea	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  003ef	89 44 24 48	 mov	 DWORD PTR y$4[rsp], eax

; 6774 :                 w = stbi__get16le(s);

  003f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003fb	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00400	89 44 24 34	 mov	 DWORD PTR w$2[rsp], eax

; 6775 :                 h = stbi__get16le(s);

  00404	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0040c	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00411	89 44 24 4c	 mov	 DWORD PTR h$5[rsp], eax

; 6776 :                 if (((x + w) > (g->w)) || ((y + h) > (g->h)))

  00415	8b 44 24 34	 mov	 eax, DWORD PTR w$2[rsp]
  00419	8b 4c 24 44	 mov	 ecx, DWORD PTR x$3[rsp]
  0041d	03 c8		 add	 ecx, eax
  0041f	8b c1		 mov	 eax, ecx
  00421	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00429	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0042b	7f 19		 jg	 SHORT $LN33@stbi__gif_
  0042d	8b 44 24 4c	 mov	 eax, DWORD PTR h$5[rsp]
  00431	8b 4c 24 48	 mov	 ecx, DWORD PTR y$4[rsp]
  00435	03 c8		 add	 ecx, eax
  00437	8b c1		 mov	 eax, ecx
  00439	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00441	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  00444	7e 2c		 jle	 SHORT $LN32@stbi__gif_
$LN33@stbi__gif_:

; 6777 :                     return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

  00446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40643
  0044d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00452	85 c0		 test	 eax, eax
  00454	74 0a		 je	 SHORT $LN59@stbi__gif_
  00456	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv266[rsp], 0
  0045e	eb 08		 jmp	 SHORT $LN60@stbi__gif_
$LN59@stbi__gif_:
  00460	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv266[rsp], 0
$LN60@stbi__gif_:
  00468	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv266[rsp]
  0046d	e9 4e 05 00 00	 jmp	 $LN1@stbi__gif_
$LN32@stbi__gif_:

; 6778 :                 
; 6779 :                 g->line_size = g->w * 4;

  00472	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0047a	8b 00		 mov	 eax, DWORD PTR [rax]
  0047c	c1 e0 02	 shl	 eax, 2
  0047f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00487	89 81 64 88 00
	00		 mov	 DWORD PTR [rcx+34916], eax

; 6780 :                 g->start_x = x * 4;

  0048d	8b 44 24 44	 mov	 eax, DWORD PTR x$3[rsp]
  00491	c1 e0 02	 shl	 eax, 2
  00494	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0049c	89 81 4c 88 00
	00		 mov	 DWORD PTR [rcx+34892], eax

; 6781 :                 g->start_y = y * g->line_size;

  004a2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  004aa	8b 4c 24 48	 mov	 ecx, DWORD PTR y$4[rsp]
  004ae	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  004b5	8b c1		 mov	 eax, ecx
  004b7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  004bf	89 81 50 88 00
	00		 mov	 DWORD PTR [rcx+34896], eax

; 6782 :                 g->max_x   = g->start_x + w * 4;

  004c5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  004cd	8b 80 4c 88 00
	00		 mov	 eax, DWORD PTR [rax+34892]
  004d3	8b 4c 24 34	 mov	 ecx, DWORD PTR w$2[rsp]
  004d7	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  004da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  004e2	89 81 54 88 00
	00		 mov	 DWORD PTR [rcx+34900], eax

; 6783 :                 g->max_y   = g->start_y + h * g->line_size;

  004e8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  004f0	8b 4c 24 4c	 mov	 ecx, DWORD PTR h$5[rsp]
  004f4	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  004fb	8b c1		 mov	 eax, ecx
  004fd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00505	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  0050b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00513	89 81 58 88 00
	00		 mov	 DWORD PTR [rcx+34904], eax

; 6784 :                 g->cur_x   = g->start_x;

  00519	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00521	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00529	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  0052f	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6785 :                 g->cur_y   = g->start_y;

  00535	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0053d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00545	8b 89 50 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34896]
  0054b	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx

; 6786 :                 
; 6787 :                 // if the width of the specified rectangle is 0, that means
; 6788 :                 // we may not see *any* pixels or the image is malformed;
; 6789 :                 // to make sure this is caught, move the current y down to
; 6790 :                 // max_y (which is what out_gif_code checks).
; 6791 :                 if (w == 0)

  00551	83 7c 24 34 00	 cmp	 DWORD PTR w$2[rsp], 0
  00556	75 1c		 jne	 SHORT $LN34@stbi__gif_

; 6792 :                     g->cur_y = g->max_y;

  00558	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00560	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00568	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  0056e	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx
$LN34@stbi__gif_:

; 6793 :                 
; 6794 :                 g->lflags = stbi__get8(s);

  00574	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0057c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00581	0f b6 c0	 movzx	 eax, al
  00584	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0058c	89 81 48 88 00
	00		 mov	 DWORD PTR [rcx+34888], eax

; 6795 :                 
; 6796 :                 if (g->lflags & 0x40) {

  00592	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0059a	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  005a0	83 e0 40	 and	 eax, 64			; 00000040H
  005a3	85 c0		 test	 eax, eax
  005a5	74 33		 je	 SHORT $LN35@stbi__gif_

; 6797 :                     g->step = 8 * g->line_size; // first interlaced spacing

  005a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005af	8b 80 64 88 00
	00		 mov	 eax, DWORD PTR [rax+34916]
  005b5	c1 e0 03	 shl	 eax, 3
  005b8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005c0	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6798 :                     g->parse = 3;

  005c6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005ce	c7 80 40 88 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+34880], 3

; 6799 :                 } else {

  005d8	eb 2e		 jmp	 SHORT $LN36@stbi__gif_
$LN35@stbi__gif_:

; 6800 :                     g->step = g->line_size;

  005da	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005e2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005ea	8b 89 64 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34916]
  005f0	89 88 44 88 00
	00		 mov	 DWORD PTR [rax+34884], ecx

; 6801 :                     g->parse = 0;

  005f6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005fe	c7 80 40 88 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+34880], 0
$LN36@stbi__gif_:

; 6802 :                 }
; 6803 :                 
; 6804 :                 if (g->lflags & 0x80) {

  00608	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00610	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  00616	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0061b	85 c0		 test	 eax, eax
  0061d	0f 84 94 00 00
	00		 je	 $LN37@stbi__gif_

; 6805 :                     stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

  00623	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0062b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0062e	83 e0 01	 and	 eax, 1
  00631	85 c0		 test	 eax, eax
  00633	74 11		 je	 SHORT $LN61@stbi__gif_
  00635	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0063d	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00640	89 44 24 50	 mov	 DWORD PTR tv313[rsp], eax
  00644	eb 08		 jmp	 SHORT $LN62@stbi__gif_
$LN61@stbi__gif_:
  00646	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR tv313[rsp], -1
$LN62@stbi__gif_:
  0064e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00656	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  0065c	83 e0 07	 and	 eax, 7
  0065f	b9 02 00 00 00	 mov	 ecx, 2
  00664	89 4c 24 64	 mov	 DWORD PTR tv614[rsp], ecx
  00668	0f b6 c8	 movzx	 ecx, al
  0066b	8b 44 24 64	 mov	 eax, DWORD PTR tv614[rsp]
  0066f	d3 e0		 shl	 eax, cl
  00671	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00679	48 81 c1 34 04
	00 00		 add	 rcx, 1076		; 00000434H
  00680	44 8b 4c 24 50	 mov	 r9d, DWORD PTR tv313[rsp]
  00685	44 8b c0	 mov	 r8d, eax
  00688	48 8b d1	 mov	 rdx, rcx
  0068b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00693	e8 00 00 00 00	 call	 ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable

; 6806 :                     g->color_table = (stbi_uc *) g->lpal;

  00698	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  006a0	48 05 34 04 00
	00		 add	 rax, 1076		; 00000434H
  006a6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  006ae	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax
  006b5	eb 5d		 jmp	 SHORT $LN38@stbi__gif_
$LN37@stbi__gif_:

; 6807 :                 } else if (g->flags & 0x80) {

  006b7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  006bf	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  006c2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006c7	85 c0		 test	 eax, eax
  006c9	74 1d		 je	 SHORT $LN39@stbi__gif_

; 6808 :                     g->color_table = (stbi_uc *) g->pal;

  006cb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  006d3	48 83 c0 34	 add	 rax, 52			; 00000034H
  006d7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  006df	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax

; 6809 :                 } else

  006e6	eb 2c		 jmp	 SHORT $LN40@stbi__gif_
$LN39@stbi__gif_:

; 6810 :                     return stbi__errpuc("missing color table", "Corrupt GIF");

  006e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40651
  006ef	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  006f4	85 c0		 test	 eax, eax
  006f6	74 0a		 je	 SHORT $LN63@stbi__gif_
  006f8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv332[rsp], 0
  00700	eb 08		 jmp	 SHORT $LN64@stbi__gif_
$LN63@stbi__gif_:
  00702	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv332[rsp], 0
$LN64@stbi__gif_:
  0070a	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv332[rsp]
  0070f	e9 ac 02 00 00	 jmp	 $LN1@stbi__gif_
$LN40@stbi__gif_:
$LN38@stbi__gif_:

; 6811 :                 
; 6812 :                 o = stbi__process_gif_raster(s, g);

  00714	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  0071c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00724	e8 00 00 00 00	 call	 ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ; stbi__process_gif_raster
  00729	48 89 44 24 70	 mov	 QWORD PTR o$8[rsp], rax

; 6813 :                 if (!o) return NULL;

  0072e	48 83 7c 24 70
	00		 cmp	 QWORD PTR o$8[rsp], 0
  00734	75 07		 jne	 SHORT $LN41@stbi__gif_
  00736	33 c0		 xor	 eax, eax
  00738	e9 83 02 00 00	 jmp	 $LN1@stbi__gif_
$LN41@stbi__gif_:

; 6814 :                 
; 6815 :                 // if this was the first frame,
; 6816 :                 pcount = g->w * g->h;

  0073d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00745	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0074d	8b 00		 mov	 eax, DWORD PTR [rax]
  0074f	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00753	89 44 24 24	 mov	 DWORD PTR pcount$[rsp], eax

; 6817 :                 if (first_frame && (g->bgindex > 0)) {

  00757	83 7c 24 58 00	 cmp	 DWORD PTR first_frame$[rsp], 0
  0075c	0f 84 a5 00 00
	00		 je	 $LN42@stbi__gif_
  00762	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0076a	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  0076e	0f 8e 93 00 00
	00		 jle	 $LN42@stbi__gif_

; 6818 :                     // if first frame, any pixel not drawn to gets the background color
; 6819 :                     for (pi = 0; pi < pcount; ++pi) {

  00774	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  0077c	eb 0a		 jmp	 SHORT $LN15@stbi__gif_
$LN13@stbi__gif_:
  0077e	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  00782	ff c0		 inc	 eax
  00784	89 44 24 20	 mov	 DWORD PTR pi$[rsp], eax
$LN15@stbi__gif_:
  00788	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  0078c	39 44 24 20	 cmp	 DWORD PTR pi$[rsp], eax
  00790	7d 75		 jge	 SHORT $LN14@stbi__gif_

; 6820 :                         if (g->history[pi] == 0) {

  00792	48 63 44 24 20	 movsxd	 rax, DWORD PTR pi$[rsp]
  00797	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0079f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  007a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007a7	85 c0		 test	 eax, eax
  007a9	75 57		 jne	 SHORT $LN43@stbi__gif_

; 6821 :                             g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;

  007ab	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007b3	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  007b7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  007bf	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  007c4	b9 01 00 00 00	 mov	 ecx, 1
  007c9	48 6b c9 03	 imul	 rcx, rcx, 3
  007cd	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 6822 :                             memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );

  007d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007d9	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  007dd	8b 4c 24 20	 mov	 ecx, DWORD PTR pi$[rsp]
  007e1	c1 e1 02	 shl	 ecx, 2
  007e4	48 63 c9	 movsxd	 rcx, ecx
  007e7	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  007ef	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  007f3	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR g$[rsp]
  007fb	8b 44 87 34	 mov	 eax, DWORD PTR [rdi+rax*4+52]
  007ff	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN43@stbi__gif_:

; 6823 :                         }
; 6824 :                     }

  00802	e9 77 ff ff ff	 jmp	 $LN13@stbi__gif_
$LN14@stbi__gif_:
$LN42@stbi__gif_:

; 6825 :                 }
; 6826 :                 
; 6827 :                 return o;

  00807	48 8b 44 24 70	 mov	 rax, QWORD PTR o$8[rsp]
  0080c	e9 af 01 00 00	 jmp	 $LN1@stbi__gif_
$LN44@stbi__gif_:

; 6828 :             }
; 6829 :             
; 6830 :             case 0x21: // Comment Extension.
; 6831 :             {
; 6832 :                 int len;
; 6833 :                 int ext = stbi__get8(s);

  00811	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00819	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0081e	0f b6 c0	 movzx	 eax, al
  00821	89 44 24 68	 mov	 DWORD PTR ext$7[rsp], eax

; 6834 :                 if (ext == 0xF9) { // Graphic Control Extension.

  00825	81 7c 24 68 f9
	00 00 00	 cmp	 DWORD PTR ext$7[rsp], 249 ; 000000f9H
  0082d	0f 85 25 01 00
	00		 jne	 $LN45@stbi__gif_

; 6835 :                     len = stbi__get8(s);

  00833	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0083b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00840	0f b6 c0	 movzx	 eax, al
  00843	89 44 24 28	 mov	 DWORD PTR len$1[rsp], eax

; 6836 :                     if (len == 4) {

  00847	83 7c 24 28 04	 cmp	 DWORD PTR len$1[rsp], 4
  0084c	0f 85 f3 00 00
	00		 jne	 $LN46@stbi__gif_

; 6837 :                         g->eflags = stbi__get8(s);

  00852	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0085a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0085f	0f b6 c0	 movzx	 eax, al
  00862	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0086a	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 6838 :                         g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

  0086d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00875	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0087a	6b c0 0a	 imul	 eax, eax, 10
  0087d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00885	89 81 68 88 00
	00		 mov	 DWORD PTR [rcx+34920], eax

; 6839 :                         
; 6840 :                         // unset old transparent
; 6841 :                         if (g->transparent >= 0) {

  0088b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00893	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00897	7c 26		 jl	 SHORT $LN48@stbi__gif_

; 6842 :                             g->pal[g->transparent][3] = 255;

  00899	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  008a1	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  008a5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  008ad	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  008b2	b9 01 00 00 00	 mov	 ecx, 1
  008b7	48 6b c9 03	 imul	 rcx, rcx, 3
  008bb	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH
$LN48@stbi__gif_:

; 6843 :                         }
; 6844 :                         if (g->eflags & 0x01) {

  008bf	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  008c7	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  008ca	83 e0 01	 and	 eax, 1
  008cd	85 c0		 test	 eax, eax
  008cf	74 51		 je	 SHORT $LN49@stbi__gif_

; 6845 :                             g->transparent = stbi__get8(s);

  008d1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008d9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  008de	0f b6 c0	 movzx	 eax, al
  008e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  008e9	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 6846 :                             if (g->transparent >= 0) {

  008ec	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  008f4	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  008f8	7c 26		 jl	 SHORT $LN51@stbi__gif_

; 6847 :                                 g->pal[g->transparent][3] = 0;

  008fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00902	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  00906	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0090e	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  00913	b9 01 00 00 00	 mov	 ecx, 1
  00918	48 6b c9 03	 imul	 rcx, rcx, 3
  0091c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN51@stbi__gif_:

; 6848 :                             }
; 6849 :                         } else {

  00920	eb 21		 jmp	 SHORT $LN50@stbi__gif_
$LN49@stbi__gif_:

; 6850 :                             // don't need transparent
; 6851 :                             stbi__skip(s, 1);

  00922	ba 01 00 00 00	 mov	 edx, 1
  00927	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0092f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6852 :                             g->transparent = -1;

  00934	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0093c	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1
$LN50@stbi__gif_:

; 6853 :                         }
; 6854 :                     } else {

  00943	eb 13		 jmp	 SHORT $LN47@stbi__gif_
$LN46@stbi__gif_:

; 6855 :                         stbi__skip(s, len);

  00945	8b 54 24 28	 mov	 edx, DWORD PTR len$1[rsp]
  00949	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00951	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6856 :                         break;

  00956	eb 63		 jmp	 SHORT $LN11@stbi__gif_
$LN47@stbi__gif_:
$LN45@stbi__gif_:
$LN16@stbi__gif_:

; 6857 :                     }
; 6858 :                 }
; 6859 :                 while ((len = stbi__get8(s)) != 0) {

  00958	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00960	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00965	0f b6 c0	 movzx	 eax, al
  00968	89 44 24 28	 mov	 DWORD PTR len$1[rsp], eax
  0096c	83 7c 24 28 00	 cmp	 DWORD PTR len$1[rsp], 0
  00971	74 13		 je	 SHORT $LN17@stbi__gif_

; 6860 :                     stbi__skip(s, len);

  00973	8b 54 24 28	 mov	 edx, DWORD PTR len$1[rsp]
  00977	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0097f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6861 :                 }

  00984	eb d2		 jmp	 SHORT $LN16@stbi__gif_
$LN17@stbi__gif_:

; 6862 :                 break;

  00986	eb 33		 jmp	 SHORT $LN11@stbi__gif_
$LN52@stbi__gif_:

; 6863 :             }
; 6864 :             
; 6865 :             case 0x3B: // gif stream termination code
; 6866 :             return (stbi_uc *) s; // using '1' causes warning on some compilers

  00988	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00990	eb 2e		 jmp	 SHORT $LN1@stbi__gif_
$LN53@stbi__gif_:

; 6867 :             
; 6868 :             default:
; 6869 :             return stbi__errpuc("unknown code", "Corrupt GIF");

  00992	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40665
  00999	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0099e	85 c0		 test	 eax, eax
  009a0	74 0a		 je	 SHORT $LN65@stbi__gif_
  009a2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv431[rsp], 0
  009aa	eb 08		 jmp	 SHORT $LN66@stbi__gif_
$LN65@stbi__gif_:
  009ac	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv431[rsp], 0
$LN66@stbi__gif_:
  009b4	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv431[rsp]
  009b9	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN11@stbi__gif_:

; 6870 :         }
; 6871 :     }

  009bb	e9 d3 f9 ff ff	 jmp	 $LN8@stbi__gif_
$LN1@stbi__gif_:

; 6872 : }

  009c0	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  009c7	5f		 pop	 rdi
  009c8	5e		 pop	 rsi
  009c9	c3		 ret	 0
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ENDP ; stbi__gif_load_next
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
lzw_cs$ = 32
tv192 = 33
avail$ = 36
len$ = 40
codesize$ = 44
init_code$ = 48
code$1 = 52
valid_bits$ = 56
bits$ = 60
clear$ = 64
oldcode$ = 68
codemask$ = 72
first$ = 76
tv163 = 80
tv175 = 84
tv197 = 88
tv210 = 92
p$ = 96
tv242 = 104
tv246 = 108
tv273 = 112
tv299 = 116
s$ = 144
g$ = 152
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z PROC ; stbi__process_gif_raster

; 6614 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 6615 :     stbi_uc lzw_cs;
; 6616 :     stbi__int32 len, init_code;
; 6617 :     stbi__uint32 first;
; 6618 :     stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6619 :     stbi__gif_lzw *p;
; 6620 :     
; 6621 :     lzw_cs = stbi__get8(s);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00019	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0001e	88 44 24 20	 mov	 BYTE PTR lzw_cs$[rsp], al

; 6622 :     if (lzw_cs > 12) return NULL;

  00022	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00027	83 f8 0c	 cmp	 eax, 12
  0002a	7e 07		 jle	 SHORT $LN10@stbi__proc
  0002c	33 c0		 xor	 eax, eax
  0002e	e9 0e 04 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 6623 :     clear = 1 << lzw_cs;

  00033	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00038	b9 01 00 00 00	 mov	 ecx, 1
  0003d	89 4c 24 68	 mov	 DWORD PTR tv242[rsp], ecx
  00041	0f b6 c8	 movzx	 ecx, al
  00044	8b 44 24 68	 mov	 eax, DWORD PTR tv242[rsp]
  00048	d3 e0		 shl	 eax, cl
  0004a	89 44 24 40	 mov	 DWORD PTR clear$[rsp], eax

; 6624 :     first = 1;

  0004e	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1

; 6625 :     codesize = lzw_cs + 1;

  00056	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	89 44 24 2c	 mov	 DWORD PTR codesize$[rsp], eax

; 6626 :     codemask = (1 << codesize) - 1;

  00061	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  00065	b9 01 00 00 00	 mov	 ecx, 1
  0006a	89 4c 24 6c	 mov	 DWORD PTR tv246[rsp], ecx
  0006e	0f b6 c8	 movzx	 ecx, al
  00071	8b 44 24 6c	 mov	 eax, DWORD PTR tv246[rsp]
  00075	d3 e0		 shl	 eax, cl
  00077	ff c8		 dec	 eax
  00079	89 44 24 48	 mov	 DWORD PTR codemask$[rsp], eax

; 6627 :     bits = 0;

  0007d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 6628 :     valid_bits = 0;

  00085	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR valid_bits$[rsp], 0

; 6629 :     for (init_code = 0; init_code < clear; init_code++) {

  0008d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR init_code$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  00097	8b 44 24 30	 mov	 eax, DWORD PTR init_code$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 30	 mov	 DWORD PTR init_code$[rsp], eax
$LN4@stbi__proc:
  000a1	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  000a5	39 44 24 30	 cmp	 DWORD PTR init_code$[rsp], eax
  000a9	7d 4e		 jge	 SHORT $LN3@stbi__proc

; 6630 :         g->codes[init_code].prefix = -1;

  000ab	48 63 44 24 30	 movsxd	 rax, DWORD PTR init_code$[rsp]
  000b0	b9 ff ff ff ff	 mov	 ecx, -1
  000b5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  000bd	66 89 8c 82 34
	08 00 00	 mov	 WORD PTR [rdx+rax*4+2100], cx

; 6631 :         g->codes[init_code].first = (stbi_uc) init_code;

  000c5	48 63 44 24 30	 movsxd	 rax, DWORD PTR init_code$[rsp]
  000ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000d2	0f b6 54 24 30	 movzx	 edx, BYTE PTR init_code$[rsp]
  000d7	88 94 81 36 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2102], dl

; 6632 :         g->codes[init_code].suffix = (stbi_uc) init_code;

  000de	48 63 44 24 30	 movsxd	 rax, DWORD PTR init_code$[rsp]
  000e3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000eb	0f b6 54 24 30	 movzx	 edx, BYTE PTR init_code$[rsp]
  000f0	88 94 81 37 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2103], dl

; 6633 :     }

  000f7	eb 9e		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 6634 :     
; 6635 :     // support no starting clear code
; 6636 :     avail = clear+2;

  000f9	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  000fd	83 c0 02	 add	 eax, 2
  00100	89 44 24 24	 mov	 DWORD PTR avail$[rsp], eax

; 6637 :     oldcode = -1;

  00104	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR oldcode$[rsp], -1

; 6638 :     
; 6639 :     len = 0;

  0010c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN5@stbi__proc:

; 6640 :     for(;;) {
; 6641 :         if (valid_bits < codesize) {

  00114	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  00118	39 44 24 38	 cmp	 DWORD PTR valid_bits$[rsp], eax
  0011c	7d 6f		 jge	 SHORT $LN11@stbi__proc

; 6642 :             if (len == 0) {

  0011e	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00123	75 2c		 jne	 SHORT $LN13@stbi__proc

; 6643 :                 len = stbi__get8(s); // start new block

  00125	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00132	0f b6 c0	 movzx	 eax, al
  00135	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6644 :                 if (len == 0)

  00139	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  0013e	75 11		 jne	 SHORT $LN14@stbi__proc

; 6645 :                     return g->out;

  00140	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00148	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0014c	e9 f0 02 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:
$LN13@stbi__proc:

; 6646 :             }
; 6647 :             --len;

  00151	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00155	ff c8		 dec	 eax
  00157	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6648 :             bits |= (stbi__int32) stbi__get8(s) << valid_bits;

  0015b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00163	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00168	0f b6 c0	 movzx	 eax, al
  0016b	8b 4c 24 38	 mov	 ecx, DWORD PTR valid_bits$[rsp]
  0016f	d3 e0		 shl	 eax, cl
  00171	8b 4c 24 3c	 mov	 ecx, DWORD PTR bits$[rsp]
  00175	0b c8		 or	 ecx, eax
  00177	8b c1		 mov	 eax, ecx
  00179	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 6649 :             valid_bits += 8;

  0017d	8b 44 24 38	 mov	 eax, DWORD PTR valid_bits$[rsp]
  00181	83 c0 08	 add	 eax, 8
  00184	89 44 24 38	 mov	 DWORD PTR valid_bits$[rsp], eax

; 6650 :         } else {

  00188	e9 af 02 00 00	 jmp	 $LN12@stbi__proc
$LN11@stbi__proc:

; 6651 :             stbi__int32 code = bits & codemask;

  0018d	8b 44 24 48	 mov	 eax, DWORD PTR codemask$[rsp]
  00191	8b 4c 24 3c	 mov	 ecx, DWORD PTR bits$[rsp]
  00195	23 c8		 and	 ecx, eax
  00197	8b c1		 mov	 eax, ecx
  00199	89 44 24 34	 mov	 DWORD PTR code$1[rsp], eax

; 6652 :             bits >>= codesize;

  0019d	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  001a1	0f b6 c8	 movzx	 ecx, al
  001a4	8b 44 24 3c	 mov	 eax, DWORD PTR bits$[rsp]
  001a8	d3 f8		 sar	 eax, cl
  001aa	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 6653 :             valid_bits -= codesize;

  001ae	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  001b2	8b 4c 24 38	 mov	 ecx, DWORD PTR valid_bits$[rsp]
  001b6	2b c8		 sub	 ecx, eax
  001b8	8b c1		 mov	 eax, ecx
  001ba	89 44 24 38	 mov	 DWORD PTR valid_bits$[rsp], eax

; 6654 :             // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6655 :             if (code == clear) {  // clear code

  001be	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  001c2	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  001c6	75 47		 jne	 SHORT $LN15@stbi__proc

; 6656 :                 codesize = lzw_cs + 1;

  001c8	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  001cd	ff c0		 inc	 eax
  001cf	89 44 24 2c	 mov	 DWORD PTR codesize$[rsp], eax

; 6657 :                 codemask = (1 << codesize) - 1;

  001d3	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	89 4c 24 70	 mov	 DWORD PTR tv273[rsp], ecx
  001e0	0f b6 c8	 movzx	 ecx, al
  001e3	8b 44 24 70	 mov	 eax, DWORD PTR tv273[rsp]
  001e7	d3 e0		 shl	 eax, cl
  001e9	ff c8		 dec	 eax
  001eb	89 44 24 48	 mov	 DWORD PTR codemask$[rsp], eax

; 6658 :                 avail = clear + 2;

  001ef	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  001f3	83 c0 02	 add	 eax, 2
  001f6	89 44 24 24	 mov	 DWORD PTR avail$[rsp], eax

; 6659 :                 oldcode = -1;

  001fa	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR oldcode$[rsp], -1

; 6660 :                 first = 0;

  00202	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0
  0020a	e9 2d 02 00 00	 jmp	 $LN16@stbi__proc
$LN15@stbi__proc:

; 6661 :             } else if (code == clear + 1) { // end of stream code

  0020f	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  00213	ff c0		 inc	 eax
  00215	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00219	75 55		 jne	 SHORT $LN17@stbi__proc

; 6662 :                 stbi__skip(s, len);

  0021b	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0021f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00227	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN8@stbi__proc:

; 6663 :                 while ((len = stbi__get8(s)) > 0)

  0022c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00234	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00239	0f b6 c0	 movzx	 eax, al
  0023c	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
  00240	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00245	7e 13		 jle	 SHORT $LN9@stbi__proc

; 6664 :                     stbi__skip(s,len);

  00247	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0024b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00253	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
  00258	eb d2		 jmp	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:

; 6665 :                 return g->out;

  0025a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00262	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00266	e9 d6 01 00 00	 jmp	 $LN1@stbi__proc
  0026b	e9 cc 01 00 00	 jmp	 $LN18@stbi__proc
$LN17@stbi__proc:

; 6666 :             } else if (code <= avail) {

  00270	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  00274	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00278	0f 8f 95 01 00
	00		 jg	 $LN19@stbi__proc

; 6667 :                 if (first) {

  0027e	83 7c 24 4c 00	 cmp	 DWORD PTR first$[rsp], 0
  00283	74 2c		 je	 SHORT $LN21@stbi__proc

; 6668 :                     return stbi__errpuc("no clear code", "Corrupt GIF");

  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40564
  0028c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00291	85 c0		 test	 eax, eax
  00293	74 0a		 je	 SHORT $LN28@stbi__proc
  00295	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
  0029d	eb 08		 jmp	 SHORT $LN29@stbi__proc
$LN28@stbi__proc:
  0029f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN29@stbi__proc:
  002a7	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv163[rsp]
  002ac	e9 90 01 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 6669 :                 }
; 6670 :                 
; 6671 :                 if (oldcode >= 0) {

  002b1	83 7c 24 44 00	 cmp	 DWORD PTR oldcode$[rsp], 0
  002b6	0f 8c c5 00 00
	00		 jl	 $LN22@stbi__proc

; 6672 :                     p = &g->codes[avail++];

  002bc	48 63 44 24 24	 movsxd	 rax, DWORD PTR avail$[rsp]
  002c1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  002c9	48 8d 84 81 34
	08 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+2100]
  002d1	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
  002d6	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  002da	ff c0		 inc	 eax
  002dc	89 44 24 24	 mov	 DWORD PTR avail$[rsp], eax

; 6673 :                     if (avail > 8192) {

  002e0	81 7c 24 24 00
	20 00 00	 cmp	 DWORD PTR avail$[rsp], 8192 ; 00002000H
  002e8	7e 2c		 jle	 SHORT $LN24@stbi__proc

; 6674 :                         return stbi__errpuc("too many codes", "Corrupt GIF");

  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40568
  002f1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002f6	85 c0		 test	 eax, eax
  002f8	74 0a		 je	 SHORT $LN30@stbi__proc
  002fa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
  00302	eb 08		 jmp	 SHORT $LN31@stbi__proc
$LN30@stbi__proc:
  00304	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN31@stbi__proc:
  0030c	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv175[rsp]
  00311	e9 2b 01 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 6675 :                     }
; 6676 :                     
; 6677 :                     p->prefix = (stbi__int16) oldcode;

  00316	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0031b	0f b7 4c 24 44	 movzx	 ecx, WORD PTR oldcode$[rsp]
  00320	66 89 08	 mov	 WORD PTR [rax], cx

; 6678 :                     p->first = g->codes[oldcode].first;

  00323	48 63 44 24 44	 movsxd	 rax, DWORD PTR oldcode$[rsp]
  00328	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0032d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00335	0f b6 84 82 36
	08 00 00	 movzx	 eax, BYTE PTR [rdx+rax*4+2102]
  0033d	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6679 :                     p->suffix = (code == avail) ? p->first : g->codes[code].first;

  00340	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  00344	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00348	75 0f		 jne	 SHORT $LN32@stbi__proc
  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0034f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00353	88 44 24 21	 mov	 BYTE PTR tv192[rsp], al
  00357	eb 19		 jmp	 SHORT $LN33@stbi__proc
$LN32@stbi__proc:
  00359	48 63 44 24 34	 movsxd	 rax, DWORD PTR code$1[rsp]
  0035e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00366	0f b6 84 81 36
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2102]
  0036e	88 44 24 21	 mov	 BYTE PTR tv192[rsp], al
$LN33@stbi__proc:
  00372	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00377	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv192[rsp]
  0037c	88 48 03	 mov	 BYTE PTR [rax+3], cl
  0037f	eb 36		 jmp	 SHORT $LN23@stbi__proc
$LN22@stbi__proc:

; 6680 :                 } else if (code == avail)

  00381	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  00385	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00389	75 2c		 jne	 SHORT $LN25@stbi__proc

; 6681 :                     return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40570
  00392	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00397	85 c0		 test	 eax, eax
  00399	74 0a		 je	 SHORT $LN34@stbi__proc
  0039b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
  003a3	eb 08		 jmp	 SHORT $LN35@stbi__proc
$LN34@stbi__proc:
  003a5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
$LN35@stbi__proc:
  003ad	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv197[rsp]
  003b2	e9 8a 00 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:
$LN23@stbi__proc:

; 6682 :                 
; 6683 :                 stbi__out_gif_code(g, (stbi__uint16) code);

  003b7	0f b7 54 24 34	 movzx	 edx, WORD PTR code$1[rsp]
  003bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  003c4	e8 00 00 00 00	 call	 ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code

; 6684 :                 
; 6685 :                 if ((avail & codemask) == 0 && avail <= 0x0FFF) {

  003c9	8b 44 24 48	 mov	 eax, DWORD PTR codemask$[rsp]
  003cd	8b 4c 24 24	 mov	 ecx, DWORD PTR avail$[rsp]
  003d1	23 c8		 and	 ecx, eax
  003d3	8b c1		 mov	 eax, ecx
  003d5	85 c0		 test	 eax, eax
  003d7	75 30		 jne	 SHORT $LN26@stbi__proc
  003d9	81 7c 24 24 ff
	0f 00 00	 cmp	 DWORD PTR avail$[rsp], 4095 ; 00000fffH
  003e1	7f 26		 jg	 SHORT $LN26@stbi__proc

; 6686 :                     codesize++;

  003e3	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  003e7	ff c0		 inc	 eax
  003e9	89 44 24 2c	 mov	 DWORD PTR codesize$[rsp], eax

; 6687 :                     codemask = (1 << codesize) - 1;

  003ed	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  003f1	b9 01 00 00 00	 mov	 ecx, 1
  003f6	89 4c 24 74	 mov	 DWORD PTR tv299[rsp], ecx
  003fa	0f b6 c8	 movzx	 ecx, al
  003fd	8b 44 24 74	 mov	 eax, DWORD PTR tv299[rsp]
  00401	d3 e0		 shl	 eax, cl
  00403	ff c8		 dec	 eax
  00405	89 44 24 48	 mov	 DWORD PTR codemask$[rsp], eax
$LN26@stbi__proc:

; 6688 :                 }
; 6689 :                 
; 6690 :                 oldcode = code;

  00409	8b 44 24 34	 mov	 eax, DWORD PTR code$1[rsp]
  0040d	89 44 24 44	 mov	 DWORD PTR oldcode$[rsp], eax

; 6691 :             } else {

  00411	eb 29		 jmp	 SHORT $LN20@stbi__proc
$LN19@stbi__proc:

; 6692 :                 return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  00413	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40572
  0041a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0041f	85 c0		 test	 eax, eax
  00421	74 0a		 je	 SHORT $LN36@stbi__proc
  00423	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
  0042b	eb 08		 jmp	 SHORT $LN37@stbi__proc
$LN36@stbi__proc:
  0042d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN37@stbi__proc:
  00435	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv210[rsp]
  0043a	eb 05		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:
$LN18@stbi__proc:
$LN16@stbi__proc:
$LN12@stbi__proc:

; 6693 :             }
; 6694 :         }
; 6695 :     }

  0043c	e9 d3 fc ff ff	 jmp	 $LN5@stbi__proc
$LN1@stbi__proc:

; 6696 : }

  00441	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00448	c3		 ret	 0
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ENDP ; stbi__process_gif_raster
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
idx$ = 32
tv256 = 36
c$ = 40
p$ = 48
g$ = 80
code$ = 88
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z PROC		; stbi__out_gif_code

; 6577 : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6578 :     stbi_uc *p, *c;
; 6579 :     int idx;
; 6580 :     
; 6581 :     // recurse to decode the prefixes, since the linked-list is backwards,
; 6582 :     // and working backwards through an interleaved image would be nasty
; 6583 :     if (g->codes[code].prefix >= 0)

  0000e	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00018	0f bf 84 81 34
	08 00 00	 movsx	 eax, WORD PTR [rcx+rax*4+2100]
  00020	85 c0		 test	 eax, eax
  00022	7c 1c		 jl	 SHORT $LN4@stbi__out_

; 6584 :         stbi__out_gif_code(g, g->codes[code].prefix);

  00024	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0002e	0f b7 94 81 34
	08 00 00	 movzx	 edx, WORD PTR [rcx+rax*4+2100]
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code
$LN4@stbi__out_:

; 6585 :     
; 6586 :     if (g->cur_y >= g->max_y) return;

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0004a	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00050	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00056	7c 05		 jl	 SHORT $LN5@stbi__out_
  00058	e9 34 02 00 00	 jmp	 $LN1@stbi__out_
$LN5@stbi__out_:

; 6587 :     
; 6588 :     idx = g->cur_x + g->cur_y;

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00062	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0006d	03 81 60 88 00
	00		 add	 eax, DWORD PTR [rcx+34912]
  00073	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 6589 :     p = &g->out[idx];

  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00081	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 6590 :     g->history[idx / 4] = 1;

  00090	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  00094	99		 cdq
  00095	83 e2 03	 and	 edx, 3
  00098	03 c2		 add	 eax, edx
  0009a	c1 f8 02	 sar	 eax, 2
  0009d	48 98		 cdqe
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000a4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a8	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 6591 :     
; 6592 :     c = &g->color_table[g->codes[code].suffix * 4];

  000ac	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000b6	0f b6 84 81 37
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2103]
  000be	c1 e0 02	 shl	 eax, 2
  000c1	48 98		 cdqe
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000c8	48 8b 89 38 88
	00 00		 mov	 rcx, QWORD PTR [rcx+34872]
  000cf	48 03 c8	 add	 rcx, rax
  000d2	48 8b c1	 mov	 rax, rcx
  000d5	48 89 44 24 28	 mov	 QWORD PTR c$[rsp], rax

; 6593 :     if (c[3] > 128) { // don't render transparent pixels;

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	48 6b c0 03	 imul	 rax, rax, 3
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR c$[rsp]
  000e8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ec	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000f1	0f 8e 90 00 00
	00		 jle	 $LN6@stbi__out_

; 6594 :         p[0] = c[2];

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	48 6b c0 02	 imul	 rax, rax, 2
  00100	b9 01 00 00 00	 mov	 ecx, 1
  00105	48 6b c9 00	 imul	 rcx, rcx, 0
  00109	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0010e	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00113	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00118	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6595 :         p[1] = c[1];

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	48 6b c0 01	 imul	 rax, rax, 1
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00132	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00137	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0013c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6596 :         p[2] = c[0];

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	48 6b c0 00	 imul	 rax, rax, 0
  00148	b9 01 00 00 00	 mov	 ecx, 1
  0014d	48 6b c9 02	 imul	 rcx, rcx, 2
  00151	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00156	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  0015b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00160	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6597 :         p[3] = c[3];

  00163	b8 01 00 00 00	 mov	 eax, 1
  00168	48 6b c0 03	 imul	 rax, rax, 3
  0016c	b9 01 00 00 00	 mov	 ecx, 1
  00171	48 6b c9 03	 imul	 rcx, rcx, 3
  00175	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0017a	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  0017f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00184	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN6@stbi__out_:

; 6598 :     }
; 6599 :     g->cur_x += 4;

  00187	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  0018c	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  00192	83 c0 04	 add	 eax, 4
  00195	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0019a	89 81 5c 88 00
	00		 mov	 DWORD PTR [rcx+34908], eax

; 6600 :     
; 6601 :     if (g->cur_x >= g->max_x) {

  001a0	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001aa	8b 89 54 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34900]
  001b0	39 88 5c 88 00
	00		 cmp	 DWORD PTR [rax+34908], ecx
  001b6	0f 8c d5 00 00
	00		 jl	 $LN7@stbi__out_

; 6602 :         g->cur_x = g->start_x;

  001bc	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001c6	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  001cc	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6603 :         g->cur_y += g->step;

  001d2	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001d7	8b 80 60 88 00
	00		 mov	 eax, DWORD PTR [rax+34912]
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001e2	03 81 44 88 00
	00		 add	 eax, DWORD PTR [rcx+34884]
  001e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001ed	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax
$LN2@stbi__out_:

; 6604 :         
; 6605 :         while (g->cur_y >= g->max_y && g->parse > 0) {

  001f3	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001fd	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00203	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00209	0f 8c 82 00 00
	00		 jl	 $LN3@stbi__out_
  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00214	83 b8 40 88 00
	00 00		 cmp	 DWORD PTR [rax+34880], 0
  0021b	7e 74		 jle	 SHORT $LN3@stbi__out_

; 6606 :             g->step = (1 << g->parse) * g->line_size;

  0021d	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00222	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  00228	b9 01 00 00 00	 mov	 ecx, 1
  0022d	89 4c 24 24	 mov	 DWORD PTR tv256[rsp], ecx
  00231	0f b6 c8	 movzx	 ecx, al
  00234	8b 44 24 24	 mov	 eax, DWORD PTR tv256[rsp]
  00238	d3 e0		 shl	 eax, cl
  0023a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0023f	0f af 81 64 88
	00 00		 imul	 eax, DWORD PTR [rcx+34916]
  00246	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0024b	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6607 :             g->cur_y = g->start_y + (g->step >> 1);

  00251	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00256	8b 80 44 88 00
	00		 mov	 eax, DWORD PTR [rax+34884]
  0025c	d1 f8		 sar	 eax, 1
  0025e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00263	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  00269	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0026e	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax

; 6608 :             --g->parse;

  00274	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00279	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  0027f	ff c8		 dec	 eax
  00281	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00286	89 81 40 88 00
	00		 mov	 DWORD PTR [rcx+34880], eax

; 6609 :         }

  0028c	e9 62 ff ff ff	 jmp	 $LN2@stbi__out_
$LN3@stbi__out_:
$LN7@stbi__out_:
$LN1@stbi__out_:

; 6610 :     }
; 6611 : }

  00291	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00295	c3		 ret	 0
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ENDP		; stbi__out_gif_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
g$ = 32
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z PROC ; stbi__gif_info_raw

; 6562 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6563 :     stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));

  00018	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  0001d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00022	48 89 44 24 20	 mov	 QWORD PTR g$[rsp], rax

; 6564 :     if (!g) return stbi__err("outofmem", "Out of memory");

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR g$[rsp], 0
  0002d	75 0e		 jne	 SHORT $LN2@stbi__gif_
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40497
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	eb 72		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6565 :     if (!stbi__gif_header(s, g, comp, 1)) {

  0003d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00043	4c 8b 44 24 58	 mov	 r8, QWORD PTR comp$[rsp]
  00048	48 8b 54 24 20	 mov	 rdx, QWORD PTR g$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00052	e8 00 00 00 00	 call	 ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
  00057	85 c0		 test	 eax, eax
  00059	75 18		 jne	 SHORT $LN3@stbi__gif_

; 6566 :         STBI_FREE(g);

  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  00060	e8 00 00 00 00	 call	 free

; 6567 :         stbi__rewind( s );

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6568 :         return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 3c		 jmp	 SHORT $LN1@stbi__gif_
$LN3@stbi__gif_:

; 6569 :     }
; 6570 :     if (x) *x = g->w;

  00073	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00079	74 0e		 je	 SHORT $LN4@stbi__gif_
  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  00085	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00087	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__gif_:

; 6571 :     if (y) *y = g->h;

  00089	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  0008f	74 0f		 je	 SHORT $LN5@stbi__gif_
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  0009b	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0009e	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__gif_:

; 6572 :     STBI_FREE(g);

  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  000a5	e8 00 00 00 00	 call	 free

; 6573 :     return 1;

  000aa	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6574 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z ENDP ; stbi__gif_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
version$ = 32
tv224 = 36
s$ = 64
g$ = 72
comp$ = 80
is_info$ = 88
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z PROC ; stbi__gif_header

; 6531 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6532 :     stbi_uc version;
; 6533 :     if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00022	0f b6 c0	 movzx	 eax, al
  00025	83 f8 47	 cmp	 eax, 71			; 00000047H
  00028	75 36		 jne	 SHORT $LN3@stbi__gif_
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00034	0f b6 c0	 movzx	 eax, al
  00037	83 f8 49	 cmp	 eax, 73			; 00000049H
  0003a	75 24		 jne	 SHORT $LN3@stbi__gif_
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00046	0f b6 c0	 movzx	 eax, al
  00049	83 f8 46	 cmp	 eax, 70			; 00000046H
  0004c	75 12		 jne	 SHORT $LN3@stbi__gif_
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00058	0f b6 c0	 movzx	 eax, al
  0005b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0005e	74 11		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6534 :         return stbi__err("not GIF", "Corrupt GIF");

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40474
  00067	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0006c	e9 96 01 00 00	 jmp	 $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6535 :     
; 6536 :     version = stbi__get8(s);

  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00076	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0007b	88 44 24 20	 mov	 BYTE PTR version$[rsp], al

; 6537 :     if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR version$[rsp]
  00084	83 f8 37	 cmp	 eax, 55			; 00000037H
  00087	74 1b		 je	 SHORT $LN4@stbi__gif_
  00089	0f b6 44 24 20	 movzx	 eax, BYTE PTR version$[rsp]
  0008e	83 f8 39	 cmp	 eax, 57			; 00000039H
  00091	74 11		 je	 SHORT $LN4@stbi__gif_
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40476
  0009a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0009f	e9 63 01 00 00	 jmp	 $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6538 :     if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ae	0f b6 c0	 movzx	 eax, al
  000b1	83 f8 61	 cmp	 eax, 97			; 00000061H
  000b4	74 11		 je	 SHORT $LN5@stbi__gif_
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40478
  000bd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000c2	e9 40 01 00 00	 jmp	 $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6539 :     
; 6540 :     stbi__g_failure_reason = "";

  000c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
  000cc	8b c0		 mov	 eax, eax
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40479
  000e8	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 6541 :     g->w = stbi__get16le(s);

  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  000fb	89 01		 mov	 DWORD PTR [rcx], eax

; 6542 :     g->h = stbi__get16le(s);

  000fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00102	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00107	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  0010c	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 6543 :     g->flags = stbi__get8(s);

  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00119	0f b6 c0	 movzx	 eax, al
  0011c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  00121	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 6544 :     g->bgindex = stbi__get8(s);

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00129	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0012e	0f b6 c0	 movzx	 eax, al
  00131	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  00136	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 6545 :     g->ratio = stbi__get8(s);

  00139	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00143	0f b6 c0	 movzx	 eax, al
  00146	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  0014b	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 6546 :     g->transparent = -1;

  0014e	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  00153	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1

; 6547 :     
; 6548 :     if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  0015a	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  0015f	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00165	7e 11		 jle	 SHORT $LN6@stbi__gif_
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40481
  0016e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00173	e9 8f 00 00 00	 jmp	 $LN1@stbi__gif_
$LN6@stbi__gif_:

; 6549 :     if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00178	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  0017d	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00184	7e 0e		 jle	 SHORT $LN7@stbi__gif_
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40483
  0018d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00192	eb 73		 jmp	 SHORT $LN1@stbi__gif_
$LN7@stbi__gif_:

; 6550 :     
; 6551 :     if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

  00194	48 83 7c 24 50
	00		 cmp	 QWORD PTR comp$[rsp], 0
  0019a	74 0b		 je	 SHORT $LN8@stbi__gif_
  0019c	48 8b 44 24 50	 mov	 rax, QWORD PTR comp$[rsp]
  001a1	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN8@stbi__gif_:

; 6552 :     
; 6553 :     if (is_info) return 1;

  001a7	83 7c 24 58 00	 cmp	 DWORD PTR is_info$[rsp], 0
  001ac	74 07		 je	 SHORT $LN9@stbi__gif_
  001ae	b8 01 00 00 00	 mov	 eax, 1
  001b3	eb 52		 jmp	 SHORT $LN1@stbi__gif_
$LN9@stbi__gif_:

; 6554 :     
; 6555 :     if (g->flags & 0x80)

  001b5	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  001ba	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001bd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001c2	85 c0		 test	 eax, eax
  001c4	74 3c		 je	 SHORT $LN10@stbi__gif_

; 6556 :         stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

  001c6	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  001cb	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001ce	83 e0 07	 and	 eax, 7
  001d1	b9 02 00 00 00	 mov	 ecx, 2
  001d6	89 4c 24 24	 mov	 DWORD PTR tv224[rsp], ecx
  001da	0f b6 c8	 movzx	 ecx, al
  001dd	8b 44 24 24	 mov	 eax, DWORD PTR tv224[rsp]
  001e1	d3 e0		 shl	 eax, cl
  001e3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  001e8	48 83 c1 34	 add	 rcx, 52			; 00000034H
  001ec	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  001f2	44 8b c0	 mov	 r8d, eax
  001f5	48 8b d1	 mov	 rdx, rcx
  001f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	e8 00 00 00 00	 call	 ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable
$LN10@stbi__gif_:

; 6557 :     
; 6558 :     return 1;

  00202	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6559 : }

  00207	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0020b	c3		 ret	 0
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ENDP ; stbi__gif_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv93 = 36
s$ = 64
pal$ = 72
num_entries$ = 80
transp$ = 88
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z PROC ; stbi__gif_parse_colortable

; 6520 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6521 :     int i;
; 6522 :     for (i=0; i < num_entries; ++i) {

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00020	eb 0a		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  00022	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__gif_:
  0002c	8b 44 24 50	 mov	 eax, DWORD PTR num_entries$[rsp]
  00030	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00034	0f 8d ac 00 00
	00		 jge	 $LN3@stbi__gif_

; 6523 :         pal[i][2] = stbi__get8(s);

  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00044	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00049	48 8b 54 24 48	 mov	 rdx, QWORD PTR pal$[rsp]
  0004e	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00052	ba 01 00 00 00	 mov	 edx, 1
  00057	48 6b d2 02	 imul	 rdx, rdx, 2
  0005b	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6524 :         pal[i][1] = stbi__get8(s);

  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00068	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006d	48 8b 54 24 48	 mov	 rdx, QWORD PTR pal$[rsp]
  00072	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00076	ba 01 00 00 00	 mov	 edx, 1
  0007b	48 6b d2 01	 imul	 rdx, rdx, 1
  0007f	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6525 :         pal[i][0] = stbi__get8(s);

  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00087	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0008c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00091	48 8b 54 24 48	 mov	 rdx, QWORD PTR pal$[rsp]
  00096	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  0009a	ba 01 00 00 00	 mov	 edx, 1
  0009f	48 6b d2 00	 imul	 rdx, rdx, 0
  000a3	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6526 :         pal[i][3] = transp == i ? 0 : 255;

  000a6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000aa	39 44 24 58	 cmp	 DWORD PTR transp$[rsp], eax
  000ae	75 0a		 jne	 SHORT $LN6@stbi__gif_
  000b0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
  000b8	eb 08		 jmp	 SHORT $LN7@stbi__gif_
$LN6@stbi__gif_:
  000ba	c7 44 24 24 ff
	00 00 00	 mov	 DWORD PTR tv93[rsp], 255 ; 000000ffH
$LN7@stbi__gif_:
  000c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pal$[rsp]
  000cc	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	48 6b c9 03	 imul	 rcx, rcx, 3
  000d9	0f b6 54 24 24	 movzx	 edx, BYTE PTR tv93[rsp]
  000de	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 6527 :     }

  000e1	e9 3c ff ff ff	 jmp	 $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6528 : }

  000e6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ea	c3		 ret	 0
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ENDP ; stbi__gif_parse_colortable
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
sz$ = 32
s$ = 64
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__gif_test_raw

; 6503 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6504 :     int sz;
; 6505 :     if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	83 f8 47	 cmp	 eax, 71			; 00000047H
  00019	75 36		 jne	 SHORT $LN3@stbi__gif_
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00025	0f b6 c0	 movzx	 eax, al
  00028	83 f8 49	 cmp	 eax, 73			; 00000049H
  0002b	75 24		 jne	 SHORT $LN3@stbi__gif_
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00032	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00037	0f b6 c0	 movzx	 eax, al
  0003a	83 f8 46	 cmp	 eax, 70			; 00000046H
  0003d	75 12		 jne	 SHORT $LN3@stbi__gif_
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00044	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00049	0f b6 c0	 movzx	 eax, al
  0004c	83 f8 38	 cmp	 eax, 56			; 00000038H
  0004f	74 04		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:
  00051	33 c0		 xor	 eax, eax
  00053	eb 3e		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6506 :     sz = stbi__get8(s);

  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0005f	0f b6 c0	 movzx	 eax, al
  00062	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 6507 :     if (sz != '9' && sz != '7') return 0;

  00066	83 7c 24 20 39	 cmp	 DWORD PTR sz$[rsp], 57	; 00000039H
  0006b	74 0b		 je	 SHORT $LN4@stbi__gif_
  0006d	83 7c 24 20 37	 cmp	 DWORD PTR sz$[rsp], 55	; 00000037H
  00072	74 04		 je	 SHORT $LN4@stbi__gif_
  00074	33 c0		 xor	 eax, eax
  00076	eb 1b		 jmp	 SHORT $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6508 :     if (stbi__get8(s) != 'a') return 0;

  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0007d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00082	0f b6 c0	 movzx	 eax, al
  00085	83 f8 61	 cmp	 eax, 97			; 00000061H
  00088	74 04		 je	 SHORT $LN5@stbi__gif_
  0008a	33 c0		 xor	 eax, eax
  0008c	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6509 :     return 1;

  0008e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6510 : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__gif_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
count$1 = 32
count$2 = 36
i$3 = 40
dest$4 = 48
num_packets$ = 56
left$5 = 60
left$6 = 64
packet_idx$7 = 68
y$ = 72
act_comp$ = 76
tv155 = 80
x$8 = 84
i$9 = 88
packet$10 = 96
tv69 = 104
tv128 = 108
tv136 = 112
tv141 = 116
tv159 = 120
tv180 = 124
tv212 = 128
tv223 = 132
tv245 = 136
packet$11 = 144
chained$ = 152
value$12 = 156
value$13 = 160
packets$ = 168
__$ArrayPad$ = 200
s$ = 224
width$ = 232
height$ = 240
comp$ = 248
result$ = 256
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z PROC ; stbi__pic_load_core

; 6313 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6314 :     int act_comp=0,num_packets=0,y,chained;

  0002c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR act_comp$[rsp], 0
  00034	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR num_packets$[rsp], 0
$LN4@stbi__pic_:

; 6315 :     stbi__pic_packet packets[10];
; 6316 :     
; 6317 :     // this will (should...) cater for even some bizarre stuff like having data
; 6318 :     // for the same channel in multiple packets.
; 6319 :     do {
; 6320 :         stbi__pic_packet *packet;
; 6321 :         
; 6322 :         if (num_packets==sizeof(packets)/sizeof(packets[0]))

  0003c	48 63 44 24 38	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00041	48 83 f8 0a	 cmp	 rax, 10
  00045	75 2c		 jne	 SHORT $LN29@stbi__pic_

; 6323 :             return stbi__errpuc("bad format","too many packets");

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40319
  0004e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00053	85 c0		 test	 eax, eax
  00055	74 0a		 je	 SHORT $LN50@stbi__pic_
  00057	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  0005f	eb 08		 jmp	 SHORT $LN51@stbi__pic_
$LN50@stbi__pic_:
  00061	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN51@stbi__pic_:
  00069	48 63 44 24 68	 movsxd	 rax, DWORD PTR tv69[rsp]
  0006e	e9 ae 05 00 00	 jmp	 $LN1@stbi__pic_
$LN29@stbi__pic_:

; 6324 :         
; 6325 :         packet = &packets[num_packets++];

  00073	48 63 44 24 38	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00078	48 6b c0 03	 imul	 rax, rax, 3
  0007c	48 8d 84 04 a8
	00 00 00	 lea	 rax, QWORD PTR packets$[rsp+rax]
  00084	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR packet$11[rsp], rax
  0008c	8b 44 24 38	 mov	 eax, DWORD PTR num_packets$[rsp]
  00090	ff c0		 inc	 eax
  00092	89 44 24 38	 mov	 DWORD PTR num_packets$[rsp], eax

; 6326 :         
; 6327 :         chained = stbi__get8(s);

  00096	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	89 84 24 98 00
	00 00		 mov	 DWORD PTR chained$[rsp], eax

; 6328 :         packet->size    = stbi__get8(s);

  000ad	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ba	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR packet$11[rsp]
  000c2	88 01		 mov	 BYTE PTR [rcx], al

; 6329 :         packet->type    = stbi__get8(s);

  000c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cc	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR packet$11[rsp]
  000d9	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 6330 :         packet->channel = stbi__get8(s);

  000dc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR packet$11[rsp]
  000f1	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6331 :         
; 6332 :         act_comp |= packet->channel;

  000f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR packet$11[rsp]
  000fc	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00100	8b 4c 24 4c	 mov	 ecx, DWORD PTR act_comp$[rsp]
  00104	0b c8		 or	 ecx, eax
  00106	8b c1		 mov	 eax, ecx
  00108	89 44 24 4c	 mov	 DWORD PTR act_comp$[rsp], eax

; 6333 :         
; 6334 :         if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");

  0010c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00119	85 c0		 test	 eax, eax
  0011b	74 2c		 je	 SHORT $LN30@stbi__pic_
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40321
  00124	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00129	85 c0		 test	 eax, eax
  0012b	74 0a		 je	 SHORT $LN52@stbi__pic_
  0012d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
  00135	eb 08		 jmp	 SHORT $LN53@stbi__pic_
$LN52@stbi__pic_:
  00137	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN53@stbi__pic_:
  0013f	48 63 44 24 6c	 movsxd	 rax, DWORD PTR tv128[rsp]
  00144	e9 d8 04 00 00	 jmp	 $LN1@stbi__pic_
$LN30@stbi__pic_:

; 6335 :         if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");

  00149	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR packet$11[rsp]
  00151	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00154	83 f8 08	 cmp	 eax, 8
  00157	74 2c		 je	 SHORT $LN31@stbi__pic_
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40323
  00160	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00165	85 c0		 test	 eax, eax
  00167	74 0a		 je	 SHORT $LN54@stbi__pic_
  00169	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
  00171	eb 08		 jmp	 SHORT $LN55@stbi__pic_
$LN54@stbi__pic_:
  00173	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN55@stbi__pic_:
  0017b	48 63 44 24 70	 movsxd	 rax, DWORD PTR tv136[rsp]
  00180	e9 9c 04 00 00	 jmp	 $LN1@stbi__pic_
$LN31@stbi__pic_:

; 6336 :     } while (chained);

  00185	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR chained$[rsp], 0
  0018d	0f 85 a9 fe ff
	ff		 jne	 $LN4@stbi__pic_

; 6337 :     
; 6338 :     *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

  00193	8b 44 24 4c	 mov	 eax, DWORD PTR act_comp$[rsp]
  00197	83 e0 10	 and	 eax, 16
  0019a	85 c0		 test	 eax, eax
  0019c	74 0a		 je	 SHORT $LN56@stbi__pic_
  0019e	c7 44 24 74 04
	00 00 00	 mov	 DWORD PTR tv141[rsp], 4
  001a6	eb 08		 jmp	 SHORT $LN57@stbi__pic_
$LN56@stbi__pic_:
  001a8	c7 44 24 74 03
	00 00 00	 mov	 DWORD PTR tv141[rsp], 3
$LN57@stbi__pic_:
  001b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  001b8	8b 4c 24 74	 mov	 ecx, DWORD PTR tv141[rsp]
  001bc	89 08		 mov	 DWORD PTR [rax], ecx

; 6339 :     
; 6340 :     for(y=0; y<height; ++y) {

  001be	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR y$[rsp], 0
  001c6	eb 0a		 jmp	 SHORT $LN7@stbi__pic_
$LN5@stbi__pic_:
  001c8	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax
$LN7@stbi__pic_:
  001d2	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR height$[rsp]
  001d9	39 44 24 48	 cmp	 DWORD PTR y$[rsp], eax
  001dd	0f 8d 36 04 00
	00		 jge	 $LN6@stbi__pic_

; 6341 :         int packet_idx;
; 6342 :         
; 6343 :         for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {

  001e3	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR packet_idx$7[rsp], 0
  001eb	eb 0a		 jmp	 SHORT $LN10@stbi__pic_
$LN8@stbi__pic_:
  001ed	8b 44 24 44	 mov	 eax, DWORD PTR packet_idx$7[rsp]
  001f1	ff c0		 inc	 eax
  001f3	89 44 24 44	 mov	 DWORD PTR packet_idx$7[rsp], eax
$LN10@stbi__pic_:
  001f7	8b 44 24 38	 mov	 eax, DWORD PTR num_packets$[rsp]
  001fb	39 44 24 44	 cmp	 DWORD PTR packet_idx$7[rsp], eax
  001ff	0f 8d 0f 04 00
	00		 jge	 $LN9@stbi__pic_

; 6344 :             stbi__pic_packet *packet = &packets[packet_idx];

  00205	48 63 44 24 44	 movsxd	 rax, DWORD PTR packet_idx$7[rsp]
  0020a	48 6b c0 03	 imul	 rax, rax, 3
  0020e	48 8d 84 04 a8
	00 00 00	 lea	 rax, QWORD PTR packets$[rsp+rax]
  00216	48 89 44 24 60	 mov	 QWORD PTR packet$10[rsp], rax

; 6345 :             stbi_uc *dest = result+y*width*4;

  0021b	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  0021f	0f af 84 24 e8
	00 00 00	 imul	 eax, DWORD PTR width$[rsp]
  00227	c1 e0 02	 shl	 eax, 2
  0022a	48 98		 cdqe
  0022c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00234	48 03 c8	 add	 rcx, rax
  00237	48 8b c1	 mov	 rax, rcx
  0023a	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax

; 6346 :             
; 6347 :             switch (packet->type) {

  0023f	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  00244	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00248	88 44 24 50	 mov	 BYTE PTR tv155[rsp], al
  0024c	80 7c 24 50 00	 cmp	 BYTE PTR tv155[rsp], 0
  00251	74 42		 je	 SHORT $LN33@stbi__pic_
  00253	80 7c 24 50 01	 cmp	 BYTE PTR tv155[rsp], 1
  00258	0f 84 96 00 00
	00		 je	 $LN35@stbi__pic_
  0025e	80 7c 24 50 02	 cmp	 BYTE PTR tv155[rsp], 2
  00263	0f 84 96 01 00
	00		 je	 $LN39@stbi__pic_

; 6348 :                 default:
; 6349 :                 return stbi__errpuc("bad format","packet has bad compression type");

  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40325
  00270	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00275	85 c0		 test	 eax, eax
  00277	74 0a		 je	 SHORT $LN58@stbi__pic_
  00279	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  00281	eb 08		 jmp	 SHORT $LN59@stbi__pic_
$LN58@stbi__pic_:
  00283	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN59@stbi__pic_:
  0028b	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv159[rsp]
  00290	e9 8c 03 00 00	 jmp	 $LN1@stbi__pic_
$LN33@stbi__pic_:

; 6350 :                 
; 6351 :                 case 0: {//uncompressed
; 6352 :                     int x;
; 6353 :                     
; 6354 :                     for(x=0;x<width;++x, dest+=4)

  00295	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR x$8[rsp], 0
  0029d	eb 18		 jmp	 SHORT $LN15@stbi__pic_
$LN13@stbi__pic_:
  0029f	8b 44 24 54	 mov	 eax, DWORD PTR x$8[rsp]
  002a3	ff c0		 inc	 eax
  002a5	89 44 24 54	 mov	 DWORD PTR x$8[rsp], eax
  002a9	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  002ae	48 83 c0 04	 add	 rax, 4
  002b2	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN15@stbi__pic_:
  002b7	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  002be	39 44 24 54	 cmp	 DWORD PTR x$8[rsp], eax
  002c2	7d 2b		 jge	 SHORT $LN14@stbi__pic_

; 6355 :                         if (!stbi__readval(s,packet->channel,dest))

  002c4	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  002c9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  002cd	4c 8b 44 24 30	 mov	 r8, QWORD PTR dest$4[rsp]
  002d2	8b d0		 mov	 edx, eax
  002d4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002dc	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  002e1	48 85 c0	 test	 rax, rax
  002e4	75 07		 jne	 SHORT $LN34@stbi__pic_

; 6356 :                         return 0;

  002e6	33 c0		 xor	 eax, eax
  002e8	e9 34 03 00 00	 jmp	 $LN1@stbi__pic_
$LN34@stbi__pic_:
  002ed	eb b0		 jmp	 SHORT $LN13@stbi__pic_
$LN14@stbi__pic_:

; 6357 :                     break;

  002ef	e9 1b 03 00 00	 jmp	 $LN11@stbi__pic_
$LN35@stbi__pic_:

; 6358 :                 }
; 6359 :                 
; 6360 :                 case 1://Pure RLE
; 6361 :                 {
; 6362 :                     int left=width, i;

  002f4	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  002fb	89 44 24 3c	 mov	 DWORD PTR left$5[rsp], eax
$LN16@stbi__pic_:

; 6363 :                     
; 6364 :                     while (left>0) {

  002ff	83 7c 24 3c 00	 cmp	 DWORD PTR left$5[rsp], 0
  00304	0f 8e f0 00 00
	00		 jle	 $LN17@stbi__pic_

; 6365 :                         stbi_uc count,value[4];
; 6366 :                         
; 6367 :                         count=stbi__get8(s);

  0030a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00312	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00317	88 44 24 20	 mov	 BYTE PTR count$1[rsp], al

; 6368 :                         if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

  0031b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00323	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00328	85 c0		 test	 eax, eax
  0032a	74 2c		 je	 SHORT $LN36@stbi__pic_
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40330
  00333	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00338	85 c0		 test	 eax, eax
  0033a	74 0a		 je	 SHORT $LN60@stbi__pic_
  0033c	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
  00344	eb 08		 jmp	 SHORT $LN61@stbi__pic_
$LN60@stbi__pic_:
  00346	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN61@stbi__pic_:
  0034e	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv180[rsp]
  00353	e9 c9 02 00 00	 jmp	 $LN1@stbi__pic_
$LN36@stbi__pic_:

; 6369 :                         
; 6370 :                         if (count > left)

  00358	0f b6 44 24 20	 movzx	 eax, BYTE PTR count$1[rsp]
  0035d	3b 44 24 3c	 cmp	 eax, DWORD PTR left$5[rsp]
  00361	7e 09		 jle	 SHORT $LN37@stbi__pic_

; 6371 :                             count = (stbi_uc) left;

  00363	0f b6 44 24 3c	 movzx	 eax, BYTE PTR left$5[rsp]
  00368	88 44 24 20	 mov	 BYTE PTR count$1[rsp], al
$LN37@stbi__pic_:

; 6372 :                         
; 6373 :                         if (!stbi__readval(s,packet->channel,value))  return 0;

  0036c	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  00371	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00375	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR value$12[rsp]
  0037d	8b d0		 mov	 edx, eax
  0037f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00387	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  0038c	48 85 c0	 test	 rax, rax
  0038f	75 07		 jne	 SHORT $LN38@stbi__pic_
  00391	33 c0		 xor	 eax, eax
  00393	e9 89 02 00 00	 jmp	 $LN1@stbi__pic_
$LN38@stbi__pic_:

; 6374 :                         
; 6375 :                         for(i=0; i<count; ++i,dest+=4)

  00398	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$9[rsp], 0
  003a0	eb 18		 jmp	 SHORT $LN20@stbi__pic_
$LN18@stbi__pic_:
  003a2	8b 44 24 58	 mov	 eax, DWORD PTR i$9[rsp]
  003a6	ff c0		 inc	 eax
  003a8	89 44 24 58	 mov	 DWORD PTR i$9[rsp], eax
  003ac	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  003b1	48 83 c0 04	 add	 rax, 4
  003b5	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN20@stbi__pic_:
  003ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR count$1[rsp]
  003bf	39 44 24 58	 cmp	 DWORD PTR i$9[rsp], eax
  003c3	7d 1f		 jge	 SHORT $LN19@stbi__pic_

; 6376 :                             stbi__copyval(packet->channel,dest,value);

  003c5	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  003ca	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003ce	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR value$12[rsp]
  003d6	48 8b 54 24 30	 mov	 rdx, QWORD PTR dest$4[rsp]
  003db	8b c8		 mov	 ecx, eax
  003dd	e8 00 00 00 00	 call	 ?stbi__copyval@@YAXHPEAEPEBE@Z ; stbi__copyval
  003e2	eb be		 jmp	 SHORT $LN18@stbi__pic_
$LN19@stbi__pic_:

; 6377 :                         left -= count;

  003e4	0f b6 44 24 20	 movzx	 eax, BYTE PTR count$1[rsp]
  003e9	8b 4c 24 3c	 mov	 ecx, DWORD PTR left$5[rsp]
  003ed	2b c8		 sub	 ecx, eax
  003ef	8b c1		 mov	 eax, ecx
  003f1	89 44 24 3c	 mov	 DWORD PTR left$5[rsp], eax

; 6378 :                     }

  003f5	e9 05 ff ff ff	 jmp	 $LN16@stbi__pic_
$LN17@stbi__pic_:

; 6379 :                 }
; 6380 :                 break;

  003fa	e9 10 02 00 00	 jmp	 $LN11@stbi__pic_
$LN39@stbi__pic_:

; 6381 :                 
; 6382 :                 case 2: {//Mixed RLE
; 6383 :                     int left=width;

  003ff	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  00406	89 44 24 40	 mov	 DWORD PTR left$6[rsp], eax
$LN21@stbi__pic_:

; 6384 :                     while (left>0) {

  0040a	83 7c 24 40 00	 cmp	 DWORD PTR left$6[rsp], 0
  0040f	0f 8e fa 01 00
	00		 jle	 $LN22@stbi__pic_

; 6385 :                         int count = stbi__get8(s), i;

  00415	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0041d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00422	0f b6 c0	 movzx	 eax, al
  00425	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax

; 6386 :                         if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

  00429	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00431	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00436	85 c0		 test	 eax, eax
  00438	74 35		 je	 SHORT $LN40@stbi__pic_
  0043a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40335
  00441	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00446	85 c0		 test	 eax, eax
  00448	74 0d		 je	 SHORT $LN62@stbi__pic_
  0044a	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
  00455	eb 0b		 jmp	 SHORT $LN63@stbi__pic_
$LN62@stbi__pic_:
  00457	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN63@stbi__pic_:
  00462	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR tv212[rsp]
  0046a	e9 b2 01 00 00	 jmp	 $LN1@stbi__pic_
$LN40@stbi__pic_:

; 6387 :                         
; 6388 :                         if (count >= 128) { // Repeated

  0046f	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR count$2[rsp], 128 ; 00000080H
  00477	0f 8c e3 00 00
	00		 jl	 $LN41@stbi__pic_

; 6389 :                             stbi_uc value[4];
; 6390 :                             
; 6391 :                             if (count==128)

  0047d	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR count$2[rsp], 128 ; 00000080H
  00485	75 13		 jne	 SHORT $LN43@stbi__pic_

; 6392 :                                 count = stbi__get16be(s);

  00487	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0048f	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00494	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax
  00498	eb 0b		 jmp	 SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 6393 :                             else
; 6394 :                                 count -= 127;

  0049a	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  0049e	83 e8 7f	 sub	 eax, 127		; 0000007fH
  004a1	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax
$LN44@stbi__pic_:

; 6395 :                             if (count > left)

  004a5	8b 44 24 40	 mov	 eax, DWORD PTR left$6[rsp]
  004a9	39 44 24 24	 cmp	 DWORD PTR count$2[rsp], eax
  004ad	7e 35		 jle	 SHORT $LN45@stbi__pic_

; 6396 :                                 return stbi__errpuc("bad file","scanline overrun");

  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40341
  004b6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004bb	85 c0		 test	 eax, eax
  004bd	74 0d		 je	 SHORT $LN64@stbi__pic_
  004bf	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv223[rsp], 0
  004ca	eb 0b		 jmp	 SHORT $LN65@stbi__pic_
$LN64@stbi__pic_:
  004cc	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv223[rsp], 0
$LN65@stbi__pic_:
  004d7	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv223[rsp]
  004df	e9 3d 01 00 00	 jmp	 $LN1@stbi__pic_
$LN45@stbi__pic_:

; 6397 :                             
; 6398 :                             if (!stbi__readval(s,packet->channel,value))

  004e4	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  004e9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  004ed	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR value$13[rsp]
  004f5	8b d0		 mov	 edx, eax
  004f7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ff	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  00504	48 85 c0	 test	 rax, rax
  00507	75 07		 jne	 SHORT $LN46@stbi__pic_

; 6399 :                                 return 0;

  00509	33 c0		 xor	 eax, eax
  0050b	e9 11 01 00 00	 jmp	 $LN1@stbi__pic_
$LN46@stbi__pic_:

; 6400 :                             
; 6401 :                             for(i=0;i<count;++i, dest += 4)

  00510	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00518	eb 18		 jmp	 SHORT $LN25@stbi__pic_
$LN23@stbi__pic_:
  0051a	8b 44 24 28	 mov	 eax, DWORD PTR i$3[rsp]
  0051e	ff c0		 inc	 eax
  00520	89 44 24 28	 mov	 DWORD PTR i$3[rsp], eax
  00524	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  00529	48 83 c0 04	 add	 rax, 4
  0052d	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN25@stbi__pic_:
  00532	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  00536	39 44 24 28	 cmp	 DWORD PTR i$3[rsp], eax
  0053a	7d 1f		 jge	 SHORT $LN24@stbi__pic_

; 6402 :                                 stbi__copyval(packet->channel,dest,value);

  0053c	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  00541	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00545	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR value$13[rsp]
  0054d	48 8b 54 24 30	 mov	 rdx, QWORD PTR dest$4[rsp]
  00552	8b c8		 mov	 ecx, eax
  00554	e8 00 00 00 00	 call	 ?stbi__copyval@@YAXHPEAEPEBE@Z ; stbi__copyval
  00559	eb bf		 jmp	 SHORT $LN23@stbi__pic_
$LN24@stbi__pic_:

; 6403 :                         } else { // Raw

  0055b	e9 9a 00 00 00	 jmp	 $LN42@stbi__pic_
$LN41@stbi__pic_:

; 6404 :                             ++count;

  00560	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  00564	ff c0		 inc	 eax
  00566	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax

; 6405 :                             if (count>left) return stbi__errpuc("bad file","scanline overrun");

  0056a	8b 44 24 40	 mov	 eax, DWORD PTR left$6[rsp]
  0056e	39 44 24 24	 cmp	 DWORD PTR count$2[rsp], eax
  00572	7e 32		 jle	 SHORT $LN47@stbi__pic_
  00574	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40344
  0057b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00580	85 c0		 test	 eax, eax
  00582	74 0d		 je	 SHORT $LN66@stbi__pic_
  00584	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
  0058f	eb 0b		 jmp	 SHORT $LN67@stbi__pic_
$LN66@stbi__pic_:
  00591	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN67@stbi__pic_:
  0059c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv245[rsp]
  005a4	eb 7b		 jmp	 SHORT $LN1@stbi__pic_
$LN47@stbi__pic_:

; 6406 :                             
; 6407 :                             for(i=0;i<count;++i, dest+=4)

  005a6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  005ae	eb 18		 jmp	 SHORT $LN28@stbi__pic_
$LN26@stbi__pic_:
  005b0	8b 44 24 28	 mov	 eax, DWORD PTR i$3[rsp]
  005b4	ff c0		 inc	 eax
  005b6	89 44 24 28	 mov	 DWORD PTR i$3[rsp], eax
  005ba	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  005bf	48 83 c0 04	 add	 rax, 4
  005c3	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN28@stbi__pic_:
  005c8	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  005cc	39 44 24 28	 cmp	 DWORD PTR i$3[rsp], eax
  005d0	7d 28		 jge	 SHORT $LN27@stbi__pic_

; 6408 :                                 if (!stbi__readval(s,packet->channel,dest))

  005d2	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  005d7	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005db	4c 8b 44 24 30	 mov	 r8, QWORD PTR dest$4[rsp]
  005e0	8b d0		 mov	 edx, eax
  005e2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ea	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  005ef	48 85 c0	 test	 rax, rax
  005f2	75 04		 jne	 SHORT $LN48@stbi__pic_

; 6409 :                                 return 0;

  005f4	33 c0		 xor	 eax, eax
  005f6	eb 29		 jmp	 SHORT $LN1@stbi__pic_
$LN48@stbi__pic_:
  005f8	eb b6		 jmp	 SHORT $LN26@stbi__pic_
$LN27@stbi__pic_:
$LN42@stbi__pic_:

; 6410 :                         }
; 6411 :                         left-=count;

  005fa	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  005fe	8b 4c 24 40	 mov	 ecx, DWORD PTR left$6[rsp]
  00602	2b c8		 sub	 ecx, eax
  00604	8b c1		 mov	 eax, ecx
  00606	89 44 24 40	 mov	 DWORD PTR left$6[rsp], eax

; 6412 :                     }

  0060a	e9 fb fd ff ff	 jmp	 $LN21@stbi__pic_
$LN22@stbi__pic_:
$LN11@stbi__pic_:

; 6413 :                     break;
; 6414 :                 }
; 6415 :             }
; 6416 :         }

  0060f	e9 d9 fb ff ff	 jmp	 $LN8@stbi__pic_
$LN9@stbi__pic_:

; 6417 :     }

  00614	e9 af fb ff ff	 jmp	 $LN5@stbi__pic_
$LN6@stbi__pic_:

; 6418 :     
; 6419 :     return result;

  00619	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 6420 : }

  00621	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00629	48 33 cc	 xor	 rcx, rsp
  0062c	e8 00 00 00 00	 call	 __security_check_cookie
  00631	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00638	c3		 ret	 0
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ENDP ; stbi__pic_load_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
mask$ = 4
channel$ = 32
dest$ = 40
src$ = 48
?stbi__copyval@@YAXHPEAEPEBE@Z PROC			; stbi__copyval

; 6304 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 6305 :     int mask=0x80,i;

  00012	c7 44 24 04 80
	00 00 00	 mov	 DWORD PTR mask$[rsp], 128 ; 00000080H

; 6306 :     
; 6307 :     for (i=0;i<4; ++i, mask>>=1)

  0001a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00021	eb 12		 jmp	 SHORT $LN4@stbi__copy
$LN2@stbi__copy:
  00023	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0002b	8b 44 24 04	 mov	 eax, DWORD PTR mask$[rsp]
  0002f	d1 f8		 sar	 eax, 1
  00031	89 44 24 04	 mov	 DWORD PTR mask$[rsp], eax
$LN4@stbi__copy:
  00035	83 3c 24 04	 cmp	 DWORD PTR i$[rsp], 4
  00039	7d 2c		 jge	 SHORT $LN3@stbi__copy

; 6308 :         if (channel&mask)

  0003b	8b 44 24 04	 mov	 eax, DWORD PTR mask$[rsp]
  0003f	8b 4c 24 20	 mov	 ecx, DWORD PTR channel$[rsp]
  00043	23 c8		 and	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN5@stbi__copy

; 6309 :         dest[i]=src[i];

  0004b	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0004f	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00053	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$[rsp]
  00058	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$[rsp]
  0005d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00062	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__copy:
  00065	eb bc		 jmp	 SHORT $LN2@stbi__copy
$LN3@stbi__copy:

; 6310 : }

  00067	48 83 c4 18	 add	 rsp, 24
  0006b	c3		 ret	 0
?stbi__copyval@@YAXHPEAEPEBE@Z ENDP			; stbi__copyval
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
mask$ = 36
tv75 = 40
s$ = 64
channel$ = 72
dest$ = 80
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z PROC	; stbi__readval

; 6290 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6291 :     int mask=0x80, i;

  00012	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR mask$[rsp], 128 ; 00000080H

; 6292 :     
; 6293 :     for (i=0; i<4; ++i, mask>>=1) {

  0001a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00022	eb 14		 jmp	 SHORT $LN4@stbi__read
$LN2@stbi__read:
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00028	ff c0		 inc	 eax
  0002a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR mask$[rsp]
  00032	d1 f8		 sar	 eax, 1
  00034	89 44 24 24	 mov	 DWORD PTR mask$[rsp], eax
$LN4@stbi__read:
  00038	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  0003d	7d 60		 jge	 SHORT $LN3@stbi__read

; 6294 :         if (channel & mask) {

  0003f	8b 44 24 24	 mov	 eax, DWORD PTR mask$[rsp]
  00043	8b 4c 24 48	 mov	 ecx, DWORD PTR channel$[rsp]
  00047	23 c8		 and	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	85 c0		 test	 eax, eax
  0004d	74 4e		 je	 SHORT $LN5@stbi__read

; 6295 :             if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");

  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00054	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00059	85 c0		 test	 eax, eax
  0005b	74 29		 je	 SHORT $LN6@stbi__read
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40237
  00064	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00069	85 c0		 test	 eax, eax
  0006b	74 0a		 je	 SHORT $LN8@stbi__read
  0006d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00075	eb 08		 jmp	 SHORT $LN9@stbi__read
$LN8@stbi__read:
  00077	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@stbi__read:
  0007f	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv75[rsp]
  00084	eb 1e		 jmp	 SHORT $LN1@stbi__read
$LN6@stbi__read:

; 6296 :             dest[i]=stbi__get8(s);

  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0008b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00090	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00095	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest$[rsp]
  0009a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__read:

; 6297 :         }
; 6298 :     }

  0009d	eb 85		 jmp	 SHORT $LN2@stbi__read
$LN3@stbi__read:

; 6299 :     
; 6300 :     return dest;

  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@stbi__read:

; 6301 : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ENDP	; stbi__readval
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z PROC	; stbi__pic_test_core

; 6269 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6270 :     int i;
; 6271 :     
; 6272 :     if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40205
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN5@stbi__pic_

; 6273 :         return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 45		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:

; 6274 :     
; 6275 :     for(i=0;i<84;++i)

  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002a	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  0002c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00036	83 7c 24 20 54	 cmp	 DWORD PTR i$[rsp], 84	; 00000054H
  0003b	7d 0c		 jge	 SHORT $LN3@stbi__pic_

; 6276 :         stbi__get8(s);

  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00047	eb e3		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6277 :     
; 6278 :     if (!stbi__pic_is4(s,"PICT"))

  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40207
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00055	e8 00 00 00 00	 call	 ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
  0005a	85 c0		 test	 eax, eax
  0005c	75 04		 jne	 SHORT $LN6@stbi__pic_

; 6279 :         return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 05		 jmp	 SHORT $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6280 :     
; 6281 :     return 1;

  00062	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 6282 : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ENDP	; stbi__pic_test_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
str$ = 72
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__pic_is4

; 6259 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6260 :     int i;
; 6261 :     for (i=0; i<4; ++i)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00022	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  00027	7d 25		 jge	 SHORT $LN3@stbi__pic_

; 6262 :         if (stbi__get8(s) != (stbi_uc)str[i])

  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00033	0f b6 c0	 movzx	 eax, al
  00036	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0003b	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  00040	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00044	3b c1		 cmp	 eax, ecx
  00046	74 04		 je	 SHORT $LN5@stbi__pic_

; 6263 :         return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 07		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:
  0004c	eb ca		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6264 :     
; 6265 :     return 1;

  0004e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 6266 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__pic_is4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
val$1 = 32
len$ = 36
count$ = 40
nleft$ = 44
s$ = 64
p$ = 72
pixelCount$ = 80
?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z PROC ; stbi__psd_decode_rle

; 6011 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6012 :     int count, nleft, len;
; 6013 :     
; 6014 :     count = 0;

  00013	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@stbi__psd_:

; 6015 :     while ((nleft = pixelCount - count) > 0) {

  0001b	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  0001f	8b 4c 24 50	 mov	 ecx, DWORD PTR pixelCount$[rsp]
  00023	2b c8		 sub	 ecx, eax
  00025	8b c1		 mov	 eax, ecx
  00027	89 44 24 2c	 mov	 DWORD PTR nleft$[rsp], eax
  0002b	83 7c 24 2c 00	 cmp	 DWORD PTR nleft$[rsp], 0
  00030	0f 8e fe 00 00
	00		 jle	 $LN3@stbi__psd_

; 6016 :         len = stbi__get8(s);

  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00040	0f b6 c0	 movzx	 eax, al
  00043	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6017 :         if (len == 128) {

  00047	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  0004f	75 05		 jne	 SHORT $LN8@stbi__psd_
  00051	e9 d9 00 00 00	 jmp	 $LN9@stbi__psd_
$LN8@stbi__psd_:

; 6018 :             // No-op.
; 6019 :         } else if (len < 128) {

  00056	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  0005e	7d 5f		 jge	 SHORT $LN10@stbi__psd_

; 6020 :             // Copy next len+1 bytes literally.
; 6021 :             len++;

  00060	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00064	ff c0		 inc	 eax
  00066	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6022 :             if (len > nleft) return 0; // corrupt data

  0006a	8b 44 24 2c	 mov	 eax, DWORD PTR nleft$[rsp]
  0006e	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  00072	7e 07		 jle	 SHORT $LN12@stbi__psd_
  00074	33 c0		 xor	 eax, eax
  00076	e9 be 00 00 00	 jmp	 $LN1@stbi__psd_
$LN12@stbi__psd_:

; 6023 :             count += len;

  0007b	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  0007f	8b 4c 24 28	 mov	 ecx, DWORD PTR count$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax
$LN4@stbi__psd_:

; 6024 :             while (len) {

  0008b	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  00090	74 2b		 je	 SHORT $LN5@stbi__psd_

; 6025 :                 *p = stbi__get8(s);

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00097	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0009c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  000a1	88 01		 mov	 BYTE PTR [rcx], al

; 6026 :                 p += 4;

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000a8	48 83 c0 04	 add	 rax, 4
  000ac	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax

; 6027 :                 len--;

  000b1	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6028 :             }

  000bb	eb ce		 jmp	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 6029 :         } else if (len > 128) {

  000bd	eb 70		 jmp	 SHORT $LN11@stbi__psd_
$LN10@stbi__psd_:
  000bf	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  000c7	7e 66		 jle	 SHORT $LN13@stbi__psd_

; 6030 :             stbi_uc   val;
; 6031 :             // Next -len+1 bytes in the dest are replicated from next source byte.
; 6032 :             // (Interpret len as a negative 8-bit int.)
; 6033 :             len = 257 - len;

  000c9	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  000ce	2b 44 24 24	 sub	 eax, DWORD PTR len$[rsp]
  000d2	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6034 :             if (len > nleft) return 0; // corrupt data

  000d6	8b 44 24 2c	 mov	 eax, DWORD PTR nleft$[rsp]
  000da	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  000de	7e 04		 jle	 SHORT $LN14@stbi__psd_
  000e0	33 c0		 xor	 eax, eax
  000e2	eb 55		 jmp	 SHORT $LN1@stbi__psd_
$LN14@stbi__psd_:

; 6035 :             val = stbi__get8(s);

  000e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ee	88 44 24 20	 mov	 BYTE PTR val$1[rsp], al

; 6036 :             count += len;

  000f2	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000f6	8b 4c 24 28	 mov	 ecx, DWORD PTR count$[rsp]
  000fa	03 c8		 add	 ecx, eax
  000fc	8b c1		 mov	 eax, ecx
  000fe	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax
$LN6@stbi__psd_:

; 6037 :             while (len) {

  00102	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  00107	74 26		 je	 SHORT $LN7@stbi__psd_

; 6038 :                 *p = val;

  00109	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  0010e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR val$1[rsp]
  00113	88 08		 mov	 BYTE PTR [rax], cl

; 6039 :                 p += 4;

  00115	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  0011a	48 83 c0 04	 add	 rax, 4
  0011e	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax

; 6040 :                 len--;

  00123	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00127	ff c8		 dec	 eax
  00129	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6041 :             }

  0012d	eb d3		 jmp	 SHORT $LN6@stbi__psd_
$LN7@stbi__psd_:
$LN13@stbi__psd_:
$LN11@stbi__psd_:
$LN9@stbi__psd_:

; 6042 :         }
; 6043 :     }

  0012f	e9 e7 fe ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 6044 :     
; 6045 :     return 1;

  00134	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 6046 : }

  00139	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0013d	c3		 ret	 0
?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z ENDP ; stbi__psd_decode_rle
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
px$ = 32
fiveBitMask$ = 36
r$ = 40
g$ = 44
b$ = 48
s$ = 80
out$ = 88
?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z PROC ; stbi__tga_read_rgb16

; 5775 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5776 :     stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00018	66 89 44 24 20	 mov	 WORD PTR px$[rsp], ax

; 5777 :     stbi__uint16 fiveBitMask = 31;

  0001d	b8 1f 00 00 00	 mov	 eax, 31
  00022	66 89 44 24 24	 mov	 WORD PTR fiveBitMask$[rsp], ax

; 5778 :     // we have 3 channels with 5bits each
; 5779 :     int r = (px >> 10) & fiveBitMask;

  00027	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  0002c	c1 f8 0a	 sar	 eax, 10
  0002f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00034	23 c1		 and	 eax, ecx
  00036	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 5780 :     int g = (px >> 5) & fiveBitMask;

  0003a	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  0003f	c1 f8 05	 sar	 eax, 5
  00042	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00047	23 c1		 and	 eax, ecx
  00049	89 44 24 2c	 mov	 DWORD PTR g$[rsp], eax

; 5781 :     int b = px & fiveBitMask;

  0004d	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  00052	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00057	23 c1		 and	 eax, ecx
  00059	89 44 24 30	 mov	 DWORD PTR b$[rsp], eax

; 5782 :     // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5783 :     out[0] = (stbi_uc)((r * 255)/31);

  0005d	69 44 24 28 ff
	00 00 00	 imul	 eax, DWORD PTR r$[rsp], 255 ; 000000ffH
  00065	99		 cdq
  00066	b9 1f 00 00 00	 mov	 ecx, 31
  0006b	f7 f9		 idiv	 ecx
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	48 6b c9 00	 imul	 rcx, rcx, 0
  00076	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  0007b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5784 :     out[1] = (stbi_uc)((g * 255)/31);

  0007e	69 44 24 2c ff
	00 00 00	 imul	 eax, DWORD PTR g$[rsp], 255 ; 000000ffH
  00086	99		 cdq
  00087	b9 1f 00 00 00	 mov	 ecx, 31
  0008c	f7 f9		 idiv	 ecx
  0008e	b9 01 00 00 00	 mov	 ecx, 1
  00093	48 6b c9 01	 imul	 rcx, rcx, 1
  00097	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  0009c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5785 :     out[2] = (stbi_uc)((b * 255)/31);

  0009f	69 44 24 30 ff
	00 00 00	 imul	 eax, DWORD PTR b$[rsp], 255 ; 000000ffH
  000a7	99		 cdq
  000a8	b9 1f 00 00 00	 mov	 ecx, 31
  000ad	f7 f9		 idiv	 ecx
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	48 6b c9 02	 imul	 rcx, rcx, 2
  000b8	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  000bd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5786 :     
; 5787 :     // some people claim that the most significant bit might be used for alpha
; 5788 :     // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5789 :     // but that only made 16bit test images completely translucent..
; 5790 :     // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5791 : }

  000c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c4	c3		 ret	 0
?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ENDP ; stbi__tga_read_rgb16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv65 = 0
bits_per_pixel$ = 32
is_grey$ = 40
is_rgb16$ = 48
?stbi__tga_get_comp@@YAHHHPEAH@Z PROC			; stbi__tga_get_comp

; 5662 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24

; 5663 :     // only RGB or RGBA (incl. 16bit) or grey allowed
; 5664 :     if (is_rgb16) *is_rgb16 = 0;

  00011	48 83 7c 24 30
	00		 cmp	 QWORD PTR is_rgb16$[rsp], 0
  00017	74 0b		 je	 SHORT $LN4@stbi__tga_
  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR is_rgb16$[rsp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@stbi__tga_:

; 5665 :     switch(bits_per_pixel) {

  00024	8b 44 24 20	 mov	 eax, DWORD PTR bits_per_pixel$[rsp]
  00028	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  0002b	83 3c 24 08	 cmp	 DWORD PTR tv65[rsp], 8
  0002f	74 1a		 je	 SHORT $LN5@stbi__tga_
  00031	83 3c 24 0f	 cmp	 DWORD PTR tv65[rsp], 15
  00035	74 29		 je	 SHORT $LN8@stbi__tga_
  00037	83 3c 24 10	 cmp	 DWORD PTR tv65[rsp], 16
  0003b	74 15		 je	 SHORT $LN6@stbi__tga_
  0003d	83 3c 24 18	 cmp	 DWORD PTR tv65[rsp], 24
  00041	74 37		 je	 SHORT $LN10@stbi__tga_
  00043	83 3c 24 20	 cmp	 DWORD PTR tv65[rsp], 32	; 00000020H
  00047	74 31		 je	 SHORT $LN11@stbi__tga_
  00049	eb 3e		 jmp	 SHORT $LN12@stbi__tga_
$LN5@stbi__tga_:

; 5666 :         case 8:  return STBI_grey;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	eb 39		 jmp	 SHORT $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5667 :         case 16: if(is_grey) return STBI_grey_alpha;

  00052	83 7c 24 28 00	 cmp	 DWORD PTR is_grey$[rsp], 0
  00057	74 07		 je	 SHORT $LN7@stbi__tga_
  00059	b8 02 00 00 00	 mov	 eax, 2
  0005e	eb 2b		 jmp	 SHORT $LN1@stbi__tga_
$LN7@stbi__tga_:
$LN8@stbi__tga_:

; 5668 :         // fallthrough
; 5669 :         case 15: if(is_rgb16) *is_rgb16 = 1;

  00060	48 83 7c 24 30
	00		 cmp	 QWORD PTR is_rgb16$[rsp], 0
  00066	74 0b		 je	 SHORT $LN9@stbi__tga_
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR is_rgb16$[rsp]
  0006d	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN9@stbi__tga_:

; 5670 :         return STBI_rgb;

  00073	b8 03 00 00 00	 mov	 eax, 3
  00078	eb 11		 jmp	 SHORT $LN1@stbi__tga_
$LN10@stbi__tga_:
$LN11@stbi__tga_:

; 5671 :         case 24: // fallthrough
; 5672 :         case 32: return bits_per_pixel/8;

  0007a	8b 44 24 20	 mov	 eax, DWORD PTR bits_per_pixel$[rsp]
  0007e	99		 cdq
  0007f	83 e2 07	 and	 edx, 7
  00082	03 c2		 add	 eax, edx
  00084	c1 f8 03	 sar	 eax, 3
  00087	eb 02		 jmp	 SHORT $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5673 :         default: return 0;

  00089	33 c0		 xor	 eax, eax
$LN1@stbi__tga_:

; 5674 :     }
; 5675 : }

  0008b	48 83 c4 18	 add	 rsp, 24
  0008f	c3		 ret	 0
?stbi__tga_get_comp@@YAHHHPEAH@Z ENDP			; stbi__tga_get_comp
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
hsz$ = 32
compress$1 = 36
i$2 = 40
tv75 = 44
tv128 = 48
tv138 = 52
tv159 = 56
tv172 = 60
tv178 = 64
tv188 = 68
tv231 = 72
tv236 = 76
tv243 = 80
s$ = 112
info$ = 120
?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z PROC ; stbi__bmp_parse_header

; 5385 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5386 :     int hsz;
; 5387 :     if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00018	0f b6 c0	 movzx	 eax, al
  0001b	83 f8 42	 cmp	 eax, 66			; 00000042H
  0001e	75 12		 jne	 SHORT $LN6@stbi__bmp_
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00025	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00030	74 2c		 je	 SHORT $LN5@stbi__bmp_
$LN6@stbi__bmp_:
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39579
  00039	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN32@stbi__bmp_
  00042	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0004a	eb 08		 jmp	 SHORT $LN33@stbi__bmp_
$LN32@stbi__bmp_:
  0004c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN33@stbi__bmp_:
  00054	48 63 44 24 2c	 movsxd	 rax, DWORD PTR tv75[rsp]
  00059	e9 ec 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN5@stbi__bmp_:

; 5388 :     stbi__get32le(s); // discard filesize

  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5389 :     stbi__get16le(s); // discard reserved

  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5390 :     stbi__get16le(s); // discard reserved

  00072	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00077	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5391 :     info->offset = stbi__get32le(s);

  0007c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00081	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  0008b	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5392 :     info->hsz = hsz = stbi__get32le(s);

  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00093	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00098	89 44 24 20	 mov	 DWORD PTR hsz$[rsp], eax
  0009c	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000a1	8b 4c 24 20	 mov	 ecx, DWORD PTR hsz$[rsp]
  000a5	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5393 :     info->mr = info->mg = info->mb = info->ma = 0;

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000ad	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000b9	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000c0	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000c5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  000cc	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000d1	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 5394 :     info->extra_read = 14;

  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000dd	c7 40 20 0e 00
	00 00		 mov	 DWORD PTR [rax+32], 14

; 5395 :     
; 5396 :     if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

  000e4	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000e9	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  000ed	7d 2c		 jge	 SHORT $LN7@stbi__bmp_
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39581
  000f6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000fb	85 c0		 test	 eax, eax
  000fd	74 0a		 je	 SHORT $LN34@stbi__bmp_
  000ff	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
  00107	eb 08		 jmp	 SHORT $LN35@stbi__bmp_
$LN34@stbi__bmp_:
  00109	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN35@stbi__bmp_:
  00111	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv128[rsp]
  00116	e9 2f 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN7@stbi__bmp_:

; 5397 :     
; 5398 :     if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

  0011b	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  00120	74 48		 je	 SHORT $LN8@stbi__bmp_
  00122	83 7c 24 20 28	 cmp	 DWORD PTR hsz$[rsp], 40	; 00000028H
  00127	74 41		 je	 SHORT $LN8@stbi__bmp_
  00129	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  0012e	74 3a		 je	 SHORT $LN8@stbi__bmp_
  00130	83 7c 24 20 6c	 cmp	 DWORD PTR hsz$[rsp], 108 ; 0000006cH
  00135	74 33		 je	 SHORT $LN8@stbi__bmp_
  00137	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  0013c	74 2c		 je	 SHORT $LN8@stbi__bmp_
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39583
  00145	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014a	85 c0		 test	 eax, eax
  0014c	74 0a		 je	 SHORT $LN36@stbi__bmp_
  0014e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
  00156	eb 08		 jmp	 SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:
  00158	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN37@stbi__bmp_:
  00160	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv138[rsp]
  00165	e9 e0 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN8@stbi__bmp_:

; 5399 :     if (hsz == 12) {

  0016a	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  0016f	75 25		 jne	 SHORT $LN9@stbi__bmp_

; 5400 :         s->img_x = stbi__get16le(s);

  00171	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00176	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0017b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00180	89 01		 mov	 DWORD PTR [rcx], eax

; 5401 :         s->img_y = stbi__get16le(s);

  00182	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00187	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0018c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00191	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5402 :     } else {

  00194	eb 23		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:

; 5403 :         s->img_x = stbi__get32le(s);

  00196	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0019b	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  001a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001a5	89 01		 mov	 DWORD PTR [rcx], eax

; 5404 :         s->img_y = stbi__get32le(s);

  001a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001ac	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  001b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001b6	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN10@stbi__bmp_:

; 5405 :     }
; 5406 :     if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

  001b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001be	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  001c3	83 f8 01	 cmp	 eax, 1
  001c6	74 2c		 je	 SHORT $LN11@stbi__bmp_
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39587
  001cf	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001d4	85 c0		 test	 eax, eax
  001d6	74 0a		 je	 SHORT $LN38@stbi__bmp_
  001d8	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  001e0	eb 08		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:
  001e2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN39@stbi__bmp_:
  001ea	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv159[rsp]
  001ef	e9 56 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN11@stbi__bmp_:

; 5407 :     info->bpp = stbi__get16le(s);

  001f4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001f9	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  001fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  00203	89 01		 mov	 DWORD PTR [rcx], eax

; 5408 :     if (hsz != 12) {

  00205	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  0020a	0f 84 35 03 00
	00		 je	 $LN12@stbi__bmp_

; 5409 :         int compress = stbi__get32le(s);

  00210	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00215	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0021a	89 44 24 24	 mov	 DWORD PTR compress$1[rsp], eax

; 5410 :         if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

  0021e	83 7c 24 24 01	 cmp	 DWORD PTR compress$1[rsp], 1
  00223	74 07		 je	 SHORT $LN14@stbi__bmp_
  00225	83 7c 24 24 02	 cmp	 DWORD PTR compress$1[rsp], 2
  0022a	75 2c		 jne	 SHORT $LN13@stbi__bmp_
$LN14@stbi__bmp_:
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39591
  00233	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN40@stbi__bmp_
  0023c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  00244	eb 08		 jmp	 SHORT $LN41@stbi__bmp_
$LN40@stbi__bmp_:
  00246	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN41@stbi__bmp_:
  0024e	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv172[rsp]
  00253	e9 f2 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN13@stbi__bmp_:

; 5411 :         if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes

  00258	83 7c 24 24 04	 cmp	 DWORD PTR compress$1[rsp], 4
  0025d	7c 2c		 jl	 SHORT $LN15@stbi__bmp_
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39593
  00266	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0026b	85 c0		 test	 eax, eax
  0026d	74 0a		 je	 SHORT $LN42@stbi__bmp_
  0026f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
  00277	eb 08		 jmp	 SHORT $LN43@stbi__bmp_
$LN42@stbi__bmp_:
  00279	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN43@stbi__bmp_:
  00281	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv178[rsp]
  00286	e9 bf 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN15@stbi__bmp_:

; 5412 :         if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel

  0028b	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  00290	75 40		 jne	 SHORT $LN16@stbi__bmp_
  00292	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  00297	83 38 10	 cmp	 DWORD PTR [rax], 16
  0029a	74 36		 je	 SHORT $LN16@stbi__bmp_
  0029c	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  002a1	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  002a4	74 2c		 je	 SHORT $LN16@stbi__bmp_
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39595
  002ad	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002b2	85 c0		 test	 eax, eax
  002b4	74 0a		 je	 SHORT $LN44@stbi__bmp_
  002b6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
  002be	eb 08		 jmp	 SHORT $LN45@stbi__bmp_
$LN44@stbi__bmp_:
  002c0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN45@stbi__bmp_:
  002c8	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv188[rsp]
  002cd	e9 78 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN16@stbi__bmp_:

; 5413 :         stbi__get32le(s); // discard sizeof

  002d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002d7	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5414 :         stbi__get32le(s); // discard hres

  002dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002e1	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5415 :         stbi__get32le(s); // discard vres

  002e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002eb	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5416 :         stbi__get32le(s); // discard colorsused

  002f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002f5	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5417 :         stbi__get32le(s); // discard max important

  002fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002ff	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5418 :         if (hsz == 40 || hsz == 56) {

  00304	83 7c 24 20 28	 cmp	 DWORD PTR hsz$[rsp], 40	; 00000028H
  00309	74 0b		 je	 SHORT $LN19@stbi__bmp_
  0030b	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  00310	0f 85 38 01 00
	00		 jne	 $LN17@stbi__bmp_
$LN19@stbi__bmp_:

; 5419 :             if (hsz == 56) {

  00316	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  0031b	75 28		 jne	 SHORT $LN20@stbi__bmp_

; 5420 :                 stbi__get32le(s);

  0031d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00322	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5421 :                 stbi__get32le(s);

  00327	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0032c	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5422 :                 stbi__get32le(s);

  00331	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00336	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5423 :                 stbi__get32le(s);

  0033b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00340	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN20@stbi__bmp_:

; 5424 :             }
; 5425 :             if (info->bpp == 16 || info->bpp == 32) {

  00345	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  0034a	83 38 10	 cmp	 DWORD PTR [rax], 16
  0034d	74 0e		 je	 SHORT $LN22@stbi__bmp_
  0034f	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  00354	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  00357	0f 85 ec 00 00
	00		 jne	 $LN21@stbi__bmp_
$LN22@stbi__bmp_:

; 5426 :                 if (compress == 0) {

  0035d	83 7c 24 24 00	 cmp	 DWORD PTR compress$1[rsp], 0
  00362	75 13		 jne	 SHORT $LN23@stbi__bmp_

; 5427 :                     stbi__bmp_set_mask_defaults(info, compress);

  00364	8b 54 24 24	 mov	 edx, DWORD PTR compress$1[rsp]
  00368	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  0036d	e8 00 00 00 00	 call	 ?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ; stbi__bmp_set_mask_defaults
  00372	e9 d2 00 00 00	 jmp	 $LN24@stbi__bmp_
$LN23@stbi__bmp_:

; 5428 :                 } else if (compress == 3) {

  00377	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  0037c	0f 85 9b 00 00
	00		 jne	 $LN25@stbi__bmp_

; 5429 :                     info->mr = stbi__get32le(s);

  00382	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00387	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0038c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  00391	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5430 :                     info->mg = stbi__get32le(s);

  00394	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00399	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0039e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003a3	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5431 :                     info->mb = stbi__get32le(s);

  003a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003ab	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  003b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003b5	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5432 :                     info->extra_read += 12;

  003b8	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  003bd	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  003c0	83 c0 0c	 add	 eax, 12
  003c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003c8	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 5433 :                     // not documented, but generated by photoshop and handled by mspaint
; 5434 :                     if (info->mr == info->mg && info->mg == info->mb) {

  003cb	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  003d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003d5	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  003d8	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  003db	75 3e		 jne	 SHORT $LN27@stbi__bmp_
  003dd	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  003e2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003e7	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  003ea	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  003ed	75 2c		 jne	 SHORT $LN27@stbi__bmp_

; 5435 :                         // ?!?!?
; 5436 :                         return stbi__errpuc("bad BMP", "bad BMP");

  003ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39607
  003f6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003fb	85 c0		 test	 eax, eax
  003fd	74 0a		 je	 SHORT $LN46@stbi__bmp_
  003ff	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
  00407	eb 08		 jmp	 SHORT $LN47@stbi__bmp_
$LN46@stbi__bmp_:
  00409	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
$LN47@stbi__bmp_:
  00411	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv231[rsp]
  00416	e9 2f 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN27@stbi__bmp_:

; 5437 :                     }
; 5438 :                 } else

  0041b	eb 2c		 jmp	 SHORT $LN26@stbi__bmp_
$LN25@stbi__bmp_:

; 5439 :                     return stbi__errpuc("bad BMP", "bad BMP");

  0041d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39608
  00424	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00429	85 c0		 test	 eax, eax
  0042b	74 0a		 je	 SHORT $LN48@stbi__bmp_
  0042d	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
  00435	eb 08		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:
  00437	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN49@stbi__bmp_:
  0043f	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv236[rsp]
  00444	e9 01 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN26@stbi__bmp_:
$LN24@stbi__bmp_:
$LN21@stbi__bmp_:

; 5440 :             }
; 5441 :         } else {

  00449	e9 f7 00 00 00	 jmp	 $LN18@stbi__bmp_
$LN17@stbi__bmp_:

; 5442 :             // V4/V5 header
; 5443 :             int i;
; 5444 :             if (hsz != 108 && hsz != 124)

  0044e	83 7c 24 20 6c	 cmp	 DWORD PTR hsz$[rsp], 108 ; 0000006cH
  00453	74 33		 je	 SHORT $LN28@stbi__bmp_
  00455	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  0045a	74 2c		 je	 SHORT $LN28@stbi__bmp_

; 5445 :                 return stbi__errpuc("bad BMP", "bad BMP");

  0045c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39610
  00463	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00468	85 c0		 test	 eax, eax
  0046a	74 0a		 je	 SHORT $LN50@stbi__bmp_
  0046c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv243[rsp], 0
  00474	eb 08		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:
  00476	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv243[rsp], 0
$LN51@stbi__bmp_:
  0047e	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv243[rsp]
  00483	e9 c2 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN28@stbi__bmp_:

; 5446 :             info->mr = stbi__get32le(s);

  00488	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0048d	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00492	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  00497	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5447 :             info->mg = stbi__get32le(s);

  0049a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0049f	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  004a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004a9	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5448 :             info->mb = stbi__get32le(s);

  004ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004b1	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  004b6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004bb	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5449 :             info->ma = stbi__get32le(s);

  004be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004c3	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  004c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004cd	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 5450 :             if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs

  004d0	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  004d5	74 0e		 je	 SHORT $LN29@stbi__bmp_

; 5451 :                 stbi__bmp_set_mask_defaults(info, compress);

  004d7	8b 54 24 24	 mov	 edx, DWORD PTR compress$1[rsp]
  004db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004e0	e8 00 00 00 00	 call	 ?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ; stbi__bmp_set_mask_defaults
$LN29@stbi__bmp_:

; 5452 :             stbi__get32le(s); // discard color space

  004e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004ea	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5453 :             for (i=0; i < 12; ++i)

  004ef	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  004f7	eb 0a		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  004f9	8b 44 24 28	 mov	 eax, DWORD PTR i$2[rsp]
  004fd	ff c0		 inc	 eax
  004ff	89 44 24 28	 mov	 DWORD PTR i$2[rsp], eax
$LN4@stbi__bmp_:
  00503	83 7c 24 28 0c	 cmp	 DWORD PTR i$2[rsp], 12
  00508	7d 0c		 jge	 SHORT $LN3@stbi__bmp_

; 5454 :                 stbi__get32le(s); // discard color space parameters

  0050a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0050f	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00514	eb e3		 jmp	 SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5455 :             if (hsz == 124) {

  00516	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  0051b	75 28		 jne	 SHORT $LN30@stbi__bmp_

; 5456 :                 stbi__get32le(s); // discard rendering intent

  0051d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00522	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5457 :                 stbi__get32le(s); // discard offset of profile data

  00527	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0052c	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5458 :                 stbi__get32le(s); // discard size of profile data

  00531	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00536	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5459 :                 stbi__get32le(s); // discard reserved

  0053b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00540	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN30@stbi__bmp_:
$LN18@stbi__bmp_:
$LN12@stbi__bmp_:

; 5460 :             }
; 5461 :         }
; 5462 :     }
; 5463 :     return (void *) 1;

  00545	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 5464 : }

  0054a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0054e	c3		 ret	 0
?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ENDP ; stbi__bmp_parse_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
info$ = 8
compress$ = 16
?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z PROC ; stbi__bmp_set_mask_defaults

; 5359 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 5360 :     // BI_BITFIELDS specifies masks explicitly, don't override
; 5361 :     if (compress == 3)

  00009	83 7c 24 10 03	 cmp	 DWORD PTR compress$[rsp], 3
  0000e	75 0a		 jne	 SHORT $LN2@stbi__bmp_

; 5362 :         return 1;

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	e9 bc 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 5363 :     
; 5364 :     if (compress == 0) {

  0001a	83 7c 24 10 00	 cmp	 DWORD PTR compress$[rsp], 0
  0001f	0f 85 af 00 00
	00		 jne	 $LN3@stbi__bmp_

; 5365 :         if (info->bpp == 16) {

  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0002a	83 38 10	 cmp	 DWORD PTR [rax], 16
  0002d	75 26		 jne	 SHORT $LN4@stbi__bmp_

; 5366 :             info->mr = 31u << 10;

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00034	c7 40 0c 00 7c
	00 00		 mov	 DWORD PTR [rax+12], 31744 ; 00007c00H

; 5367 :             info->mg = 31u <<  5;

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00040	c7 40 10 e0 03
	00 00		 mov	 DWORD PTR [rax+16], 992	; 000003e0H

; 5368 :             info->mb = 31u <<  0;

  00047	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0004c	c7 40 14 1f 00
	00 00		 mov	 DWORD PTR [rax+20], 31
  00053	eb 78		 jmp	 SHORT $LN5@stbi__bmp_
$LN4@stbi__bmp_:

; 5369 :         } else if (info->bpp == 32) {

  00055	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0005a	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  0005d	75 3e		 jne	 SHORT $LN6@stbi__bmp_

; 5370 :             info->mr = 0xffu << 16;

  0005f	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00064	c7 40 0c 00 00
	ff 00		 mov	 DWORD PTR [rax+12], 16711680 ; 00ff0000H

; 5371 :             info->mg = 0xffu <<  8;

  0006b	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00070	c7 40 10 00 ff
	00 00		 mov	 DWORD PTR [rax+16], 65280 ; 0000ff00H

; 5372 :             info->mb = 0xffu <<  0;

  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0007c	c7 40 14 ff 00
	00 00		 mov	 DWORD PTR [rax+20], 255	; 000000ffH

; 5373 :             info->ma = 0xffu << 24;

  00083	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00088	c7 40 18 00 00
	00 ff		 mov	 DWORD PTR [rax+24], -16777216 ; ff000000H

; 5374 :             info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

  0008f	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00094	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 5375 :         } else {

  0009b	eb 30		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 5376 :             // otherwise, use defaults, which is all-0
; 5377 :             info->mr = info->mg = info->mb = info->ma = 0;

  0009d	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000a9	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000ae	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000b5	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000ba	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  000c1	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000c6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 5378 :         }
; 5379 :         return 1;

  000cd	b8 01 00 00 00	 mov	 eax, 1
  000d2	eb 02		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5380 :     }
; 5381 :     return 0; // error

  000d4	33 c0		 xor	 eax, eax
$LN1@stbi__bmp_:

; 5382 : }

  000d6	c3		 ret	 0
?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ENDP ; stbi__bmp_set_mask_defaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
v$ = 8
shift$ = 16
bits$ = 24
?stbi__shiftsigned@@YAHIHH@Z PROC			; stbi__shiftsigned

; 5332 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 5333 :     static unsigned int mul_table[9] = {
; 5334 :         0,
; 5335 :         0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5336 :         0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5337 :     };
; 5338 :     static unsigned int shift_table[9] = {
; 5339 :         0, 0,0,1,0,2,4,6,0,
; 5340 :     };
; 5341 :     if (shift < 0)

  0000d	83 7c 24 10 00	 cmp	 DWORD PTR shift$[rsp], 0
  00012	7d 15		 jge	 SHORT $LN2@stbi__shif

; 5342 :         v <<= -shift;

  00014	8b 44 24 10	 mov	 eax, DWORD PTR shift$[rsp]
  00018	f7 d8		 neg	 eax
  0001a	0f b6 c8	 movzx	 ecx, al
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR v$[rsp]
  00021	d3 e0		 shl	 eax, cl
  00023	89 44 24 08	 mov	 DWORD PTR v$[rsp], eax
  00027	eb 11		 jmp	 SHORT $LN3@stbi__shif
$LN2@stbi__shif:

; 5343 :     else
; 5344 :         v >>= shift;

  00029	8b 44 24 10	 mov	 eax, DWORD PTR shift$[rsp]
  0002d	0f b6 c8	 movzx	 ecx, al
  00030	8b 44 24 08	 mov	 eax, DWORD PTR v$[rsp]
  00034	d3 e8		 shr	 eax, cl
  00036	89 44 24 08	 mov	 DWORD PTR v$[rsp], eax
$LN3@stbi__shif:

; 5345 :     STBI_ASSERT(v < 256);

  0003a	81 7c 24 08 00
	01 00 00	 cmp	 DWORD PTR v$[rsp], 256	; 00000100H
  00042	72 0b		 jb	 SHORT $LN4@stbi__shif
  00044	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN4@stbi__shif:

; 5346 :     v >>= (8-bits);

  0004f	b8 08 00 00 00	 mov	 eax, 8
  00054	2b 44 24 18	 sub	 eax, DWORD PTR bits$[rsp]
  00058	0f b6 c8	 movzx	 ecx, al
  0005b	8b 44 24 08	 mov	 eax, DWORD PTR v$[rsp]
  0005f	d3 e8		 shr	 eax, cl
  00061	89 44 24 08	 mov	 DWORD PTR v$[rsp], eax

; 5347 :     STBI_ASSERT(bits >= 0 && bits <= 8);

  00065	83 7c 24 18 00	 cmp	 DWORD PTR bits$[rsp], 0
  0006a	7c 07		 jl	 SHORT $LN6@stbi__shif
  0006c	83 7c 24 18 08	 cmp	 DWORD PTR bits$[rsp], 8
  00071	7e 0b		 jle	 SHORT $LN5@stbi__shif
$LN6@stbi__shif:
  00073	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN5@stbi__shif:

; 5348 :     return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

  0007e	48 63 44 24 18	 movsxd	 rax, DWORD PTR bits$[rsp]
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
  0008a	8b 54 24 08	 mov	 edx, DWORD PTR v$[rsp]
  0008e	0f af 14 81	 imul	 edx, DWORD PTR [rcx+rax*4]
  00092	8b c2		 mov	 eax, edx
  00094	48 63 4c 24 18	 movsxd	 rcx, DWORD PTR bits$[rsp]
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
  000a0	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  000a3	d3 f8		 sar	 eax, cl

; 5349 : }

  000a5	c3		 ret	 0
?stbi__shiftsigned@@YAHIHH@Z ENDP			; stbi__shiftsigned
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 8
?stbi__bitcount@@YAHI@Z PROC				; stbi__bitcount

; 5319 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 5320 :     a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

  00004	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  00008	25 55 55 55 55	 and	 eax, 1431655765		; 55555555H
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  00011	d1 e9		 shr	 ecx, 1
  00013	81 e1 55 55 55
	55		 and	 ecx, 1431655765		; 55555555H
  00019	03 c1		 add	 eax, ecx
  0001b	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5321 :     a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

  0001f	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  00023	25 33 33 33 33	 and	 eax, 858993459		; 33333333H
  00028	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  0002c	c1 e9 02	 shr	 ecx, 2
  0002f	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H
  00035	03 c1		 add	 eax, ecx
  00037	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5322 :     a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

  0003b	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  0003f	c1 e8 04	 shr	 eax, 4
  00042	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  00046	03 c8		 add	 ecx, eax
  00048	8b c1		 mov	 eax, ecx
  0004a	25 0f 0f 0f 0f	 and	 eax, 252645135		; 0f0f0f0fH
  0004f	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5323 :     a = (a + (a >> 8)); // max 16 per 8 bits

  00053	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  00057	c1 e8 08	 shr	 eax, 8
  0005a	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5324 :     a = (a + (a >> 16)); // max 32 per 8 bits

  00066	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  0006a	c1 e8 10	 shr	 eax, 16
  0006d	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  00071	03 c8		 add	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5325 :     return a & 0xff;

  00079	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  0007d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 5326 : }

  00082	c3		 ret	 0
?stbi__bitcount@@YAHI@Z ENDP				; stbi__bitcount
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
n$ = 0
z$ = 32
?stbi__high_bit@@YAHI@Z PROC				; stbi__high_bit

; 5307 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 5308 :     int n=0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR n$[rsp], 0

; 5309 :     if (z == 0) return -1;

  0000f	83 7c 24 20 00	 cmp	 DWORD PTR z$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN2@stbi__high
  00016	b8 ff ff ff ff	 mov	 eax, -1
  0001b	e9 84 00 00 00	 jmp	 $LN1@stbi__high
$LN2@stbi__high:

; 5310 :     if (z >= 0x10000) { n += 16; z >>= 16; }

  00020	81 7c 24 20 00
	00 01 00	 cmp	 DWORD PTR z$[rsp], 65536 ; 00010000H
  00028	72 14		 jb	 SHORT $LN3@stbi__high
  0002a	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0002d	83 c0 10	 add	 eax, 16
  00030	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN3@stbi__high:

; 5311 :     if (z >= 0x00100) { n +=  8; z >>=  8; }

  0003e	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR z$[rsp], 256	; 00000100H
  00046	72 14		 jb	 SHORT $LN4@stbi__high
  00048	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0004b	83 c0 08	 add	 eax, 8
  0004e	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00051	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00055	c1 e8 08	 shr	 eax, 8
  00058	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN4@stbi__high:

; 5312 :     if (z >= 0x00010) { n +=  4; z >>=  4; }

  0005c	83 7c 24 20 10	 cmp	 DWORD PTR z$[rsp], 16
  00061	72 14		 jb	 SHORT $LN5@stbi__high
  00063	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00066	83 c0 04	 add	 eax, 4
  00069	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  0006c	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00070	c1 e8 04	 shr	 eax, 4
  00073	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN5@stbi__high:

; 5313 :     if (z >= 0x00004) { n +=  2; z >>=  2; }

  00077	83 7c 24 20 04	 cmp	 DWORD PTR z$[rsp], 4
  0007c	72 14		 jb	 SHORT $LN6@stbi__high
  0007e	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00081	83 c0 02	 add	 eax, 2
  00084	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00087	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  0008b	c1 e8 02	 shr	 eax, 2
  0008e	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN6@stbi__high:

; 5314 :     if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }

  00092	83 7c 24 20 02	 cmp	 DWORD PTR z$[rsp], 2
  00097	72 08		 jb	 SHORT $LN7@stbi__high
  00099	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 04 24	 mov	 DWORD PTR n$[rsp], eax
$LN7@stbi__high:

; 5315 :     return n;

  000a1	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
$LN1@stbi__high:

; 5316 : }

  000a4	48 83 c4 18	 add	 rsp, 24
  000a8	c3		 ret	 0
?stbi__high_bit@@YAHI@Z ENDP				; stbi__high_bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
sz$ = 32
tv83 = 36
r$ = 40
s$ = 64
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__bmp_test_raw

; 5283 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5284 :     int r;
; 5285 :     int sz;
; 5286 :     if (stbi__get8(s) != 'B') return 0;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	83 f8 42	 cmp	 eax, 66			; 00000042H
  00019	74 07		 je	 SHORT $LN2@stbi__bmp_
  0001b	33 c0		 xor	 eax, eax
  0001d	e9 8d 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 5287 :     if (stbi__get8(s) != 'M') return 0;

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00027	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00032	74 04		 je	 SHORT $LN3@stbi__bmp_
  00034	33 c0		 xor	 eax, eax
  00036	eb 77		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5288 :     stbi__get32le(s); // discard filesize

  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5289 :     stbi__get16le(s); // discard reserved

  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00047	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5290 :     stbi__get16le(s); // discard reserved

  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00051	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5291 :     stbi__get32le(s); // discard data offset

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5292 :     sz = stbi__get32le(s);

  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00065	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0006a	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5293 :     r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

  0006e	83 7c 24 20 0c	 cmp	 DWORD PTR sz$[rsp], 12
  00073	74 26		 je	 SHORT $LN5@stbi__bmp_
  00075	83 7c 24 20 28	 cmp	 DWORD PTR sz$[rsp], 40	; 00000028H
  0007a	74 1f		 je	 SHORT $LN5@stbi__bmp_
  0007c	83 7c 24 20 38	 cmp	 DWORD PTR sz$[rsp], 56	; 00000038H
  00081	74 18		 je	 SHORT $LN5@stbi__bmp_
  00083	83 7c 24 20 6c	 cmp	 DWORD PTR sz$[rsp], 108	; 0000006cH
  00088	74 11		 je	 SHORT $LN5@stbi__bmp_
  0008a	83 7c 24 20 7c	 cmp	 DWORD PTR sz$[rsp], 124	; 0000007cH
  0008f	74 0a		 je	 SHORT $LN5@stbi__bmp_
  00091	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  00099	eb 08		 jmp	 SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
  0009b	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
$LN6@stbi__bmp_:
  000a3	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  000a7	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 5294 :     return r;

  000ab	8b 44 24 28	 mov	 eax, DWORD PTR r$[rsp]
$LN1@stbi__bmp_:

; 5295 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__bmp_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z PROC	; stbi__png_info_raw

; 5247 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5248 :     if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

  00018	45 33 c0	 xor	 r8d, r8d
  0001b	ba 02 00 00 00	 mov	 edx, 2
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00025	e8 00 00 00 00	 call	 ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
  0002a	85 c0		 test	 eax, eax
  0002c	75 11		 jne	 SHORT $LN2@stbi__png_

; 5249 :         stbi__rewind( p->s );

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00033	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00036	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5250 :         return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 52		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5251 :     }
; 5252 :     if (x) *x = p->s->img_x;

  0003f	48 83 7c 24 38
	00		 cmp	 QWORD PTR x$[rsp], 0
  00045	74 11		 je	 SHORT $LN3@stbi__png_
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$[rsp]
  00054	8b 00		 mov	 eax, DWORD PTR [rax]
  00056	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__png_:

; 5253 :     if (y) *y = p->s->img_y;

  00058	48 83 7c 24 40
	00		 cmp	 QWORD PTR y$[rsp], 0
  0005e	74 12		 je	 SHORT $LN4@stbi__png_
  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR y$[rsp]
  0006d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00070	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__png_:

; 5254 :     if (comp) *comp = p->s->img_n;

  00072	48 83 7c 24 48
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00078	74 12		 je	 SHORT $LN5@stbi__png_
  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0007f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR comp$[rsp]
  00087	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008a	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__png_:

; 5255 :     return 1;

  0008c	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 5256 : }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	c3		 ret	 0
?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ENDP	; stbi__png_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv69 = 48
tv85 = 52
result$ = 56
p$ = 80
x$ = 88
y$ = 96
n$ = 104
req_comp$ = 112
ri$ = 120
?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__do_png

; 5200 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5201 :     void *result=NULL;

  00018	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 5202 :     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  00021	83 7c 24 70 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00026	7c 07		 jl	 SHORT $LN3@stbi__do_p
  00028	83 7c 24 70 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  0002d	7e 2c		 jle	 SHORT $LN2@stbi__do_p
$LN3@stbi__do_p:
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39425
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN15@stbi__do_p
  0003f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00047	eb 08		 jmp	 SHORT $LN16@stbi__do_p
$LN15@stbi__do_p:
  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN16@stbi__do_p:
  00051	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv69[rsp]
  00056	e9 e2 01 00 00	 jmp	 $LN1@stbi__do_p
$LN2@stbi__do_p:

; 5203 :     if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

  0005b	44 8b 44 24 70	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00060	33 d2		 xor	 edx, edx
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 73 01 00
	00		 je	 $LN4@stbi__do_p

; 5204 :         if (p->depth <= 8)

  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00079	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  0007d	7f 0d		 jg	 SHORT $LN5@stbi__do_p

; 5205 :             ri->bits_per_channel = 8;

  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR ri$[rsp]
  00084	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
  0008a	eb 44		 jmp	 SHORT $LN6@stbi__do_p
$LN5@stbi__do_p:

; 5206 :         else if (p->depth == 16)

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00091	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00095	75 0d		 jne	 SHORT $LN7@stbi__do_p

; 5207 :             ri->bits_per_channel = 16;

  00097	48 8b 44 24 78	 mov	 rax, QWORD PTR ri$[rsp]
  0009c	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16
  000a2	eb 2c		 jmp	 SHORT $LN8@stbi__do_p
$LN7@stbi__do_p:

; 5208 :         else
; 5209 :             return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");

  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39431
  000ab	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN17@stbi__do_p
  000b4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
  000bc	eb 08		 jmp	 SHORT $LN18@stbi__do_p
$LN17@stbi__do_p:
  000be	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN18@stbi__do_p:
  000c6	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv85[rsp]
  000cb	e9 6d 01 00 00	 jmp	 $LN1@stbi__do_p
$LN8@stbi__do_p:
$LN6@stbi__do_p:

; 5210 :         result = p->out;

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000d5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d9	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 5211 :         p->out = NULL;

  000de	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000e3	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5212 :         if (req_comp && req_comp != p->s->img_out_n) {

  000eb	83 7c 24 70 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000f0	0f 84 b4 00 00
	00		 je	 $LN9@stbi__do_p
  000f6	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fe	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00101	39 44 24 70	 cmp	 DWORD PTR req_comp$[rsp], eax
  00105	0f 84 9f 00 00
	00		 je	 $LN9@stbi__do_p

; 5213 :             if (ri->bits_per_channel == 8)

  0010b	48 8b 44 24 78	 mov	 rax, QWORD PTR ri$[rsp]
  00110	83 38 08	 cmp	 DWORD PTR [rax], 8
  00113	75 3b		 jne	 SHORT $LN10@stbi__do_p

; 5214 :                 result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0011a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00122	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00125	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  0012a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0012d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00130	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00134	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00137	44 8b 44 24 70	 mov	 r8d, DWORD PTR req_comp$[rsp]
  0013c	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  0013f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00144	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00149	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
  0014e	eb 39		 jmp	 SHORT $LN11@stbi__do_p
$LN10@stbi__do_p:

; 5215 :             else
; 5216 :                 result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00150	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00155	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00158	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  0015d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00160	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  00165	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00168	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0016b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0016f	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00172	44 8b 44 24 70	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00177	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  0017a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0017f	e8 00 00 00 00	 call	 ?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
  00184	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
$LN11@stbi__do_p:

; 5217 :             p->s->img_out_n = req_comp;

  00189	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0018e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00191	8b 4c 24 70	 mov	 ecx, DWORD PTR req_comp$[rsp]
  00195	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5218 :             if (result == NULL) return result;

  00198	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  0019e	75 0a		 jne	 SHORT $LN12@stbi__do_p
  001a0	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  001a5	e9 93 00 00 00	 jmp	 $LN1@stbi__do_p
$LN12@stbi__do_p:
$LN9@stbi__do_p:

; 5219 :         }
; 5220 :         *x = p->s->img_x;

  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR x$[rsp]
  001b7	8b 00		 mov	 eax, DWORD PTR [rax]
  001b9	89 01		 mov	 DWORD PTR [rcx], eax

; 5221 :         *y = p->s->img_y;

  001bb	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR y$[rsp]
  001c8	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001cb	89 01		 mov	 DWORD PTR [rcx], eax

; 5222 :         if (n) *n = p->s->img_n;

  001cd	48 83 7c 24 68
	00		 cmp	 QWORD PTR n$[rsp], 0
  001d3	74 12		 je	 SHORT $LN13@stbi__do_p
  001d5	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001da	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  001e2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001e5	89 01		 mov	 DWORD PTR [rcx], eax
$LN13@stbi__do_p:
$LN4@stbi__do_p:

; 5223 :     }
; 5224 :     STBI_FREE(p->out);      p->out      = NULL;

  001e7	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001ec	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001f0	e8 00 00 00 00	 call	 free
  001f5	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001fa	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5225 :     STBI_FREE(p->expanded); p->expanded = NULL;

  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00207	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0020b	e8 00 00 00 00	 call	 free
  00210	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00215	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5226 :     STBI_FREE(p->idata);    p->idata    = NULL;

  0021d	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00222	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00226	e8 00 00 00 00	 call	 free
  0022b	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00230	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5227 :     
; 5228 :     return result;

  00238	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__do_p:

; 5229 : }

  0023d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00241	c3		 ret	 0
?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__do_png
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
pal_img_n$ = 64
s$ = 72
has_trans$ = 80
i$ = 84
c$1 = 88
k$ = 96
idata_limit$ = 100
ioff$ = 104
color$ = 108
tv78 = 112
pal_len$ = 116
first$ = 120
tc$ = 124
interlace$ = 128
raw_len$2 = 132
is_iphone$ = 136
tv197 = 140
tv194 = 144
tv337 = 148
tv386 = 152
tv485 = 156
comp$3 = 160
filter$4 = 164
bpl$5 = 168
p$6 = 176
idata_limit_old$7 = 184
$T8 = 188
tc16$ = 196
palette$ = 208
__$ArrayPad$ = 1232
z$ = 1264
scan$ = 1272
req_comp$ = 1280
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z PROC	; stbi__parse_png_file

; 5024 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec e0 04
	00 00		 sub	 rsp, 1248		; 000004e0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5025 :     stbi_uc palette[1024], pal_img_n=0;

  00028	c6 44 24 40 00	 mov	 BYTE PTR pal_img_n$[rsp], 0

; 5026 :     stbi_uc has_trans=0, tc[3]={0};

  0002d	c6 44 24 50 00	 mov	 BYTE PTR has_trans$[rsp], 0
  00032	48 8d 44 24 7c	 lea	 rax, QWORD PTR tc$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 03 00 00 00	 mov	 ecx, 3
  00041	f3 aa		 rep stosb

; 5027 :     stbi__uint16 tc16[3];
; 5028 :     stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;

  00043	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR ioff$[rsp], 0
  0004b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR idata_limit$[rsp], 0
  00053	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR pal_len$[rsp], 0

; 5029 :     int first=1,k,interlace=0, color=0, is_iphone=0;

  0005b	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1
  00063	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR interlace$[rsp], 0
  0006e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR color$[rsp], 0
  00076	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR is_iphone$[rsp], 0

; 5030 :     stbi__context *s = z->s;

  00081	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 44 24 48	 mov	 QWORD PTR s$[rsp], rax

; 5031 :     
; 5032 :     z->expanded = NULL;

  00091	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00099	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5033 :     z->idata = NULL;

  000a1	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000a9	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5034 :     z->out = NULL;

  000b1	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000b9	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5035 :     
; 5036 :     if (!stbi__check_png_header(s)) return 0;

  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000c6	e8 00 00 00 00	 call	 ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
  000cb	85 c0		 test	 eax, eax
  000cd	75 07		 jne	 SHORT $LN21@stbi__pars
  000cf	33 c0		 xor	 eax, eax
  000d1	e9 73 0c 00 00	 jmp	 $LN1@stbi__pars
$LN21@stbi__pars:

; 5037 :     
; 5038 :     if (scan == STBI__SCAN_type) return 1;

  000d6	83 bc 24 f8 04
	00 00 01	 cmp	 DWORD PTR scan$[rsp], 1
  000de	75 0a		 jne	 SHORT $LN22@stbi__pars
  000e0	b8 01 00 00 00	 mov	 eax, 1
  000e5	e9 5f 0c 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:
$LN2@stbi__pars:

; 5039 :     
; 5040 :     for (;;) {
; 5041 :         stbi__pngchunk c = stbi__get_chunk_header(s);

  000ea	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ; stbi__get_chunk_header
  000f4	48 89 84 24 bc
	00 00 00	 mov	 QWORD PTR $T8[rsp], rax
  000fc	48 8b 84 24 bc
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  00104	48 89 44 24 58	 mov	 QWORD PTR c$1[rsp], rax

; 5042 :         switch (c.type) {

  00109	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  0010d	89 44 24 70	 mov	 DWORD PTR tv78[rsp], eax
  00111	81 7c 24 70 52
	44 48 49	 cmp	 DWORD PTR tv78[rsp], 1229472850 ; 49484452H
  00119	77 35		 ja	 SHORT $LN105@stbi__pars
  0011b	81 7c 24 70 52
	44 48 49	 cmp	 DWORD PTR tv78[rsp], 1229472850 ; 49484452H
  00123	74 6a		 je	 SHORT $LN24@stbi__pars
  00125	81 7c 24 70 49
	42 67 43	 cmp	 DWORD PTR tv78[rsp], 1130840649 ; 43674249H
  0012d	74 42		 je	 SHORT $LN23@stbi__pars
  0012f	81 7c 24 70 54
	41 44 49	 cmp	 DWORD PTR tv78[rsp], 1229209940 ; 49444154H
  00137	0f 84 40 06 00
	00		 je	 $LN61@stbi__pars
  0013d	81 7c 24 70 44
	4e 45 49	 cmp	 DWORD PTR tv78[rsp], 1229278788 ; 49454e44H
  00145	0f 84 b3 07 00
	00		 je	 $LN70@stbi__pars
  0014b	e9 2c 0b 00 00	 jmp	 $LN91@stbi__pars
$LN105@stbi__pars:
  00150	81 7c 24 70 45
	54 4c 50	 cmp	 DWORD PTR tv78[rsp], 1347179589 ; 504c5445H
  00158	0f 84 5d 03 00
	00		 je	 $LN45@stbi__pars
  0015e	81 7c 24 70 53
	4e 52 74	 cmp	 DWORD PTR tv78[rsp], 1951551059 ; 74524e53H
  00166	0f 84 42 04 00
	00		 je	 $LN49@stbi__pars
  0016c	e9 0b 0b 00 00	 jmp	 $LN91@stbi__pars
$LN23@stbi__pars:

; 5043 :             case STBI__PNG_TYPE('C','g','B','I'):
; 5044 :             is_iphone = 1;

  00171	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR is_iphone$[rsp], 1

; 5045 :             stbi__skip(s, c.length);

  0017c	8b 54 24 58	 mov	 edx, DWORD PTR c$1[rsp]
  00180	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00185	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5046 :             break;

  0018a	e9 ab 0b 00 00	 jmp	 $LN5@stbi__pars
$LN24@stbi__pars:

; 5047 :             case STBI__PNG_TYPE('I','H','D','R'): {
; 5048 :                 int comp,filter;
; 5049 :                 if (!first) return stbi__err("multiple IHDR","Corrupt PNG");

  0018f	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00194	75 11		 jne	 SHORT $LN25@stbi__pars
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39310
  0019d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001a2	e9 a2 0b 00 00	 jmp	 $LN1@stbi__pars
$LN25@stbi__pars:

; 5050 :                 first = 0;

  001a7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0

; 5051 :                 if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");

  001af	83 7c 24 58 0d	 cmp	 DWORD PTR c$1[rsp], 13
  001b4	74 11		 je	 SHORT $LN26@stbi__pars
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39312
  001bd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c2	e9 82 0b 00 00	 jmp	 $LN1@stbi__pars
$LN26@stbi__pars:

; 5052 :                 s->img_x = stbi__get32be(s);

  001c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001cc	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  001d1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001d6	89 01		 mov	 DWORD PTR [rcx], eax

; 5053 :                 s->img_y = stbi__get32be(s);

  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001dd	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  001e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001e7	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5054 :                 if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  001ea	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  001ef	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  001f6	76 11		 jbe	 SHORT $LN27@stbi__pars
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39314
  001ff	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00204	e9 40 0b 00 00	 jmp	 $LN1@stbi__pars
$LN27@stbi__pars:

; 5055 :                 if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00209	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0020e	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00214	76 11		 jbe	 SHORT $LN28@stbi__pars
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39316
  0021d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00222	e9 22 0b 00 00	 jmp	 $LN1@stbi__pars
$LN28@stbi__pars:

; 5056 :                 z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");

  00227	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0022c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00231	0f b6 c0	 movzx	 eax, al
  00234	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0023c	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0023f	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00247	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  0024b	74 49		 je	 SHORT $LN29@stbi__pars
  0024d	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00255	83 78 20 02	 cmp	 DWORD PTR [rax+32], 2
  00259	74 3b		 je	 SHORT $LN29@stbi__pars
  0025b	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00263	83 78 20 04	 cmp	 DWORD PTR [rax+32], 4
  00267	74 2d		 je	 SHORT $LN29@stbi__pars
  00269	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00271	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  00275	74 1f		 je	 SHORT $LN29@stbi__pars
  00277	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0027f	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00283	74 11		 je	 SHORT $LN29@stbi__pars
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39318
  0028c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00291	e9 b3 0a 00 00	 jmp	 $LN1@stbi__pars
$LN29@stbi__pars:

; 5057 :                 color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");

  00296	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0029b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  002a0	0f b6 c0	 movzx	 eax, al
  002a3	89 44 24 6c	 mov	 DWORD PTR color$[rsp], eax
  002a7	83 7c 24 6c 06	 cmp	 DWORD PTR color$[rsp], 6
  002ac	7e 11		 jle	 SHORT $LN30@stbi__pars
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39320
  002b5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002ba	e9 8a 0a 00 00	 jmp	 $LN1@stbi__pars
$LN30@stbi__pars:

; 5058 :                 if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");

  002bf	83 7c 24 6c 03	 cmp	 DWORD PTR color$[rsp], 3
  002c4	75 1f		 jne	 SHORT $LN31@stbi__pars
  002c6	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002ce	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  002d2	75 11		 jne	 SHORT $LN31@stbi__pars
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39322
  002db	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002e0	e9 64 0a 00 00	 jmp	 $LN1@stbi__pars
$LN31@stbi__pars:

; 5059 :                 if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");

  002e5	83 7c 24 6c 03	 cmp	 DWORD PTR color$[rsp], 3
  002ea	75 07		 jne	 SHORT $LN32@stbi__pars
  002ec	c6 44 24 40 03	 mov	 BYTE PTR pal_img_n$[rsp], 3
  002f1	eb 1c		 jmp	 SHORT $LN33@stbi__pars
$LN32@stbi__pars:
  002f3	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  002f7	83 e0 01	 and	 eax, 1
  002fa	85 c0		 test	 eax, eax
  002fc	74 11		 je	 SHORT $LN34@stbi__pars
  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39326
  00305	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0030a	e9 3a 0a 00 00	 jmp	 $LN1@stbi__pars
$LN34@stbi__pars:
$LN33@stbi__pars:

; 5060 :                 comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");

  0030f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00314	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00319	0f b6 c0	 movzx	 eax, al
  0031c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR comp$3[rsp], eax
  00323	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR comp$3[rsp], 0
  0032b	74 11		 je	 SHORT $LN35@stbi__pars
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39328
  00334	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00339	e9 0b 0a 00 00	 jmp	 $LN1@stbi__pars
$LN35@stbi__pars:

; 5061 :                 filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");

  0033e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00343	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00348	0f b6 c0	 movzx	 eax, al
  0034b	89 84 24 a4 00
	00 00		 mov	 DWORD PTR filter$4[rsp], eax
  00352	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR filter$4[rsp], 0
  0035a	74 11		 je	 SHORT $LN36@stbi__pars
  0035c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39330
  00363	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00368	e9 dc 09 00 00	 jmp	 $LN1@stbi__pars
$LN36@stbi__pars:

; 5062 :                 interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");

  0036d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00372	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00377	0f b6 c0	 movzx	 eax, al
  0037a	89 84 24 80 00
	00 00		 mov	 DWORD PTR interlace$[rsp], eax
  00381	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR interlace$[rsp], 1
  00389	7e 11		 jle	 SHORT $LN37@stbi__pars
  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39332
  00392	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00397	e9 ad 09 00 00	 jmp	 $LN1@stbi__pars
$LN37@stbi__pars:

; 5063 :                 if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");

  0039c	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  003a1	83 38 00	 cmp	 DWORD PTR [rax], 0
  003a4	74 0b		 je	 SHORT $LN39@stbi__pars
  003a6	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  003ab	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  003af	75 11		 jne	 SHORT $LN38@stbi__pars
$LN39@stbi__pars:
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39335
  003b8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003bd	e9 87 09 00 00	 jmp	 $LN1@stbi__pars
$LN38@stbi__pars:

; 5064 :                 if (!pal_img_n) {

  003c2	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  003c7	85 c0		 test	 eax, eax
  003c9	0f 85 a9 00 00
	00		 jne	 $LN40@stbi__pars

; 5065 :                     s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

  003cf	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  003d3	83 e0 02	 and	 eax, 2
  003d6	85 c0		 test	 eax, eax
  003d8	74 0d		 je	 SHORT $LN95@stbi__pars
  003da	c7 84 24 90 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv194[rsp], 3
  003e5	eb 0b		 jmp	 SHORT $LN96@stbi__pars
$LN95@stbi__pars:
  003e7	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv194[rsp], 1
$LN96@stbi__pars:
  003f2	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  003f6	83 e0 04	 and	 eax, 4
  003f9	85 c0		 test	 eax, eax
  003fb	74 0d		 je	 SHORT $LN97@stbi__pars
  003fd	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv197[rsp], 1
  00408	eb 0b		 jmp	 SHORT $LN98@stbi__pars
$LN97@stbi__pars:
  0040a	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN98@stbi__pars:
  00415	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  0041c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  00423	03 c8		 add	 ecx, eax
  00425	8b c1		 mov	 eax, ecx
  00427	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0042c	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5066 :                     if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

  0042f	33 d2		 xor	 edx, edx
  00431	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00436	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0043b	f7 31		 div	 DWORD PTR [rcx]
  0043d	33 d2		 xor	 edx, edx
  0043f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00444	f7 71 08	 div	 DWORD PTR [rcx+8]
  00447	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0044c	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  0044f	73 11		 jae	 SHORT $LN42@stbi__pars
  00451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39339
  00458	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0045d	e9 e7 08 00 00	 jmp	 $LN1@stbi__pars
$LN42@stbi__pars:

; 5067 :                     if (scan == STBI__SCAN_header) return 1;

  00462	83 bc 24 f8 04
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  0046a	75 0a		 jne	 SHORT $LN43@stbi__pars
  0046c	b8 01 00 00 00	 mov	 eax, 1
  00471	e9 d3 08 00 00	 jmp	 $LN1@stbi__pars
$LN43@stbi__pars:

; 5068 :                 } else {

  00476	eb 3e		 jmp	 SHORT $LN41@stbi__pars
$LN40@stbi__pars:

; 5069 :                     // if paletted, then pal_n is our final components, and
; 5070 :                     // img_n is # components to decompress/filter.
; 5071 :                     s->img_n = 1;

  00478	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0047d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1

; 5072 :                     if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");

  00484	33 d2		 xor	 edx, edx
  00486	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  0048b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00490	f7 31		 div	 DWORD PTR [rcx]
  00492	33 d2		 xor	 edx, edx
  00494	b9 04 00 00 00	 mov	 ecx, 4
  00499	f7 f1		 div	 ecx
  0049b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  004a0	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  004a3	73 11		 jae	 SHORT $LN44@stbi__pars
  004a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39342
  004ac	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004b1	e9 93 08 00 00	 jmp	 $LN1@stbi__pars
$LN44@stbi__pars:
$LN41@stbi__pars:

; 5073 :                     // if SCAN_header, have to scan to see if we have a tRNS
; 5074 :                 }
; 5075 :                 break;

  004b6	e9 7f 08 00 00	 jmp	 $LN5@stbi__pars
$LN45@stbi__pars:

; 5076 :             }
; 5077 :             
; 5078 :             case STBI__PNG_TYPE('P','L','T','E'):  {
; 5079 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  004bb	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  004c0	74 11		 je	 SHORT $LN46@stbi__pars
  004c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39345
  004c9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004ce	e9 76 08 00 00	 jmp	 $LN1@stbi__pars
$LN46@stbi__pars:

; 5080 :                 if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");

  004d3	81 7c 24 58 00
	03 00 00	 cmp	 DWORD PTR c$1[rsp], 768	; 00000300H
  004db	76 11		 jbe	 SHORT $LN47@stbi__pars
  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39347
  004e4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004e9	e9 5b 08 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 5081 :                 pal_len = c.length / 3;

  004ee	33 d2		 xor	 edx, edx
  004f0	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  004f4	b9 03 00 00 00	 mov	 ecx, 3
  004f9	f7 f1		 div	 ecx
  004fb	89 44 24 74	 mov	 DWORD PTR pal_len$[rsp], eax

; 5082 :                 if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");

  004ff	6b 44 24 74 03	 imul	 eax, DWORD PTR pal_len$[rsp], 3
  00504	3b 44 24 58	 cmp	 eax, DWORD PTR c$1[rsp]
  00508	74 11		 je	 SHORT $LN48@stbi__pars
  0050a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39349
  00511	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00516	e9 2e 08 00 00	 jmp	 $LN1@stbi__pars
$LN48@stbi__pars:

; 5083 :                 for (i=0; i < pal_len; ++i) {

  0051b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00523	eb 0a		 jmp	 SHORT $LN9@stbi__pars
$LN7@stbi__pars:
  00525	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00529	ff c0		 inc	 eax
  0052b	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN9@stbi__pars:
  0052f	8b 44 24 74	 mov	 eax, DWORD PTR pal_len$[rsp]
  00533	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00537	73 70		 jae	 SHORT $LN8@stbi__pars

; 5084 :                     palette[i*4+0] = stbi__get8(s);

  00539	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0053e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00543	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00547	c1 e1 02	 shl	 ecx, 2
  0054a	8b c9		 mov	 ecx, ecx
  0054c	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al

; 5085 :                     palette[i*4+1] = stbi__get8(s);

  00553	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00558	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0055d	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00561	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  00568	8b c9		 mov	 ecx, ecx
  0056a	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al

; 5086 :                     palette[i*4+2] = stbi__get8(s);

  00571	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00576	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0057b	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  0057f	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  00586	8b c9		 mov	 ecx, ecx
  00588	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al

; 5087 :                     palette[i*4+3] = 255;

  0058f	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00593	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  0059a	8b c0		 mov	 eax, eax
  0059c	c6 84 04 d0 00
	00 00 ff	 mov	 BYTE PTR palette$[rsp+rax], 255 ; 000000ffH

; 5088 :                 }

  005a4	e9 7c ff ff ff	 jmp	 $LN7@stbi__pars
$LN8@stbi__pars:

; 5089 :                 break;

  005a9	e9 8c 07 00 00	 jmp	 $LN5@stbi__pars
$LN49@stbi__pars:

; 5090 :             }
; 5091 :             
; 5092 :             case STBI__PNG_TYPE('t','R','N','S'): {
; 5093 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  005ae	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  005b3	74 11		 je	 SHORT $LN50@stbi__pars
  005b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39352
  005bc	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005c1	e9 83 07 00 00	 jmp	 $LN1@stbi__pars
$LN50@stbi__pars:

; 5094 :                 if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");

  005c6	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005ce	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  005d3	74 11		 je	 SHORT $LN51@stbi__pars
  005d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39354
  005dc	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005e1	e9 63 07 00 00	 jmp	 $LN1@stbi__pars
$LN51@stbi__pars:

; 5095 :                 if (pal_img_n) {

  005e6	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  005eb	85 c0		 test	 eax, eax
  005ed	0f 84 9b 00 00
	00		 je	 $LN52@stbi__pars

; 5096 :                     if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

  005f3	83 bc 24 f8 04
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  005fb	75 16		 jne	 SHORT $LN54@stbi__pars
  005fd	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00602	c7 40 08 04 00
	00 00		 mov	 DWORD PTR [rax+8], 4
  00609	b8 01 00 00 00	 mov	 eax, 1
  0060e	e9 36 07 00 00	 jmp	 $LN1@stbi__pars
$LN54@stbi__pars:

; 5097 :                     if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");

  00613	83 7c 24 74 00	 cmp	 DWORD PTR pal_len$[rsp], 0
  00618	75 11		 jne	 SHORT $LN55@stbi__pars
  0061a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39359
  00621	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00626	e9 1e 07 00 00	 jmp	 $LN1@stbi__pars
$LN55@stbi__pars:

; 5098 :                     if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");

  0062b	8b 44 24 74	 mov	 eax, DWORD PTR pal_len$[rsp]
  0062f	39 44 24 58	 cmp	 DWORD PTR c$1[rsp], eax
  00633	76 11		 jbe	 SHORT $LN56@stbi__pars
  00635	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39361
  0063c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00641	e9 03 07 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 5099 :                     pal_img_n = 4;

  00646	c6 44 24 40 04	 mov	 BYTE PTR pal_img_n$[rsp], 4

; 5100 :                     for (i=0; i < c.length; ++i)

  0064b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00653	eb 0a		 jmp	 SHORT $LN12@stbi__pars
$LN10@stbi__pars:
  00655	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00659	ff c0		 inc	 eax
  0065b	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN12@stbi__pars:
  0065f	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  00663	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00667	73 20		 jae	 SHORT $LN11@stbi__pars

; 5101 :                         palette[i*4+3] = stbi__get8(s);

  00669	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0066e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00673	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00677	8d 0c 8d 03 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+3]
  0067e	8b c9		 mov	 ecx, ecx
  00680	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al
  00687	eb cc		 jmp	 SHORT $LN10@stbi__pars
$LN11@stbi__pars:

; 5102 :                 } else {

  00689	e9 ea 00 00 00	 jmp	 $LN53@stbi__pars
$LN52@stbi__pars:

; 5103 :                     if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");

  0068e	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00693	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00696	83 e0 01	 and	 eax, 1
  00699	85 c0		 test	 eax, eax
  0069b	75 11		 jne	 SHORT $LN57@stbi__pars
  0069d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39363
  006a4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  006a9	e9 9b 06 00 00	 jmp	 $LN1@stbi__pars
$LN57@stbi__pars:

; 5104 :                     if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");

  006ae	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  006b3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006b6	d1 e0		 shl	 eax, 1
  006b8	39 44 24 58	 cmp	 DWORD PTR c$1[rsp], eax
  006bc	74 11		 je	 SHORT $LN58@stbi__pars
  006be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39365
  006c5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  006ca	e9 7a 06 00 00	 jmp	 $LN1@stbi__pars
$LN58@stbi__pars:

; 5105 :                     has_trans = 1;

  006cf	c6 44 24 50 01	 mov	 BYTE PTR has_trans$[rsp], 1

; 5106 :                     if (z->depth == 16) {

  006d4	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006dc	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  006e0	75 3d		 jne	 SHORT $LN59@stbi__pars

; 5107 :                         for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

  006e2	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  006ea	eb 0a		 jmp	 SHORT $LN15@stbi__pars
$LN13@stbi__pars:
  006ec	8b 44 24 60	 mov	 eax, DWORD PTR k$[rsp]
  006f0	ff c0		 inc	 eax
  006f2	89 44 24 60	 mov	 DWORD PTR k$[rsp], eax
$LN15@stbi__pars:
  006f6	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  006fb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006fe	39 44 24 60	 cmp	 DWORD PTR k$[rsp], eax
  00702	7d 19		 jge	 SHORT $LN14@stbi__pars
  00704	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00709	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0070e	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR k$[rsp]
  00713	66 89 84 4c c4
	00 00 00	 mov	 WORD PTR tc16$[rsp+rcx*2], ax
  0071b	eb cf		 jmp	 SHORT $LN13@stbi__pars
$LN14@stbi__pars:

; 5108 :                     } else {

  0071d	eb 59		 jmp	 SHORT $LN60@stbi__pars
$LN59@stbi__pars:

; 5109 :                         for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

  0071f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00727	eb 0a		 jmp	 SHORT $LN18@stbi__pars
$LN16@stbi__pars:
  00729	8b 44 24 60	 mov	 eax, DWORD PTR k$[rsp]
  0072d	ff c0		 inc	 eax
  0072f	89 44 24 60	 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__pars:
  00733	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00738	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0073b	39 44 24 60	 cmp	 DWORD PTR k$[rsp], eax
  0073f	7d 37		 jge	 SHORT $LN17@stbi__pars
  00741	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00746	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0074b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00750	0f b6 c0	 movzx	 eax, al
  00753	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0075b	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  0075f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__depth_scale_table@@3QBEB
  00766	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0076a	0f af c1	 imul	 eax, ecx
  0076d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR k$[rsp]
  00772	88 44 0c 7c	 mov	 BYTE PTR tc$[rsp+rcx], al
  00776	eb b1		 jmp	 SHORT $LN16@stbi__pars
$LN17@stbi__pars:
$LN60@stbi__pars:
$LN53@stbi__pars:

; 5110 :                     }
; 5111 :                 }
; 5112 :                 break;

  00778	e9 bd 05 00 00	 jmp	 $LN5@stbi__pars
$LN61@stbi__pars:

; 5113 :             }
; 5114 :             
; 5115 :             case STBI__PNG_TYPE('I','D','A','T'): {
; 5116 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0077d	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00782	74 11		 je	 SHORT $LN62@stbi__pars
  00784	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39370
  0078b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00790	e9 b4 05 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 5117 :                 if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");

  00795	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  0079a	85 c0		 test	 eax, eax
  0079c	74 18		 je	 SHORT $LN63@stbi__pars
  0079e	83 7c 24 74 00	 cmp	 DWORD PTR pal_len$[rsp], 0
  007a3	75 11		 jne	 SHORT $LN63@stbi__pars
  007a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39372
  007ac	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  007b1	e9 93 05 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:

; 5118 :                 if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }

  007b6	83 bc 24 f8 04
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  007be	75 17		 jne	 SHORT $LN64@stbi__pars
  007c0	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  007c5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  007ca	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  007cd	b8 01 00 00 00	 mov	 eax, 1
  007d2	e9 72 05 00 00	 jmp	 $LN1@stbi__pars
$LN64@stbi__pars:

; 5119 :                 if ((int)(ioff + c.length) < (int)ioff) return 0;

  007d7	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  007db	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  007df	03 c8		 add	 ecx, eax
  007e1	8b c1		 mov	 eax, ecx
  007e3	3b 44 24 68	 cmp	 eax, DWORD PTR ioff$[rsp]
  007e7	7d 07		 jge	 SHORT $LN65@stbi__pars
  007e9	33 c0		 xor	 eax, eax
  007eb	e9 59 05 00 00	 jmp	 $LN1@stbi__pars
$LN65@stbi__pars:

; 5120 :                 if (ioff + c.length > idata_limit) {

  007f0	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  007f4	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  007f8	03 c8		 add	 ecx, eax
  007fa	8b c1		 mov	 eax, ecx
  007fc	3b 44 24 64	 cmp	 eax, DWORD PTR idata_limit$[rsp]
  00800	0f 86 ac 00 00
	00		 jbe	 $LN66@stbi__pars

; 5121 :                     stbi__uint32 idata_limit_old = idata_limit;

  00806	8b 44 24 64	 mov	 eax, DWORD PTR idata_limit$[rsp]
  0080a	89 84 24 b8 00
	00 00		 mov	 DWORD PTR idata_limit_old$7[rsp], eax

; 5122 :                     stbi_uc *p;
; 5123 :                     if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

  00811	83 7c 24 64 00	 cmp	 DWORD PTR idata_limit$[rsp], 0
  00816	75 2d		 jne	 SHORT $LN67@stbi__pars
  00818	81 7c 24 58 00
	10 00 00	 cmp	 DWORD PTR c$1[rsp], 4096 ; 00001000H
  00820	76 0d		 jbe	 SHORT $LN99@stbi__pars
  00822	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  00826	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv337[rsp], eax
  0082d	eb 0b		 jmp	 SHORT $LN100@stbi__pars
$LN99@stbi__pars:
  0082f	c7 84 24 94 00
	00 00 00 10 00
	00		 mov	 DWORD PTR tv337[rsp], 4096 ; 00001000H
$LN100@stbi__pars:
  0083a	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv337[rsp]
  00841	89 44 24 64	 mov	 DWORD PTR idata_limit$[rsp], eax
$LN67@stbi__pars:
$LN19@stbi__pars:

; 5124 :                     while (ioff + c.length > idata_limit)

  00845	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  00849	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  0084d	03 c8		 add	 ecx, eax
  0084f	8b c1		 mov	 eax, ecx
  00851	3b 44 24 64	 cmp	 eax, DWORD PTR idata_limit$[rsp]
  00855	76 0c		 jbe	 SHORT $LN20@stbi__pars

; 5125 :                         idata_limit *= 2;

  00857	8b 44 24 64	 mov	 eax, DWORD PTR idata_limit$[rsp]
  0085b	d1 e0		 shl	 eax, 1
  0085d	89 44 24 64	 mov	 DWORD PTR idata_limit$[rsp], eax
  00861	eb e2		 jmp	 SHORT $LN19@stbi__pars
$LN20@stbi__pars:

; 5126 :                     STBI_NOTUSED(idata_limit_old);
; 5127 :                     p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00863	8b 44 24 64	 mov	 eax, DWORD PTR idata_limit$[rsp]
  00867	8b d0		 mov	 edx, eax
  00869	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00871	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00875	e8 00 00 00 00	 call	 realloc
  0087a	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR p$6[rsp], rax
  00882	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR p$6[rsp], 0
  0088b	75 11		 jne	 SHORT $LN68@stbi__pars
  0088d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39378
  00894	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00899	e9 ab 04 00 00	 jmp	 $LN1@stbi__pars
$LN68@stbi__pars:

; 5128 :                     z->idata = p;

  0089e	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008a6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$6[rsp]
  008ae	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN66@stbi__pars:

; 5129 :                 }
; 5130 :                 if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");

  008b2	8b 44 24 68	 mov	 eax, DWORD PTR ioff$[rsp]
  008b6	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008be	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  008c2	44 8b 44 24 58	 mov	 r8d, DWORD PTR c$1[rsp]
  008c7	48 8b d0	 mov	 rdx, rax
  008ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  008cf	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
  008d4	85 c0		 test	 eax, eax
  008d6	75 11		 jne	 SHORT $LN69@stbi__pars
  008d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39380
  008df	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  008e4	e9 60 04 00 00	 jmp	 $LN1@stbi__pars
$LN69@stbi__pars:

; 5131 :                 ioff += c.length;

  008e9	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  008ed	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  008f1	03 c8		 add	 ecx, eax
  008f3	8b c1		 mov	 eax, ecx
  008f5	89 44 24 68	 mov	 DWORD PTR ioff$[rsp], eax

; 5132 :                 break;

  008f9	e9 3c 04 00 00	 jmp	 $LN5@stbi__pars
$LN70@stbi__pars:

; 5133 :             }
; 5134 :             
; 5135 :             case STBI__PNG_TYPE('I','E','N','D'): {
; 5136 :                 stbi__uint32 raw_len, bpl;
; 5137 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  008fe	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00903	74 11		 je	 SHORT $LN71@stbi__pars
  00905	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39383
  0090c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00911	e9 33 04 00 00	 jmp	 $LN1@stbi__pars
$LN71@stbi__pars:

; 5138 :                 if (scan != STBI__SCAN_load) return 1;

  00916	83 bc 24 f8 04
	00 00 00	 cmp	 DWORD PTR scan$[rsp], 0
  0091e	74 0a		 je	 SHORT $LN72@stbi__pars
  00920	b8 01 00 00 00	 mov	 eax, 1
  00925	e9 1f 04 00 00	 jmp	 $LN1@stbi__pars
$LN72@stbi__pars:

; 5139 :                 if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");

  0092a	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00932	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00937	75 11		 jne	 SHORT $LN73@stbi__pars
  00939	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39386
  00940	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00945	e9 ff 03 00 00	 jmp	 $LN1@stbi__pars
$LN73@stbi__pars:

; 5140 :                 // initial guess for decoded data size to avoid unnecessary reallocs
; 5141 :                 bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

  0094a	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0094f	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00957	8b 00		 mov	 eax, DWORD PTR [rax]
  00959	0f af 41 20	 imul	 eax, DWORD PTR [rcx+32]
  0095d	83 c0 07	 add	 eax, 7
  00960	33 d2		 xor	 edx, edx
  00962	b9 08 00 00 00	 mov	 ecx, 8
  00967	f7 f1		 div	 ecx
  00969	89 84 24 a8 00
	00 00		 mov	 DWORD PTR bpl$5[rsp], eax

; 5142 :                 raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

  00970	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00975	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR bpl$5[rsp]
  0097c	0f af 48 04	 imul	 ecx, DWORD PTR [rax+4]
  00980	8b c1		 mov	 eax, ecx
  00982	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00987	0f af 41 08	 imul	 eax, DWORD PTR [rcx+8]
  0098b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00990	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00993	89 84 24 84 00
	00 00		 mov	 DWORD PTR raw_len$2[rsp], eax

; 5143 :                 z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

  0099a	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR is_iphone$[rsp], 0
  009a2	75 0d		 jne	 SHORT $LN101@stbi__pars
  009a4	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv386[rsp], 1
  009af	eb 0b		 jmp	 SHORT $LN102@stbi__pars
$LN101@stbi__pars:
  009b1	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv386[rsp], 0
$LN102@stbi__pars:
  009bc	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv386[rsp]
  009c3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  009c7	4c 8d 8c 24 84
	00 00 00	 lea	 r9, QWORD PTR raw_len$2[rsp]
  009cf	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR raw_len$2[rsp]
  009d7	8b 54 24 68	 mov	 edx, DWORD PTR ioff$[rsp]
  009db	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009e3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  009e7	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize_headerflag
  009ec	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009f4	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 5144 :                 if (z->expanded == NULL) return 0; // zlib should set error

  009f8	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a00	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00a05	75 07		 jne	 SHORT $LN74@stbi__pars
  00a07	33 c0		 xor	 eax, eax
  00a09	e9 3b 03 00 00	 jmp	 $LN1@stbi__pars
$LN74@stbi__pars:

; 5145 :                 STBI_FREE(z->idata); z->idata = NULL;

  00a0e	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a16	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00a1a	e8 00 00 00 00	 call	 free
  00a1f	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a27	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5146 :                 if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

  00a2f	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00a34	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a37	ff c0		 inc	 eax
  00a39	39 84 24 00 05
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00a40	75 13		 jne	 SHORT $LN78@stbi__pars
  00a42	83 bc 24 00 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  00a4a	74 09		 je	 SHORT $LN78@stbi__pars
  00a4c	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00a51	85 c0		 test	 eax, eax
  00a53	74 09		 je	 SHORT $LN77@stbi__pars
$LN78@stbi__pars:
  00a55	0f b6 44 24 50	 movzx	 eax, BYTE PTR has_trans$[rsp]
  00a5a	85 c0		 test	 eax, eax
  00a5c	74 14		 je	 SHORT $LN75@stbi__pars
$LN77@stbi__pars:

; 5147 :                     s->img_out_n = s->img_n+1;

  00a5e	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00a63	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a66	ff c0		 inc	 eax
  00a68	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00a6d	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  00a70	eb 10		 jmp	 SHORT $LN76@stbi__pars
$LN75@stbi__pars:

; 5148 :                 else
; 5149 :                     s->img_out_n = s->img_n;

  00a72	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00a77	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00a7c	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00a7f	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN76@stbi__pars:

; 5150 :                 if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

  00a82	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR interlace$[rsp]
  00a89	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a8d	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  00a91	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a95	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a9d	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00aa0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00aa4	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00aa9	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  00aad	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR raw_len$2[rsp]
  00ab5	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00abd	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00ac1	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00ac9	e8 00 00 00 00	 call	 ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ; stbi__create_png_image
  00ace	85 c0		 test	 eax, eax
  00ad0	75 07		 jne	 SHORT $LN79@stbi__pars
  00ad2	33 c0		 xor	 eax, eax
  00ad4	e9 70 02 00 00	 jmp	 $LN1@stbi__pars
$LN79@stbi__pars:

; 5151 :                 if (has_trans) {

  00ad9	0f b6 44 24 50	 movzx	 eax, BYTE PTR has_trans$[rsp]
  00ade	85 c0		 test	 eax, eax
  00ae0	74 5f		 je	 SHORT $LN80@stbi__pars

; 5152 :                     if (z->depth == 16) {

  00ae2	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00aea	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00aee	75 2b		 jne	 SHORT $LN81@stbi__pars

; 5153 :                         if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;

  00af0	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00af5	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00af9	48 8d 94 24 c4
	00 00 00	 lea	 rdx, QWORD PTR tc16$[rsp]
  00b01	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b09	e8 00 00 00 00	 call	 ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z ; stbi__compute_transparency16
  00b0e	85 c0		 test	 eax, eax
  00b10	75 07		 jne	 SHORT $LN83@stbi__pars
  00b12	33 c0		 xor	 eax, eax
  00b14	e9 30 02 00 00	 jmp	 $LN1@stbi__pars
$LN83@stbi__pars:

; 5154 :                     } else {

  00b19	eb 26		 jmp	 SHORT $LN82@stbi__pars
$LN81@stbi__pars:

; 5155 :                         if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

  00b1b	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00b20	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00b24	48 8d 54 24 7c	 lea	 rdx, QWORD PTR tc$[rsp]
  00b29	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b31	e8 00 00 00 00	 call	 ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ; stbi__compute_transparency
  00b36	85 c0		 test	 eax, eax
  00b38	75 07		 jne	 SHORT $LN84@stbi__pars
  00b3a	33 c0		 xor	 eax, eax
  00b3c	e9 08 02 00 00	 jmp	 $LN1@stbi__pars
$LN84@stbi__pars:
$LN82@stbi__pars:
$LN80@stbi__pars:

; 5156 :                     }
; 5157 :                 }
; 5158 :                 if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

  00b41	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR is_iphone$[rsp], 0
  00b49	74 75		 je	 SHORT $LN85@stbi__pars
  00b4b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_set@@3HA
  00b50	8b c0		 mov	 eax, eax
  00b52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b58	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b61	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b65	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00b69	74 26		 je	 SHORT $LN103@stbi__pars
  00b6b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_local@@3HA
  00b70	8b c0		 mov	 eax, eax
  00b72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b78	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b81	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b85	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00b88	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv485[rsp], eax
  00b8f	eb 0d		 jmp	 SHORT $LN104@stbi__pars
$LN103@stbi__pars:
  00b91	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__de_iphone_flag_global@@3HA
  00b97	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv485[rsp], eax
$LN104@stbi__pars:
  00b9e	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv485[rsp], 0
  00ba6	74 18		 je	 SHORT $LN85@stbi__pars
  00ba8	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00bad	83 78 0c 02	 cmp	 DWORD PTR [rax+12], 2
  00bb1	7e 0d		 jle	 SHORT $LN85@stbi__pars

; 5159 :                     stbi__de_iphone(z);

  00bb3	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00bbb	e8 00 00 00 00	 call	 ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z ; stbi__de_iphone
$LN85@stbi__pars:

; 5160 :                 if (pal_img_n) {

  00bc0	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00bc5	85 c0		 test	 eax, eax
  00bc7	74 63		 je	 SHORT $LN86@stbi__pars

; 5161 :                     // pal_img_n == 3 or 4
; 5162 :                     s->img_n = pal_img_n; // record the actual colors we had

  00bc9	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00bce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00bd3	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5163 :                     s->img_out_n = pal_img_n;

  00bd6	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00bdb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00be0	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5164 :                     if (req_comp >= 3) s->img_out_n = req_comp;

  00be3	83 bc 24 00 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  00beb	7c 0f		 jl	 SHORT $LN88@stbi__pars
  00bed	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00bf2	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  00bf9	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN88@stbi__pars:

; 5165 :                     if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

  00bfc	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00c01	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  00c05	44 8b 44 24 74	 mov	 r8d, DWORD PTR pal_len$[rsp]
  00c0a	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR palette$[rsp]
  00c12	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c1a	e8 00 00 00 00	 call	 ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ; stbi__expand_png_palette
  00c1f	85 c0		 test	 eax, eax
  00c21	75 07		 jne	 SHORT $LN89@stbi__pars

; 5166 :                         return 0;

  00c23	33 c0		 xor	 eax, eax
  00c25	e9 1f 01 00 00	 jmp	 $LN1@stbi__pars
$LN89@stbi__pars:
  00c2a	eb 1b		 jmp	 SHORT $LN87@stbi__pars
$LN86@stbi__pars:

; 5167 :                 } else if (has_trans) {

  00c2c	0f b6 44 24 50	 movzx	 eax, BYTE PTR has_trans$[rsp]
  00c31	85 c0		 test	 eax, eax
  00c33	74 12		 je	 SHORT $LN90@stbi__pars

; 5168 :                     // non-paletted image with tRNS -> source image has (constant) alpha
; 5169 :                     ++s->img_n;

  00c35	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00c3a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00c3d	ff c0		 inc	 eax
  00c3f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00c44	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN90@stbi__pars:
$LN87@stbi__pars:

; 5170 :                 }
; 5171 :                 STBI_FREE(z->expanded); z->expanded = NULL;

  00c47	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c4f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00c53	e8 00 00 00 00	 call	 free
  00c58	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c60	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5172 :                 // end of PNG chunk, read and skip CRC
; 5173 :                 stbi__get32be(s);

  00c68	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00c6d	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 5174 :                 return 1;

  00c72	b8 01 00 00 00	 mov	 eax, 1
  00c77	e9 cd 00 00 00	 jmp	 $LN1@stbi__pars
$LN91@stbi__pars:

; 5175 :             }
; 5176 :             
; 5177 :             default:
; 5178 :             // if critical, fail
; 5179 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00c7c	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00c81	74 11		 je	 SHORT $LN92@stbi__pars
  00c83	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39406
  00c8a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00c8f	e9 b5 00 00 00	 jmp	 $LN1@stbi__pars
$LN92@stbi__pars:

; 5180 :             if ((c.type & (1 << 29)) == 0) {

  00c94	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00c98	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00c9d	85 c0		 test	 eax, eax
  00c9f	0f 85 87 00 00
	00		 jne	 $LN93@stbi__pars

; 5181 : #ifndef STBI_NO_FAILURE_STRINGS
; 5182 :                 // not threadsafe
; 5183 :                 static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5184 :                 invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

  00ca5	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00ca9	c1 e8 18	 shr	 eax, 24
  00cac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00cb1	b9 01 00 00 00	 mov	 ecx, 1
  00cb6	48 6b c9 00	 imul	 rcx, rcx, 0
  00cba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00cc1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5185 :                 invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);

  00cc4	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00cc8	c1 e8 10	 shr	 eax, 16
  00ccb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00cd0	b9 01 00 00 00	 mov	 ecx, 1
  00cd5	48 6b c9 01	 imul	 rcx, rcx, 1
  00cd9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00ce0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5186 :                 invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);

  00ce3	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00ce7	c1 e8 08	 shr	 eax, 8
  00cea	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00cef	b9 01 00 00 00	 mov	 ecx, 1
  00cf4	48 6b c9 02	 imul	 rcx, rcx, 2
  00cf8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00cff	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5187 :                 invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);

  00d02	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00d06	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d0b	b9 01 00 00 00	 mov	 ecx, 1
  00d10	48 6b c9 03	 imul	 rcx, rcx, 3
  00d14	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00d1b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5188 : #endif
; 5189 :                 return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

  00d1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?invalid_chunk@?JH@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00d25	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00d2a	eb 1d		 jmp	 SHORT $LN1@stbi__pars
$LN93@stbi__pars:

; 5190 :             }
; 5191 :             stbi__skip(s, c.length);

  00d2c	8b 54 24 58	 mov	 edx, DWORD PTR c$1[rsp]
  00d30	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00d35	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN5@stbi__pars:

; 5192 :             break;
; 5193 :         }
; 5194 :         // end of PNG chunk, read and skip CRC
; 5195 :         stbi__get32be(s);

  00d3a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00d3f	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 5196 :     }

  00d44	e9 a1 f3 ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 5197 : }

  00d49	48 8b 8c 24 d0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d51	48 33 cc	 xor	 rcx, rsp
  00d54	e8 00 00 00 00	 call	 __security_check_cookie
  00d59	48 81 c4 e0 04
	00 00		 add	 rsp, 1248		; 000004e0H
  00d60	5f		 pop	 rdi
  00d61	c3		 ret	 0
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ENDP	; stbi__parse_png_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$1 = 0
half$2 = 1
p$ = 8
t$3 = 16
i$ = 20
t$4 = 24
t$5 = 25
pixel_count$ = 28
tv130 = 32
s$ = 40
z$ = 64
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z PROC		; stbi__de_iphone

; 4979 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4980 :     stbi__context *s = z->s;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 4981 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00016	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00020	8b 00		 mov	 eax, DWORD PTR [rax]
  00022	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00026	89 44 24 1c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4982 :     stbi_uc *p = z->out;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0002f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00033	48 89 44 24 08	 mov	 QWORD PTR p$[rsp], rax

; 4983 :     
; 4984 :     if (s->img_out_n == 3) {  // convert bgr to rgb

  00038	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0003d	83 78 0c 03	 cmp	 DWORD PTR [rax+12], 3
  00041	0f 85 83 00 00
	00		 jne	 $LN11@stbi__de_i

; 4985 :         for (i=0; i < pixel_count; ++i) {

  00047	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004f	eb 0a		 jmp	 SHORT $LN4@stbi__de_i
$LN2@stbi__de_i:
  00051	8b 44 24 14	 mov	 eax, DWORD PTR i$[rsp]
  00055	ff c0		 inc	 eax
  00057	89 44 24 14	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__de_i:
  0005b	8b 44 24 1c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0005f	39 44 24 14	 cmp	 DWORD PTR i$[rsp], eax
  00063	73 60		 jae	 SHORT $LN3@stbi__de_i

; 4986 :             stbi_uc t = p[0];

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	48 6b c0 00	 imul	 rax, rax, 0
  0006e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  00073	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00077	88 44 24 18	 mov	 BYTE PTR t$4[rsp], al

; 4987 :             p[0] = p[2];

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 02	 imul	 rax, rax, 2
  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	48 6b c9 00	 imul	 rcx, rcx, 0
  0008d	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00092	4c 8b 44 24 08	 mov	 r8, QWORD PTR p$[rsp]
  00097	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0009c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4988 :             p[2] = t;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 02	 imul	 rax, rax, 2
  000a8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  000ad	0f b6 54 24 18	 movzx	 edx, BYTE PTR t$4[rsp]
  000b2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4989 :             p += 3;

  000b5	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  000ba	48 83 c0 03	 add	 rax, 3
  000be	48 89 44 24 08	 mov	 QWORD PTR p$[rsp], rax

; 4990 :         }

  000c3	eb 8c		 jmp	 SHORT $LN2@stbi__de_i
$LN3@stbi__de_i:

; 4991 :     } else {

  000c5	e9 3b 02 00 00	 jmp	 $LN12@stbi__de_i
$LN11@stbi__de_i:

; 4992 :         STBI_ASSERT(s->img_out_n == 4);

  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000cf	83 78 0c 04	 cmp	 DWORD PTR [rax+12], 4
  000d3	74 0b		 je	 SHORT $LN13@stbi__de_i
  000d5	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN13@stbi__de_i:

; 4993 :         if (stbi__unpremultiply_on_load) {

  000e0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_set@@3HA
  000e5	8b c0		 mov	 eax, eax
  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000ed	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000f6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000fa	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  000fe	74 23		 je	 SHORT $LN19@stbi__de_i
  00100	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_local@@3HA
  00105	8b c0		 mov	 eax, eax
  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0010d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00116	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0011a	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  0011d	89 44 24 20	 mov	 DWORD PTR tv130[rsp], eax
  00121	eb 0a		 jmp	 SHORT $LN20@stbi__de_i
$LN19@stbi__de_i:
  00123	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__unpremultiply_on_load_global@@3HA
  00129	89 44 24 20	 mov	 DWORD PTR tv130[rsp], eax
$LN20@stbi__de_i:
  0012d	83 7c 24 20 00	 cmp	 DWORD PTR tv130[rsp], 0
  00132	0f 84 4f 01 00
	00		 je	 $LN14@stbi__de_i

; 4994 :             // convert bgr to rgb and unpremultiply
; 4995 :             for (i=0; i < pixel_count; ++i) {

  00138	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00140	eb 0a		 jmp	 SHORT $LN7@stbi__de_i
$LN5@stbi__de_i:
  00142	8b 44 24 14	 mov	 eax, DWORD PTR i$[rsp]
  00146	ff c0		 inc	 eax
  00148	89 44 24 14	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__de_i:
  0014c	8b 44 24 1c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00150	39 44 24 14	 cmp	 DWORD PTR i$[rsp], eax
  00154	0f 83 2b 01 00
	00		 jae	 $LN6@stbi__de_i

; 4996 :                 stbi_uc a = p[3];

  0015a	b8 01 00 00 00	 mov	 eax, 1
  0015f	48 6b c0 03	 imul	 rax, rax, 3
  00163	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  00168	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0016c	88 04 24	 mov	 BYTE PTR a$1[rsp], al

; 4997 :                 stbi_uc t = p[0];

  0016f	b8 01 00 00 00	 mov	 eax, 1
  00174	48 6b c0 00	 imul	 rax, rax, 0
  00178	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  0017d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00181	88 44 24 10	 mov	 BYTE PTR t$3[rsp], al

; 4998 :                 if (a) {

  00185	0f b6 04 24	 movzx	 eax, BYTE PTR a$1[rsp]
  00189	85 c0		 test	 eax, eax
  0018b	0f 84 a7 00 00
	00		 je	 $LN16@stbi__de_i

; 4999 :                     stbi_uc half = a / 2;

  00191	0f b6 04 24	 movzx	 eax, BYTE PTR a$1[rsp]
  00195	99		 cdq
  00196	2b c2		 sub	 eax, edx
  00198	d1 f8		 sar	 eax, 1
  0019a	88 44 24 01	 mov	 BYTE PTR half$2[rsp], al

; 5000 :                     p[0] = (p[2] * 255 + half) / a;

  0019e	b8 01 00 00 00	 mov	 eax, 1
  001a3	48 6b c0 02	 imul	 rax, rax, 2
  001a7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  001ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b0	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  001b6	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR half$2[rsp]
  001bb	03 c1		 add	 eax, ecx
  001bd	0f b6 0c 24	 movzx	 ecx, BYTE PTR a$1[rsp]
  001c1	99		 cdq
  001c2	f7 f9		 idiv	 ecx
  001c4	b9 01 00 00 00	 mov	 ecx, 1
  001c9	48 6b c9 00	 imul	 rcx, rcx, 0
  001cd	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  001d2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5001 :                     p[1] = (p[1] * 255 + half) / a;

  001d5	b8 01 00 00 00	 mov	 eax, 1
  001da	48 6b c0 01	 imul	 rax, rax, 1
  001de	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  001e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e7	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  001ed	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR half$2[rsp]
  001f2	03 c1		 add	 eax, ecx
  001f4	0f b6 0c 24	 movzx	 ecx, BYTE PTR a$1[rsp]
  001f8	99		 cdq
  001f9	f7 f9		 idiv	 ecx
  001fb	b9 01 00 00 00	 mov	 ecx, 1
  00200	48 6b c9 01	 imul	 rcx, rcx, 1
  00204	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00209	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5002 :                     p[2] = ( t   * 255 + half) / a;

  0020c	0f b6 44 24 10	 movzx	 eax, BYTE PTR t$3[rsp]
  00211	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  00217	0f b6 4c 24 01	 movzx	 ecx, BYTE PTR half$2[rsp]
  0021c	03 c1		 add	 eax, ecx
  0021e	0f b6 0c 24	 movzx	 ecx, BYTE PTR a$1[rsp]
  00222	99		 cdq
  00223	f7 f9		 idiv	 ecx
  00225	b9 01 00 00 00	 mov	 ecx, 1
  0022a	48 6b c9 02	 imul	 rcx, rcx, 2
  0022e	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  00233	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5003 :                 } else {

  00236	eb 3a		 jmp	 SHORT $LN17@stbi__de_i
$LN16@stbi__de_i:

; 5004 :                     p[0] = p[2];

  00238	b8 01 00 00 00	 mov	 eax, 1
  0023d	48 6b c0 02	 imul	 rax, rax, 2
  00241	b9 01 00 00 00	 mov	 ecx, 1
  00246	48 6b c9 00	 imul	 rcx, rcx, 0
  0024a	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  0024f	4c 8b 44 24 08	 mov	 r8, QWORD PTR p$[rsp]
  00254	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00259	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5005 :                     p[2] = t;

  0025c	b8 01 00 00 00	 mov	 eax, 1
  00261	48 6b c0 02	 imul	 rax, rax, 2
  00265	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  0026a	0f b6 54 24 10	 movzx	 edx, BYTE PTR t$3[rsp]
  0026f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN17@stbi__de_i:

; 5006 :                 }
; 5007 :                 p += 4;

  00272	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  00277	48 83 c0 04	 add	 rax, 4
  0027b	48 89 44 24 08	 mov	 QWORD PTR p$[rsp], rax

; 5008 :             }

  00280	e9 bd fe ff ff	 jmp	 $LN5@stbi__de_i
$LN6@stbi__de_i:

; 5009 :         } else {

  00285	eb 7e		 jmp	 SHORT $LN15@stbi__de_i
$LN14@stbi__de_i:

; 5010 :             // convert bgr to rgb
; 5011 :             for (i=0; i < pixel_count; ++i) {

  00287	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0028f	eb 0a		 jmp	 SHORT $LN10@stbi__de_i
$LN8@stbi__de_i:
  00291	8b 44 24 14	 mov	 eax, DWORD PTR i$[rsp]
  00295	ff c0		 inc	 eax
  00297	89 44 24 14	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__de_i:
  0029b	8b 44 24 1c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0029f	39 44 24 14	 cmp	 DWORD PTR i$[rsp], eax
  002a3	73 60		 jae	 SHORT $LN9@stbi__de_i

; 5012 :                 stbi_uc t = p[0];

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	48 6b c0 00	 imul	 rax, rax, 0
  002ae	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  002b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b7	88 44 24 19	 mov	 BYTE PTR t$5[rsp], al

; 5013 :                 p[0] = p[2];

  002bb	b8 01 00 00 00	 mov	 eax, 1
  002c0	48 6b c0 02	 imul	 rax, rax, 2
  002c4	b9 01 00 00 00	 mov	 ecx, 1
  002c9	48 6b c9 00	 imul	 rcx, rcx, 0
  002cd	48 8b 54 24 08	 mov	 rdx, QWORD PTR p$[rsp]
  002d2	4c 8b 44 24 08	 mov	 r8, QWORD PTR p$[rsp]
  002d7	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002dc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5014 :                 p[2] = t;

  002df	b8 01 00 00 00	 mov	 eax, 1
  002e4	48 6b c0 02	 imul	 rax, rax, 2
  002e8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR p$[rsp]
  002ed	0f b6 54 24 19	 movzx	 edx, BYTE PTR t$5[rsp]
  002f2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5015 :                 p += 4;

  002f5	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  002fa	48 83 c0 04	 add	 rax, 4
  002fe	48 89 44 24 08	 mov	 QWORD PTR p$[rsp], rax

; 5016 :             }

  00303	eb 8c		 jmp	 SHORT $LN8@stbi__de_i
$LN9@stbi__de_i:
$LN15@stbi__de_i:
$LN12@stbi__de_i:

; 5017 :         }
; 5018 :     }
; 5019 : }

  00305	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00309	c3		 ret	 0
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z ENDP		; stbi__de_iphone
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 8
?stbi__unpremultiply_on_load_thread@@YAXH@Z PROC	; stbi__unpremultiply_on_load_thread

; 4959 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4960 :     stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;

  00004	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_local@@3HA
  00009	8b c0		 mov	 eax, eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00011	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
  00022	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 4961 :     stbi__unpremultiply_on_load_set = 1;

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_set@@3HA
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003f	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 4962 : }

  00046	c3		 ret	 0
?stbi__unpremultiply_on_load_thread@@YAXH@Z ENDP	; stbi__unpremultiply_on_load_thread
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
n$1 = 36
n$2 = 40
pixel_count$ = 44
p$ = 48
orig$ = 56
temp_out$ = 64
a$ = 96
palette$ = 104
len$ = 112
pal_img_n$ = 120
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z PROC ; stbi__expand_png_palette

; 4902 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4903 :     stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0002e	89 44 24 2c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4904 :     stbi_uc *p, *temp_out, *orig = a->out;

  00032	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00037	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003b	48 89 44 24 38	 mov	 QWORD PTR orig$[rsp], rax

; 4905 :     
; 4906 :     p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);

  00040	45 33 c0	 xor	 r8d, r8d
  00043	8b 54 24 78	 mov	 edx, DWORD PTR pal_img_n$[rsp]
  00047	8b 4c 24 2c	 mov	 ecx, DWORD PTR pixel_count$[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  00050	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4907 :     if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0005b	75 11		 jne	 SHORT $LN8@stbi__expa
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39168
  00064	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00069	e9 bf 01 00 00	 jmp	 $LN1@stbi__expa
$LN8@stbi__expa:

; 4908 :     
; 4909 :     // between here and free(out) below, exitting would leak
; 4910 :     temp_out = p;

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00073	48 89 44 24 40	 mov	 QWORD PTR temp_out$[rsp], rax

; 4911 :     
; 4912 :     if (pal_img_n == 3) {

  00078	83 7c 24 78 03	 cmp	 DWORD PTR pal_img_n$[rsp], 3
  0007d	0f 85 b5 00 00
	00		 jne	 $LN9@stbi__expa

; 4913 :         for (i=0; i < pixel_count; ++i) {

  00083	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0008b	eb 0a		 jmp	 SHORT $LN4@stbi__expa
$LN2@stbi__expa:
  0008d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__expa:
  00097	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0009b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0009f	0f 83 8e 00 00
	00		 jae	 $LN3@stbi__expa

; 4914 :             int n = orig[i]*4;

  000a5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR orig$[rsp]
  000ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b2	c1 e0 02	 shl	 eax, 2
  000b5	89 44 24 28	 mov	 DWORD PTR n$2[rsp], eax

; 4915 :             p[0] = palette[n  ];

  000b9	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$2[rsp]
  000be	b9 01 00 00 00	 mov	 ecx, 1
  000c3	48 6b c9 00	 imul	 rcx, rcx, 0
  000c7	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  000cc	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  000d1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000d6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4916 :             p[1] = palette[n+1];

  000d9	8b 44 24 28	 mov	 eax, DWORD PTR n$2[rsp]
  000dd	ff c0		 inc	 eax
  000df	48 98		 cdqe
  000e1	b9 01 00 00 00	 mov	 ecx, 1
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  000ef	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  000f4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000f9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4917 :             p[2] = palette[n+2];

  000fc	8b 44 24 28	 mov	 eax, DWORD PTR n$2[rsp]
  00100	83 c0 02	 add	 eax, 2
  00103	48 98		 cdqe
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 6b c9 02	 imul	 rcx, rcx, 2
  0010e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00113	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00118	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0011d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4918 :             p += 3;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00125	48 83 c0 03	 add	 rax, 3
  00129	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4919 :         }

  0012e	e9 5a ff ff ff	 jmp	 $LN2@stbi__expa
$LN3@stbi__expa:

; 4920 :     } else {

  00133	e9 d4 00 00 00	 jmp	 $LN10@stbi__expa
$LN9@stbi__expa:

; 4921 :         for (i=0; i < pixel_count; ++i) {

  00138	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00140	eb 0a		 jmp	 SHORT $LN7@stbi__expa
$LN5@stbi__expa:
  00142	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00146	ff c0		 inc	 eax
  00148	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__expa:
  0014c	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00150	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00154	0f 83 b2 00 00
	00		 jae	 $LN6@stbi__expa

; 4922 :             int n = orig[i]*4;

  0015a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0015e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR orig$[rsp]
  00163	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00167	c1 e0 02	 shl	 eax, 2
  0016a	89 44 24 24	 mov	 DWORD PTR n$1[rsp], eax

; 4923 :             p[0] = palette[n  ];

  0016e	48 63 44 24 24	 movsxd	 rax, DWORD PTR n$1[rsp]
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 6b c9 00	 imul	 rcx, rcx, 0
  0017c	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00181	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00186	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0018b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4924 :             p[1] = palette[n+1];

  0018e	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  00192	ff c0		 inc	 eax
  00194	48 98		 cdqe
  00196	b9 01 00 00 00	 mov	 ecx, 1
  0019b	48 6b c9 01	 imul	 rcx, rcx, 1
  0019f	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001a4	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001a9	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001ae	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4925 :             p[2] = palette[n+2];

  001b1	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  001b5	83 c0 02	 add	 eax, 2
  001b8	48 98		 cdqe
  001ba	b9 01 00 00 00	 mov	 ecx, 1
  001bf	48 6b c9 02	 imul	 rcx, rcx, 2
  001c3	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001c8	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001cd	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001d2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4926 :             p[3] = palette[n+3];

  001d5	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  001d9	83 c0 03	 add	 eax, 3
  001dc	48 98		 cdqe
  001de	b9 01 00 00 00	 mov	 ecx, 1
  001e3	48 6b c9 03	 imul	 rcx, rcx, 3
  001e7	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001ec	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001f1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4927 :             p += 4;

  001f9	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  001fe	48 83 c0 04	 add	 rax, 4
  00202	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4928 :         }

  00207	e9 36 ff ff ff	 jmp	 $LN5@stbi__expa
$LN6@stbi__expa:
$LN10@stbi__expa:

; 4929 :     }
; 4930 :     STBI_FREE(a->out);

  0020c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00211	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00215	e8 00 00 00 00	 call	 free

; 4931 :     a->out = temp_out;

  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0021f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR temp_out$[rsp]
  00224	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4932 :     
; 4933 :     STBI_NOTUSED(len);
; 4934 :     
; 4935 :     return 1;

  00228	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__expa:

; 4936 : }

  0022d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00231	c3		 ret	 0
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ENDP ; stbi__expand_png_palette
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
tv84 = 4
pixel_count$ = 8
p$ = 16
s$ = 24
z$ = 48
tc$ = 56
out_n$ = 64
?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z PROC ; stbi__compute_transparency16

; 4877 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4878 :     stbi__context *s = z->s;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 18	 mov	 QWORD PTR s$[rsp], rax

; 4879 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00020	48 8b 44 24 18	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 4c 24 18	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00030	89 44 24 08	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4880 :     stbi__uint16 *p = (stbi__uint16*) z->out;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  00039	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003d	48 89 44 24 10	 mov	 QWORD PTR p$[rsp], rax

; 4881 :     
; 4882 :     // compute color-based transparency, assuming we've
; 4883 :     // already got 65535 as the alpha value in the output
; 4884 :     STBI_ASSERT(out_n == 2 || out_n == 4);

  00042	83 7c 24 40 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00047	74 12		 je	 SHORT $LN8@stbi__comp
  00049	83 7c 24 40 04	 cmp	 DWORD PTR out_n$[rsp], 4
  0004e	74 0b		 je	 SHORT $LN8@stbi__comp
  00050	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN8@stbi__comp:

; 4885 :     
; 4886 :     if (out_n == 2) {

  0005b	83 7c 24 40 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00060	0f 85 80 00 00
	00		 jne	 $LN9@stbi__comp

; 4887 :         for (i = 0; i < pixel_count; ++i) {

  00066	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0006d	eb 08		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  0006f	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00072	ff c0		 inc	 eax
  00074	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  00077	8b 44 24 08	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0007b	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0007e	73 61		 jae	 SHORT $LN3@stbi__comp

; 4888 :             p[1] = (p[0] == tc[0] ? 0 : 65535);

  00080	b8 02 00 00 00	 mov	 eax, 2
  00085	48 6b c0 00	 imul	 rax, rax, 0
  00089	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  0008e	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00092	b9 02 00 00 00	 mov	 ecx, 2
  00097	48 6b c9 00	 imul	 rcx, rcx, 0
  0009b	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  000a0	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  000a4	3b c1		 cmp	 eax, ecx
  000a6	75 0a		 jne	 SHORT $LN13@stbi__comp
  000a8	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  000b0	eb 08		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000b2	c7 44 24 04 ff
	ff 00 00	 mov	 DWORD PTR tv84[rsp], 65535 ; 0000ffffH
$LN14@stbi__comp:
  000ba	b8 02 00 00 00	 mov	 eax, 2
  000bf	48 6b c0 01	 imul	 rax, rax, 1
  000c3	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  000c8	0f b7 54 24 04	 movzx	 edx, WORD PTR tv84[rsp]
  000cd	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx

; 4889 :             p += 2;

  000d1	48 8b 44 24 10	 mov	 rax, QWORD PTR p$[rsp]
  000d6	48 83 c0 04	 add	 rax, 4
  000da	48 89 44 24 10	 mov	 QWORD PTR p$[rsp], rax

; 4890 :         }

  000df	eb 8e		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4891 :     } else {

  000e1	e9 bd 00 00 00	 jmp	 $LN10@stbi__comp
$LN9@stbi__comp:

; 4892 :         for (i = 0; i < pixel_count; ++i) {

  000e6	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  000ed	eb 08		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  000ef	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000f2	ff c0		 inc	 eax
  000f4	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
  000f7	8b 44 24 08	 mov	 eax, DWORD PTR pixel_count$[rsp]
  000fb	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000fe	0f 83 9f 00 00
	00		 jae	 $LN6@stbi__comp

; 4893 :             if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  00104	b8 02 00 00 00	 mov	 eax, 2
  00109	48 6b c0 00	 imul	 rax, rax, 0
  0010d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00112	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00116	b9 02 00 00 00	 mov	 ecx, 2
  0011b	48 6b c9 00	 imul	 rcx, rcx, 0
  0011f	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  00124	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00128	3b c1		 cmp	 eax, ecx
  0012a	75 64		 jne	 SHORT $LN11@stbi__comp
  0012c	b8 02 00 00 00	 mov	 eax, 2
  00131	48 6b c0 01	 imul	 rax, rax, 1
  00135	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  0013a	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0013e	b9 02 00 00 00	 mov	 ecx, 2
  00143	48 6b c9 01	 imul	 rcx, rcx, 1
  00147	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  0014c	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00150	3b c1		 cmp	 eax, ecx
  00152	75 3c		 jne	 SHORT $LN11@stbi__comp
  00154	b8 02 00 00 00	 mov	 eax, 2
  00159	48 6b c0 02	 imul	 rax, rax, 2
  0015d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00162	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00166	b9 02 00 00 00	 mov	 ecx, 2
  0016b	48 6b c9 02	 imul	 rcx, rcx, 2
  0016f	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  00174	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00178	3b c1		 cmp	 eax, ecx
  0017a	75 14		 jne	 SHORT $LN11@stbi__comp

; 4894 :                 p[3] = 0;

  0017c	b8 02 00 00 00	 mov	 eax, 2
  00181	48 6b c0 03	 imul	 rax, rax, 3
  00185	33 c9		 xor	 ecx, ecx
  00187	48 8b 54 24 10	 mov	 rdx, QWORD PTR p$[rsp]
  0018c	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
$LN11@stbi__comp:

; 4895 :             p += 4;

  00190	48 8b 44 24 10	 mov	 rax, QWORD PTR p$[rsp]
  00195	48 83 c0 08	 add	 rax, 8
  00199	48 89 44 24 10	 mov	 QWORD PTR p$[rsp], rax

; 4896 :         }

  0019e	e9 4c ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN10@stbi__comp:

; 4897 :     }
; 4898 :     return 1;

  001a3	b8 01 00 00 00	 mov	 eax, 1

; 4899 : }

  001a8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001ac	c3		 ret	 0
?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z ENDP ; stbi__compute_transparency16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
tv84 = 4
pixel_count$ = 8
p$ = 16
s$ = 24
z$ = 48
tc$ = 56
out_n$ = 64
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z PROC ; stbi__compute_transparency

; 4852 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4853 :     stbi__context *s = z->s;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 18	 mov	 QWORD PTR s$[rsp], rax

; 4854 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00020	48 8b 44 24 18	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 4c 24 18	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00030	89 44 24 08	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4855 :     stbi_uc *p = z->out;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR z$[rsp]
  00039	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003d	48 89 44 24 10	 mov	 QWORD PTR p$[rsp], rax

; 4856 :     
; 4857 :     // compute color-based transparency, assuming we've
; 4858 :     // already got 255 as the alpha value in the output
; 4859 :     STBI_ASSERT(out_n == 2 || out_n == 4);

  00042	83 7c 24 40 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00047	74 12		 je	 SHORT $LN8@stbi__comp
  00049	83 7c 24 40 04	 cmp	 DWORD PTR out_n$[rsp], 4
  0004e	74 0b		 je	 SHORT $LN8@stbi__comp
  00050	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN8@stbi__comp:

; 4860 :     
; 4861 :     if (out_n == 2) {

  0005b	83 7c 24 40 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00060	75 7f		 jne	 SHORT $LN9@stbi__comp

; 4862 :         for (i=0; i < pixel_count; ++i) {

  00062	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00069	eb 08		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  0006b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0006e	ff c0		 inc	 eax
  00070	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  00073	8b 44 24 08	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00077	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0007a	73 60		 jae	 SHORT $LN3@stbi__comp

; 4863 :             p[1] = (p[0] == tc[0] ? 0 : 255);

  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	48 6b c0 00	 imul	 rax, rax, 0
  00085	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  0008a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008e	b9 01 00 00 00	 mov	 ecx, 1
  00093	48 6b c9 00	 imul	 rcx, rcx, 0
  00097	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  0009c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000a0	3b c1		 cmp	 eax, ecx
  000a2	75 0a		 jne	 SHORT $LN13@stbi__comp
  000a4	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  000ac	eb 08		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000ae	c7 44 24 04 ff
	00 00 00	 mov	 DWORD PTR tv84[rsp], 255 ; 000000ffH
$LN14@stbi__comp:
  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	48 6b c0 01	 imul	 rax, rax, 1
  000bf	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  000c4	0f b6 54 24 04	 movzx	 edx, BYTE PTR tv84[rsp]
  000c9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4864 :             p += 2;

  000cc	48 8b 44 24 10	 mov	 rax, QWORD PTR p$[rsp]
  000d1	48 83 c0 02	 add	 rax, 2
  000d5	48 89 44 24 10	 mov	 QWORD PTR p$[rsp], rax

; 4865 :         }

  000da	eb 8f		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4866 :     } else {

  000dc	e9 bb 00 00 00	 jmp	 $LN10@stbi__comp
$LN9@stbi__comp:

; 4867 :         for (i=0; i < pixel_count; ++i) {

  000e1	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  000e8	eb 08		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  000ea	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000ed	ff c0		 inc	 eax
  000ef	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
  000f2	8b 44 24 08	 mov	 eax, DWORD PTR pixel_count$[rsp]
  000f6	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000f9	0f 83 9d 00 00
	00		 jae	 $LN6@stbi__comp

; 4868 :             if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  000ff	b8 01 00 00 00	 mov	 eax, 1
  00104	48 6b c0 00	 imul	 rax, rax, 0
  00108	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  0010d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00111	b9 01 00 00 00	 mov	 ecx, 1
  00116	48 6b c9 00	 imul	 rcx, rcx, 0
  0011a	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  0011f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00123	3b c1		 cmp	 eax, ecx
  00125	75 62		 jne	 SHORT $LN11@stbi__comp
  00127	b8 01 00 00 00	 mov	 eax, 1
  0012c	48 6b c0 01	 imul	 rax, rax, 1
  00130	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00135	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	48 6b c9 01	 imul	 rcx, rcx, 1
  00142	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  00147	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0014b	3b c1		 cmp	 eax, ecx
  0014d	75 3a		 jne	 SHORT $LN11@stbi__comp
  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	48 6b c0 02	 imul	 rax, rax, 2
  00158	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  0015d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00161	b9 01 00 00 00	 mov	 ecx, 1
  00166	48 6b c9 02	 imul	 rcx, rcx, 2
  0016a	48 8b 54 24 38	 mov	 rdx, QWORD PTR tc$[rsp]
  0016f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00173	3b c1		 cmp	 eax, ecx
  00175	75 12		 jne	 SHORT $LN11@stbi__comp

; 4869 :                 p[3] = 0;

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	48 6b c0 03	 imul	 rax, rax, 3
  00180	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p$[rsp]
  00185	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN11@stbi__comp:

; 4870 :             p += 4;

  00189	48 8b 44 24 10	 mov	 rax, QWORD PTR p$[rsp]
  0018e	48 83 c0 04	 add	 rax, 4
  00192	48 89 44 24 10	 mov	 QWORD PTR p$[rsp], rax

; 4871 :         }

  00197	e9 4e ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN10@stbi__comp:

; 4872 :     }
; 4873 :     return 1;

  0019c	b8 01 00 00 00	 mov	 eax, 1

; 4874 : }

  001a1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001a5	c3		 ret	 0
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ENDP ; stbi__compute_transparency
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 64
j$1 = 68
x$2 = 72
i$3 = 76
out_bytes$ = 80
y$4 = 84
tv65 = 88
img_len$5 = 92
final$ = 96
bytes$ = 104
out_y$6 = 108
out_x$7 = 112
yspc$8 = 120
xspc$9 = 152
yorig$10 = 184
xorig$11 = 216
__$ArrayPad$ = 248
a$ = 288
image_data$ = 296
image_data_len$ = 304
out_n$ = 312
depth$ = 320
color$ = 328
interlaced$ = 336
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z PROC ; stbi__create_png_image

; 4807 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4808 :     int bytes = (depth == 16 ? 2 : 1);

  0002f	83 bc 24 40 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00037	75 0a		 jne	 SHORT $LN16@stbi__crea
  00039	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv65[rsp], 2
  00041	eb 08		 jmp	 SHORT $LN17@stbi__crea
$LN16@stbi__crea:
  00043	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
$LN17@stbi__crea:
  0004b	8b 44 24 58	 mov	 eax, DWORD PTR tv65[rsp]
  0004f	89 44 24 68	 mov	 DWORD PTR bytes$[rsp], eax

; 4809 :     int out_bytes = out_n * bytes;

  00053	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  0005a	0f af 44 24 68	 imul	 eax, DWORD PTR bytes$[rsp]
  0005f	89 44 24 50	 mov	 DWORD PTR out_bytes$[rsp], eax

; 4810 :     stbi_uc *final;
; 4811 :     int p;
; 4812 :     if (!interlaced)

  00063	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR interlaced$[rsp], 0
  0006b	75 63		 jne	 SHORT $LN11@stbi__crea

; 4813 :         return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

  0006d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00080	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00083	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR color$[rsp]
  0008a	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  0008e	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR depth$[rsp]
  00095	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00099	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0009c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a0	8b 01		 mov	 eax, DWORD PTR [rcx]
  000a2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a6	44 8b 8c 24 38
	01 00 00	 mov	 r9d, DWORD PTR out_n$[rsp]
  000ae	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR image_data_len$[rsp]
  000b6	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR image_data$[rsp]
  000be	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000c6	e8 00 00 00 00	 call	 ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
  000cb	e9 02 04 00 00	 jmp	 $LN1@stbi__crea
$LN11@stbi__crea:

; 4814 :     
; 4815 :     // de-interlacing
; 4816 :     final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

  000d0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000db	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000e3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e6	45 33 c9	 xor	 r9d, r9d
  000e9	44 8b 44 24 50	 mov	 r8d, DWORD PTR out_bytes$[rsp]
  000ee	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  000f1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000f3	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  000f8	48 89 44 24 60	 mov	 QWORD PTR final$[rsp], rax

; 4817 :     if (!final) return stbi__err("outofmem", "Out of memory");

  000fd	48 83 7c 24 60
	00		 cmp	 QWORD PTR final$[rsp], 0
  00103	75 11		 jne	 SHORT $LN12@stbi__crea
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39102
  0010c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00111	e9 bc 03 00 00	 jmp	 $LN1@stbi__crea
$LN12@stbi__crea:

; 4818 :     for (p=0; p < 7; ++p) {

  00116	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR p$[rsp], 0
  0011e	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  00120	8b 44 24 40	 mov	 eax, DWORD PTR p$[rsp]
  00124	ff c0		 inc	 eax
  00126	89 44 24 40	 mov	 DWORD PTR p$[rsp], eax
$LN4@stbi__crea:
  0012a	83 7c 24 40 07	 cmp	 DWORD PTR p$[rsp], 7
  0012f	0f 8d 87 03 00
	00		 jge	 $LN3@stbi__crea

; 4819 :         int xorig[] = { 0,4,0,2,0,1,0 };

  00135	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp], 0
  00140	c7 84 24 dc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+4], 4
  0014b	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+8], 0
  00156	c7 84 24 e4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+12], 2
  00161	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+16], 0
  0016c	c7 84 24 ec 00
	00 00 01 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+20], 1
  00177	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+24], 0

; 4820 :         int yorig[] = { 0,0,4,0,2,0,1 };

  00182	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp], 0
  0018d	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+4], 0
  00198	c7 84 24 c0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+8], 4
  001a3	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+12], 0
  001ae	c7 84 24 c8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+16], 2
  001b9	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+20], 0
  001c4	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+24], 1

; 4821 :         int xspc[]  = { 8,8,4,4,2,2,1 };

  001cf	c7 84 24 98 00
	00 00 08 00 00
	00		 mov	 DWORD PTR xspc$9[rsp], 8
  001da	c7 84 24 9c 00
	00 00 08 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+4], 8
  001e5	c7 84 24 a0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+8], 4
  001f0	c7 84 24 a4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+12], 4
  001fb	c7 84 24 a8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+16], 2
  00206	c7 84 24 ac 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+20], 2
  00211	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+24], 1

; 4822 :         int yspc[]  = { 8,8,8,4,4,2,2 };

  0021c	c7 44 24 78 08
	00 00 00	 mov	 DWORD PTR yspc$8[rsp], 8
  00224	c7 44 24 7c 08
	00 00 00	 mov	 DWORD PTR yspc$8[rsp+4], 8
  0022c	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+8], 8
  00237	c7 84 24 84 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+12], 4
  00242	c7 84 24 88 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+16], 4
  0024d	c7 84 24 8c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+20], 2
  00258	c7 84 24 90 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+24], 2

; 4823 :         int i,j,x,y;
; 4824 :         // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4825 :         x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];

  00263	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0026b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0026e	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00273	8b 8c 8c d8 00
	00 00		 mov	 ecx, DWORD PTR xorig$11[rsp+rcx*4]
  0027a	8b 00		 mov	 eax, DWORD PTR [rax]
  0027c	2b c1		 sub	 eax, ecx
  0027e	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00283	8b 8c 8c 98 00
	00 00		 mov	 ecx, DWORD PTR xspc$9[rsp+rcx*4]
  0028a	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0028e	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00293	33 d2		 xor	 edx, edx
  00295	f7 b4 8c 98 00
	00 00		 div	 DWORD PTR xspc$9[rsp+rcx*4]
  0029c	89 44 24 48	 mov	 DWORD PTR x$2[rsp], eax

; 4826 :         y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

  002a0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ab	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  002b0	8b 8c 8c b8 00
	00 00		 mov	 ecx, DWORD PTR yorig$10[rsp+rcx*4]
  002b7	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002ba	2b c1		 sub	 eax, ecx
  002bc	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  002c1	8b 4c 8c 78	 mov	 ecx, DWORD PTR yspc$8[rsp+rcx*4]
  002c5	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002c9	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  002ce	33 d2		 xor	 edx, edx
  002d0	f7 74 8c 78	 div	 DWORD PTR yspc$8[rsp+rcx*4]
  002d4	89 44 24 54	 mov	 DWORD PTR y$4[rsp], eax

; 4827 :         if (x && y) {

  002d8	83 7c 24 48 00	 cmp	 DWORD PTR x$2[rsp], 0
  002dd	0f 84 d4 01 00
	00		 je	 $LN13@stbi__crea
  002e3	83 7c 24 54 00	 cmp	 DWORD PTR y$4[rsp], 0
  002e8	0f 84 c9 01 00
	00		 je	 $LN13@stbi__crea

; 4828 :             stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

  002ee	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002f6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002f9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002fc	0f af 44 24 48	 imul	 eax, DWORD PTR x$2[rsp]
  00301	0f af 84 24 40
	01 00 00	 imul	 eax, DWORD PTR depth$[rsp]
  00309	83 c0 07	 add	 eax, 7
  0030c	c1 f8 03	 sar	 eax, 3
  0030f	ff c0		 inc	 eax
  00311	0f af 44 24 54	 imul	 eax, DWORD PTR y$4[rsp]
  00316	89 44 24 5c	 mov	 DWORD PTR img_len$5[rsp], eax

; 4829 :             if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

  0031a	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  00321	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00325	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR depth$[rsp]
  0032c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00330	8b 44 24 54	 mov	 eax, DWORD PTR y$4[rsp]
  00334	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00338	8b 44 24 48	 mov	 eax, DWORD PTR x$2[rsp]
  0033c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00340	44 8b 8c 24 38
	01 00 00	 mov	 r9d, DWORD PTR out_n$[rsp]
  00348	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR image_data_len$[rsp]
  00350	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR image_data$[rsp]
  00358	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00360	e8 00 00 00 00	 call	 ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
  00365	85 c0		 test	 eax, eax
  00367	75 11		 jne	 SHORT $LN14@stbi__crea

; 4830 :                 STBI_FREE(final);

  00369	48 8b 4c 24 60	 mov	 rcx, QWORD PTR final$[rsp]
  0036e	e8 00 00 00 00	 call	 free

; 4831 :                 return 0;

  00373	33 c0		 xor	 eax, eax
  00375	e9 58 01 00 00	 jmp	 $LN1@stbi__crea
$LN14@stbi__crea:

; 4832 :             }
; 4833 :             for (j=0; j < y; ++j) {

  0037a	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$1[rsp], 0
  00382	eb 0a		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  00384	8b 44 24 44	 mov	 eax, DWORD PTR j$1[rsp]
  00388	ff c0		 inc	 eax
  0038a	89 44 24 44	 mov	 DWORD PTR j$1[rsp], eax
$LN7@stbi__crea:
  0038e	8b 44 24 54	 mov	 eax, DWORD PTR y$4[rsp]
  00392	39 44 24 44	 cmp	 DWORD PTR j$1[rsp], eax
  00396	0f 8d da 00 00
	00		 jge	 $LN6@stbi__crea

; 4834 :                 for (i=0; i < x; ++i) {

  0039c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  003a4	eb 0a		 jmp	 SHORT $LN10@stbi__crea
$LN8@stbi__crea:
  003a6	8b 44 24 4c	 mov	 eax, DWORD PTR i$3[rsp]
  003aa	ff c0		 inc	 eax
  003ac	89 44 24 4c	 mov	 DWORD PTR i$3[rsp], eax
$LN10@stbi__crea:
  003b0	8b 44 24 48	 mov	 eax, DWORD PTR x$2[rsp]
  003b4	39 44 24 4c	 cmp	 DWORD PTR i$3[rsp], eax
  003b8	0f 8d b3 00 00
	00		 jge	 $LN9@stbi__crea

; 4835 :                     int out_y = j*yspc[p]+yorig[p];

  003be	48 63 44 24 40	 movsxd	 rax, DWORD PTR p$[rsp]
  003c3	8b 4c 24 44	 mov	 ecx, DWORD PTR j$1[rsp]
  003c7	0f af 4c 84 78	 imul	 ecx, DWORD PTR yspc$8[rsp+rax*4]
  003cc	8b c1		 mov	 eax, ecx
  003ce	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  003d3	03 84 8c b8 00
	00 00		 add	 eax, DWORD PTR yorig$10[rsp+rcx*4]
  003da	89 44 24 6c	 mov	 DWORD PTR out_y$6[rsp], eax

; 4836 :                     int out_x = i*xspc[p]+xorig[p];

  003de	48 63 44 24 40	 movsxd	 rax, DWORD PTR p$[rsp]
  003e3	8b 4c 24 4c	 mov	 ecx, DWORD PTR i$3[rsp]
  003e7	0f af 8c 84 98
	00 00 00	 imul	 ecx, DWORD PTR xspc$9[rsp+rax*4]
  003ef	8b c1		 mov	 eax, ecx
  003f1	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  003f6	03 84 8c d8 00
	00 00		 add	 eax, DWORD PTR xorig$11[rsp+rcx*4]
  003fd	89 44 24 70	 mov	 DWORD PTR out_x$7[rsp], eax

; 4837 :                     memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,

  00401	48 63 44 24 50	 movsxd	 rax, DWORD PTR out_bytes$[rsp]
  00406	8b 4c 24 44	 mov	 ecx, DWORD PTR j$1[rsp]
  0040a	0f af 4c 24 48	 imul	 ecx, DWORD PTR x$2[rsp]
  0040f	03 4c 24 4c	 add	 ecx, DWORD PTR i$3[rsp]
  00413	0f af 4c 24 50	 imul	 ecx, DWORD PTR out_bytes$[rsp]
  00418	48 63 c9	 movsxd	 rcx, ecx
  0041b	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  00423	48 03 4a 18	 add	 rcx, QWORD PTR [rdx+24]
  00427	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  0042f	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00432	44 8b 44 24 6c	 mov	 r8d, DWORD PTR out_y$6[rsp]
  00437	44 0f af 02	 imul	 r8d, DWORD PTR [rdx]
  0043b	41 8b d0	 mov	 edx, r8d
  0043e	0f af 54 24 50	 imul	 edx, DWORD PTR out_bytes$[rsp]
  00443	8b d2		 mov	 edx, edx
  00445	4c 8b 44 24 60	 mov	 r8, QWORD PTR final$[rsp]
  0044a	4c 03 c2	 add	 r8, rdx
  0044d	49 8b d0	 mov	 rdx, r8
  00450	44 8b 44 24 70	 mov	 r8d, DWORD PTR out_x$7[rsp]
  00455	44 0f af 44 24
	50		 imul	 r8d, DWORD PTR out_bytes$[rsp]
  0045b	4d 63 c0	 movsxd	 r8, r8d
  0045e	49 03 d0	 add	 rdx, r8
  00461	48 8b fa	 mov	 rdi, rdx
  00464	48 8b f1	 mov	 rsi, rcx
  00467	48 8b c8	 mov	 rcx, rax
  0046a	f3 a4		 rep movsb

; 4838 :                            a->out + (j*x+i)*out_bytes, out_bytes);
; 4839 :                 }

  0046c	e9 35 ff ff ff	 jmp	 $LN8@stbi__crea
$LN9@stbi__crea:

; 4840 :             }

  00471	e9 0e ff ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4841 :             STBI_FREE(a->out);

  00476	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0047e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00482	e8 00 00 00 00	 call	 free

; 4842 :             image_data += img_len;

  00487	8b 44 24 5c	 mov	 eax, DWORD PTR img_len$5[rsp]
  0048b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR image_data$[rsp]
  00493	48 03 c8	 add	 rcx, rax
  00496	48 8b c1	 mov	 rax, rcx
  00499	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR image_data$[rsp], rax

; 4843 :             image_data_len -= img_len;

  004a1	8b 44 24 5c	 mov	 eax, DWORD PTR img_len$5[rsp]
  004a5	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR image_data_len$[rsp]
  004ac	2b c8		 sub	 ecx, eax
  004ae	8b c1		 mov	 eax, ecx
  004b0	89 84 24 30 01
	00 00		 mov	 DWORD PTR image_data_len$[rsp], eax
$LN13@stbi__crea:

; 4844 :         }
; 4845 :     }

  004b7	e9 64 fc ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4846 :     a->out = final;

  004bc	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR final$[rsp]
  004c9	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4847 :     
; 4848 :     return 1;

  004cd	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4849 : }

  004d2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004da	48 33 cc	 xor	 rcx, rsp
  004dd	e8 00 00 00 00	 call	 __security_check_cookie
  004e2	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  004e9	5f		 pop	 rdi
  004ea	5e		 pop	 rsi
  004eb	c3		 ret	 0
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ENDP ; stbi__create_png_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
scale$1 = 36
cur$2 = 40
i$ = 48
filter_bytes$ = 52
cur$3 = 56
output_bytes$ = 64
q$4 = 68
img_n$ = 72
prior$5 = 80
in$6 = 88
j$ = 96
nk$7 = 100
filter$8 = 104
stride$ = 108
img_width_bytes$ = 112
bytes$ = 116
tv65 = 120
tv165 = 124
width$ = 128
tv271 = 132
tv409 = 136
tv662 = 140
cur$9 = 144
img_len$ = 152
tv213 = 156
tv342 = 160
tv390 = 164
tv542 = 168
tv614 = 172
s$ = 176
cur16$10 = 184
a$ = 224
raw$ = 232
raw_len$ = 240
out_n$ = 248
x$ = 256
y$ = 264
depth$ = 272
color$ = 280
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z PROC ; stbi__create_png_image_raw

; 4595 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 4596 :     int bytes = (depth == 16? 2 : 1);

  0001d	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00025	75 0a		 jne	 SHORT $LN162@stbi__crea
  00027	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR tv65[rsp], 2
  0002f	eb 08		 jmp	 SHORT $LN163@stbi__crea
$LN162@stbi__crea:
  00031	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
$LN163@stbi__crea:
  00039	8b 44 24 78	 mov	 eax, DWORD PTR tv65[rsp]
  0003d	89 44 24 74	 mov	 DWORD PTR bytes$[rsp], eax

; 4597 :     stbi__context *s = a->s;

  00041	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 4598 :     stbi__uint32 i,j,stride = x*out_n*bytes;

  00054	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0005b	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  00063	0f af 44 24 74	 imul	 eax, DWORD PTR bytes$[rsp]
  00068	89 44 24 6c	 mov	 DWORD PTR stride$[rsp], eax

; 4599 :     stbi__uint32 img_len, img_width_bytes;
; 4600 :     int k;
; 4601 :     int img_n = s->img_n; // copy it into a local for later

  0006c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00074	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00077	89 44 24 48	 mov	 DWORD PTR img_n$[rsp], eax

; 4602 :     
; 4603 :     int output_bytes = out_n*bytes;

  0007b	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00082	0f af 44 24 74	 imul	 eax, DWORD PTR bytes$[rsp]
  00087	89 44 24 40	 mov	 DWORD PTR output_bytes$[rsp], eax

; 4604 :     int filter_bytes = img_n*bytes;

  0008b	8b 44 24 48	 mov	 eax, DWORD PTR img_n$[rsp]
  0008f	0f af 44 24 74	 imul	 eax, DWORD PTR bytes$[rsp]
  00094	89 44 24 34	 mov	 DWORD PTR filter_bytes$[rsp], eax

; 4605 :     int width = x;

  00098	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0009f	89 84 24 80 00
	00 00		 mov	 DWORD PTR width$[rsp], eax

; 4606 :     
; 4607 :     STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);

  000a6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000ae	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000b1	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR out_n$[rsp], eax
  000b8	74 21		 je	 SHORT $LN98@stbi__crea
  000ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c5	ff c0		 inc	 eax
  000c7	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR out_n$[rsp], eax
  000ce	74 0b		 je	 SHORT $LN98@stbi__crea
  000d0	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN98@stbi__crea:

; 4608 :     a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

  000db	45 33 c9	 xor	 r9d, r9d
  000de	44 8b 44 24 40	 mov	 r8d, DWORD PTR output_bytes$[rsp]
  000e3	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR y$[rsp]
  000ea	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR x$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  000f6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000fe	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4609 :     if (!a->out) return stbi__err("outofmem", "Out of memory");

  00102	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0010a	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0010f	75 11		 jne	 SHORT $LN99@stbi__crea
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39000
  00118	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0011d	e9 b4 16 00 00	 jmp	 $LN1@stbi__crea
$LN99@stbi__crea:

; 4610 :     
; 4611 :     if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");

  00122	41 b9 07 00 00
	00		 mov	 r9d, 7
  00128	44 8b 84 24 10
	01 00 00	 mov	 r8d, DWORD PTR depth$[rsp]
  00130	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR x$[rsp]
  00137	8b 4c 24 48	 mov	 ecx, DWORD PTR img_n$[rsp]
  0013b	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  00140	85 c0		 test	 eax, eax
  00142	75 11		 jne	 SHORT $LN100@stbi__crea
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39002
  0014b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00150	e9 81 16 00 00	 jmp	 $LN1@stbi__crea
$LN100@stbi__crea:

; 4612 :     img_width_bytes = (((img_n * x * depth) + 7) >> 3);

  00155	8b 44 24 48	 mov	 eax, DWORD PTR img_n$[rsp]
  00159	0f af 84 24 00
	01 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00161	0f af 84 24 10
	01 00 00	 imul	 eax, DWORD PTR depth$[rsp]
  00169	83 c0 07	 add	 eax, 7
  0016c	c1 e8 03	 shr	 eax, 3
  0016f	89 44 24 70	 mov	 DWORD PTR img_width_bytes$[rsp], eax

; 4613 :     img_len = (img_width_bytes + 1) * y;

  00173	8b 44 24 70	 mov	 eax, DWORD PTR img_width_bytes$[rsp]
  00177	ff c0		 inc	 eax
  00179	0f af 84 24 08
	01 00 00	 imul	 eax, DWORD PTR y$[rsp]
  00181	89 84 24 98 00
	00 00		 mov	 DWORD PTR img_len$[rsp], eax

; 4614 :     
; 4615 :     // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4616 :     // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4617 :     // so just check for raw_len < img_len always.
; 4618 :     if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

  00188	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR img_len$[rsp]
  0018f	39 84 24 f0 00
	00 00		 cmp	 DWORD PTR raw_len$[rsp], eax
  00196	73 11		 jae	 SHORT $LN101@stbi__crea
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39004
  0019f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001a4	e9 2d 16 00 00	 jmp	 $LN1@stbi__crea
$LN101@stbi__crea:

; 4619 :     
; 4620 :     for (j=0; j < y; ++j) {

  001a9	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001b1	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  001b3	8b 44 24 60	 mov	 eax, DWORD PTR j$[rsp]
  001b7	ff c0		 inc	 eax
  001b9	89 44 24 60	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__crea:
  001bd	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  001c4	39 44 24 60	 cmp	 DWORD PTR j$[rsp], eax
  001c8	0f 83 f0 0d 00
	00		 jae	 $LN3@stbi__crea

; 4621 :         stbi_uc *cur = a->out + stride*j;

  001ce	8b 44 24 6c	 mov	 eax, DWORD PTR stride$[rsp]
  001d2	0f af 44 24 60	 imul	 eax, DWORD PTR j$[rsp]
  001d7	8b c0		 mov	 eax, eax
  001d9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001e1	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  001e5	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax

; 4622 :         stbi_uc *prior;
; 4623 :         int filter = *raw++;

  001ea	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  001f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f5	89 44 24 68	 mov	 DWORD PTR filter$8[rsp], eax
  001f9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  00201	48 ff c0	 inc	 rax
  00204	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4624 :         
; 4625 :         if (filter > 4)

  0020c	83 7c 24 68 04	 cmp	 DWORD PTR filter$8[rsp], 4
  00211	7e 11		 jle	 SHORT $LN102@stbi__crea

; 4626 :             return stbi__err("invalid filter","Corrupt PNG");

  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39006
  0021a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0021f	e9 b2 15 00 00	 jmp	 $LN1@stbi__crea
$LN102@stbi__crea:

; 4627 :         
; 4628 :         if (depth < 8) {

  00224	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  0022c	7d 56		 jge	 SHORT $LN103@stbi__crea

; 4629 :             if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");

  0022e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00235	39 44 24 70	 cmp	 DWORD PTR img_width_bytes$[rsp], eax
  00239	76 11		 jbe	 SHORT $LN104@stbi__crea
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39009
  00242	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00247	e9 8a 15 00 00	 jmp	 $LN1@stbi__crea
$LN104@stbi__crea:

; 4630 :             cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

  0024c	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00253	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  0025b	2b 44 24 70	 sub	 eax, DWORD PTR img_width_bytes$[rsp]
  0025f	8b c0		 mov	 eax, eax
  00261	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00266	48 03 c8	 add	 rcx, rax
  00269	48 8b c1	 mov	 rax, rcx
  0026c	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax

; 4631 :             filter_bytes = 1;

  00271	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR filter_bytes$[rsp], 1

; 4632 :             width = img_width_bytes;

  00279	8b 44 24 70	 mov	 eax, DWORD PTR img_width_bytes$[rsp]
  0027d	89 84 24 80 00
	00 00		 mov	 DWORD PTR width$[rsp], eax
$LN103@stbi__crea:

; 4633 :         }
; 4634 :         prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

  00284	8b 44 24 6c	 mov	 eax, DWORD PTR stride$[rsp]
  00288	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  0028d	48 2b c8	 sub	 rcx, rax
  00290	48 8b c1	 mov	 rax, rcx
  00293	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax

; 4635 :         
; 4636 :         // if first row, use special filter that doesn't sample previous row
; 4637 :         if (j == 0) filter = first_row_filter[filter];

  00298	83 7c 24 60 00	 cmp	 DWORD PTR j$[rsp], 0
  0029d	75 14		 jne	 SHORT $LN105@stbi__crea
  0029f	48 63 44 24 68	 movsxd	 rax, DWORD PTR filter$8[rsp]
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?first_row_filter@@3PAEA
  002ab	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002af	89 44 24 68	 mov	 DWORD PTR filter$8[rsp], eax
$LN105@stbi__crea:

; 4638 :         
; 4639 :         // handle first byte explicitly
; 4640 :         for (k=0; k < filter_bytes; ++k) {

  002b3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  002bb	eb 0a		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  002bd	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  002c1	ff c0		 inc	 eax
  002c3	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__crea:
  002c7	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  002cb	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  002cf	0f 8d 7b 01 00
	00		 jge	 $LN6@stbi__crea

; 4641 :             switch (filter) {

  002d5	8b 44 24 68	 mov	 eax, DWORD PTR filter$8[rsp]
  002d9	89 44 24 7c	 mov	 DWORD PTR tv165[rsp], eax
  002dd	83 7c 24 7c 06	 cmp	 DWORD PTR tv165[rsp], 6
  002e2	0f 87 63 01 00
	00		 ja	 $LN8@stbi__crea
  002e8	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv165[rsp]
  002ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002f4	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN168@stbi__crea[rcx+rax*4]
  002fb	48 03 c1	 add	 rax, rcx
  002fe	ff e0		 jmp	 rax
$LN106@stbi__crea:

; 4642 :                 case STBI__F_none       : cur[k] = raw[k]; break;

  00300	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00305	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  0030a	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0030f	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  00317	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0031c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0031f	e9 27 01 00 00	 jmp	 $LN8@stbi__crea
$LN107@stbi__crea:

; 4643 :                 case STBI__F_sub        : cur[k] = raw[k]; break;

  00324	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00329	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  0032e	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00333	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  0033b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00340	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00343	e9 03 01 00 00	 jmp	 $LN8@stbi__crea
$LN108@stbi__crea:

; 4644 :                 case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

  00348	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  0034d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00355	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00359	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  0035e	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  00363	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00367	03 c1		 add	 eax, ecx
  00369	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0036e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00373	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00378	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0037b	e9 cb 00 00 00	 jmp	 $LN8@stbi__crea
$LN109@stbi__crea:

; 4645 :                 case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;

  00380	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00385	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0038d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00391	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00396	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  0039b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0039f	d1 f9		 sar	 ecx, 1
  003a1	03 c1		 add	 eax, ecx
  003a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003a8	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  003ad	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  003b2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003b5	e9 91 00 00 00	 jmp	 $LN8@stbi__crea
$LN110@stbi__crea:

; 4646 :                 case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;

  003ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  003bf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  003c7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003cb	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  003d2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  003d7	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  003dc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003e0	45 33 c0	 xor	 r8d, r8d
  003e3	8b d1		 mov	 edx, ecx
  003e5	33 c9		 xor	 ecx, ecx
  003e7	e8 00 00 00 00	 call	 ?stbi__paeth@@YAHHHH@Z	; stbi__paeth
  003ec	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv213[rsp]
  003f3	03 c8		 add	 ecx, eax
  003f5	8b c1		 mov	 eax, ecx
  003f7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003fc	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00401	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00406	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00409	eb 40		 jmp	 SHORT $LN8@stbi__crea
$LN111@stbi__crea:

; 4647 :                 case STBI__F_avg_first  : cur[k] = raw[k]; break;

  0040b	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00410	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00415	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0041a	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  00422	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00427	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0042a	eb 1f		 jmp	 SHORT $LN8@stbi__crea
$LN112@stbi__crea:

; 4648 :                 case STBI__F_paeth_first: cur[k] = raw[k]; break;

  0042c	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00431	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00436	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0043b	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR raw$[rsp]
  00443	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00448	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN8@stbi__crea:

; 4649 :             }
; 4650 :         }

  0044b	e9 6d fe ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4651 :         
; 4652 :         if (depth == 8) {

  00450	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  00458	75 6b		 jne	 SHORT $LN113@stbi__crea

; 4653 :             if (img_n != out_n)

  0045a	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00461	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  00465	74 0e		 je	 SHORT $LN115@stbi__crea

; 4654 :                 cur[img_n] = 255; // first pixel

  00467	48 63 44 24 48	 movsxd	 rax, DWORD PTR img_n$[rsp]
  0046c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00471	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN115@stbi__crea:

; 4655 :             raw += img_n;

  00475	48 63 44 24 48	 movsxd	 rax, DWORD PTR img_n$[rsp]
  0047a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00482	48 03 c8	 add	 rcx, rax
  00485	48 8b c1	 mov	 rax, rcx
  00488	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4656 :             cur += out_n;

  00490	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR out_n$[rsp]
  00498	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  0049d	48 03 c8	 add	 rcx, rax
  004a0	48 8b c1	 mov	 rax, rcx
  004a3	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax

; 4657 :             prior += out_n;

  004a8	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR out_n$[rsp]
  004b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  004b5	48 03 c8	 add	 rcx, rax
  004b8	48 8b c1	 mov	 rax, rcx
  004bb	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
  004c0	e9 aa 00 00 00	 jmp	 $LN114@stbi__crea
$LN113@stbi__crea:

; 4658 :         } else if (depth == 16) {

  004c5	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  004cd	75 73		 jne	 SHORT $LN116@stbi__crea

; 4659 :             if (img_n != out_n) {

  004cf	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  004d6	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  004da	74 1f		 je	 SHORT $LN118@stbi__crea

; 4660 :                 cur[filter_bytes]   = 255; // first pixel top byte

  004dc	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  004e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  004e6	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4661 :                 cur[filter_bytes+1] = 255; // first pixel bottom byte

  004ea	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  004ee	ff c0		 inc	 eax
  004f0	48 98		 cdqe
  004f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  004f7	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
$LN118@stbi__crea:

; 4662 :             }
; 4663 :             raw += filter_bytes;

  004fb	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00500	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00508	48 03 c8	 add	 rcx, rax
  0050b	48 8b c1	 mov	 rax, rcx
  0050e	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4664 :             cur += output_bytes;

  00516	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  0051b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00520	48 03 c8	 add	 rcx, rax
  00523	48 8b c1	 mov	 rax, rcx
  00526	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax

; 4665 :             prior += output_bytes;

  0052b	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00530	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00535	48 03 c8	 add	 rcx, rax
  00538	48 8b c1	 mov	 rax, rcx
  0053b	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax

; 4666 :         } else {

  00540	eb 2d		 jmp	 SHORT $LN117@stbi__crea
$LN116@stbi__crea:

; 4667 :             raw += 1;

  00542	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  0054a	48 ff c0	 inc	 rax
  0054d	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4668 :             cur += 1;

  00555	48 8b 44 24 38	 mov	 rax, QWORD PTR cur$3[rsp]
  0055a	48 ff c0	 inc	 rax
  0055d	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax

; 4669 :             prior += 1;

  00562	48 8b 44 24 50	 mov	 rax, QWORD PTR prior$5[rsp]
  00567	48 ff c0	 inc	 rax
  0056a	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN117@stbi__crea:
$LN114@stbi__crea:

; 4670 :         }
; 4671 :         
; 4672 :         // this is a little gross, so that we don't switch per-pixel or per-component
; 4673 :         if (depth < 8 || img_n == out_n) {

  0056f	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  00577	7c 11		 jl	 SHORT $LN121@stbi__crea
  00579	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00580	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  00584	0f 85 31 03 00
	00		 jne	 $LN119@stbi__crea
$LN121@stbi__crea:

; 4674 :             int nk = (width - 1)*filter_bytes;

  0058a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  00591	ff c8		 dec	 eax
  00593	0f af 44 24 34	 imul	 eax, DWORD PTR filter_bytes$[rsp]
  00598	89 44 24 64	 mov	 DWORD PTR nk$7[rsp], eax

; 4675 : #define STBI__CASE(f) \
; 4676 : case f:     \
; 4677 : for (k=0; k < nk; ++k)
; 4678 :             switch (filter) {

  0059c	8b 44 24 68	 mov	 eax, DWORD PTR filter$8[rsp]
  005a0	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv271[rsp], eax
  005a7	83 bc 24 84 00
	00 00 06	 cmp	 DWORD PTR tv271[rsp], 6
  005af	0f 87 e6 02 00
	00		 ja	 $LN10@stbi__crea
  005b5	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv271[rsp]
  005bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  005c4	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN167@stbi__crea[rcx+rax*4]
  005cb	48 03 c1	 add	 rax, rcx
  005ce	ff e0		 jmp	 rax
$LN122@stbi__crea:

; 4679 :                 // "none" filter turns into a memcpy here; make that explicit.
; 4680 :                 case STBI__F_none:         memcpy(cur, raw, nk); break;

  005d0	48 63 44 24 64	 movsxd	 rax, DWORD PTR nk$7[rsp]
  005d5	48 8b 7c 24 38	 mov	 rdi, QWORD PTR cur$3[rsp]
  005da	48 8b b4 24 e8
	00 00 00	 mov	 rsi, QWORD PTR raw$[rsp]
  005e2	48 8b c8	 mov	 rcx, rax
  005e5	f3 a4		 rep movsb
  005e7	e9 af 02 00 00	 jmp	 $LN10@stbi__crea
$LN123@stbi__crea:

; 4681 :                 STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;

  005ec	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  005f4	eb 0a		 jmp	 SHORT $LN14@stbi__crea
$LN12@stbi__crea:
  005f6	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  005fa	ff c0		 inc	 eax
  005fc	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN14@stbi__crea:
  00600	8b 44 24 64	 mov	 eax, DWORD PTR nk$7[rsp]
  00604	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00608	7d 3f		 jge	 SHORT $LN13@stbi__crea
  0060a	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  0060f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00617	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0061b	8b 4c 24 34	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  0061f	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  00623	2b d1		 sub	 edx, ecx
  00625	8b ca		 mov	 ecx, edx
  00627	48 63 c9	 movsxd	 rcx, ecx
  0062a	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0062f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00633	03 c1		 add	 eax, ecx
  00635	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0063a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  0063f	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00644	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00647	eb ad		 jmp	 SHORT $LN12@stbi__crea
$LN13@stbi__crea:
  00649	e9 4d 02 00 00	 jmp	 $LN10@stbi__crea
$LN124@stbi__crea:

; 4682 :                 STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

  0064e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00656	eb 0a		 jmp	 SHORT $LN17@stbi__crea
$LN15@stbi__crea:
  00658	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0065c	ff c0		 inc	 eax
  0065e	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN17@stbi__crea:
  00662	8b 44 24 64	 mov	 eax, DWORD PTR nk$7[rsp]
  00666	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0066a	7d 35		 jge	 SHORT $LN16@stbi__crea
  0066c	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00671	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00679	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0067d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00682	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  00687	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0068b	03 c1		 add	 eax, ecx
  0068d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00692	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00697	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0069c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0069f	eb b7		 jmp	 SHORT $LN15@stbi__crea
$LN16@stbi__crea:
  006a1	e9 f5 01 00 00	 jmp	 $LN10@stbi__crea
$LN125@stbi__crea:

; 4683 :                 STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;

  006a6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  006ae	eb 0a		 jmp	 SHORT $LN20@stbi__crea
$LN18@stbi__crea:
  006b0	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  006b4	ff c0		 inc	 eax
  006b6	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN20@stbi__crea:
  006ba	8b 44 24 64	 mov	 eax, DWORD PTR nk$7[rsp]
  006be	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  006c2	7d 51		 jge	 SHORT $LN19@stbi__crea
  006c4	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  006c9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  006d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006d5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  006da	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  006df	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  006e3	8b 54 24 34	 mov	 edx, DWORD PTR filter_bytes$[rsp]
  006e7	8b 7c 24 20	 mov	 edi, DWORD PTR k$[rsp]
  006eb	2b fa		 sub	 edi, edx
  006ed	8b d7		 mov	 edx, edi
  006ef	48 63 d2	 movsxd	 rdx, edx
  006f2	48 8b 7c 24 38	 mov	 rdi, QWORD PTR cur$3[rsp]
  006f7	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  006fb	03 ca		 add	 ecx, edx
  006fd	d1 f9		 sar	 ecx, 1
  006ff	03 c1		 add	 eax, ecx
  00701	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00706	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  0070b	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00710	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00713	eb 9b		 jmp	 SHORT $LN18@stbi__crea
$LN19@stbi__crea:
  00715	e9 81 01 00 00	 jmp	 $LN10@stbi__crea
$LN126@stbi__crea:

; 4684 :                 STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;

  0071a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00722	eb 0a		 jmp	 SHORT $LN23@stbi__crea
$LN21@stbi__crea:
  00724	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00728	ff c0		 inc	 eax
  0072a	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN23@stbi__crea:
  0072e	8b 44 24 64	 mov	 eax, DWORD PTR nk$7[rsp]
  00732	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00736	0f 8d 82 00 00
	00		 jge	 $LN22@stbi__crea
  0073c	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00741	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00749	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0074d	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv342[rsp], eax
  00754	8b 4c 24 34	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  00758	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  0075c	2b d1		 sub	 edx, ecx
  0075e	8b ca		 mov	 ecx, edx
  00760	48 63 c9	 movsxd	 rcx, ecx
  00763	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  00768	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0076c	48 63 54 24 20	 movsxd	 rdx, DWORD PTR k$[rsp]
  00771	48 8b 7c 24 50	 mov	 rdi, QWORD PTR prior$5[rsp]
  00776	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  0077a	8b 7c 24 34	 mov	 edi, DWORD PTR filter_bytes$[rsp]
  0077e	8b 74 24 20	 mov	 esi, DWORD PTR k$[rsp]
  00782	2b f7		 sub	 esi, edi
  00784	8b fe		 mov	 edi, esi
  00786	48 63 ff	 movsxd	 rdi, edi
  00789	48 8b 74 24 38	 mov	 rsi, QWORD PTR cur$3[rsp]
  0078e	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00792	44 8b c1	 mov	 r8d, ecx
  00795	8b cf		 mov	 ecx, edi
  00797	e8 00 00 00 00	 call	 ?stbi__paeth@@YAHHHH@Z	; stbi__paeth
  0079c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv342[rsp]
  007a3	03 c8		 add	 ecx, eax
  007a5	8b c1		 mov	 eax, ecx
  007a7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007ac	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  007b1	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  007b6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007b9	e9 66 ff ff ff	 jmp	 $LN21@stbi__crea
$LN22@stbi__crea:
  007be	e9 d8 00 00 00	 jmp	 $LN10@stbi__crea
$LN127@stbi__crea:

; 4685 :                 STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;

  007c3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  007cb	eb 0a		 jmp	 SHORT $LN26@stbi__crea
$LN24@stbi__crea:
  007cd	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  007d1	ff c0		 inc	 eax
  007d3	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN26@stbi__crea:
  007d7	8b 44 24 64	 mov	 eax, DWORD PTR nk$7[rsp]
  007db	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  007df	7d 41		 jge	 SHORT $LN25@stbi__crea
  007e1	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  007e6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  007ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007f2	8b 4c 24 34	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  007f6	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  007fa	2b d1		 sub	 edx, ecx
  007fc	8b ca		 mov	 ecx, edx
  007fe	48 63 c9	 movsxd	 rcx, ecx
  00801	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00806	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0080a	d1 f9		 sar	 ecx, 1
  0080c	03 c1		 add	 eax, ecx
  0080e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00813	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00818	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0081d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00820	eb ab		 jmp	 SHORT $LN24@stbi__crea
$LN25@stbi__crea:
  00822	eb 77		 jmp	 SHORT $LN10@stbi__crea
$LN128@stbi__crea:

; 4686 :                 STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;

  00824	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  0082c	eb 0a		 jmp	 SHORT $LN29@stbi__crea
$LN27@stbi__crea:
  0082e	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00832	ff c0		 inc	 eax
  00834	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN29@stbi__crea:
  00838	8b 44 24 64	 mov	 eax, DWORD PTR nk$7[rsp]
  0083c	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00840	7d 59		 jge	 SHORT $LN28@stbi__crea
  00842	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00847	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0084f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00853	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv390[rsp], eax
  0085a	8b 4c 24 34	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  0085e	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  00862	2b d1		 sub	 edx, ecx
  00864	8b ca		 mov	 ecx, edx
  00866	48 63 c9	 movsxd	 rcx, ecx
  00869	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  0086e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00872	45 33 c0	 xor	 r8d, r8d
  00875	33 d2		 xor	 edx, edx
  00877	e8 00 00 00 00	 call	 ?stbi__paeth@@YAHHHH@Z	; stbi__paeth
  0087c	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv390[rsp]
  00883	03 c8		 add	 ecx, eax
  00885	8b c1		 mov	 eax, ecx
  00887	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0088c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00891	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00896	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00899	eb 93		 jmp	 SHORT $LN27@stbi__crea
$LN28@stbi__crea:
$LN10@stbi__crea:

; 4687 :             }
; 4688 : #undef STBI__CASE
; 4689 :             raw += nk;

  0089b	48 63 44 24 64	 movsxd	 rax, DWORD PTR nk$7[rsp]
  008a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  008a8	48 03 c8	 add	 rcx, rax
  008ab	48 8b c1	 mov	 rax, rcx
  008ae	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4690 :         } else {

  008b6	e9 fe 06 00 00	 jmp	 $LN120@stbi__crea
$LN119@stbi__crea:

; 4691 :             STBI_ASSERT(img_n+1 == out_n);

  008bb	8b 44 24 48	 mov	 eax, DWORD PTR img_n$[rsp]
  008bf	ff c0		 inc	 eax
  008c1	3b 84 24 f8 00
	00 00		 cmp	 eax, DWORD PTR out_n$[rsp]
  008c8	74 0b		 je	 SHORT $LN129@stbi__crea
  008ca	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN129@stbi__crea:

; 4692 : #define STBI__CASE(f) \
; 4693 : case f:     \
; 4694 : for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
; 4695 : for (k=0; k < filter_bytes; ++k)
; 4696 :             switch (filter) {

  008d5	8b 44 24 68	 mov	 eax, DWORD PTR filter$8[rsp]
  008d9	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv409[rsp], eax
  008e0	83 bc 24 88 00
	00 00 06	 cmp	 DWORD PTR tv409[rsp], 6
  008e8	0f 87 5c 06 00
	00		 ja	 $LN30@stbi__crea
  008ee	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv409[rsp]
  008f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  008fd	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN166@stbi__crea[rcx+rax*4]
  00904	48 03 c1	 add	 rax, rcx
  00907	ff e0		 jmp	 rax
$LN130@stbi__crea:

; 4697 :                 STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;

  00909	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00910	ff c8		 dec	 eax
  00912	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00916	eb 5d		 jmp	 SHORT $LN34@stbi__crea
$LN32@stbi__crea:
  00918	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0091c	ff c8		 dec	 eax
  0091e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00922	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00927	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  0092c	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00930	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00935	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0093d	48 03 c8	 add	 rcx, rax
  00940	48 8b c1	 mov	 rax, rcx
  00943	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  0094b	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00950	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00955	48 03 c8	 add	 rcx, rax
  00958	48 8b c1	 mov	 rax, rcx
  0095b	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00960	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00965	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  0096a	48 03 c8	 add	 rcx, rax
  0096d	48 8b c1	 mov	 rax, rcx
  00970	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN34@stbi__crea:
  00975	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  0097a	72 43		 jb	 SHORT $LN33@stbi__crea
  0097c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00984	eb 0a		 jmp	 SHORT $LN37@stbi__crea
$LN35@stbi__crea:
  00986	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0098a	ff c0		 inc	 eax
  0098c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN37@stbi__crea:
  00990	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00994	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00998	7d 20		 jge	 SHORT $LN36@stbi__crea
  0099a	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  0099f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  009a4	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  009a9	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR raw$[rsp]
  009b1	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  009b5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  009b8	eb cc		 jmp	 SHORT $LN35@stbi__crea
$LN36@stbi__crea:
  009ba	e9 59 ff ff ff	 jmp	 $LN32@stbi__crea
$LN33@stbi__crea:
  009bf	e9 86 05 00 00	 jmp	 $LN30@stbi__crea
$LN131@stbi__crea:

; 4698 :                 STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;

  009c4	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  009cb	ff c8		 dec	 eax
  009cd	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  009d1	eb 5d		 jmp	 SHORT $LN40@stbi__crea
$LN38@stbi__crea:
  009d3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  009d7	ff c8		 dec	 eax
  009d9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  009dd	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  009e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  009e7	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  009eb	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  009f0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  009f8	48 03 c8	 add	 rcx, rax
  009fb	48 8b c1	 mov	 rax, rcx
  009fe	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00a06	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00a0b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00a10	48 03 c8	 add	 rcx, rax
  00a13	48 8b c1	 mov	 rax, rcx
  00a16	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00a1b	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00a20	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00a25	48 03 c8	 add	 rcx, rax
  00a28	48 8b c1	 mov	 rax, rcx
  00a2b	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN40@stbi__crea:
  00a30	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00a35	72 62		 jb	 SHORT $LN39@stbi__crea
  00a37	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00a3f	eb 0a		 jmp	 SHORT $LN43@stbi__crea
$LN41@stbi__crea:
  00a41	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00a45	ff c0		 inc	 eax
  00a47	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN43@stbi__crea:
  00a4b	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00a4f	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00a53	7d 3f		 jge	 SHORT $LN42@stbi__crea
  00a55	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00a5a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00a62	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a66	8b 4c 24 40	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00a6a	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  00a6e	2b d1		 sub	 edx, ecx
  00a70	8b ca		 mov	 ecx, edx
  00a72	48 63 c9	 movsxd	 rcx, ecx
  00a75	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00a7a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00a7e	03 c1		 add	 eax, ecx
  00a80	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a85	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00a8a	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00a8f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00a92	eb ad		 jmp	 SHORT $LN41@stbi__crea
$LN42@stbi__crea:
  00a94	e9 3a ff ff ff	 jmp	 $LN38@stbi__crea
$LN39@stbi__crea:
  00a99	e9 ac 04 00 00	 jmp	 $LN30@stbi__crea
$LN132@stbi__crea:

; 4699 :                 STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;

  00a9e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00aa5	ff c8		 dec	 eax
  00aa7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00aab	eb 5d		 jmp	 SHORT $LN46@stbi__crea
$LN44@stbi__crea:
  00aad	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00ab1	ff c8		 dec	 eax
  00ab3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00ab7	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00abc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00ac1	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00ac5	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00aca	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00ad2	48 03 c8	 add	 rcx, rax
  00ad5	48 8b c1	 mov	 rax, rcx
  00ad8	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00ae0	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00ae5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00aea	48 03 c8	 add	 rcx, rax
  00aed	48 8b c1	 mov	 rax, rcx
  00af0	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00af5	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00afa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00aff	48 03 c8	 add	 rcx, rax
  00b02	48 8b c1	 mov	 rax, rcx
  00b05	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN46@stbi__crea:
  00b0a	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00b0f	72 58		 jb	 SHORT $LN45@stbi__crea
  00b11	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00b19	eb 0a		 jmp	 SHORT $LN49@stbi__crea
$LN47@stbi__crea:
  00b1b	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00b1f	ff c0		 inc	 eax
  00b21	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN49@stbi__crea:
  00b25	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00b29	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00b2d	7d 35		 jge	 SHORT $LN48@stbi__crea
  00b2f	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00b34	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00b3c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b40	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00b45	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  00b4a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00b4e	03 c1		 add	 eax, ecx
  00b50	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b55	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00b5a	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00b5f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00b62	eb b7		 jmp	 SHORT $LN47@stbi__crea
$LN48@stbi__crea:
  00b64	e9 44 ff ff ff	 jmp	 $LN44@stbi__crea
$LN45@stbi__crea:
  00b69	e9 dc 03 00 00	 jmp	 $LN30@stbi__crea
$LN133@stbi__crea:

; 4700 :                 STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;

  00b6e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00b75	ff c8		 dec	 eax
  00b77	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00b7b	eb 5d		 jmp	 SHORT $LN52@stbi__crea
$LN50@stbi__crea:
  00b7d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00b81	ff c8		 dec	 eax
  00b83	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00b87	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00b8c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00b91	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00b95	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00b9a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00ba2	48 03 c8	 add	 rcx, rax
  00ba5	48 8b c1	 mov	 rax, rcx
  00ba8	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00bb0	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00bb5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00bba	48 03 c8	 add	 rcx, rax
  00bbd	48 8b c1	 mov	 rax, rcx
  00bc0	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00bc5	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00bca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00bcf	48 03 c8	 add	 rcx, rax
  00bd2	48 8b c1	 mov	 rax, rcx
  00bd5	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN52@stbi__crea:
  00bda	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00bdf	72 74		 jb	 SHORT $LN51@stbi__crea
  00be1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00be9	eb 0a		 jmp	 SHORT $LN55@stbi__crea
$LN53@stbi__crea:
  00beb	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00bef	ff c0		 inc	 eax
  00bf1	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN55@stbi__crea:
  00bf5	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00bf9	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00bfd	7d 51		 jge	 SHORT $LN54@stbi__crea
  00bff	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00c04	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00c0c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c10	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00c15	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  00c1a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00c1e	8b 54 24 40	 mov	 edx, DWORD PTR output_bytes$[rsp]
  00c22	8b 7c 24 20	 mov	 edi, DWORD PTR k$[rsp]
  00c26	2b fa		 sub	 edi, edx
  00c28	8b d7		 mov	 edx, edi
  00c2a	48 63 d2	 movsxd	 rdx, edx
  00c2d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR cur$3[rsp]
  00c32	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00c36	03 ca		 add	 ecx, edx
  00c38	d1 f9		 sar	 ecx, 1
  00c3a	03 c1		 add	 eax, ecx
  00c3c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c41	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00c46	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00c4b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c4e	eb 9b		 jmp	 SHORT $LN53@stbi__crea
$LN54@stbi__crea:
  00c50	e9 28 ff ff ff	 jmp	 $LN50@stbi__crea
$LN51@stbi__crea:
  00c55	e9 f0 02 00 00	 jmp	 $LN30@stbi__crea
$LN134@stbi__crea:

; 4701 :                 STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;

  00c5a	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00c61	ff c8		 dec	 eax
  00c63	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00c67	eb 5d		 jmp	 SHORT $LN58@stbi__crea
$LN56@stbi__crea:
  00c69	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00c6d	ff c8		 dec	 eax
  00c6f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00c73	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00c78	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00c7d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00c81	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00c86	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00c8e	48 03 c8	 add	 rcx, rax
  00c91	48 8b c1	 mov	 rax, rcx
  00c94	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00c9c	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00ca1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00ca6	48 03 c8	 add	 rcx, rax
  00ca9	48 8b c1	 mov	 rax, rcx
  00cac	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00cb1	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00cb6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00cbb	48 03 c8	 add	 rcx, rax
  00cbe	48 8b c1	 mov	 rax, rcx
  00cc1	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN58@stbi__crea:
  00cc6	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00ccb	0f 82 a9 00 00
	00		 jb	 $LN57@stbi__crea
  00cd1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00cd9	eb 0a		 jmp	 SHORT $LN61@stbi__crea
$LN59@stbi__crea:
  00cdb	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00cdf	ff c0		 inc	 eax
  00ce1	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN61@stbi__crea:
  00ce5	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00ce9	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00ced	0f 8d 82 00 00
	00		 jge	 $LN60@stbi__crea
  00cf3	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00cf8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00d00	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d04	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv542[rsp], eax
  00d0b	8b 4c 24 40	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00d0f	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  00d13	2b d1		 sub	 edx, ecx
  00d15	8b ca		 mov	 ecx, edx
  00d17	48 63 c9	 movsxd	 rcx, ecx
  00d1a	48 8b 54 24 50	 mov	 rdx, QWORD PTR prior$5[rsp]
  00d1f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d23	48 63 54 24 20	 movsxd	 rdx, DWORD PTR k$[rsp]
  00d28	48 8b 7c 24 50	 mov	 rdi, QWORD PTR prior$5[rsp]
  00d2d	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00d31	8b 7c 24 40	 mov	 edi, DWORD PTR output_bytes$[rsp]
  00d35	8b 74 24 20	 mov	 esi, DWORD PTR k$[rsp]
  00d39	2b f7		 sub	 esi, edi
  00d3b	8b fe		 mov	 edi, esi
  00d3d	48 63 ff	 movsxd	 rdi, edi
  00d40	48 8b 74 24 38	 mov	 rsi, QWORD PTR cur$3[rsp]
  00d45	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00d49	44 8b c1	 mov	 r8d, ecx
  00d4c	8b cf		 mov	 ecx, edi
  00d4e	e8 00 00 00 00	 call	 ?stbi__paeth@@YAHHHH@Z	; stbi__paeth
  00d53	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv542[rsp]
  00d5a	03 c8		 add	 ecx, eax
  00d5c	8b c1		 mov	 eax, ecx
  00d5e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d63	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00d68	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00d6d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00d70	e9 66 ff ff ff	 jmp	 $LN59@stbi__crea
$LN60@stbi__crea:
  00d75	e9 ef fe ff ff	 jmp	 $LN56@stbi__crea
$LN57@stbi__crea:
  00d7a	e9 cb 01 00 00	 jmp	 $LN30@stbi__crea
$LN135@stbi__crea:

; 4702 :                 STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;

  00d7f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00d86	ff c8		 dec	 eax
  00d88	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00d8c	eb 5d		 jmp	 SHORT $LN64@stbi__crea
$LN62@stbi__crea:
  00d8e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00d92	ff c8		 dec	 eax
  00d94	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00d98	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00d9d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00da2	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00da6	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00dab	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00db3	48 03 c8	 add	 rcx, rax
  00db6	48 8b c1	 mov	 rax, rcx
  00db9	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00dc1	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00dc6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00dcb	48 03 c8	 add	 rcx, rax
  00dce	48 8b c1	 mov	 rax, rcx
  00dd1	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00dd6	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00ddb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00de0	48 03 c8	 add	 rcx, rax
  00de3	48 8b c1	 mov	 rax, rcx
  00de6	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN64@stbi__crea:
  00deb	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00df0	72 64		 jb	 SHORT $LN63@stbi__crea
  00df2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00dfa	eb 0a		 jmp	 SHORT $LN67@stbi__crea
$LN65@stbi__crea:
  00dfc	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00e00	ff c0		 inc	 eax
  00e02	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN67@stbi__crea:
  00e06	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00e0a	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00e0e	7d 41		 jge	 SHORT $LN66@stbi__crea
  00e10	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00e15	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00e1d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e21	8b 4c 24 40	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00e25	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  00e29	2b d1		 sub	 edx, ecx
  00e2b	8b ca		 mov	 ecx, edx
  00e2d	48 63 c9	 movsxd	 rcx, ecx
  00e30	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00e35	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e39	d1 f9		 sar	 ecx, 1
  00e3b	03 c1		 add	 eax, ecx
  00e3d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e42	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00e47	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00e4c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00e4f	eb ab		 jmp	 SHORT $LN65@stbi__crea
$LN66@stbi__crea:
  00e51	e9 38 ff ff ff	 jmp	 $LN62@stbi__crea
$LN63@stbi__crea:
  00e56	e9 ef 00 00 00	 jmp	 $LN30@stbi__crea
$LN136@stbi__crea:

; 4703 :                 STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;

  00e5b	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00e62	ff c8		 dec	 eax
  00e64	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00e68	eb 5d		 jmp	 SHORT $LN70@stbi__crea
$LN68@stbi__crea:
  00e6a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00e6e	ff c8		 dec	 eax
  00e70	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00e74	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00e79	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00e7e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00e82	48 63 44 24 34	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  00e87	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00e8f	48 03 c8	 add	 rcx, rax
  00e92	48 8b c1	 mov	 rax, rcx
  00e95	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax
  00e9d	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00ea2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00ea7	48 03 c8	 add	 rcx, rax
  00eaa	48 8b c1	 mov	 rax, rcx
  00ead	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
  00eb2	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00eb7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR prior$5[rsp]
  00ebc	48 03 c8	 add	 rcx, rax
  00ebf	48 8b c1	 mov	 rax, rcx
  00ec2	48 89 44 24 50	 mov	 QWORD PTR prior$5[rsp], rax
$LN70@stbi__crea:
  00ec7	83 7c 24 30 01	 cmp	 DWORD PTR i$[rsp], 1
  00ecc	72 7c		 jb	 SHORT $LN69@stbi__crea
  00ece	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00ed6	eb 0a		 jmp	 SHORT $LN73@stbi__crea
$LN71@stbi__crea:
  00ed8	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00edc	ff c0		 inc	 eax
  00ede	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN73@stbi__crea:
  00ee2	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00ee6	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00eea	7d 59		 jge	 SHORT $LN72@stbi__crea
  00eec	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00ef1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00ef9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00efd	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv614[rsp], eax
  00f04	8b 4c 24 40	 mov	 ecx, DWORD PTR output_bytes$[rsp]
  00f08	8b 54 24 20	 mov	 edx, DWORD PTR k$[rsp]
  00f0c	2b d1		 sub	 edx, ecx
  00f0e	8b ca		 mov	 ecx, edx
  00f10	48 63 c9	 movsxd	 rcx, ecx
  00f13	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00f18	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00f1c	45 33 c0	 xor	 r8d, r8d
  00f1f	33 d2		 xor	 edx, edx
  00f21	e8 00 00 00 00	 call	 ?stbi__paeth@@YAHHHH@Z	; stbi__paeth
  00f26	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv614[rsp]
  00f2d	03 c8		 add	 ecx, eax
  00f2f	8b c1		 mov	 eax, ecx
  00f31	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f36	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00f3b	48 8b 54 24 38	 mov	 rdx, QWORD PTR cur$3[rsp]
  00f40	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f43	eb 93		 jmp	 SHORT $LN71@stbi__crea
$LN72@stbi__crea:
  00f45	e9 20 ff ff ff	 jmp	 $LN68@stbi__crea
$LN69@stbi__crea:
$LN30@stbi__crea:

; 4704 :             }
; 4705 : #undef STBI__CASE
; 4706 :             
; 4707 :             // the loop above sets the high byte of the pixels' alpha, but for
; 4708 :             // 16 bit png files we also need the low byte set. we'll do that here.
; 4709 :             if (depth == 16) {

  00f4a	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00f52	75 65		 jne	 SHORT $LN137@stbi__crea

; 4710 :                 cur = a->out + stride*j; // start at the beginning of the row again

  00f54	8b 44 24 6c	 mov	 eax, DWORD PTR stride$[rsp]
  00f58	0f af 44 24 60	 imul	 eax, DWORD PTR j$[rsp]
  00f5d	8b c0		 mov	 eax, eax
  00f5f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00f67	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00f6b	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax

; 4711 :                 for (i=0; i < x; ++i,cur+=output_bytes) {

  00f70	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00f78	eb 1f		 jmp	 SHORT $LN76@stbi__crea
$LN74@stbi__crea:
  00f7a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00f7e	ff c0		 inc	 eax
  00f80	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00f84	48 63 44 24 40	 movsxd	 rax, DWORD PTR output_bytes$[rsp]
  00f89	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00f8e	48 03 c8	 add	 rcx, rax
  00f91	48 8b c1	 mov	 rax, rcx
  00f94	48 89 44 24 38	 mov	 QWORD PTR cur$3[rsp], rax
$LN76@stbi__crea:
  00f99	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00fa0	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00fa4	73 13		 jae	 SHORT $LN75@stbi__crea

; 4712 :                     cur[filter_bytes+1] = 255;

  00fa6	8b 44 24 34	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00faa	ff c0		 inc	 eax
  00fac	48 98		 cdqe
  00fae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cur$3[rsp]
  00fb3	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4713 :                 }

  00fb7	eb c1		 jmp	 SHORT $LN74@stbi__crea
$LN75@stbi__crea:
$LN137@stbi__crea:
$LN120@stbi__crea:

; 4714 :             }
; 4715 :         }
; 4716 :     }

  00fb9	e9 f5 f1 ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4717 :     
; 4718 :     // we make a separate pass to expand bits to pixels; for performance,
; 4719 :     // this could run two scanlines behind the above code, so it won't
; 4720 :     // intefere with filtering but will still be in the cache.
; 4721 :     if (depth < 8) {

  00fbe	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  00fc6	0f 8d 3b 07 00
	00		 jge	 $LN138@stbi__crea

; 4722 :         for (j=0; j < y; ++j) {

  00fcc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00fd4	eb 0a		 jmp	 SHORT $LN79@stbi__crea
$LN77@stbi__crea:
  00fd6	8b 44 24 60	 mov	 eax, DWORD PTR j$[rsp]
  00fda	ff c0		 inc	 eax
  00fdc	89 44 24 60	 mov	 DWORD PTR j$[rsp], eax
$LN79@stbi__crea:
  00fe0	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  00fe7	39 44 24 60	 cmp	 DWORD PTR j$[rsp], eax
  00feb	0f 83 11 07 00
	00		 jae	 $LN78@stbi__crea

; 4723 :             stbi_uc *cur = a->out + stride*j;

  00ff1	8b 44 24 6c	 mov	 eax, DWORD PTR stride$[rsp]
  00ff5	0f af 44 24 60	 imul	 eax, DWORD PTR j$[rsp]
  00ffa	8b c0		 mov	 eax, eax
  00ffc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  01004	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01008	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4724 :             stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;

  0100d	8b 44 24 6c	 mov	 eax, DWORD PTR stride$[rsp]
  01011	0f af 44 24 60	 imul	 eax, DWORD PTR j$[rsp]
  01016	8b c0		 mov	 eax, eax
  01018	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  01020	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01024	48 03 c8	 add	 rcx, rax
  01027	48 8b c1	 mov	 rax, rcx
  0102a	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR x$[rsp]
  01031	0f af 8c 24 f8
	00 00 00	 imul	 ecx, DWORD PTR out_n$[rsp]
  01039	8b c9		 mov	 ecx, ecx
  0103b	48 03 c1	 add	 rax, rcx
  0103e	8b 4c 24 70	 mov	 ecx, DWORD PTR img_width_bytes$[rsp]
  01042	48 2b c1	 sub	 rax, rcx
  01045	48 89 44 24 58	 mov	 QWORD PTR in$6[rsp], rax

; 4725 :             // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4726 :             // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4727 :             stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

  0104a	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR color$[rsp], 0
  01052	75 1c		 jne	 SHORT $LN164@stbi__crea
  01054	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR depth$[rsp]
  0105c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__depth_scale_table@@3QBEB
  01063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01067	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv662[rsp], eax
  0106e	eb 0b		 jmp	 SHORT $LN165@stbi__crea
$LN164@stbi__crea:
  01070	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv662[rsp], 1
$LN165@stbi__crea:
  0107b	0f b6 84 24 8c
	00 00 00	 movzx	 eax, BYTE PTR tv662[rsp]
  01083	88 44 24 24	 mov	 BYTE PTR scale$1[rsp], al

; 4728 :             
; 4729 :             // note that the final byte might overshoot and write more data than desired.
; 4730 :             // we can allocate enough data that this never writes out of memory, but it
; 4731 :             // could also overwrite the next scanline. can it overwrite non-empty data
; 4732 :             // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4733 :             // so we need to explicitly clamp the final ones
; 4734 :             
; 4735 :             if (depth == 4) {

  01087	83 bc 24 10 01
	00 00 04	 cmp	 DWORD PTR depth$[rsp], 4
  0108f	0f 85 b4 00 00
	00		 jne	 $LN140@stbi__crea

; 4736 :                 for (k=x*img_n; k >= 2; k-=2, ++in) {

  01095	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0109c	0f af 44 24 48	 imul	 eax, DWORD PTR img_n$[rsp]
  010a1	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  010a5	eb 18		 jmp	 SHORT $LN82@stbi__crea
$LN80@stbi__crea:
  010a7	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  010ab	83 e8 02	 sub	 eax, 2
  010ae	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  010b2	48 8b 44 24 58	 mov	 rax, QWORD PTR in$6[rsp]
  010b7	48 ff c0	 inc	 rax
  010ba	48 89 44 24 58	 mov	 QWORD PTR in$6[rsp], rax
$LN82@stbi__crea:
  010bf	83 7c 24 20 02	 cmp	 DWORD PTR k$[rsp], 2
  010c4	7c 50		 jl	 SHORT $LN81@stbi__crea

; 4737 :                     *cur++ = scale * ((*in >> 4)       );

  010c6	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  010cb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  010d0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  010d3	c1 f9 04	 sar	 ecx, 4
  010d6	0f af c1	 imul	 eax, ecx
  010d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  010de	88 01		 mov	 BYTE PTR [rcx], al
  010e0	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  010e5	48 ff c0	 inc	 rax
  010e8	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4738 :                     *cur++ = scale * ((*in     ) & 0x0f);

  010ed	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  010f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  010f7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  010fa	83 e1 0f	 and	 ecx, 15
  010fd	0f af c1	 imul	 eax, ecx
  01100	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01105	88 01		 mov	 BYTE PTR [rcx], al
  01107	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0110c	48 ff c0	 inc	 rax
  0110f	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4739 :                 }

  01114	eb 91		 jmp	 SHORT $LN80@stbi__crea
$LN81@stbi__crea:

; 4740 :                 if (k > 0) *cur++ = scale * ((*in >> 4)       );

  01116	83 7c 24 20 00	 cmp	 DWORD PTR k$[rsp], 0
  0111b	7e 27		 jle	 SHORT $LN142@stbi__crea
  0111d	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01122	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01127	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0112a	c1 f9 04	 sar	 ecx, 4
  0112d	0f af c1	 imul	 eax, ecx
  01130	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01135	88 01		 mov	 BYTE PTR [rcx], al
  01137	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0113c	48 ff c0	 inc	 rax
  0113f	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN142@stbi__crea:
  01144	e9 63 04 00 00	 jmp	 $LN141@stbi__crea
$LN140@stbi__crea:

; 4741 :             } else if (depth == 2) {

  01149	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR depth$[rsp], 2
  01151	0f 85 71 01 00
	00		 jne	 $LN143@stbi__crea

; 4742 :                 for (k=x*img_n; k >= 4; k-=4, ++in) {

  01157	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0115e	0f af 44 24 48	 imul	 eax, DWORD PTR img_n$[rsp]
  01163	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  01167	eb 18		 jmp	 SHORT $LN85@stbi__crea
$LN83@stbi__crea:
  01169	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0116d	83 e8 04	 sub	 eax, 4
  01170	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  01174	48 8b 44 24 58	 mov	 rax, QWORD PTR in$6[rsp]
  01179	48 ff c0	 inc	 rax
  0117c	48 89 44 24 58	 mov	 QWORD PTR in$6[rsp], rax
$LN85@stbi__crea:
  01181	83 7c 24 20 04	 cmp	 DWORD PTR k$[rsp], 4
  01186	0f 8c a7 00 00
	00		 jl	 $LN84@stbi__crea

; 4743 :                     *cur++ = scale * ((*in >> 6)       );

  0118c	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01191	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01196	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01199	c1 f9 06	 sar	 ecx, 6
  0119c	0f af c1	 imul	 eax, ecx
  0119f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  011a4	88 01		 mov	 BYTE PTR [rcx], al
  011a6	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  011ab	48 ff c0	 inc	 rax
  011ae	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4744 :                     *cur++ = scale * ((*in >> 4) & 0x03);

  011b3	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  011b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  011bd	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  011c0	c1 f9 04	 sar	 ecx, 4
  011c3	83 e1 03	 and	 ecx, 3
  011c6	0f af c1	 imul	 eax, ecx
  011c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  011ce	88 01		 mov	 BYTE PTR [rcx], al
  011d0	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  011d5	48 ff c0	 inc	 rax
  011d8	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4745 :                     *cur++ = scale * ((*in >> 2) & 0x03);

  011dd	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  011e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  011e7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  011ea	c1 f9 02	 sar	 ecx, 2
  011ed	83 e1 03	 and	 ecx, 3
  011f0	0f af c1	 imul	 eax, ecx
  011f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  011f8	88 01		 mov	 BYTE PTR [rcx], al
  011fa	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  011ff	48 ff c0	 inc	 rax
  01202	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4746 :                     *cur++ = scale * ((*in     ) & 0x03);

  01207	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  0120c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01211	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01214	83 e1 03	 and	 ecx, 3
  01217	0f af c1	 imul	 eax, ecx
  0121a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0121f	88 01		 mov	 BYTE PTR [rcx], al
  01221	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01226	48 ff c0	 inc	 rax
  01229	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4747 :                 }

  0122e	e9 36 ff ff ff	 jmp	 $LN83@stbi__crea
$LN84@stbi__crea:

; 4748 :                 if (k > 0) *cur++ = scale * ((*in >> 6)       );

  01233	83 7c 24 20 00	 cmp	 DWORD PTR k$[rsp], 0
  01238	7e 27		 jle	 SHORT $LN145@stbi__crea
  0123a	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  0123f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01244	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01247	c1 f9 06	 sar	 ecx, 6
  0124a	0f af c1	 imul	 eax, ecx
  0124d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01252	88 01		 mov	 BYTE PTR [rcx], al
  01254	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01259	48 ff c0	 inc	 rax
  0125c	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN145@stbi__crea:

; 4749 :                 if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);

  01261	83 7c 24 20 01	 cmp	 DWORD PTR k$[rsp], 1
  01266	7e 2a		 jle	 SHORT $LN146@stbi__crea
  01268	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  0126d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01272	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01275	c1 f9 04	 sar	 ecx, 4
  01278	83 e1 03	 and	 ecx, 3
  0127b	0f af c1	 imul	 eax, ecx
  0127e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01283	88 01		 mov	 BYTE PTR [rcx], al
  01285	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0128a	48 ff c0	 inc	 rax
  0128d	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN146@stbi__crea:

; 4750 :                 if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);

  01292	83 7c 24 20 02	 cmp	 DWORD PTR k$[rsp], 2
  01297	7e 2a		 jle	 SHORT $LN147@stbi__crea
  01299	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  0129e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  012a3	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  012a6	c1 f9 02	 sar	 ecx, 2
  012a9	83 e1 03	 and	 ecx, 3
  012ac	0f af c1	 imul	 eax, ecx
  012af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  012b4	88 01		 mov	 BYTE PTR [rcx], al
  012b6	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  012bb	48 ff c0	 inc	 rax
  012be	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN147@stbi__crea:
  012c3	e9 e4 02 00 00	 jmp	 $LN144@stbi__crea
$LN143@stbi__crea:

; 4751 :             } else if (depth == 1) {

  012c8	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR depth$[rsp], 1
  012d0	0f 85 d6 02 00
	00		 jne	 $LN148@stbi__crea

; 4752 :                 for (k=x*img_n; k >= 8; k-=8, ++in) {

  012d6	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  012dd	0f af 44 24 48	 imul	 eax, DWORD PTR img_n$[rsp]
  012e2	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  012e6	eb 18		 jmp	 SHORT $LN88@stbi__crea
$LN86@stbi__crea:
  012e8	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  012ec	83 e8 08	 sub	 eax, 8
  012ef	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  012f3	48 8b 44 24 58	 mov	 rax, QWORD PTR in$6[rsp]
  012f8	48 ff c0	 inc	 rax
  012fb	48 89 44 24 58	 mov	 QWORD PTR in$6[rsp], rax
$LN88@stbi__crea:
  01300	83 7c 24 20 08	 cmp	 DWORD PTR k$[rsp], 8
  01305	0f 8c 4e 01 00
	00		 jl	 $LN87@stbi__crea

; 4753 :                     *cur++ = scale * ((*in >> 7)       );

  0130b	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01310	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01315	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01318	c1 f9 07	 sar	 ecx, 7
  0131b	0f af c1	 imul	 eax, ecx
  0131e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01323	88 01		 mov	 BYTE PTR [rcx], al
  01325	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0132a	48 ff c0	 inc	 rax
  0132d	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4754 :                     *cur++ = scale * ((*in >> 6) & 0x01);

  01332	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01337	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  0133c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0133f	c1 f9 06	 sar	 ecx, 6
  01342	83 e1 01	 and	 ecx, 1
  01345	0f af c1	 imul	 eax, ecx
  01348	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0134d	88 01		 mov	 BYTE PTR [rcx], al
  0134f	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01354	48 ff c0	 inc	 rax
  01357	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4755 :                     *cur++ = scale * ((*in >> 5) & 0x01);

  0135c	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01361	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01366	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01369	c1 f9 05	 sar	 ecx, 5
  0136c	83 e1 01	 and	 ecx, 1
  0136f	0f af c1	 imul	 eax, ecx
  01372	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01377	88 01		 mov	 BYTE PTR [rcx], al
  01379	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0137e	48 ff c0	 inc	 rax
  01381	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4756 :                     *cur++ = scale * ((*in >> 4) & 0x01);

  01386	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  0138b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01390	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01393	c1 f9 04	 sar	 ecx, 4
  01396	83 e1 01	 and	 ecx, 1
  01399	0f af c1	 imul	 eax, ecx
  0139c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  013a1	88 01		 mov	 BYTE PTR [rcx], al
  013a3	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  013a8	48 ff c0	 inc	 rax
  013ab	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4757 :                     *cur++ = scale * ((*in >> 3) & 0x01);

  013b0	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  013b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  013ba	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  013bd	c1 f9 03	 sar	 ecx, 3
  013c0	83 e1 01	 and	 ecx, 1
  013c3	0f af c1	 imul	 eax, ecx
  013c6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  013cb	88 01		 mov	 BYTE PTR [rcx], al
  013cd	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  013d2	48 ff c0	 inc	 rax
  013d5	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4758 :                     *cur++ = scale * ((*in >> 2) & 0x01);

  013da	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  013df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  013e4	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  013e7	c1 f9 02	 sar	 ecx, 2
  013ea	83 e1 01	 and	 ecx, 1
  013ed	0f af c1	 imul	 eax, ecx
  013f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  013f5	88 01		 mov	 BYTE PTR [rcx], al
  013f7	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  013fc	48 ff c0	 inc	 rax
  013ff	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4759 :                     *cur++ = scale * ((*in >> 1) & 0x01);

  01404	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01409	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  0140e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01411	d1 f9		 sar	 ecx, 1
  01413	83 e1 01	 and	 ecx, 1
  01416	0f af c1	 imul	 eax, ecx
  01419	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0141e	88 01		 mov	 BYTE PTR [rcx], al
  01420	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01425	48 ff c0	 inc	 rax
  01428	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4760 :                     *cur++ = scale * ((*in     ) & 0x01);

  0142d	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01432	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01437	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0143a	83 e1 01	 and	 ecx, 1
  0143d	0f af c1	 imul	 eax, ecx
  01440	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01445	88 01		 mov	 BYTE PTR [rcx], al
  01447	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0144c	48 ff c0	 inc	 rax
  0144f	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4761 :                 }

  01454	e9 8f fe ff ff	 jmp	 $LN86@stbi__crea
$LN87@stbi__crea:

; 4762 :                 if (k > 0) *cur++ = scale * ((*in >> 7)       );

  01459	83 7c 24 20 00	 cmp	 DWORD PTR k$[rsp], 0
  0145e	7e 27		 jle	 SHORT $LN149@stbi__crea
  01460	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01465	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  0146a	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0146d	c1 f9 07	 sar	 ecx, 7
  01470	0f af c1	 imul	 eax, ecx
  01473	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01478	88 01		 mov	 BYTE PTR [rcx], al
  0147a	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  0147f	48 ff c0	 inc	 rax
  01482	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN149@stbi__crea:

; 4763 :                 if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);

  01487	83 7c 24 20 01	 cmp	 DWORD PTR k$[rsp], 1
  0148c	7e 2a		 jle	 SHORT $LN150@stbi__crea
  0148e	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01493	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  01498	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0149b	c1 f9 06	 sar	 ecx, 6
  0149e	83 e1 01	 and	 ecx, 1
  014a1	0f af c1	 imul	 eax, ecx
  014a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  014a9	88 01		 mov	 BYTE PTR [rcx], al
  014ab	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  014b0	48 ff c0	 inc	 rax
  014b3	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN150@stbi__crea:

; 4764 :                 if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);

  014b8	83 7c 24 20 02	 cmp	 DWORD PTR k$[rsp], 2
  014bd	7e 2a		 jle	 SHORT $LN151@stbi__crea
  014bf	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  014c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  014c9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  014cc	c1 f9 05	 sar	 ecx, 5
  014cf	83 e1 01	 and	 ecx, 1
  014d2	0f af c1	 imul	 eax, ecx
  014d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  014da	88 01		 mov	 BYTE PTR [rcx], al
  014dc	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  014e1	48 ff c0	 inc	 rax
  014e4	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN151@stbi__crea:

; 4765 :                 if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);

  014e9	83 7c 24 20 03	 cmp	 DWORD PTR k$[rsp], 3
  014ee	7e 2a		 jle	 SHORT $LN152@stbi__crea
  014f0	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  014f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  014fa	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  014fd	c1 f9 04	 sar	 ecx, 4
  01500	83 e1 01	 and	 ecx, 1
  01503	0f af c1	 imul	 eax, ecx
  01506	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0150b	88 01		 mov	 BYTE PTR [rcx], al
  0150d	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01512	48 ff c0	 inc	 rax
  01515	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN152@stbi__crea:

; 4766 :                 if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);

  0151a	83 7c 24 20 04	 cmp	 DWORD PTR k$[rsp], 4
  0151f	7e 2a		 jle	 SHORT $LN153@stbi__crea
  01521	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01526	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  0152b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0152e	c1 f9 03	 sar	 ecx, 3
  01531	83 e1 01	 and	 ecx, 1
  01534	0f af c1	 imul	 eax, ecx
  01537	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0153c	88 01		 mov	 BYTE PTR [rcx], al
  0153e	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01543	48 ff c0	 inc	 rax
  01546	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN153@stbi__crea:

; 4767 :                 if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);

  0154b	83 7c 24 20 05	 cmp	 DWORD PTR k$[rsp], 5
  01550	7e 2a		 jle	 SHORT $LN154@stbi__crea
  01552	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01557	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  0155c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0155f	c1 f9 02	 sar	 ecx, 2
  01562	83 e1 01	 and	 ecx, 1
  01565	0f af c1	 imul	 eax, ecx
  01568	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0156d	88 01		 mov	 BYTE PTR [rcx], al
  0156f	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  01574	48 ff c0	 inc	 rax
  01577	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN154@stbi__crea:

; 4768 :                 if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);

  0157c	83 7c 24 20 06	 cmp	 DWORD PTR k$[rsp], 6
  01581	7e 29		 jle	 SHORT $LN155@stbi__crea
  01583	0f b6 44 24 24	 movzx	 eax, BYTE PTR scale$1[rsp]
  01588	48 8b 4c 24 58	 mov	 rcx, QWORD PTR in$6[rsp]
  0158d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01590	d1 f9		 sar	 ecx, 1
  01592	83 e1 01	 and	 ecx, 1
  01595	0f af c1	 imul	 eax, ecx
  01598	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0159d	88 01		 mov	 BYTE PTR [rcx], al
  0159f	48 8b 44 24 28	 mov	 rax, QWORD PTR cur$2[rsp]
  015a4	48 ff c0	 inc	 rax
  015a7	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax
$LN155@stbi__crea:
$LN148@stbi__crea:
$LN144@stbi__crea:
$LN141@stbi__crea:

; 4769 :             }
; 4770 :             if (img_n != out_n) {

  015ac	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  015b3	39 44 24 48	 cmp	 DWORD PTR img_n$[rsp], eax
  015b7	0f 84 40 01 00
	00		 je	 $LN156@stbi__crea

; 4771 :                 int q;
; 4772 :                 // insert alpha = 255
; 4773 :                 cur = a->out + stride*j;

  015bd	8b 44 24 6c	 mov	 eax, DWORD PTR stride$[rsp]
  015c1	0f af 44 24 60	 imul	 eax, DWORD PTR j$[rsp]
  015c6	8b c0		 mov	 eax, eax
  015c8	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  015d0	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  015d4	48 89 44 24 28	 mov	 QWORD PTR cur$2[rsp], rax

; 4774 :                 if (img_n == 1) {

  015d9	83 7c 24 48 01	 cmp	 DWORD PTR img_n$[rsp], 1
  015de	75 59		 jne	 SHORT $LN157@stbi__crea

; 4775 :                     for (q=x-1; q >= 0; --q) {

  015e0	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  015e7	ff c8		 dec	 eax
  015e9	89 44 24 44	 mov	 DWORD PTR q$4[rsp], eax
  015ed	eb 0a		 jmp	 SHORT $LN91@stbi__crea
$LN89@stbi__crea:
  015ef	8b 44 24 44	 mov	 eax, DWORD PTR q$4[rsp]
  015f3	ff c8		 dec	 eax
  015f5	89 44 24 44	 mov	 DWORD PTR q$4[rsp], eax
$LN91@stbi__crea:
  015f9	83 7c 24 44 00	 cmp	 DWORD PTR q$4[rsp], 0
  015fe	7c 34		 jl	 SHORT $LN90@stbi__crea

; 4776 :                         cur[q*2+1] = 255;

  01600	8b 44 24 44	 mov	 eax, DWORD PTR q$4[rsp]
  01604	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  01608	48 98		 cdqe
  0160a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  0160f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4777 :                         cur[q*2+0] = cur[q];

  01613	48 63 44 24 44	 movsxd	 rax, DWORD PTR q$4[rsp]
  01618	8b 4c 24 44	 mov	 ecx, DWORD PTR q$4[rsp]
  0161c	03 c9		 add	 ecx, ecx
  0161e	48 63 c9	 movsxd	 rcx, ecx
  01621	48 8b 54 24 28	 mov	 rdx, QWORD PTR cur$2[rsp]
  01626	48 8b 7c 24 28	 mov	 rdi, QWORD PTR cur$2[rsp]
  0162b	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  0162f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4778 :                     }

  01632	eb bb		 jmp	 SHORT $LN89@stbi__crea
$LN90@stbi__crea:

; 4779 :                 } else {

  01634	e9 c4 00 00 00	 jmp	 $LN158@stbi__crea
$LN157@stbi__crea:

; 4780 :                     STBI_ASSERT(img_n == 3);

  01639	83 7c 24 48 03	 cmp	 DWORD PTR img_n$[rsp], 3
  0163e	74 0b		 je	 SHORT $LN159@stbi__crea
  01640	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN159@stbi__crea:

; 4781 :                     for (q=x-1; q >= 0; --q) {

  0164b	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  01652	ff c8		 dec	 eax
  01654	89 44 24 44	 mov	 DWORD PTR q$4[rsp], eax
  01658	eb 0a		 jmp	 SHORT $LN94@stbi__crea
$LN92@stbi__crea:
  0165a	8b 44 24 44	 mov	 eax, DWORD PTR q$4[rsp]
  0165e	ff c8		 dec	 eax
  01660	89 44 24 44	 mov	 DWORD PTR q$4[rsp], eax
$LN94@stbi__crea:
  01664	83 7c 24 44 00	 cmp	 DWORD PTR q$4[rsp], 0
  01669	0f 8c 8e 00 00
	00		 jl	 $LN93@stbi__crea

; 4782 :                         cur[q*4+3] = 255;

  0166f	8b 44 24 44	 mov	 eax, DWORD PTR q$4[rsp]
  01673	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  0167a	48 98		 cdqe
  0167c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cur$2[rsp]
  01681	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4783 :                         cur[q*4+2] = cur[q*3+2];

  01685	6b 44 24 44 03	 imul	 eax, DWORD PTR q$4[rsp], 3
  0168a	83 c0 02	 add	 eax, 2
  0168d	48 98		 cdqe
  0168f	8b 4c 24 44	 mov	 ecx, DWORD PTR q$4[rsp]
  01693	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  0169a	48 63 c9	 movsxd	 rcx, ecx
  0169d	48 8b 54 24 28	 mov	 rdx, QWORD PTR cur$2[rsp]
  016a2	48 8b 7c 24 28	 mov	 rdi, QWORD PTR cur$2[rsp]
  016a7	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  016ab	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4784 :                         cur[q*4+1] = cur[q*3+1];

  016ae	6b 44 24 44 03	 imul	 eax, DWORD PTR q$4[rsp], 3
  016b3	ff c0		 inc	 eax
  016b5	48 98		 cdqe
  016b7	8b 4c 24 44	 mov	 ecx, DWORD PTR q$4[rsp]
  016bb	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  016c2	48 63 c9	 movsxd	 rcx, ecx
  016c5	48 8b 54 24 28	 mov	 rdx, QWORD PTR cur$2[rsp]
  016ca	48 8b 7c 24 28	 mov	 rdi, QWORD PTR cur$2[rsp]
  016cf	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  016d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4785 :                         cur[q*4+0] = cur[q*3+0];

  016d6	6b 44 24 44 03	 imul	 eax, DWORD PTR q$4[rsp], 3
  016db	48 98		 cdqe
  016dd	8b 4c 24 44	 mov	 ecx, DWORD PTR q$4[rsp]
  016e1	c1 e1 02	 shl	 ecx, 2
  016e4	48 63 c9	 movsxd	 rcx, ecx
  016e7	48 8b 54 24 28	 mov	 rdx, QWORD PTR cur$2[rsp]
  016ec	48 8b 7c 24 28	 mov	 rdi, QWORD PTR cur$2[rsp]
  016f1	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  016f5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4786 :                     }

  016f8	e9 5d ff ff ff	 jmp	 $LN92@stbi__crea
$LN93@stbi__crea:
$LN158@stbi__crea:
$LN156@stbi__crea:

; 4787 :                 }
; 4788 :             }
; 4789 :         }

  016fd	e9 d4 f8 ff ff	 jmp	 $LN77@stbi__crea
$LN78@stbi__crea:

; 4790 :     } else if (depth == 16) {

  01702	e9 ca 00 00 00	 jmp	 $LN139@stbi__crea
$LN138@stbi__crea:
  01707	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  0170f	0f 85 bc 00 00
	00		 jne	 $LN160@stbi__crea

; 4791 :         // force the image data from big-endian to platform-native.
; 4792 :         // this is done in a separate pass due to the decoding relying
; 4793 :         // on the data being untouched, but could probably be done
; 4794 :         // per-line during decode if care is taken.
; 4795 :         stbi_uc *cur = a->out;

  01715	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0171d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01721	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cur$9[rsp], rax

; 4796 :         stbi__uint16 *cur16 = (stbi__uint16*)cur;

  01729	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cur$9[rsp]
  01731	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cur16$10[rsp], rax

; 4797 :         
; 4798 :         for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {

  01739	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01741	eb 32		 jmp	 SHORT $LN97@stbi__crea
$LN95@stbi__crea:
  01743	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  01747	ff c0		 inc	 eax
  01749	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0174d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR cur16$10[rsp]
  01755	48 83 c0 02	 add	 rax, 2
  01759	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cur16$10[rsp], rax
  01761	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cur$9[rsp]
  01769	48 83 c0 02	 add	 rax, 2
  0176d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cur$9[rsp], rax
$LN97@stbi__crea:
  01775	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0177c	0f af 84 24 08
	01 00 00	 imul	 eax, DWORD PTR y$[rsp]
  01784	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  0178c	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  01790	73 3f		 jae	 SHORT $LN96@stbi__crea

; 4799 :             *cur16 = (cur[0] << 8) | cur[1];

  01792	b8 01 00 00 00	 mov	 eax, 1
  01797	48 6b c0 00	 imul	 rax, rax, 0
  0179b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cur$9[rsp]
  017a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  017a7	c1 e0 08	 shl	 eax, 8
  017aa	b9 01 00 00 00	 mov	 ecx, 1
  017af	48 6b c9 01	 imul	 rcx, rcx, 1
  017b3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR cur$9[rsp]
  017bb	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  017bf	0b c1		 or	 eax, ecx
  017c1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR cur16$10[rsp]
  017c9	66 89 01	 mov	 WORD PTR [rcx], ax

; 4800 :         }

  017cc	e9 72 ff ff ff	 jmp	 $LN95@stbi__crea
$LN96@stbi__crea:
$LN160@stbi__crea:
$LN139@stbi__crea:

; 4801 :     }
; 4802 :     
; 4803 :     return 1;

  017d1	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4804 : }

  017d6	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  017dd	5f		 pop	 rdi
  017de	5e		 pop	 rsi
  017df	c3		 ret	 0
$LN168@stbi__crea:
  017e0	00 00 00 00	 DD	 $LN106@stbi__crea
  017e4	00 00 00 00	 DD	 $LN107@stbi__crea
  017e8	00 00 00 00	 DD	 $LN108@stbi__crea
  017ec	00 00 00 00	 DD	 $LN109@stbi__crea
  017f0	00 00 00 00	 DD	 $LN110@stbi__crea
  017f4	00 00 00 00	 DD	 $LN111@stbi__crea
  017f8	00 00 00 00	 DD	 $LN112@stbi__crea
$LN167@stbi__crea:
  017fc	00 00 00 00	 DD	 $LN122@stbi__crea
  01800	00 00 00 00	 DD	 $LN123@stbi__crea
  01804	00 00 00 00	 DD	 $LN124@stbi__crea
  01808	00 00 00 00	 DD	 $LN125@stbi__crea
  0180c	00 00 00 00	 DD	 $LN126@stbi__crea
  01810	00 00 00 00	 DD	 $LN127@stbi__crea
  01814	00 00 00 00	 DD	 $LN128@stbi__crea
$LN166@stbi__crea:
  01818	00 00 00 00	 DD	 $LN130@stbi__crea
  0181c	00 00 00 00	 DD	 $LN131@stbi__crea
  01820	00 00 00 00	 DD	 $LN132@stbi__crea
  01824	00 00 00 00	 DD	 $LN133@stbi__crea
  01828	00 00 00 00	 DD	 $LN134@stbi__crea
  0182c	00 00 00 00	 DD	 $LN135@stbi__crea
  01830	00 00 00 00	 DD	 $LN136@stbi__crea
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ENDP ; stbi__create_png_image_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 0
pa$ = 4
pc$ = 8
pb$ = 12
a$ = 32
b$ = 40
c$ = 48
?stbi__paeth@@YAHHHH@Z PROC				; stbi__paeth

; 4581 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24

; 4582 :     int p = a + b - c;

  00011	8b 44 24 28	 mov	 eax, DWORD PTR b$[rsp]
  00015	8b 4c 24 20	 mov	 ecx, DWORD PTR a$[rsp]
  00019	03 c8		 add	 ecx, eax
  0001b	8b c1		 mov	 eax, ecx
  0001d	2b 44 24 30	 sub	 eax, DWORD PTR c$[rsp]
  00021	89 04 24	 mov	 DWORD PTR p$[rsp], eax

; 4583 :     int pa = abs(p-a);

  00024	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]
  00028	8b 0c 24	 mov	 ecx, DWORD PTR p$[rsp]
  0002b	2b c8		 sub	 ecx, eax
  0002d	8b c1		 mov	 eax, ecx
  0002f	99		 cdq
  00030	8b ca		 mov	 ecx, edx
  00032	33 c1		 xor	 eax, ecx
  00034	2b c1		 sub	 eax, ecx
  00036	89 44 24 04	 mov	 DWORD PTR pa$[rsp], eax

; 4584 :     int pb = abs(p-b);

  0003a	8b 44 24 28	 mov	 eax, DWORD PTR b$[rsp]
  0003e	8b 0c 24	 mov	 ecx, DWORD PTR p$[rsp]
  00041	2b c8		 sub	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	99		 cdq
  00046	8b ca		 mov	 ecx, edx
  00048	33 c1		 xor	 eax, ecx
  0004a	2b c1		 sub	 eax, ecx
  0004c	89 44 24 0c	 mov	 DWORD PTR pb$[rsp], eax

; 4585 :     int pc = abs(p-c);

  00050	8b 44 24 30	 mov	 eax, DWORD PTR c$[rsp]
  00054	8b 0c 24	 mov	 ecx, DWORD PTR p$[rsp]
  00057	2b c8		 sub	 ecx, eax
  00059	8b c1		 mov	 eax, ecx
  0005b	99		 cdq
  0005c	8b ca		 mov	 ecx, edx
  0005e	33 c1		 xor	 eax, ecx
  00060	2b c1		 sub	 eax, ecx
  00062	89 44 24 08	 mov	 DWORD PTR pc$[rsp], eax

; 4586 :     if (pa <= pb && pa <= pc) return a;

  00066	8b 44 24 0c	 mov	 eax, DWORD PTR pb$[rsp]
  0006a	39 44 24 04	 cmp	 DWORD PTR pa$[rsp], eax
  0006e	7f 10		 jg	 SHORT $LN2@stbi__paet
  00070	8b 44 24 08	 mov	 eax, DWORD PTR pc$[rsp]
  00074	39 44 24 04	 cmp	 DWORD PTR pa$[rsp], eax
  00078	7f 06		 jg	 SHORT $LN2@stbi__paet
  0007a	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]
  0007e	eb 14		 jmp	 SHORT $LN1@stbi__paet
$LN2@stbi__paet:

; 4587 :     if (pb <= pc) return b;

  00080	8b 44 24 08	 mov	 eax, DWORD PTR pc$[rsp]
  00084	39 44 24 0c	 cmp	 DWORD PTR pb$[rsp], eax
  00088	7f 06		 jg	 SHORT $LN3@stbi__paet
  0008a	8b 44 24 28	 mov	 eax, DWORD PTR b$[rsp]
  0008e	eb 04		 jmp	 SHORT $LN1@stbi__paet
$LN3@stbi__paet:

; 4588 :     return c;

  00090	8b 44 24 30	 mov	 eax, DWORD PTR c$[rsp]
$LN1@stbi__paet:

; 4589 : }

  00094	48 83 c4 18	 add	 rsp, 24
  00098	c3		 ret	 0
?stbi__paeth@@YAHHHH@Z ENDP				; stbi__paeth
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z PROC	; stbi__check_png_header

; 4544 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4545 :     static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4546 :     int i;
; 4547 :     for (i=0; i < 8; ++i)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@stbi__chec
$LN2@stbi__chec:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__chec:
  0001d	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00022	7d 31		 jge	 SHORT $LN3@stbi__chec

; 4548 :         if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB
  0003d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00041	3b c1		 cmp	 eax, ecx
  00043	74 0e		 je	 SHORT $LN5@stbi__chec
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38811
  0004c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00051	eb 07		 jmp	 SHORT $LN1@stbi__chec
$LN5@stbi__chec:
  00053	eb be		 jmp	 SHORT $LN2@stbi__chec
$LN3@stbi__chec:

; 4549 :     return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__chec:

; 4550 : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ENDP	; stbi__check_png_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
c$ = 32
s$ = 64
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z PROC ; stbi__get_chunk_header

; 4536 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4537 :     stbi__pngchunk c;
; 4538 :     c.length = stbi__get32be(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00013	89 44 24 20	 mov	 DWORD PTR c$[rsp], eax

; 4539 :     c.type   = stbi__get32be(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00021	89 44 24 24	 mov	 DWORD PTR c$[rsp+4], eax

; 4540 :     return c;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]

; 4541 : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ENDP ; stbi__get_chunk_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 48
obuf$ = 56
olen$ = 64
exp$ = 72
parse_header$ = 80
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z PROC	; stbi__do_zlib

; 4433 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4434 :     a->zout_start = obuf;

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  00022	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4435 :     a->zout       = obuf;

  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  00030	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4436 :     a->zout_end   = obuf + olen;

  00034	48 63 44 24 40	 movsxd	 rax, DWORD PTR olen$[rsp]
  00039	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  0003e	48 03 c8	 add	 rcx, rax
  00041	48 8b c1	 mov	 rax, rcx
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00049	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4437 :     a->z_expandable = exp;

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00052	8b 4c 24 48	 mov	 ecx, DWORD PTR exp$[rsp]
  00056	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 4438 :     
; 4439 :     return stbi__parse_zlib(a, parse_header);

  00059	8b 54 24 50	 mov	 edx, DWORD PTR parse_header$[rsp]
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00062	e8 00 00 00 00	 call	 ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ; stbi__parse_zlib

; 4440 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ENDP	; stbi__do_zlib
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
type$ = 32
final$ = 36
a$ = 64
parse_header$ = 72
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z PROC		; stbi__parse_zlib

; 4405 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4406 :     int final, type;
; 4407 :     if (parse_header)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR parse_header$[rsp], 0
  00012	74 15		 je	 SHORT $LN5@stbi__pars

; 4408 :         if (!stbi__parse_zlib_header(a)) return 0;

  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00019	e8 00 00 00 00	 call	 ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_zlib_header
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN6@stbi__pars
  00022	33 c0		 xor	 eax, eax
  00024	e9 fa 00 00 00	 jmp	 $LN1@stbi__pars
$LN6@stbi__pars:
$LN5@stbi__pars:

; 4409 :     a->num_bits = 0;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 4410 :     a->code_buffer = 0;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0003a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN4@stbi__pars:

; 4411 :     do {
; 4412 :         final = stbi__zreceive(a,1);

  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00050	89 44 24 24	 mov	 DWORD PTR final$[rsp], eax

; 4413 :         type = stbi__zreceive(a,2);

  00054	ba 02 00 00 00	 mov	 edx, 2
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0005e	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00063	89 44 24 20	 mov	 DWORD PTR type$[rsp], eax

; 4414 :         if (type == 0) {

  00067	83 7c 24 20 00	 cmp	 DWORD PTR type$[rsp], 0
  0006c	75 1a		 jne	 SHORT $LN7@stbi__pars

; 4415 :             if (!stbi__parse_uncompressed_block(a)) return 0;

  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00073	e8 00 00 00 00	 call	 ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_uncompressed_block
  00078	85 c0		 test	 eax, eax
  0007a	75 07		 jne	 SHORT $LN9@stbi__pars
  0007c	33 c0		 xor	 eax, eax
  0007e	e9 a0 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:
  00083	e9 8b 00 00 00	 jmp	 $LN8@stbi__pars
$LN7@stbi__pars:

; 4416 :         } else if (type == 3) {

  00088	83 7c 24 20 03	 cmp	 DWORD PTR type$[rsp], 3
  0008d	75 09		 jne	 SHORT $LN10@stbi__pars

; 4417 :             return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 8d 00 00 00	 jmp	 $LN1@stbi__pars

; 4418 :         } else {

  00096	eb 7b		 jmp	 SHORT $LN11@stbi__pars
$LN10@stbi__pars:

; 4419 :             if (type == 1) {

  00098	83 7c 24 20 01	 cmp	 DWORD PTR type$[rsp], 1
  0009d	75 50		 jne	 SHORT $LN12@stbi__pars

; 4420 :                 // use fixed code lengths
; 4421 :                 if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000a4	48 83 c0 34	 add	 rax, 52			; 00000034H
  000a8	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__zdefault_length@@3QBEB
  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  000bd	85 c0		 test	 eax, eax
  000bf	75 04		 jne	 SHORT $LN14@stbi__pars
  000c1	33 c0		 xor	 eax, eax
  000c3	eb 5e		 jmp	 SHORT $LN1@stbi__pars
$LN14@stbi__pars:

; 4422 :                 if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;

  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000ca	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  000d0	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__zdefault_distance@@3QBEB
  000dd	48 8b c8	 mov	 rcx, rax
  000e0	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  000e5	85 c0		 test	 eax, eax
  000e7	75 04		 jne	 SHORT $LN15@stbi__pars
  000e9	33 c0		 xor	 eax, eax
  000eb	eb 36		 jmp	 SHORT $LN1@stbi__pars
$LN15@stbi__pars:

; 4423 :             } else {

  000ed	eb 12		 jmp	 SHORT $LN13@stbi__pars
$LN12@stbi__pars:

; 4424 :                 if (!stbi__compute_huffman_codes(a)) return 0;

  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ; stbi__compute_huffman_codes
  000f9	85 c0		 test	 eax, eax
  000fb	75 04		 jne	 SHORT $LN16@stbi__pars
  000fd	33 c0		 xor	 eax, eax
  000ff	eb 22		 jmp	 SHORT $LN1@stbi__pars
$LN16@stbi__pars:
$LN13@stbi__pars:

; 4425 :             }
; 4426 :             if (!stbi__parse_huffman_block(a)) return 0;

  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00106	e8 00 00 00 00	 call	 ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_huffman_block
  0010b	85 c0		 test	 eax, eax
  0010d	75 04		 jne	 SHORT $LN17@stbi__pars
  0010f	33 c0		 xor	 eax, eax
  00111	eb 10		 jmp	 SHORT $LN1@stbi__pars
$LN17@stbi__pars:
$LN11@stbi__pars:
$LN8@stbi__pars:

; 4427 :         }
; 4428 :     } while (!final);

  00113	83 7c 24 24 00	 cmp	 DWORD PTR final$[rsp], 0
  00118	0f 84 23 ff ff
	ff		 je	 $LN4@stbi__pars

; 4429 :     return 1;

  0011e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4430 : }

  00123	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00127	c3		 ret	 0
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ENDP		; stbi__parse_zlib
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
cmf$ = 32
flg$ = 36
cm$ = 40
a$ = 64
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_zlib_header

; 4362 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4363 :     int cmf   = stbi__zget8(a);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR cmf$[rsp], eax

; 4364 :     int cm    = cmf & 15;

  0001a	8b 44 24 20	 mov	 eax, DWORD PTR cmf$[rsp]
  0001e	83 e0 0f	 and	 eax, 15
  00021	89 44 24 28	 mov	 DWORD PTR cm$[rsp], eax

; 4365 :     /* int cinfo = cmf >> 4; */
; 4366 :     int flg   = stbi__zget8(a);

  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  0002f	0f b6 c0	 movzx	 eax, al
  00032	89 44 24 24	 mov	 DWORD PTR flg$[rsp], eax

; 4367 :     if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ; stbi__zeof
  00040	85 c0		 test	 eax, eax
  00042	74 0e		 je	 SHORT $LN2@stbi__pars
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38668
  0004b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00050	eb 5b		 jmp	 SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 4368 :     if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

  00052	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR cmf$[rsp], 256 ; 00000100H
  0005a	03 44 24 24	 add	 eax, DWORD PTR flg$[rsp]
  0005e	99		 cdq
  0005f	b9 1f 00 00 00	 mov	 ecx, 31
  00064	f7 f9		 idiv	 ecx
  00066	8b c2		 mov	 eax, edx
  00068	85 c0		 test	 eax, eax
  0006a	74 0e		 je	 SHORT $LN3@stbi__pars
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38670
  00073	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00078	eb 33		 jmp	 SHORT $LN1@stbi__pars
$LN3@stbi__pars:

; 4369 :     if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

  0007a	8b 44 24 24	 mov	 eax, DWORD PTR flg$[rsp]
  0007e	83 e0 20	 and	 eax, 32			; 00000020H
  00081	85 c0		 test	 eax, eax
  00083	74 0e		 je	 SHORT $LN4@stbi__pars
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38672
  0008c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00091	eb 1a		 jmp	 SHORT $LN1@stbi__pars
$LN4@stbi__pars:

; 4370 :     if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png

  00093	83 7c 24 28 08	 cmp	 DWORD PTR cm$[rsp], 8
  00098	74 0e		 je	 SHORT $LN5@stbi__pars
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38674
  000a1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a6	eb 05		 jmp	 SHORT $LN1@stbi__pars
$LN5@stbi__pars:

; 4371 :     // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4372 :     return 1;

  000a8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4373 : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_zlib_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
len$ = 36
header$ = 40
nlen$ = 44
a$ = 80
?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__parse_uncompressed_block

; 4333 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4334 :     stbi_uc header[4];
; 4335 :     int len,nlen,k;
; 4336 :     if (a->num_bits & 7)

  0000b	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00010	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00013	83 e0 07	 and	 eax, 7
  00016	85 c0		 test	 eax, eax
  00018	74 17		 je	 SHORT $LN6@stbi__pars

; 4337 :         stbi__zreceive(a, a->num_bits & 7); // discard

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0001f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00022	83 e0 07	 and	 eax, 7
  00025	8b d0		 mov	 edx, eax
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
$LN6@stbi__pars:

; 4338 :     // drain the bit-packed data into header
; 4339 :     k = 0;

  00031	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN2@stbi__pars:

; 4340 :     while (a->num_bits > 0) {

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0003e	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00042	7e 48		 jle	 SHORT $LN3@stbi__pars

; 4341 :         header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00049	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00051	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00056	88 44 0c 28	 mov	 BYTE PTR header$[rsp+rcx], al
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0005e	ff c0		 inc	 eax
  00060	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 4342 :         a->code_buffer >>= 8;

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00069	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0006c	c1 e8 08	 shr	 eax, 8
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00074	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4343 :         a->num_bits -= 8;

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0007c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007f	83 e8 08	 sub	 eax, 8
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00087	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4344 :     }

  0008a	eb ad		 jmp	 SHORT $LN2@stbi__pars
$LN3@stbi__pars:

; 4345 :     if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00091	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00095	7d 11		 jge	 SHORT $LN7@stbi__pars
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38654
  0009e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a3	e9 44 01 00 00	 jmp	 $LN1@stbi__pars
$LN7@stbi__pars:
$LN4@stbi__pars:

; 4346 :     // now fill header the normal way
; 4347 :     while (k < 4)

  000a8	83 7c 24 20 04	 cmp	 DWORD PTR k$[rsp], 4
  000ad	7d 1f		 jge	 SHORT $LN5@stbi__pars

; 4348 :         header[k++] = stbi__zget8(a);

  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000b4	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  000b9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  000be	88 44 0c 28	 mov	 BYTE PTR header$[rsp+rcx], al
  000c2	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  000cc	eb da		 jmp	 SHORT $LN4@stbi__pars
$LN5@stbi__pars:

; 4349 :     len  = header[1] * 256 + header[0];

  000ce	b8 01 00 00 00	 mov	 eax, 1
  000d3	48 6b c0 01	 imul	 rax, rax, 1
  000d7	0f b6 44 04 28	 movzx	 eax, BYTE PTR header$[rsp+rax]
  000dc	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  000e2	b9 01 00 00 00	 mov	 ecx, 1
  000e7	48 6b c9 00	 imul	 rcx, rcx, 0
  000eb	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR header$[rsp+rcx]
  000f0	03 c1		 add	 eax, ecx
  000f2	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 4350 :     nlen = header[3] * 256 + header[2];

  000f6	b8 01 00 00 00	 mov	 eax, 1
  000fb	48 6b c0 03	 imul	 rax, rax, 3
  000ff	0f b6 44 04 28	 movzx	 eax, BYTE PTR header$[rsp+rax]
  00104	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  0010a	b9 01 00 00 00	 mov	 ecx, 1
  0010f	48 6b c9 02	 imul	 rcx, rcx, 2
  00113	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR header$[rsp+rcx]
  00118	03 c1		 add	 eax, ecx
  0011a	89 44 24 2c	 mov	 DWORD PTR nlen$[rsp], eax

; 4351 :     if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");

  0011e	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00122	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00127	39 44 24 2c	 cmp	 DWORD PTR nlen$[rsp], eax
  0012b	74 11		 je	 SHORT $LN8@stbi__pars
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38656
  00134	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00139	e9 ae 00 00 00	 jmp	 $LN1@stbi__pars
$LN8@stbi__pars:

; 4352 :     if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");

  0013e	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00148	48 03 01	 add	 rax, QWORD PTR [rcx]
  0014b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00150	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  00154	76 11		 jbe	 SHORT $LN9@stbi__pars
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38658
  0015d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00162	e9 85 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:

; 4353 :     if (a->zout + len > a->zout_end)

  00167	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  0016c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00171	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00175	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0017a	48 3b 41 28	 cmp	 rax, QWORD PTR [rcx+40]
  0017e	76 20		 jbe	 SHORT $LN10@stbi__pars

; 4354 :         if (!stbi__zexpand(a, a->zout, len)) return 0;

  00180	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  00185	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0018a	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0018e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00193	e8 00 00 00 00	 call	 ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
  00198	85 c0		 test	 eax, eax
  0019a	75 04		 jne	 SHORT $LN11@stbi__pars
  0019c	33 c0		 xor	 eax, eax
  0019e	eb 4c		 jmp	 SHORT $LN1@stbi__pars
$LN11@stbi__pars:
$LN10@stbi__pars:

; 4355 :     memcpy(a->zout, a->zbuffer, len);

  001a0	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001aa	48 8b 54 24 50	 mov	 rdx, QWORD PTR a$[rsp]
  001af	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  001b3	48 8b 32	 mov	 rsi, QWORD PTR [rdx]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 4356 :     a->zbuffer += len;

  001bb	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001c5	48 03 01	 add	 rax, QWORD PTR [rcx]
  001c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001cd	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4357 :     a->zout += len;

  001d0	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  001d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001da	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  001de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001e3	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4358 :     return 1;

  001e7	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4359 : }

  001ec	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001f0	5f		 pop	 rdi
  001f1	5e		 pop	 rsi
  001f2	c3		 ret	 0
?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__parse_uncompressed_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
c$1 = 32
fill$2 = 36
n$ = 40
i$ = 44
ntot$ = 48
hlit$ = 52
hdist$ = 56
hclen$ = 60
s$3 = 64
tv172 = 72
z_codelength$ = 80
codelength_sizes$ = 2112
lencodes$ = 2144
__$ArrayPad$ = 2608
a$ = 2640
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__compute_huffman_codes

; 4283 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 40 0a
	00 00		 sub	 rsp, 2624		; 00000a40H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 30
	0a 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4284 :     static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4285 :     stbi__zhuffman z_codelength;
; 4286 :     stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4287 :     stbi_uc codelength_sizes[19];
; 4288 :     int i,n;
; 4289 :     
; 4290 :     int hlit  = stbi__zreceive(a,5) + 257;

  0001f	ba 05 00 00 00	 mov	 edx, 5
  00024	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00031	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00036	89 44 24 34	 mov	 DWORD PTR hlit$[rsp], eax

; 4291 :     int hdist = stbi__zreceive(a,5) + 1;

  0003a	ba 05 00 00 00	 mov	 edx, 5
  0003f	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00047	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 38	 mov	 DWORD PTR hdist$[rsp], eax

; 4292 :     int hclen = stbi__zreceive(a,4) + 4;

  00052	ba 04 00 00 00	 mov	 edx, 4
  00057	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0005f	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00064	83 c0 04	 add	 eax, 4
  00067	89 44 24 3c	 mov	 DWORD PTR hclen$[rsp], eax

; 4293 :     int ntot  = hlit + hdist;

  0006b	8b 44 24 38	 mov	 eax, DWORD PTR hdist$[rsp]
  0006f	8b 4c 24 34	 mov	 ecx, DWORD PTR hlit$[rsp]
  00073	03 c8		 add	 ecx, eax
  00075	8b c1		 mov	 eax, ecx
  00077	89 44 24 30	 mov	 DWORD PTR ntot$[rsp], eax

; 4294 :     
; 4295 :     memset(codelength_sizes, 0, sizeof(codelength_sizes));

  0007b	48 8d 84 24 40
	08 00 00	 lea	 rax, QWORD PTR codelength_sizes$[rsp]
  00083	48 8b f8	 mov	 rdi, rax
  00086	33 c0		 xor	 eax, eax
  00088	b9 13 00 00 00	 mov	 ecx, 19
  0008d	f3 aa		 rep stosb

; 4296 :     for (i=0; i < hclen; ++i) {

  0008f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00097	eb 0a		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  00099	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  000a3	8b 44 24 3c	 mov	 eax, DWORD PTR hclen$[rsp]
  000a7	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  000ab	7d 34		 jge	 SHORT $LN3@stbi__comp

; 4297 :         int s = stbi__zreceive(a,3);

  000ad	ba 03 00 00 00	 mov	 edx, 3
  000b2	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000ba	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  000bf	89 44 24 40	 mov	 DWORD PTR s$3[rsp], eax

; 4298 :         codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;

  000c3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$[rsp]
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB
  000cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d3	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR s$3[rsp]
  000d8	88 8c 04 40 08
	00 00		 mov	 BYTE PTR codelength_sizes$[rsp+rax], cl

; 4299 :     }

  000df	eb b8		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4300 :     if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

  000e1	41 b8 13 00 00
	00		 mov	 r8d, 19
  000e7	48 8d 94 24 40
	08 00 00	 lea	 rdx, QWORD PTR codelength_sizes$[rsp]
  000ef	48 8d 4c 24 50	 lea	 rcx, QWORD PTR z_codelength$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  000f9	85 c0		 test	 eax, eax
  000fb	75 07		 jne	 SHORT $LN7@stbi__comp
  000fd	33 c0		 xor	 eax, eax
  000ff	e9 f5 01 00 00	 jmp	 $LN1@stbi__comp
$LN7@stbi__comp:

; 4301 :     
; 4302 :     n = 0;

  00104	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
$LN5@stbi__comp:

; 4303 :     while (n < ntot) {

  0010c	8b 44 24 30	 mov	 eax, DWORD PTR ntot$[rsp]
  00110	39 44 24 28	 cmp	 DWORD PTR n$[rsp], eax
  00114	0f 8d 68 01 00
	00		 jge	 $LN6@stbi__comp

; 4304 :         int c = stbi__zhuffman_decode(a, &z_codelength);

  0011a	48 8d 54 24 50	 lea	 rdx, QWORD PTR z_codelength$[rsp]
  0011f	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00127	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
  0012c	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax

; 4305 :         if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

  00130	83 7c 24 20 00	 cmp	 DWORD PTR c$1[rsp], 0
  00135	7c 07		 jl	 SHORT $LN9@stbi__comp
  00137	83 7c 24 20 13	 cmp	 DWORD PTR c$1[rsp], 19
  0013c	7c 11		 jl	 SHORT $LN8@stbi__comp
$LN9@stbi__comp:
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38622
  00145	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014a	e9 aa 01 00 00	 jmp	 $LN1@stbi__comp
$LN8@stbi__comp:

; 4306 :         if (c < 16)

  0014f	83 7c 24 20 10	 cmp	 DWORD PTR c$1[rsp], 16
  00154	7d 20		 jge	 SHORT $LN10@stbi__comp

; 4307 :             lencodes[n++] = (stbi_uc) c;

  00156	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$[rsp]
  0015b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$1[rsp]
  00160	88 8c 04 60 08
	00 00		 mov	 BYTE PTR lencodes$[rsp+rax], cl
  00167	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0016b	ff c0		 inc	 eax
  0016d	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  00171	e9 07 01 00 00	 jmp	 $LN11@stbi__comp
$LN10@stbi__comp:

; 4308 :         else {
; 4309 :             stbi_uc fill = 0;

  00176	c6 44 24 24 00	 mov	 BYTE PTR fill$2[rsp], 0

; 4310 :             if (c == 16) {

  0017b	83 7c 24 20 10	 cmp	 DWORD PTR c$1[rsp], 16
  00180	75 47		 jne	 SHORT $LN12@stbi__comp

; 4311 :                 c = stbi__zreceive(a,2)+3;

  00182	ba 02 00 00 00	 mov	 edx, 2
  00187	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0018f	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00194	83 c0 03	 add	 eax, 3
  00197	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax

; 4312 :                 if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

  0019b	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  001a0	75 11		 jne	 SHORT $LN14@stbi__comp
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38628
  001a9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001ae	e9 46 01 00 00	 jmp	 $LN1@stbi__comp
$LN14@stbi__comp:

; 4313 :                 fill = lencodes[n-1];

  001b3	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  001b7	ff c8		 dec	 eax
  001b9	48 98		 cdqe
  001bb	0f b6 84 04 60
	08 00 00	 movzx	 eax, BYTE PTR lencodes$[rsp+rax]
  001c3	88 44 24 24	 mov	 BYTE PTR fill$2[rsp], al
  001c7	eb 55		 jmp	 SHORT $LN13@stbi__comp
$LN12@stbi__comp:

; 4314 :             } else if (c == 17) {

  001c9	83 7c 24 20 11	 cmp	 DWORD PTR c$1[rsp], 17
  001ce	75 1b		 jne	 SHORT $LN15@stbi__comp

; 4315 :                 c = stbi__zreceive(a,3)+3;

  001d0	ba 03 00 00 00	 mov	 edx, 3
  001d5	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001dd	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  001e2	83 c0 03	 add	 eax, 3
  001e5	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax
  001e9	eb 33		 jmp	 SHORT $LN16@stbi__comp
$LN15@stbi__comp:

; 4316 :             } else if (c == 18) {

  001eb	83 7c 24 20 12	 cmp	 DWORD PTR c$1[rsp], 18
  001f0	75 1b		 jne	 SHORT $LN17@stbi__comp

; 4317 :                 c = stbi__zreceive(a,7)+11;

  001f2	ba 07 00 00 00	 mov	 edx, 7
  001f7	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001ff	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00204	83 c0 0b	 add	 eax, 11
  00207	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax

; 4318 :             } else {

  0020b	eb 11		 jmp	 SHORT $LN18@stbi__comp
$LN17@stbi__comp:

; 4319 :                 return stbi__err("bad codelengths", "Corrupt PNG");

  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38633
  00214	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00219	e9 db 00 00 00	 jmp	 $LN1@stbi__comp
$LN18@stbi__comp:
$LN16@stbi__comp:
$LN13@stbi__comp:

; 4320 :             }
; 4321 :             if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

  0021e	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00222	8b 4c 24 30	 mov	 ecx, DWORD PTR ntot$[rsp]
  00226	2b c8		 sub	 ecx, eax
  00228	8b c1		 mov	 eax, ecx
  0022a	3b 44 24 20	 cmp	 eax, DWORD PTR c$1[rsp]
  0022e	7d 11		 jge	 SHORT $LN19@stbi__comp
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38635
  00237	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0023c	e9 b8 00 00 00	 jmp	 $LN1@stbi__comp
$LN19@stbi__comp:

; 4322 :             memset(lencodes+n, fill, c);

  00241	48 63 44 24 20	 movsxd	 rax, DWORD PTR c$1[rsp]
  00246	48 89 44 24 48	 mov	 QWORD PTR tv172[rsp], rax
  0024b	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR fill$2[rsp]
  00250	48 63 54 24 28	 movsxd	 rdx, DWORD PTR n$[rsp]
  00255	48 8d 94 14 60
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rsp+rdx]
  0025d	48 63 c9	 movsxd	 rcx, ecx
  00260	48 8b fa	 mov	 rdi, rdx
  00263	48 8b c1	 mov	 rax, rcx
  00266	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv172[rsp]
  0026b	f3 aa		 rep stosb

; 4323 :             n += c;

  0026d	8b 44 24 20	 mov	 eax, DWORD PTR c$1[rsp]
  00271	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00275	03 c8		 add	 ecx, eax
  00277	8b c1		 mov	 eax, ecx
  00279	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
$LN11@stbi__comp:

; 4324 :         }
; 4325 :     }

  0027d	e9 8a fe ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:

; 4326 :     if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");

  00282	8b 44 24 30	 mov	 eax, DWORD PTR ntot$[rsp]
  00286	39 44 24 28	 cmp	 DWORD PTR n$[rsp], eax
  0028a	74 0e		 je	 SHORT $LN20@stbi__comp
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38637
  00293	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00298	eb 5f		 jmp	 SHORT $LN1@stbi__comp
$LN20@stbi__comp:

; 4327 :     if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

  0029a	48 8b 84 24 50
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002a2	48 83 c0 34	 add	 rax, 52			; 00000034H
  002a6	44 8b 44 24 34	 mov	 r8d, DWORD PTR hlit$[rsp]
  002ab	48 8d 94 24 60
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rsp]
  002b3	48 8b c8	 mov	 rcx, rax
  002b6	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  002bb	85 c0		 test	 eax, eax
  002bd	75 04		 jne	 SHORT $LN21@stbi__comp
  002bf	33 c0		 xor	 eax, eax
  002c1	eb 36		 jmp	 SHORT $LN1@stbi__comp
$LN21@stbi__comp:

; 4328 :     if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;

  002c3	48 63 44 24 34	 movsxd	 rax, DWORD PTR hlit$[rsp]
  002c8	48 8d 84 04 60
	08 00 00	 lea	 rax, QWORD PTR lencodes$[rsp+rax]
  002d0	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002d8	48 81 c1 18 08
	00 00		 add	 rcx, 2072		; 00000818H
  002df	44 8b 44 24 38	 mov	 r8d, DWORD PTR hdist$[rsp]
  002e4	48 8b d0	 mov	 rdx, rax
  002e7	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  002ec	85 c0		 test	 eax, eax
  002ee	75 04		 jne	 SHORT $LN22@stbi__comp
  002f0	33 c0		 xor	 eax, eax
  002f2	eb 05		 jmp	 SHORT $LN1@stbi__comp
$LN22@stbi__comp:

; 4329 :     return 1;

  002f4	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__comp:

; 4330 : }

  002f9	48 8b 8c 24 30
	0a 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00301	48 33 cc	 xor	 rcx, rsp
  00304	e8 00 00 00 00	 call	 __security_check_cookie
  00309	48 81 c4 40 0a
	00 00		 add	 rsp, 2624		; 00000a40H
  00310	5f		 pop	 rdi
  00311	c3		 ret	 0
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__compute_huffman_codes
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
v$1 = 32
z$2 = 36
len$3 = 40
dist$4 = 44
zout$ = 48
p$5 = 56
a$ = 80
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_huffman_block

; 4241 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4242 :     char *zout = a->zout;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0000e	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00012	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
$LN2@stbi__pars:

; 4243 :     for(;;) {
; 4244 :         int z = stbi__zhuffman_decode(a, &a->z_length);

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0001c	48 83 c0 34	 add	 rax, 52			; 00000034H
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00028	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
  0002d	89 44 24 24	 mov	 DWORD PTR z$2[rsp], eax

; 4245 :         if (z < 256) {

  00031	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR z$2[rsp], 256	; 00000100H
  00039	7d 74		 jge	 SHORT $LN11@stbi__pars

; 4246 :             if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes

  0003b	83 7c 24 24 00	 cmp	 DWORD PTR z$2[rsp], 0
  00040	7d 11		 jge	 SHORT $LN13@stbi__pars
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38579
  00049	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0004e	e9 6b 02 00 00	 jmp	 $LN1@stbi__pars
$LN13@stbi__pars:

; 4247 :             if (zout >= a->zout_end) {

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00058	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005c	48 39 44 24 30	 cmp	 QWORD PTR zout$[rsp], rax
  00061	72 2e		 jb	 SHORT $LN14@stbi__pars

; 4248 :                 if (!stbi__zexpand(a, zout, 1)) return 0;

  00063	41 b8 01 00 00
	00		 mov	 r8d, 1
  00069	48 8b 54 24 30	 mov	 rdx, QWORD PTR zout$[rsp]
  0006e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00073	e8 00 00 00 00	 call	 ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
  00078	85 c0		 test	 eax, eax
  0007a	75 07		 jne	 SHORT $LN15@stbi__pars
  0007c	33 c0		 xor	 eax, eax
  0007e	e9 3b 02 00 00	 jmp	 $LN1@stbi__pars
$LN15@stbi__pars:

; 4249 :                 zout = a->zout;

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00088	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008c	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
$LN14@stbi__pars:

; 4250 :             }
; 4251 :             *zout++ = (char) z;

  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  00096	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR z$2[rsp]
  0009b	88 08		 mov	 BYTE PTR [rax], cl
  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  000a2	48 ff c0	 inc	 rax
  000a5	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax

; 4252 :         } else {

  000aa	e9 0a 02 00 00	 jmp	 $LN12@stbi__pars
$LN11@stbi__pars:

; 4253 :             stbi_uc *p;
; 4254 :             int len,dist;
; 4255 :             if (z == 256) {

  000af	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR z$2[rsp], 256	; 00000100H
  000b7	75 18		 jne	 SHORT $LN16@stbi__pars

; 4256 :                 a->zout = zout;

  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  000c3	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4257 :                 return 1;

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	e9 ed 01 00 00	 jmp	 $LN1@stbi__pars
$LN16@stbi__pars:

; 4258 :             }
; 4259 :             z -= 257;

  000d1	8b 44 24 24	 mov	 eax, DWORD PTR z$2[rsp]
  000d5	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  000da	89 44 24 24	 mov	 DWORD PTR z$2[rsp], eax

; 4260 :             len = stbi__zlength_base[z];

  000de	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zlength_base@@3QBHB
  000ea	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000ed	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax

; 4261 :             if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

  000f1	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zlength_extra@@3QBHB
  000fd	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00101	74 25		 je	 SHORT $LN17@stbi__pars
  00103	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zlength_extra@@3QBHB
  0010f	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  00112	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00117	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0011c	8b 4c 24 28	 mov	 ecx, DWORD PTR len$3[rsp]
  00120	03 c8		 add	 ecx, eax
  00122	8b c1		 mov	 eax, ecx
  00124	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
$LN17@stbi__pars:

; 4262 :             z = stbi__zhuffman_decode(a, &a->z_distance);

  00128	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0012d	48 05 18 08 00
	00		 add	 rax, 2072		; 00000818H
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0013b	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
  00140	89 44 24 24	 mov	 DWORD PTR z$2[rsp], eax

; 4263 :             if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");

  00144	83 7c 24 24 00	 cmp	 DWORD PTR z$2[rsp], 0
  00149	7d 11		 jge	 SHORT $LN18@stbi__pars
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38585
  00152	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00157	e9 62 01 00 00	 jmp	 $LN1@stbi__pars
$LN18@stbi__pars:

; 4264 :             dist = stbi__zdist_base[z];

  0015c	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zdist_base@@3QBHB
  00168	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0016b	89 44 24 2c	 mov	 DWORD PTR dist$4[rsp], eax

; 4265 :             if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

  0016f	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zdist_extra@@3QBHB
  0017b	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  0017f	74 25		 je	 SHORT $LN19@stbi__pars
  00181	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zdist_extra@@3QBHB
  0018d	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  00190	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00195	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0019a	8b 4c 24 2c	 mov	 ecx, DWORD PTR dist$4[rsp]
  0019e	03 c8		 add	 ecx, eax
  001a0	8b c1		 mov	 eax, ecx
  001a2	89 44 24 2c	 mov	 DWORD PTR dist$4[rsp], eax
$LN19@stbi__pars:

; 4266 :             if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");

  001a6	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  001ab	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  001b4	48 2b c8	 sub	 rcx, rax
  001b7	48 8b c1	 mov	 rax, rcx
  001ba	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR dist$4[rsp]
  001bf	48 3b c1	 cmp	 rax, rcx
  001c2	7d 11		 jge	 SHORT $LN20@stbi__pars
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38588
  001cb	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001d0	e9 e9 00 00 00	 jmp	 $LN1@stbi__pars
$LN20@stbi__pars:

; 4267 :             if (zout + len > a->zout_end) {

  001d5	48 63 44 24 28	 movsxd	 rax, DWORD PTR len$3[rsp]
  001da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  001df	48 03 c8	 add	 rcx, rax
  001e2	48 8b c1	 mov	 rax, rcx
  001e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001ea	48 3b 41 28	 cmp	 rax, QWORD PTR [rcx+40]
  001ee	76 2d		 jbe	 SHORT $LN21@stbi__pars

; 4268 :                 if (!stbi__zexpand(a, zout, len)) return 0;

  001f0	44 8b 44 24 28	 mov	 r8d, DWORD PTR len$3[rsp]
  001f5	48 8b 54 24 30	 mov	 rdx, QWORD PTR zout$[rsp]
  001fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001ff	e8 00 00 00 00	 call	 ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
  00204	85 c0		 test	 eax, eax
  00206	75 07		 jne	 SHORT $LN22@stbi__pars
  00208	33 c0		 xor	 eax, eax
  0020a	e9 af 00 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:

; 4269 :                 zout = a->zout;

  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00214	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00218	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
$LN21@stbi__pars:

; 4270 :             }
; 4271 :             p = (stbi_uc *) (zout - dist);

  0021d	48 63 44 24 2c	 movsxd	 rax, DWORD PTR dist$4[rsp]
  00222	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  00227	48 2b c8	 sub	 rcx, rax
  0022a	48 8b c1	 mov	 rax, rcx
  0022d	48 89 44 24 38	 mov	 QWORD PTR p$5[rsp], rax

; 4272 :             if (dist == 1) { // run of one byte; common in images.

  00232	83 7c 24 2c 01	 cmp	 DWORD PTR dist$4[rsp], 1
  00237	75 3f		 jne	 SHORT $LN23@stbi__pars

; 4273 :                 stbi_uc v = *p;

  00239	48 8b 44 24 38	 mov	 rax, QWORD PTR p$5[rsp]
  0023e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00241	88 44 24 20	 mov	 BYTE PTR v$1[rsp], al

; 4274 :                 if (len) { do *zout++ = v; while (--len); }

  00245	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  0024a	74 2a		 je	 SHORT $LN25@stbi__pars
$LN7@stbi__pars:
  0024c	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  00251	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR v$1[rsp]
  00256	88 08		 mov	 BYTE PTR [rax], cl
  00258	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  0025d	48 ff c0	 inc	 rax
  00260	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
  00265	8b 44 24 28	 mov	 eax, DWORD PTR len$3[rsp]
  00269	ff c8		 dec	 eax
  0026b	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
  0026f	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  00274	75 d6		 jne	 SHORT $LN7@stbi__pars
$LN25@stbi__pars:

; 4275 :             } else {

  00276	eb 41		 jmp	 SHORT $LN24@stbi__pars
$LN23@stbi__pars:

; 4276 :                 if (len) { do *zout++ = *p++; while (--len); }

  00278	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  0027d	74 3a		 je	 SHORT $LN26@stbi__pars
$LN10@stbi__pars:
  0027f	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  00284	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$5[rsp]
  00289	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0028c	88 08		 mov	 BYTE PTR [rax], cl
  0028e	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  00293	48 ff c0	 inc	 rax
  00296	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
  0029b	48 8b 44 24 38	 mov	 rax, QWORD PTR p$5[rsp]
  002a0	48 ff c0	 inc	 rax
  002a3	48 89 44 24 38	 mov	 QWORD PTR p$5[rsp], rax
  002a8	8b 44 24 28	 mov	 eax, DWORD PTR len$3[rsp]
  002ac	ff c8		 dec	 eax
  002ae	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
  002b2	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  002b7	75 c6		 jne	 SHORT $LN10@stbi__pars
$LN26@stbi__pars:
$LN24@stbi__pars:
$LN12@stbi__pars:

; 4277 :             }
; 4278 :         }
; 4279 :     }

  002b9	e9 59 fd ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 4280 : }

  002be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002c2	c3		 ret	 0
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_huffman_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
limit$ = 32
cur$ = 36
old_limit$ = 40
q$ = 48
z$ = 80
zout$ = 88
n$ = 96
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z PROC		; stbi__zexpand

; 4205 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4206 :     char *q;
; 4207 :     unsigned int cur, limit, old_limit;
; 4208 :     z->zout = zout;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR zout$[rsp]
  0001d	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4209 :     if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00026	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0002a	75 11		 jne	 SHORT $LN4@stbi__zexp
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38545
  00033	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00038	e9 02 01 00 00	 jmp	 $LN1@stbi__zexp
$LN4@stbi__zexp:

; 4210 :     cur   = (unsigned int) (z->zout - z->zout_start);

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00047	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0004b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004f	48 2b c1	 sub	 rax, rcx
  00052	89 44 24 24	 mov	 DWORD PTR cur$[rsp], eax

; 4211 :     limit = old_limit = (unsigned) (z->zout_end - z->zout_start);

  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00060	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00064	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00068	48 2b c1	 sub	 rax, rcx
  0006b	89 44 24 28	 mov	 DWORD PTR old_limit$[rsp], eax
  0006f	8b 44 24 28	 mov	 eax, DWORD PTR old_limit$[rsp]
  00073	89 44 24 20	 mov	 DWORD PTR limit$[rsp], eax

; 4212 :     if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");

  00077	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0007c	2b 44 24 24	 sub	 eax, DWORD PTR cur$[rsp]
  00080	3b 44 24 60	 cmp	 eax, DWORD PTR n$[rsp]
  00084	73 11		 jae	 SHORT $LN5@stbi__zexp
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38547
  0008d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00092	e9 a8 00 00 00	 jmp	 $LN1@stbi__zexp
$LN5@stbi__zexp:
$LN2@stbi__zexp:

; 4213 :     while (cur + n > limit) {

  00097	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  0009b	8b 4c 24 24	 mov	 ecx, DWORD PTR cur$[rsp]
  0009f	03 c8		 add	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	3b 44 24 20	 cmp	 eax, DWORD PTR limit$[rsp]
  000a7	76 24		 jbe	 SHORT $LN3@stbi__zexp

; 4214 :         if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");

  000a9	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR limit$[rsp], 2147483647 ; 7fffffffH
  000b1	76 0e		 jbe	 SHORT $LN6@stbi__zexp
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38549
  000ba	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000bf	eb 7e		 jmp	 SHORT $LN1@stbi__zexp
$LN6@stbi__zexp:

; 4215 :         limit *= 2;

  000c1	8b 44 24 20	 mov	 eax, DWORD PTR limit$[rsp]
  000c5	d1 e0		 shl	 eax, 1
  000c7	89 44 24 20	 mov	 DWORD PTR limit$[rsp], eax

; 4216 :     }

  000cb	eb ca		 jmp	 SHORT $LN2@stbi__zexp
$LN3@stbi__zexp:

; 4217 :     q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

  000cd	8b 44 24 20	 mov	 eax, DWORD PTR limit$[rsp]
  000d1	8b d0		 mov	 edx, eax
  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000d8	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000dc	e8 00 00 00 00	 call	 realloc
  000e1	48 89 44 24 30	 mov	 QWORD PTR q$[rsp], rax

; 4218 :     STBI_NOTUSED(old_limit);
; 4219 :     if (q == NULL) return stbi__err("outofmem", "Out of memory");

  000e6	48 83 7c 24 30
	00		 cmp	 QWORD PTR q$[rsp], 0
  000ec	75 0e		 jne	 SHORT $LN7@stbi__zexp
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38551
  000f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000fa	eb 43		 jmp	 SHORT $LN1@stbi__zexp
$LN7@stbi__zexp:

; 4220 :     z->zout_start = q;

  000fc	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00101	48 8b 4c 24 30	 mov	 rcx, QWORD PTR q$[rsp]
  00106	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4221 :     z->zout       = q + cur;

  0010a	8b 44 24 24	 mov	 eax, DWORD PTR cur$[rsp]
  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR q$[rsp]
  00113	48 03 c8	 add	 rcx, rax
  00116	48 8b c1	 mov	 rax, rcx
  00119	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0011e	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4222 :     z->zout_end   = q + limit;

  00122	8b 44 24 20	 mov	 eax, DWORD PTR limit$[rsp]
  00126	48 8b 4c 24 30	 mov	 rcx, QWORD PTR q$[rsp]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00136	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 4223 :     return 1;

  0013a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zexp:

; 4224 : }

  0013f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00143	c3		 ret	 0
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ENDP		; stbi__zexpand
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
b$ = 32
s$ = 36
tv132 = 40
a$ = 64
z$ = 72
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode

; 4186 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4187 :     int b,s;
; 4188 :     if (a->num_bits < 16) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00017	7d 22		 jge	 SHORT $LN2@stbi__zhuf

; 4189 :         if (stbi__zeof(a)) {

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ; stbi__zeof
  00023	85 c0		 test	 eax, eax
  00025	74 0a		 je	 SHORT $LN3@stbi__zhuf

; 4190 :             return -1;   /* report error for unexpected end of data. */

  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	e9 8b 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN3@stbi__zhuf:

; 4191 :         }
; 4192 :         stbi__fill_bits(a);

  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00036	e8 00 00 00 00	 call	 ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ; stbi__fill_bits
$LN2@stbi__zhuf:

; 4193 :     }
; 4194 :     b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00040	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00043	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00048	8b c0		 mov	 eax, eax
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR z$[rsp]
  0004f	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00053	89 44 24 20	 mov	 DWORD PTR b$[rsp], eax

; 4195 :     if (b) {

  00057	83 7c 24 20 00	 cmp	 DWORD PTR b$[rsp], 0
  0005c	74 4f		 je	 SHORT $LN4@stbi__zhuf

; 4196 :         s = b >> 9;

  0005e	8b 44 24 20	 mov	 eax, DWORD PTR b$[rsp]
  00062	c1 f8 09	 sar	 eax, 9
  00065	89 44 24 24	 mov	 DWORD PTR s$[rsp], eax

; 4197 :         a->code_buffer >>= s;

  00069	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00072	48 89 4c 24 28	 mov	 QWORD PTR tv132[rsp], rcx
  00077	0f b6 c8	 movzx	 ecx, al
  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR tv132[rsp]
  0007f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00082	d3 e8		 shr	 eax, cl
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00089	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4198 :         a->num_bits -= s;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00091	8b 4c 24 24	 mov	 ecx, DWORD PTR s$[rsp]
  00095	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00098	2b c1		 sub	 eax, ecx
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0009f	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4199 :         return b & 511;

  000a2	8b 44 24 20	 mov	 eax, DWORD PTR b$[rsp]
  000a6	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000ab	eb 0f		 jmp	 SHORT $LN1@stbi__zhuf
$LN4@stbi__zhuf:

; 4200 :     }
; 4201 :     return stbi__zhuffman_decode_slowpath(a, z);

  000ad	48 8b 54 24 48	 mov	 rdx, QWORD PTR z$[rsp]
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000b7	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
$LN1@stbi__zhuf:

; 4202 : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	c3		 ret	 0
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
b$ = 36
k$ = 40
tv158 = 48
a$ = 80
z$ = 88
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode_slowpath

; 4167 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4168 :     int b,s,k;
; 4169 :     // not resolved by fast table, so compute it the slow way
; 4170 :     // use jpeg approach, which requires MSbits at top
; 4171 :     k = stbi__bit_reverse(a->code_buffer, 16);

  0000e	ba 10 00 00 00	 mov	 edx, 16
  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00018	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  0001b	e8 00 00 00 00	 call	 ?stbi__bit_reverse@@YAHHH@Z ; stbi__bit_reverse
  00020	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 4172 :     for (s=STBI__ZFAST_BITS+1; ; ++s)

  00024	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR s$[rsp], 10
  0002c	eb 0a		 jmp	 SHORT $LN4@stbi__zhuf
$LN2@stbi__zhuf:
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR s$[rsp]
  00032	ff c0		 inc	 eax
  00034	89 44 24 20	 mov	 DWORD PTR s$[rsp], eax
$LN4@stbi__zhuf:

; 4173 :         if (k < z->maxcode[s])

  00038	48 63 44 24 20	 movsxd	 rax, DWORD PTR s$[rsp]
  0003d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  00042	8b 84 81 20 04
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1056]
  00049	39 44 24 28	 cmp	 DWORD PTR k$[rsp], eax
  0004d	7d 02		 jge	 SHORT $LN5@stbi__zhuf

; 4174 :         break;

  0004f	eb 02		 jmp	 SHORT $LN3@stbi__zhuf
$LN5@stbi__zhuf:
  00051	eb db		 jmp	 SHORT $LN2@stbi__zhuf
$LN3@stbi__zhuf:

; 4175 :     if (s >= 16) return -1; // invalid code!

  00053	83 7c 24 20 10	 cmp	 DWORD PTR s$[rsp], 16
  00058	7c 0a		 jl	 SHORT $LN6@stbi__zhuf
  0005a	b8 ff ff ff ff	 mov	 eax, -1
  0005f	e9 b9 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 4176 :     // code size is s, so:
; 4177 :     b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];

  00064	b8 10 00 00 00	 mov	 eax, 16
  00069	2b 44 24 20	 sub	 eax, DWORD PTR s$[rsp]
  0006d	0f b6 c8	 movzx	 ecx, al
  00070	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00074	d3 f8		 sar	 eax, cl
  00076	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR s$[rsp]
  0007b	48 8b 54 24 58	 mov	 rdx, QWORD PTR z$[rsp]
  00080	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  00088	2b c1		 sub	 eax, ecx
  0008a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR s$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR z$[rsp]
  00094	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  0009c	03 c1		 add	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR b$[rsp], eax

; 4178 :     if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!

  000a2	81 7c 24 24 20
	01 00 00	 cmp	 DWORD PTR b$[rsp], 288	; 00000120H
  000aa	7c 07		 jl	 SHORT $LN7@stbi__zhuf
  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 6a		 jmp	 SHORT $LN1@stbi__zhuf
$LN7@stbi__zhuf:

; 4179 :     if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.

  000b3	48 63 44 24 24	 movsxd	 rax, DWORD PTR b$[rsp]
  000b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  000bd	0f b6 84 01 84
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1156]
  000c5	3b 44 24 20	 cmp	 eax, DWORD PTR s$[rsp]
  000c9	74 07		 je	 SHORT $LN8@stbi__zhuf
  000cb	b8 ff ff ff ff	 mov	 eax, -1
  000d0	eb 4b		 jmp	 SHORT $LN1@stbi__zhuf
$LN8@stbi__zhuf:

; 4180 :     a->code_buffer >>= s;

  000d2	8b 44 24 20	 mov	 eax, DWORD PTR s$[rsp]
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000db	48 89 4c 24 30	 mov	 QWORD PTR tv158[rsp], rcx
  000e0	0f b6 c8	 movzx	 ecx, al
  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv158[rsp]
  000e8	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000eb	d3 e8		 shr	 eax, cl
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000f2	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4181 :     a->num_bits -= s;

  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000fa	8b 4c 24 20	 mov	 ecx, DWORD PTR s$[rsp]
  000fe	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00101	2b c1		 sub	 eax, ecx
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00108	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4182 :     return z->value[b];

  0010b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b$[rsp]
  00110	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  00115	0f b7 84 41 a4
	05 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+1444]
$LN1@stbi__zhuf:

; 4183 : }

  0011d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00121	c3		 ret	 0
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode_slowpath
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv83 = 32
k$ = 36
tv89 = 40
z$ = 64
n$ = 72
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z PROC		; stbi__zreceive

; 4157 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4158 :     unsigned int k;
; 4159 :     if (z->num_bits < n) stbi__fill_bits(z);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00016	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00019	7d 0a		 jge	 SHORT $LN2@stbi__zrec
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ; stbi__fill_bits
$LN2@stbi__zrec:

; 4160 :     k = z->code_buffer & ((1 << n) - 1);

  00025	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00029	b9 01 00 00 00	 mov	 ecx, 1
  0002e	89 4c 24 20	 mov	 DWORD PTR tv83[rsp], ecx
  00032	0f b6 c8	 movzx	 ecx, al
  00035	8b 44 24 20	 mov	 eax, DWORD PTR tv83[rsp]
  00039	d3 e0		 shl	 eax, cl
  0003b	ff c8		 dec	 eax
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00042	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00045	23 c8		 and	 ecx, eax
  00047	8b c1		 mov	 eax, ecx
  00049	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 4161 :     z->code_buffer >>= n;

  0004d	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00056	48 89 4c 24 28	 mov	 QWORD PTR tv89[rsp], rcx
  0005b	0f b6 c8	 movzx	 ecx, al
  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR tv89[rsp]
  00063	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00066	d3 e8		 shr	 eax, cl
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0006d	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4162 :     z->num_bits -= n;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00075	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00079	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007c	2b c1		 sub	 eax, ecx
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00083	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4163 :     return k;

  00086	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]

; 4164 : }

  0008a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008e	c3		 ret	 0
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ENDP		; stbi__zreceive
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv91 = 32
z$ = 64
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z PROC		; stbi__fill_bits

; 4145 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@stbi__fill:

; 4146 :     do {
; 4147 :         if (z->code_buffer >= (1U << z->num_bits)) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0000e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00011	b9 01 00 00 00	 mov	 ecx, 1
  00016	89 4c 24 20	 mov	 DWORD PTR tv91[rsp], ecx
  0001a	0f b6 c8	 movzx	 ecx, al
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR tv91[rsp]
  00021	d3 e0		 shl	 eax, cl
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00028	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  0002b	72 13		 jb	 SHORT $LN5@stbi__fill

; 4148 :             z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00037	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4149 :             return;

  0003e	eb 49		 jmp	 SHORT $LN1@stbi__fill
$LN5@stbi__fill:

; 4150 :         }
; 4151 :         z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00045	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00052	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00055	d3 e0		 shl	 eax, cl
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0005c	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0005f	0b c8		 or	 ecx, eax
  00061	8b c1		 mov	 eax, ecx
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00068	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 4152 :         z->num_bits += 8;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00070	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00073	83 c0 08	 add	 eax, 8
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0007b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4153 :     } while (z->num_bits <= 24);

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00083	83 78 10 18	 cmp	 DWORD PTR [rax+16], 24
  00087	7e 80		 jle	 SHORT $LN4@stbi__fill
$LN1@stbi__fill:

; 4154 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ENDP		; stbi__fill_bits
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv73 = 32
z$ = 64
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z PROC		; stbi__zget8

; 4140 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4141 :     return stbi__zeof(z) ? 0 : *z->zbuffer++;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ; stbi__zeof
  00013	85 c0		 test	 eax, eax
  00015	74 0a		 je	 SHORT $LN3@stbi__zget
  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0001f	eb 22		 jmp	 SHORT $LN4@stbi__zget
$LN3@stbi__zget:
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002c	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 ff c0	 inc	 rax
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00040	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN4@stbi__zget:
  00043	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv73[rsp]

; 4142 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ENDP		; stbi__zget8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv67 = 0
z$ = 32
?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z PROC			; stbi__zeof

; 4135 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 4136 :     return (z->zbuffer >= z->zbuffer_end);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  0000e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  00013	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00017	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001a	72 09		 jb	 SHORT $LN3@stbi__zeof
  0001c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00023	eb 07		 jmp	 SHORT $LN4@stbi__zeof
$LN3@stbi__zeof:
  00025	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@stbi__zeof:
  0002c	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]

; 4137 : }

  0002f	48 83 c4 18	 add	 rsp, 24
  00033	c3		 ret	 0
?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ENDP			; stbi__zeof
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$1 = 36
code$ = 40
j$2 = 44
fastv$3 = 48
k$ = 52
c$4 = 56
tv297 = 60
sizes$ = 64
next_code$ = 144
__$ArrayPad$ = 208
z$ = 240
sizelist$ = 248
num$ = 256
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z PROC ; stbi__zbuild_huffman

; 4068 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4069 :     int i,k=0;

  00029	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 4070 :     int code, next_code[16], sizes[17];
; 4071 :     
; 4072 :     // DEFLATE spec for generating codes
; 4073 :     memset(sizes, 0, sizeof(sizes));

  00031	48 8d 44 24 40	 lea	 rax, QWORD PTR sizes$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00040	f3 aa		 rep stosb

; 4074 :     memset(z->fast, 0, sizeof(z->fast));

  00042	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0004a	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR z$[rsp]
  00052	33 c0		 xor	 eax, eax
  00054	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00059	f3 aa		 rep stosb

; 4075 :     for (i=0; i < num; ++i)

  0005b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00063	eb 0a		 jmp	 SHORT $LN4@stbi__zbui
$LN2@stbi__zbui:
  00065	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00069	ff c0		 inc	 eax
  0006b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__zbui:
  0006f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00076	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0007a	7d 2e		 jge	 SHORT $LN3@stbi__zbui

; 4076 :         ++sizes[sizelist[i]];

  0007c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00081	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR sizelist$[rsp]
  00089	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008d	8b 44 84 40	 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  00091	ff c0		 inc	 eax
  00093	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00098	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR sizelist$[rsp]
  000a0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000a4	89 44 8c 40	 mov	 DWORD PTR sizes$[rsp+rcx*4], eax
  000a8	eb bb		 jmp	 SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 4077 :     sizes[0] = 0;

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	48 6b c0 00	 imul	 rax, rax, 0
  000b3	c7 44 04 40 00
	00 00 00	 mov	 DWORD PTR sizes$[rsp+rax], 0

; 4078 :     for (i=1; i < 16; ++i)

  000bb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000c3	eb 0a		 jmp	 SHORT $LN7@stbi__zbui
$LN5@stbi__zbui:
  000c5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000c9	ff c0		 inc	 eax
  000cb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__zbui:
  000cf	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  000d4	7d 2b		 jge	 SHORT $LN6@stbi__zbui

; 4079 :         if (sizes[i] > (1 << i))

  000d6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000db	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000df	ba 01 00 00 00	 mov	 edx, 1
  000e4	d3 e2		 shl	 edx, cl
  000e6	8b ca		 mov	 ecx, edx
  000e8	39 4c 84 40	 cmp	 DWORD PTR sizes$[rsp+rax*4], ecx
  000ec	7e 11		 jle	 SHORT $LN16@stbi__zbui

; 4080 :         return stbi__err("bad sizes", "Corrupt PNG");

  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38457
  000f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000fa	e9 6a 02 00 00	 jmp	 $LN1@stbi__zbui
$LN16@stbi__zbui:
  000ff	eb c4		 jmp	 SHORT $LN5@stbi__zbui
$LN6@stbi__zbui:

; 4081 :     code = 0;

  00101	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 4082 :     for (i=1; i < 16; ++i) {

  00109	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00111	eb 0a		 jmp	 SHORT $LN10@stbi__zbui
$LN8@stbi__zbui:
  00113	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00117	ff c0		 inc	 eax
  00119	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__zbui:
  0011d	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00122	0f 8d d7 00 00
	00		 jge	 $LN9@stbi__zbui

; 4083 :         next_code[i] = code;

  00128	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0012d	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  00131	89 8c 84 90 00
	00 00		 mov	 DWORD PTR next_code$[rsp+rax*4], ecx

; 4084 :         z->firstcode[i] = (stbi__uint16) code;

  00138	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0013d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00145	0f b7 54 24 28	 movzx	 edx, WORD PTR code$[rsp]
  0014a	66 89 94 41 00
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1024], dx

; 4085 :         z->firstsymbol[i] = (stbi__uint16) k;

  00152	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00157	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0015f	0f b7 54 24 34	 movzx	 edx, WORD PTR k$[rsp]
  00164	66 89 94 41 64
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1124], dx

; 4086 :         code = (code + sizes[i]);

  0016c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00171	8b 44 84 40	 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  00175	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  00179	03 c8		 add	 ecx, eax
  0017b	8b c1		 mov	 eax, ecx
  0017d	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4087 :         if (sizes[i])

  00181	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00186	83 7c 84 40 00	 cmp	 DWORD PTR sizes$[rsp+rax*4], 0
  0018b	74 28		 je	 SHORT $LN17@stbi__zbui

; 4088 :             if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");

  0018d	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  00191	ff c8		 dec	 eax
  00193	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00197	ba 01 00 00 00	 mov	 edx, 1
  0019c	d3 e2		 shl	 edx, cl
  0019e	8b ca		 mov	 ecx, edx
  001a0	3b c1		 cmp	 eax, ecx
  001a2	7c 11		 jl	 SHORT $LN18@stbi__zbui
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38460
  001ab	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001b0	e9 b4 01 00 00	 jmp	 $LN1@stbi__zbui
$LN18@stbi__zbui:
$LN17@stbi__zbui:

; 4089 :         z->maxcode[i] = code << (16-i); // preshift for inner loop

  001b5	b8 10 00 00 00	 mov	 eax, 16
  001ba	2b 44 24 20	 sub	 eax, DWORD PTR i$[rsp]
  001be	0f b6 c8	 movzx	 ecx, al
  001c1	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  001c5	d3 e0		 shl	 eax, cl
  001c7	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001cc	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  001d4	89 84 8a 20 04
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1056], eax

; 4090 :         code <<= 1;

  001db	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  001df	d1 e0		 shl	 eax, 1
  001e1	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4091 :         k += sizes[i];

  001e5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001ea	8b 44 84 40	 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  001ee	8b 4c 24 34	 mov	 ecx, DWORD PTR k$[rsp]
  001f2	03 c8		 add	 ecx, eax
  001f4	8b c1		 mov	 eax, ecx
  001f6	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax

; 4092 :     }

  001fa	e9 14 ff ff ff	 jmp	 $LN8@stbi__zbui
$LN9@stbi__zbui:

; 4093 :     z->maxcode[16] = 0x10000; // sentinel

  001ff	b8 04 00 00 00	 mov	 eax, 4
  00204	48 6b c0 10	 imul	 rax, rax, 16
  00208	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00210	c7 84 01 20 04
	00 00 00 00 01
	00		 mov	 DWORD PTR [rcx+rax+1056], 65536 ; 00010000H

; 4094 :     for (i=0; i < num; ++i) {

  0021b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00223	eb 0a		 jmp	 SHORT $LN13@stbi__zbui
$LN11@stbi__zbui:
  00225	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00229	ff c0		 inc	 eax
  0022b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@stbi__zbui:
  0022f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00236	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0023a	0f 8d 24 01 00
	00		 jge	 $LN12@stbi__zbui

; 4095 :         int s = sizelist[i];

  00240	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00245	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR sizelist$[rsp]
  0024d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00251	89 44 24 24	 mov	 DWORD PTR s$1[rsp], eax

; 4096 :         if (s) {

  00255	83 7c 24 24 00	 cmp	 DWORD PTR s$1[rsp], 0
  0025a	0f 84 ff 00 00
	00		 je	 $LN19@stbi__zbui

; 4097 :             int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

  00260	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$1[rsp]
  00265	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$1[rsp]
  0026a	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00272	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  0027a	8b 84 84 90 00
	00 00		 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  00281	2b c1		 sub	 eax, ecx
  00283	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$1[rsp]
  00288	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00290	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  00298	03 c1		 add	 eax, ecx
  0029a	89 44 24 38	 mov	 DWORD PTR c$4[rsp], eax

; 4098 :             stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);

  0029e	8b 44 24 24	 mov	 eax, DWORD PTR s$1[rsp]
  002a2	c1 e0 09	 shl	 eax, 9
  002a5	0b 44 24 20	 or	 eax, DWORD PTR i$[rsp]
  002a9	66 89 44 24 30	 mov	 WORD PTR fastv$3[rsp], ax

; 4099 :             z->size [c] = (stbi_uc     ) s;

  002ae	48 63 44 24 38	 movsxd	 rax, DWORD PTR c$4[rsp]
  002b3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002bb	0f b6 54 24 24	 movzx	 edx, BYTE PTR s$1[rsp]
  002c0	88 94 01 84 04
	00 00		 mov	 BYTE PTR [rcx+rax+1156], dl

; 4100 :             z->value[c] = (stbi__uint16) i;

  002c7	48 63 44 24 38	 movsxd	 rax, DWORD PTR c$4[rsp]
  002cc	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002d4	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  002d9	66 89 94 41 a4
	05 00 00	 mov	 WORD PTR [rcx+rax*2+1444], dx

; 4101 :             if (s <= STBI__ZFAST_BITS) {

  002e1	83 7c 24 24 09	 cmp	 DWORD PTR s$1[rsp], 9
  002e6	7f 5d		 jg	 SHORT $LN20@stbi__zbui

; 4102 :                 int j = stbi__bit_reverse(next_code[s],s);

  002e8	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$1[rsp]
  002ed	8b 54 24 24	 mov	 edx, DWORD PTR s$1[rsp]
  002f1	8b 8c 84 90 00
	00 00		 mov	 ecx, DWORD PTR next_code$[rsp+rax*4]
  002f8	e8 00 00 00 00	 call	 ?stbi__bit_reverse@@YAHHH@Z ; stbi__bit_reverse
  002fd	89 44 24 2c	 mov	 DWORD PTR j$2[rsp], eax
$LN14@stbi__zbui:

; 4103 :                 while (j < (1 << STBI__ZFAST_BITS)) {

  00301	81 7c 24 2c 00
	02 00 00	 cmp	 DWORD PTR j$2[rsp], 512	; 00000200H
  00309	7d 3a		 jge	 SHORT $LN15@stbi__zbui

; 4104 :                     z->fast[j] = fastv;

  0030b	48 63 44 24 2c	 movsxd	 rax, DWORD PTR j$2[rsp]
  00310	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00318	0f b7 54 24 30	 movzx	 edx, WORD PTR fastv$3[rsp]
  0031d	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 4105 :                     j += (1 << s);

  00321	8b 44 24 24	 mov	 eax, DWORD PTR s$1[rsp]
  00325	b9 01 00 00 00	 mov	 ecx, 1
  0032a	89 4c 24 3c	 mov	 DWORD PTR tv297[rsp], ecx
  0032e	0f b6 c8	 movzx	 ecx, al
  00331	8b 44 24 3c	 mov	 eax, DWORD PTR tv297[rsp]
  00335	d3 e0		 shl	 eax, cl
  00337	8b 4c 24 2c	 mov	 ecx, DWORD PTR j$2[rsp]
  0033b	03 c8		 add	 ecx, eax
  0033d	8b c1		 mov	 eax, ecx
  0033f	89 44 24 2c	 mov	 DWORD PTR j$2[rsp], eax

; 4106 :                 }

  00343	eb bc		 jmp	 SHORT $LN14@stbi__zbui
$LN15@stbi__zbui:
$LN20@stbi__zbui:

; 4107 :             }
; 4108 :             ++next_code[s];

  00345	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$1[rsp]
  0034a	8b 84 84 90 00
	00 00		 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  00351	ff c0		 inc	 eax
  00353	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$1[rsp]
  00358	89 84 8c 90 00
	00 00		 mov	 DWORD PTR next_code$[rsp+rcx*4], eax
$LN19@stbi__zbui:

; 4109 :         }
; 4110 :     }

  0035f	e9 c1 fe ff ff	 jmp	 $LN11@stbi__zbui
$LN12@stbi__zbui:

; 4111 :     return 1;

  00364	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zbui:

; 4112 : }

  00369	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00371	48 33 cc	 xor	 rcx, rsp
  00374	e8 00 00 00 00	 call	 __security_check_cookie
  00379	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00380	5f		 pop	 rdi
  00381	c3		 ret	 0
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ENDP ; stbi__zbuild_huffman
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
v$ = 48
bits$ = 56
?stbi__bit_reverse@@YAHHH@Z PROC			; stbi__bit_reverse

; 4060 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4061 :     STBI_ASSERT(bits <= 16);

  0000c	83 7c 24 38 10	 cmp	 DWORD PTR bits$[rsp], 16
  00011	7e 0b		 jle	 SHORT $LN2@stbi__bit_
  00013	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@stbi__bit_:

; 4062 :     // to bit reverse n bits, reverse 16 and shift
; 4063 :     // e.g. 11 bits, bit reverse and shift away 5
; 4064 :     return stbi__bitreverse16(v) >> (16-bits);

  0001e	8b 4c 24 30	 mov	 ecx, DWORD PTR v$[rsp]
  00022	e8 00 00 00 00	 call	 ?stbi__bitreverse16@@YAHH@Z ; stbi__bitreverse16
  00027	b9 10 00 00 00	 mov	 ecx, 16
  0002c	2b 4c 24 38	 sub	 ecx, DWORD PTR bits$[rsp]
  00030	d3 f8		 sar	 eax, cl

; 4065 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
?stbi__bit_reverse@@YAHHH@Z ENDP			; stbi__bit_reverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
n$ = 8
?stbi__bitreverse16@@YAHH@Z PROC			; stbi__bitreverse16

; 4051 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4052 :     n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  00004	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00008	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0000d	d1 f8		 sar	 eax, 1
  0000f	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00013	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  00019	d1 e1		 shl	 ecx, 1
  0001b	0b c1		 or	 eax, ecx
  0001d	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4053 :     n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  00021	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00025	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  0002a	c1 f8 02	 sar	 eax, 2
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00031	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  00037	c1 e1 02	 shl	 ecx, 2
  0003a	0b c1		 or	 eax, ecx
  0003c	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4054 :     n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  00040	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00044	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  00049	c1 f8 04	 sar	 eax, 4
  0004c	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00050	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  00056	c1 e1 04	 shl	 ecx, 4
  00059	0b c1		 or	 eax, ecx
  0005b	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4055 :     n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  0005f	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00063	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00068	c1 f8 08	 sar	 eax, 8
  0006b	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  0006f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00075	c1 e1 08	 shl	 ecx, 8
  00078	0b c1		 or	 eax, ecx
  0007a	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4056 :     return n;

  0007e	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]

; 4057 : }

  00082	c3		 ret	 0
?stbi__bitreverse16@@YAHH@Z ENDP			; stbi__bitreverse16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv80 = 32
j$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z PROC	; stbi__jpeg_info_raw

; 4001 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4002 :     if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

  00018	ba 02 00 00 00	 mov	 edx, 2
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00022	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
  00027	85 c0		 test	 eax, eax
  00029	75 11		 jne	 SHORT $LN2@stbi__jpeg

; 4003 :         stbi__rewind( j->s );

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00030	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00033	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 4004 :         return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 6b		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4005 :     }
; 4006 :     if (x) *x = j->s->img_x;

  0003c	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00042	74 11		 je	 SHORT $LN3@stbi__jpeg
  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00051	8b 00		 mov	 eax, DWORD PTR [rax]
  00053	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__jpeg:

; 4007 :     if (y) *y = j->s->img_y;

  00055	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  0005b	74 12		 je	 SHORT $LN4@stbi__jpeg
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0006d	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__jpeg:

; 4008 :     if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;

  0006f	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00075	74 2b		 je	 SHORT $LN5@stbi__jpeg
  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00083	7c 0a		 jl	 SHORT $LN7@stbi__jpeg
  00085	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR tv80[rsp], 3
  0008d	eb 08		 jmp	 SHORT $LN8@stbi__jpeg
$LN7@stbi__jpeg:
  0008f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN8@stbi__jpeg:
  00097	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  0009c	8b 4c 24 20	 mov	 ecx, DWORD PTR tv80[rsp]
  000a0	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__jpeg:

; 4009 :     return 1;

  000a2	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 4010 : }

  000a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ab	c3		 ret	 0
?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z ENDP	; stbi__jpeg_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$1 = 48
out$2 = 56
k$3 = 64
m$4 = 68
m$5 = 69
m$6 = 70
n$ = 72
r$7 = 80
r$8 = 88
b$9 = 96
g$10 = 97
r$11 = 98
j$12 = 100
decode_n$ = 104
is_rgb$ = 108
tv92 = 112
tv160 = 116
tv234 = 120
tv255 = 124
y_bot$13 = 128
tv283 = 132
tv291 = 136
tv697 = 140
tv71 = 144
tv80 = 148
tv82 = 152
y$14 = 160
tv519 = 168
tv548 = 172
tv629 = 176
tv659 = 180
output$15 = 184
tv268 = 192
tv273 = 200
y$16 = 208
tv166 = 216
tv174 = 224
coutput$17 = 232
res_comp$18 = 272
__$ArrayPad$ = 464
z$ = 496
out_x$ = 504
out_y$ = 512
comp$ = 520
req_comp$ = 528
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z PROC	; load_jpeg_image

; 3812 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3813 :     int n, decode_n, is_rgb;
; 3814 :     z->s->img_n = 0; // make stbi__cleanup_jpeg safe

  0002d	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 3815 :     
; 3816 :     // validate req_comp
; 3817 :     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  0003f	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00047	7c 0a		 jl	 SHORT $LN42@load_jpeg_
  00049	83 bc 24 10 02
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00051	7e 35		 jle	 SHORT $LN41@load_jpeg_
$LN42@load_jpeg_:
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38306
  0005a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005f	85 c0		 test	 eax, eax
  00061	74 0d		 je	 SHORT $LN83@load_jpeg_
  00063	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv71[rsp], 0
  0006e	eb 0b		 jmp	 SHORT $LN84@load_jpeg_
$LN83@load_jpeg_:
  00070	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv71[rsp], 0
$LN84@load_jpeg_:
  0007b	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv71[rsp]
  00083	e9 02 11 00 00	 jmp	 $LN1@load_jpeg_
$LN41@load_jpeg_:

; 3818 :     
; 3819 :     // load a jpeg image from whichever source, but leave in YCbCr format
; 3820 :     if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

  00088	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ; stbi__decode_jpeg_image
  00095	85 c0		 test	 eax, eax
  00097	75 14		 jne	 SHORT $LN43@load_jpeg_
  00099	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000a1	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  000a6	33 c0		 xor	 eax, eax
  000a8	e9 dd 10 00 00	 jmp	 $LN1@load_jpeg_
$LN43@load_jpeg_:

; 3821 :     
; 3822 :     // determine actual number of components to generate
; 3823 :     n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

  000ad	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000b5	74 10		 je	 SHORT $LN87@load_jpeg_
  000b7	8b 84 24 10 02
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000be	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000c5	eb 37		 jmp	 SHORT $LN88@load_jpeg_
$LN87@load_jpeg_:
  000c7	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d2	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  000d6	7c 0d		 jl	 SHORT $LN85@load_jpeg_
  000d8	c7 84 24 94 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv80[rsp], 3
  000e3	eb 0b		 jmp	 SHORT $LN86@load_jpeg_
$LN85@load_jpeg_:
  000e5	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv80[rsp], 1
$LN86@load_jpeg_:
  000f0	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv80[rsp]
  000f7	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
$LN88@load_jpeg_:
  000fe	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  00105	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax

; 3824 :     
; 3825 :     is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

  00109	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00111	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00114	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00118	75 3d		 jne	 SHORT $LN91@load_jpeg_
  0011a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00122	83 b8 50 48 00
	00 03		 cmp	 DWORD PTR [rax+18512], 3
  00129	74 22		 je	 SHORT $LN90@load_jpeg_
  0012b	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00133	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  0013a	75 1b		 jne	 SHORT $LN89@load_jpeg_
  0013c	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00144	83 b8 48 48 00
	00 00		 cmp	 DWORD PTR [rax+18504], 0
  0014b	75 0a		 jne	 SHORT $LN91@load_jpeg_
$LN90@load_jpeg_:
  0014d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00155	eb 08		 jmp	 SHORT $LN92@load_jpeg_
$LN91@load_jpeg_:
$LN89@load_jpeg_:
  00157	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN92@load_jpeg_:
  0015f	8b 44 24 70	 mov	 eax, DWORD PTR tv92[rsp]
  00163	89 44 24 6c	 mov	 DWORD PTR is_rgb$[rsp], eax

; 3826 :     
; 3827 :     if (z->s->img_n == 3 && n < 3 && !is_rgb)

  00167	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0016f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00172	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00176	75 18		 jne	 SHORT $LN44@load_jpeg_
  00178	83 7c 24 48 03	 cmp	 DWORD PTR n$[rsp], 3
  0017d	7d 11		 jge	 SHORT $LN44@load_jpeg_
  0017f	83 7c 24 6c 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  00184	75 0a		 jne	 SHORT $LN44@load_jpeg_

; 3828 :         decode_n = 1;

  00186	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR decode_n$[rsp], 1
  0018e	eb 12		 jmp	 SHORT $LN45@load_jpeg_
$LN44@load_jpeg_:

; 3829 :     else
; 3830 :         decode_n = z->s->img_n;

  00190	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00198	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0019e	89 44 24 68	 mov	 DWORD PTR decode_n$[rsp], eax
$LN45@load_jpeg_:

; 3831 :     
; 3832 :     // nothing to do if no components requested; check this now to avoid
; 3833 :     // accessing uninitialized coutput[0] later
; 3834 :     if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

  001a2	83 7c 24 68 00	 cmp	 DWORD PTR decode_n$[rsp], 0
  001a7	7f 14		 jg	 SHORT $LN46@load_jpeg_
  001a9	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001b1	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  001b6	33 c0		 xor	 eax, eax
  001b8	e9 cd 0f 00 00	 jmp	 $LN1@load_jpeg_
$LN46@load_jpeg_:

; 3835 :     
; 3836 :     // resample and color-convert
; 3837 :     {
; 3838 :         int k;
; 3839 :         unsigned int i,j;
; 3840 :         stbi_uc *output;
; 3841 :         stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

  001bd	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp], 0
  001c9	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp+8], 0
  001d5	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp+16], 0
  001e1	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp+24], 0

; 3842 :         
; 3843 :         stbi__resample res_comp[4];
; 3844 :         
; 3845 :         for (k=0; k < decode_n; ++k) {

  001ed	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR k$3[rsp], 0
  001f5	eb 0a		 jmp	 SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
  001f7	8b 44 24 40	 mov	 eax, DWORD PTR k$3[rsp]
  001fb	ff c0		 inc	 eax
  001fd	89 44 24 40	 mov	 DWORD PTR k$3[rsp], eax
$LN4@load_jpeg_:
  00201	8b 44 24 68	 mov	 eax, DWORD PTR decode_n$[rsp]
  00205	39 44 24 40	 cmp	 DWORD PTR k$3[rsp], eax
  00209	0f 8d 55 02 00
	00		 jge	 $LN3@load_jpeg_

; 3846 :             stbi__resample *r = &res_comp[k];

  0020f	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  00214	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00218	48 8d 84 04 10
	01 00 00	 lea	 rax, QWORD PTR res_comp$18[rsp+rax]
  00220	48 89 44 24 50	 mov	 QWORD PTR r$7[rsp], rax

; 3847 :             
; 3848 :             // allocate line buffer big enough for upsampling off the edges
; 3849 :             // with upsample factor of 4
; 3850 :             z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);

  00225	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0022d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00230	8b 00		 mov	 eax, DWORD PTR [rax]
  00232	83 c0 03	 add	 eax, 3
  00235	8b c0		 mov	 eax, eax
  00237	8b c8		 mov	 ecx, eax
  00239	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0023e	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR k$3[rsp]
  00243	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00247	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0024f	48 89 84 0a e8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18152], rax

; 3851 :             if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  00257	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  0025c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00260	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00268	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  00271	75 39		 jne	 SHORT $LN47@load_jpeg_
  00273	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0027b	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38312
  00287	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0028c	85 c0		 test	 eax, eax
  0028e	74 0a		 je	 SHORT $LN93@load_jpeg_
  00290	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
  00298	eb 08		 jmp	 SHORT $LN94@load_jpeg_
$LN93@load_jpeg_:
  0029a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN94@load_jpeg_:
  002a2	48 63 44 24 74	 movsxd	 rax, DWORD PTR tv160[rsp]
  002a7	e9 de 0e 00 00	 jmp	 $LN1@load_jpeg_
$LN47@load_jpeg_:

; 3852 :             
; 3853 :             r->hs      = z->img_h_max / z->img_comp[k].h;

  002ac	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  002b1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002b5	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  002bd	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002c5	8b 81 88 46 00
	00		 mov	 eax, DWORD PTR [rcx+18056]
  002cb	99		 cdq
  002cc	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002d4	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR tv166[rsp]
  002dc	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  002e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  002e9	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 3854 :             r->vs      = z->img_v_max / z->img_comp[k].v;

  002ec	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  002f1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002f5	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  002fd	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00305	8b 81 8c 46 00
	00		 mov	 eax, DWORD PTR [rcx+18060]
  0030b	99		 cdq
  0030c	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00314	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR tv174[rsp]
  0031c	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  00324	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00329	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 3855 :             r->ystep   = r->vs >> 1;

  0032c	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00331	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00334	d1 f8		 sar	 eax, 1
  00336	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  0033b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 3856 :             r->w_lores = (z->s->img_x + r->hs-1) / r->hs;

  0033e	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00346	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00349	8b 00		 mov	 eax, DWORD PTR [rax]
  0034b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00350	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00353	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00357	33 d2		 xor	 edx, edx
  00359	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  0035e	f7 71 18	 div	 DWORD PTR [rcx+24]
  00361	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00366	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3857 :             r->ypos    = 0;

  00369	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0036e	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 3858 :             r->line0   = r->line1 = z->img_comp[k].data;

  00375	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  0037a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0037e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00383	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0038b	48 8b 84 02 d0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18128]
  00393	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00397	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0039c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  003a1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003a5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3859 :             
; 3860 :             if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

  003a9	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003ae	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003b2	75 1f		 jne	 SHORT $LN48@load_jpeg_
  003b4	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003b9	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  003bd	75 14		 jne	 SHORT $LN48@load_jpeg_
  003bf	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?resample_row_1@@YAPEAEPEAE00HH@Z ; resample_row_1
  003cb	48 89 08	 mov	 QWORD PTR [rax], rcx
  003ce	e9 8c 00 00 00	 jmp	 $LN49@load_jpeg_
$LN48@load_jpeg_:

; 3861 :             else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

  003d3	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003d8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003dc	75 1c		 jne	 SHORT $LN50@load_jpeg_
  003de	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003e3	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  003e7	75 11		 jne	 SHORT $LN50@load_jpeg_
  003e9	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_v_2
  003f5	48 89 08	 mov	 QWORD PTR [rax], rcx
  003f8	eb 65		 jmp	 SHORT $LN51@load_jpeg_
$LN50@load_jpeg_:

; 3862 :             else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

  003fa	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003ff	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00403	75 1c		 jne	 SHORT $LN52@load_jpeg_
  00405	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0040a	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  0040e	75 11		 jne	 SHORT $LN52@load_jpeg_
  00410	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00415	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_h_2
  0041c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0041f	eb 3e		 jmp	 SHORT $LN53@load_jpeg_
$LN52@load_jpeg_:

; 3863 :             else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

  00421	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00426	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  0042a	75 24		 jne	 SHORT $LN54@load_jpeg_
  0042c	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00431	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  00435	75 19		 jne	 SHORT $LN54@load_jpeg_
  00437	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0043c	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00444	48 8b 89 80 48
	00 00		 mov	 rcx, QWORD PTR [rcx+18560]
  0044b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0044e	eb 0f		 jmp	 SHORT $LN55@load_jpeg_
$LN54@load_jpeg_:

; 3864 :             else                               r->resample = stbi__resample_row_generic;

  00450	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00455	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ; stbi__resample_row_generic
  0045c	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN55@load_jpeg_:
$LN53@load_jpeg_:
$LN51@load_jpeg_:
$LN49@load_jpeg_:

; 3865 :         }

  0045f	e9 93 fd ff ff	 jmp	 $LN2@load_jpeg_
$LN3@load_jpeg_:

; 3866 :         
; 3867 :         // can't error after this so, this is safe
; 3868 :         output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

  00464	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0046c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0046f	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00477	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0047a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00480	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00484	8b 11		 mov	 edx, DWORD PTR [rcx]
  00486	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0048a	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0048f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR output$15[rsp], rax

; 3869 :         if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  00497	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR output$15[rsp], 0
  004a0	75 39		 jne	 SHORT $LN56@load_jpeg_
  004a2	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004aa	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38322
  004b6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004bb	85 c0		 test	 eax, eax
  004bd	74 0a		 je	 SHORT $LN95@load_jpeg_
  004bf	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
  004c7	eb 08		 jmp	 SHORT $LN96@load_jpeg_
$LN95@load_jpeg_:
  004c9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN96@load_jpeg_:
  004d1	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv234[rsp]
  004d6	e9 af 0c 00 00	 jmp	 $LN1@load_jpeg_
$LN56@load_jpeg_:

; 3870 :         
; 3871 :         // now go ahead and resample
; 3872 :         for (j=0; j < z->s->img_y; ++j) {

  004db	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$12[rsp], 0
  004e3	eb 0a		 jmp	 SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
  004e5	8b 44 24 64	 mov	 eax, DWORD PTR j$12[rsp]
  004e9	ff c0		 inc	 eax
  004eb	89 44 24 64	 mov	 DWORD PTR j$12[rsp], eax
$LN7@load_jpeg_:
  004ef	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  004f7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004fa	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  004fd	39 44 24 64	 cmp	 DWORD PTR j$12[rsp], eax
  00501	0f 83 fa 0b 00
	00		 jae	 $LN6@load_jpeg_

; 3873 :             stbi_uc *out = output + n * z->s->img_x * j;

  00507	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0050f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00512	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00516	0f af 08	 imul	 ecx, DWORD PTR [rax]
  00519	8b c1		 mov	 eax, ecx
  0051b	0f af 44 24 64	 imul	 eax, DWORD PTR j$12[rsp]
  00520	8b c0		 mov	 eax, eax
  00522	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR output$15[rsp]
  0052a	48 03 c8	 add	 rcx, rax
  0052d	48 8b c1	 mov	 rax, rcx
  00530	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3874 :             for (k=0; k < decode_n; ++k) {

  00535	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR k$3[rsp], 0
  0053d	eb 0a		 jmp	 SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
  0053f	8b 44 24 40	 mov	 eax, DWORD PTR k$3[rsp]
  00543	ff c0		 inc	 eax
  00545	89 44 24 40	 mov	 DWORD PTR k$3[rsp], eax
$LN10@load_jpeg_:
  00549	8b 44 24 68	 mov	 eax, DWORD PTR decode_n$[rsp]
  0054d	39 44 24 40	 cmp	 DWORD PTR k$3[rsp], eax
  00551	0f 8d b9 01 00
	00		 jge	 $LN9@load_jpeg_

; 3875 :                 stbi__resample *r = &res_comp[k];

  00557	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  0055c	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00560	48 8d 84 04 10
	01 00 00	 lea	 rax, QWORD PTR res_comp$18[rsp+rax]
  00568	48 89 44 24 58	 mov	 QWORD PTR r$8[rsp], rax

; 3876 :                 int y_bot = r->ystep >= (r->vs >> 1);

  0056d	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00572	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00575	d1 f8		 sar	 eax, 1
  00577	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  0057c	39 41 24	 cmp	 DWORD PTR [rcx+36], eax
  0057f	7c 0a		 jl	 SHORT $LN97@load_jpeg_
  00581	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv255[rsp], 1
  00589	eb 08		 jmp	 SHORT $LN98@load_jpeg_
$LN97@load_jpeg_:
  0058b	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv255[rsp], 0
$LN98@load_jpeg_:
  00593	8b 44 24 7c	 mov	 eax, DWORD PTR tv255[rsp]
  00597	89 84 24 80 00
	00 00		 mov	 DWORD PTR y_bot$13[rsp], eax

; 3877 :                 coutput[k] = r->resample(z->img_comp[k].linebuf,

  0059e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR y_bot$13[rsp], 0
  005a6	74 13		 je	 SHORT $LN99@load_jpeg_
  005a8	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005ad	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005b1	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
  005b9	eb 11		 jmp	 SHORT $LN100@load_jpeg_
$LN99@load_jpeg_:
  005bb	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005c0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005c4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
$LN100@load_jpeg_:
  005cc	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR y_bot$13[rsp], 0
  005d4	74 13		 je	 SHORT $LN101@load_jpeg_
  005d6	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005db	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005df	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  005e7	eb 11		 jmp	 SHORT $LN102@load_jpeg_
$LN101@load_jpeg_:
  005e9	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005ee	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005f2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
$LN102@load_jpeg_:
  005fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  005ff	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00603	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00608	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0060b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0060f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00614	44 8b 49 20	 mov	 r9d, DWORD PTR [rcx+32]
  00618	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR tv268[rsp]
  00620	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv273[rsp]
  00628	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00630	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00638	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  0063d	ff 10		 call	 QWORD PTR [rax]
  0063f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR k$3[rsp]
  00644	48 89 84 cc e8
	00 00 00	 mov	 QWORD PTR coutput$17[rsp+rcx*8], rax

; 3878 :                                          y_bot ? r->line1 : r->line0,
; 3879 :                                          y_bot ? r->line0 : r->line1,
; 3880 :                                          r->w_lores, r->hs);
; 3881 :                 if (++r->ystep >= r->vs) {

  0064c	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00651	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00654	ff c0		 inc	 eax
  00656	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv283[rsp], eax
  0065d	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00662	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv283[rsp]
  00669	89 48 24	 mov	 DWORD PTR [rax+36], ecx
  0066c	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00671	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00674	39 84 24 84 00
	00 00		 cmp	 DWORD PTR tv283[rsp], eax
  0067b	0f 8c 8a 00 00
	00		 jl	 $LN57@load_jpeg_

; 3882 :                     r->ystep = 0;

  00681	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00686	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 3883 :                     r->line0 = r->line1;

  0068d	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00692	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00697	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0069b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3884 :                     if (++r->ypos < z->img_comp[k].y)

  0069f	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  006a4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  006a7	ff c0		 inc	 eax
  006a9	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  006b0	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  006b5	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  006bc	89 48 28	 mov	 DWORD PTR [rax+40], ecx
  006bf	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  006c4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006c8	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006d0	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  006d7	39 84 24 88 00
	00 00		 cmp	 DWORD PTR tv291[rsp], eax
  006de	7d 2b		 jge	 SHORT $LN58@load_jpeg_

; 3885 :                         r->line1 += z->img_comp[k].w2;

  006e0	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  006e5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006e9	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006f1	48 63 84 01 c4
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18116]
  006f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  006fe	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00702	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00707	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN58@load_jpeg_:
$LN57@load_jpeg_:

; 3886 :                 }
; 3887 :             }

  0070b	e9 2f fe ff ff	 jmp	 $LN8@load_jpeg_
$LN9@load_jpeg_:

; 3888 :             if (n >= 3) {

  00710	83 7c 24 48 03	 cmp	 DWORD PTR n$[rsp], 3
  00715	0f 8c 45 05 00
	00		 jl	 $LN59@load_jpeg_

; 3889 :                 stbi_uc *y = coutput[0];

  0071b	b8 08 00 00 00	 mov	 eax, 8
  00720	48 6b c0 00	 imul	 rax, rax, 0
  00724	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  0072c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR y$14[rsp], rax

; 3890 :                 if (z->s->img_n == 3) {

  00734	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0073c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0073f	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00743	0f 85 39 01 00
	00		 jne	 $LN61@load_jpeg_

; 3891 :                     if (is_rgb) {

  00749	83 7c 24 6c 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  0074e	0f 84 d1 00 00
	00		 je	 $LN63@load_jpeg_

; 3892 :                         for (i=0; i < z->s->img_x; ++i) {

  00754	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0075c	eb 0a		 jmp	 SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
  0075e	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00762	ff c0		 inc	 eax
  00764	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN13@load_jpeg_:
  00768	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00770	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00773	8b 00		 mov	 eax, DWORD PTR [rax]
  00775	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00779	0f 83 a4 00 00
	00		 jae	 $LN12@load_jpeg_

; 3893 :                             out[0] = y[i];

  0077f	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00783	b9 01 00 00 00	 mov	 ecx, 1
  00788	48 6b c9 00	 imul	 rcx, rcx, 0
  0078c	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00791	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$14[rsp]
  00799	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0079e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3894 :                             out[1] = coutput[1][i];

  007a1	b8 08 00 00 00	 mov	 eax, 8
  007a6	48 6b c0 01	 imul	 rax, rax, 1
  007aa	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  007ae	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  007b6	ba 01 00 00 00	 mov	 edx, 1
  007bb	48 6b d2 01	 imul	 rdx, rdx, 1
  007bf	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  007c4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007c8	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3895 :                             out[2] = coutput[2][i];

  007cc	b8 08 00 00 00	 mov	 eax, 8
  007d1	48 6b c0 02	 imul	 rax, rax, 2
  007d5	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  007d9	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  007e1	ba 01 00 00 00	 mov	 edx, 1
  007e6	48 6b d2 02	 imul	 rdx, rdx, 2
  007ea	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  007ef	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007f3	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3896 :                             out[3] = 255;

  007f7	b8 01 00 00 00	 mov	 eax, 1
  007fc	48 6b c0 03	 imul	 rax, rax, 3
  00800	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00805	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3897 :                             out += n;

  00809	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  0080e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00813	48 03 c8	 add	 rcx, rax
  00816	48 8b c1	 mov	 rax, rcx
  00819	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3898 :                         }

  0081e	e9 3b ff ff ff	 jmp	 $LN11@load_jpeg_
$LN12@load_jpeg_:

; 3899 :                     } else {

  00823	eb 58		 jmp	 SHORT $LN64@load_jpeg_
$LN63@load_jpeg_:

; 3900 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00825	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0082d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00830	b9 08 00 00 00	 mov	 ecx, 8
  00835	48 6b c9 02	 imul	 rcx, rcx, 2
  00839	ba 08 00 00 00	 mov	 edx, 8
  0083e	48 6b d2 01	 imul	 rdx, rdx, 1
  00842	44 8b 44 24 48	 mov	 r8d, DWORD PTR n$[rsp]
  00847	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  0084c	8b 00		 mov	 eax, DWORD PTR [rax]
  0084e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00852	4c 8b 8c 0c e8
	00 00 00	 mov	 r9, QWORD PTR coutput$17[rsp+rcx]
  0085a	4c 8b 84 14 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$17[rsp+rdx]
  00862	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR y$14[rsp]
  0086a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0086f	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00877	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
$LN64@load_jpeg_:

; 3901 :                     }

  0087d	e9 d9 03 00 00	 jmp	 $LN62@load_jpeg_
$LN61@load_jpeg_:

; 3902 :                 } else if (z->s->img_n == 4) {

  00882	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0088a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0088d	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00891	0f 85 03 03 00
	00		 jne	 $LN65@load_jpeg_

; 3903 :                     if (z->app14_color_transform == 0) { // CMYK

  00897	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0089f	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  008a6	0f 85 15 01 00
	00		 jne	 $LN67@load_jpeg_

; 3904 :                         for (i=0; i < z->s->img_x; ++i) {

  008ac	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  008b4	eb 0a		 jmp	 SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
  008b6	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  008ba	ff c0		 inc	 eax
  008bc	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN16@load_jpeg_:
  008c0	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008cb	8b 00		 mov	 eax, DWORD PTR [rax]
  008cd	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  008d1	0f 83 e5 00 00
	00		 jae	 $LN15@load_jpeg_

; 3905 :                             stbi_uc m = coutput[3][i];

  008d7	b8 08 00 00 00	 mov	 eax, 8
  008dc	48 6b c0 03	 imul	 rax, rax, 3
  008e0	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  008e4	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  008ec	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  008f0	88 44 24 44	 mov	 BYTE PTR m$4[rsp], al

; 3906 :                             out[0] = stbi__blinn_8x8(coutput[0][i], m);

  008f4	b8 08 00 00 00	 mov	 eax, 8
  008f9	48 6b c0 00	 imul	 rax, rax, 0
  008fd	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00901	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00909	0f b6 54 24 44	 movzx	 edx, BYTE PTR m$4[rsp]
  0090e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00912	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00917	b9 01 00 00 00	 mov	 ecx, 1
  0091c	48 6b c9 00	 imul	 rcx, rcx, 0
  00920	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00925	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3907 :                             out[1] = stbi__blinn_8x8(coutput[1][i], m);

  00928	b8 08 00 00 00	 mov	 eax, 8
  0092d	48 6b c0 01	 imul	 rax, rax, 1
  00931	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00935	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  0093d	0f b6 54 24 44	 movzx	 edx, BYTE PTR m$4[rsp]
  00942	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00946	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  0094b	b9 01 00 00 00	 mov	 ecx, 1
  00950	48 6b c9 01	 imul	 rcx, rcx, 1
  00954	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00959	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3908 :                             out[2] = stbi__blinn_8x8(coutput[2][i], m);

  0095c	b8 08 00 00 00	 mov	 eax, 8
  00961	48 6b c0 02	 imul	 rax, rax, 2
  00965	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00969	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00971	0f b6 54 24 44	 movzx	 edx, BYTE PTR m$4[rsp]
  00976	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0097a	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  0097f	b9 01 00 00 00	 mov	 ecx, 1
  00984	48 6b c9 02	 imul	 rcx, rcx, 2
  00988	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  0098d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3909 :                             out[3] = 255;

  00990	b8 01 00 00 00	 mov	 eax, 1
  00995	48 6b c0 03	 imul	 rax, rax, 3
  00999	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0099e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3910 :                             out += n;

  009a2	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  009a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  009ac	48 03 c8	 add	 rcx, rax
  009af	48 8b c1	 mov	 rax, rcx
  009b2	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3911 :                         }

  009b7	e9 fa fe ff ff	 jmp	 $LN14@load_jpeg_
$LN15@load_jpeg_:

; 3912 :                     } else if (z->app14_color_transform == 2) { // YCCK

  009bc	e9 d4 01 00 00	 jmp	 $LN68@load_jpeg_
$LN67@load_jpeg_:
  009c1	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009c9	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  009d0	0f 85 67 01 00
	00		 jne	 $LN69@load_jpeg_

; 3913 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  009d6	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009e1	b9 08 00 00 00	 mov	 ecx, 8
  009e6	48 6b c9 02	 imul	 rcx, rcx, 2
  009ea	ba 08 00 00 00	 mov	 edx, 8
  009ef	48 6b d2 01	 imul	 rdx, rdx, 1
  009f3	44 8b 44 24 48	 mov	 r8d, DWORD PTR n$[rsp]
  009f8	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  009fd	8b 00		 mov	 eax, DWORD PTR [rax]
  009ff	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a03	4c 8b 8c 0c e8
	00 00 00	 mov	 r9, QWORD PTR coutput$17[rsp+rcx]
  00a0b	4c 8b 84 14 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$17[rsp+rdx]
  00a13	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR y$14[rsp]
  00a1b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00a20	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a28	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]

; 3914 :                         for (i=0; i < z->s->img_x; ++i) {

  00a2e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00a36	eb 0a		 jmp	 SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
  00a38	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00a3c	ff c0		 inc	 eax
  00a3e	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN19@load_jpeg_:
  00a42	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a4a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a4d	8b 00		 mov	 eax, DWORD PTR [rax]
  00a4f	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00a53	0f 83 e2 00 00
	00		 jae	 $LN18@load_jpeg_

; 3915 :                             stbi_uc m = coutput[3][i];

  00a59	b8 08 00 00 00	 mov	 eax, 8
  00a5e	48 6b c0 03	 imul	 rax, rax, 3
  00a62	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00a66	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00a6e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a72	88 44 24 45	 mov	 BYTE PTR m$5[rsp], al

; 3916 :                             out[0] = stbi__blinn_8x8(255 - out[0], m);

  00a76	b8 01 00 00 00	 mov	 eax, 1
  00a7b	48 6b c0 00	 imul	 rax, rax, 0
  00a7f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00a84	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a88	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00a8d	2b c8		 sub	 ecx, eax
  00a8f	8b c1		 mov	 eax, ecx
  00a91	0f b6 54 24 45	 movzx	 edx, BYTE PTR m$5[rsp]
  00a96	0f b6 c8	 movzx	 ecx, al
  00a99	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00a9e	b9 01 00 00 00	 mov	 ecx, 1
  00aa3	48 6b c9 00	 imul	 rcx, rcx, 0
  00aa7	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00aac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3917 :                             out[1] = stbi__blinn_8x8(255 - out[1], m);

  00aaf	b8 01 00 00 00	 mov	 eax, 1
  00ab4	48 6b c0 01	 imul	 rax, rax, 1
  00ab8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00abd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ac1	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00ac6	2b c8		 sub	 ecx, eax
  00ac8	8b c1		 mov	 eax, ecx
  00aca	0f b6 54 24 45	 movzx	 edx, BYTE PTR m$5[rsp]
  00acf	0f b6 c8	 movzx	 ecx, al
  00ad2	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00ad7	b9 01 00 00 00	 mov	 ecx, 1
  00adc	48 6b c9 01	 imul	 rcx, rcx, 1
  00ae0	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00ae5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3918 :                             out[2] = stbi__blinn_8x8(255 - out[2], m);

  00ae8	b8 01 00 00 00	 mov	 eax, 1
  00aed	48 6b c0 02	 imul	 rax, rax, 2
  00af1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00af6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00afa	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00aff	2b c8		 sub	 ecx, eax
  00b01	8b c1		 mov	 eax, ecx
  00b03	0f b6 54 24 45	 movzx	 edx, BYTE PTR m$5[rsp]
  00b08	0f b6 c8	 movzx	 ecx, al
  00b0b	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00b10	b9 01 00 00 00	 mov	 ecx, 1
  00b15	48 6b c9 02	 imul	 rcx, rcx, 2
  00b19	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00b1e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3919 :                             out += n;

  00b21	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00b26	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00b2b	48 03 c8	 add	 rcx, rax
  00b2e	48 8b c1	 mov	 rax, rcx
  00b31	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3920 :                         }

  00b36	e9 fd fe ff ff	 jmp	 $LN17@load_jpeg_
$LN18@load_jpeg_:

; 3921 :                     } else { // YCbCr + alpha?  Ignore the fourth channel for now

  00b3b	eb 58		 jmp	 SHORT $LN70@load_jpeg_
$LN69@load_jpeg_:

; 3922 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00b3d	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b45	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b48	b9 08 00 00 00	 mov	 ecx, 8
  00b4d	48 6b c9 02	 imul	 rcx, rcx, 2
  00b51	ba 08 00 00 00	 mov	 edx, 8
  00b56	48 6b d2 01	 imul	 rdx, rdx, 1
  00b5a	44 8b 44 24 48	 mov	 r8d, DWORD PTR n$[rsp]
  00b5f	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00b64	8b 00		 mov	 eax, DWORD PTR [rax]
  00b66	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b6a	4c 8b 8c 0c e8
	00 00 00	 mov	 r9, QWORD PTR coutput$17[rsp+rcx]
  00b72	4c 8b 84 14 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$17[rsp+rdx]
  00b7a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR y$14[rsp]
  00b82	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00b87	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b8f	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
$LN70@load_jpeg_:
$LN68@load_jpeg_:

; 3923 :                     }
; 3924 :                 } else

  00b95	e9 c1 00 00 00	 jmp	 $LN66@load_jpeg_
$LN65@load_jpeg_:

; 3925 :                     for (i=0; i < z->s->img_x; ++i) {

  00b9a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00ba2	eb 0a		 jmp	 SHORT $LN22@load_jpeg_
$LN20@load_jpeg_:
  00ba4	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00ba8	ff c0		 inc	 eax
  00baa	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN22@load_jpeg_:
  00bae	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bb6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bb9	8b 00		 mov	 eax, DWORD PTR [rax]
  00bbb	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00bbf	0f 83 96 00 00
	00		 jae	 $LN21@load_jpeg_

; 3926 :                     out[0] = out[1] = out[2] = y[i];

  00bc5	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00bc9	b9 01 00 00 00	 mov	 ecx, 1
  00bce	48 6b c9 02	 imul	 rcx, rcx, 2
  00bd2	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00bd7	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$14[rsp]
  00bdf	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00be4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00be7	b8 01 00 00 00	 mov	 eax, 1
  00bec	48 6b c0 02	 imul	 rax, rax, 2
  00bf0	b9 01 00 00 00	 mov	 ecx, 1
  00bf5	48 6b c9 01	 imul	 rcx, rcx, 1
  00bf9	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00bfe	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  00c03	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00c08	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c0b	b8 01 00 00 00	 mov	 eax, 1
  00c10	48 6b c0 01	 imul	 rax, rax, 1
  00c14	b9 01 00 00 00	 mov	 ecx, 1
  00c19	48 6b c9 00	 imul	 rcx, rcx, 0
  00c1d	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00c22	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  00c27	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00c2c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3927 :                     out[3] = 255; // not used if n==3

  00c2f	b8 01 00 00 00	 mov	 eax, 1
  00c34	48 6b c0 03	 imul	 rax, rax, 3
  00c38	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00c3d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3928 :                     out += n;

  00c41	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00c46	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00c4b	48 03 c8	 add	 rcx, rax
  00c4e	48 8b c1	 mov	 rax, rcx
  00c51	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3929 :                 }

  00c56	e9 49 ff ff ff	 jmp	 $LN20@load_jpeg_
$LN21@load_jpeg_:
$LN66@load_jpeg_:
$LN62@load_jpeg_:

; 3930 :             } else {

  00c5b	e9 9c 04 00 00	 jmp	 $LN60@load_jpeg_
$LN59@load_jpeg_:

; 3931 :                 if (is_rgb) {

  00c60	83 7c 24 6c 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  00c65	0f 84 88 01 00
	00		 je	 $LN71@load_jpeg_

; 3932 :                     if (n == 1)

  00c6b	83 7c 24 48 01	 cmp	 DWORD PTR n$[rsp], 1
  00c70	0f 85 b0 00 00
	00		 jne	 $LN73@load_jpeg_

; 3933 :                         for (i=0; i < z->s->img_x; ++i)

  00c76	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00c7e	eb 0a		 jmp	 SHORT $LN25@load_jpeg_
$LN23@load_jpeg_:
  00c80	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00c84	ff c0		 inc	 eax
  00c86	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN25@load_jpeg_:
  00c8a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c92	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c95	8b 00		 mov	 eax, DWORD PTR [rax]
  00c97	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00c9b	0f 83 80 00 00
	00		 jae	 $LN24@load_jpeg_

; 3934 :                         *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00ca1	b8 08 00 00 00	 mov	 eax, 8
  00ca6	48 6b c0 02	 imul	 rax, rax, 2
  00caa	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00cae	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00cb6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00cba	b9 08 00 00 00	 mov	 ecx, 8
  00cbf	48 6b c9 01	 imul	 rcx, rcx, 1
  00cc3	8b 54 24 30	 mov	 edx, DWORD PTR i$1[rsp]
  00cc7	48 8b 8c 0c e8
	00 00 00	 mov	 rcx, QWORD PTR coutput$17[rsp+rcx]
  00ccf	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00cd3	ba 08 00 00 00	 mov	 edx, 8
  00cd8	48 6b d2 00	 imul	 rdx, rdx, 0
  00cdc	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$1[rsp]
  00ce1	48 8b 94 14 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$17[rsp+rdx]
  00ce9	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00cee	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv519[rsp], edx
  00cf5	44 8b c0	 mov	 r8d, eax
  00cf8	8b d1		 mov	 edx, ecx
  00cfa	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv519[rsp]
  00d01	8b c8		 mov	 ecx, eax
  00d03	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00d08	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00d0d	88 01		 mov	 BYTE PTR [rcx], al
  00d0f	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  00d14	48 ff c0	 inc	 rax
  00d17	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
  00d1c	e9 5f ff ff ff	 jmp	 $LN23@load_jpeg_
$LN24@load_jpeg_:
  00d21	e9 c8 00 00 00	 jmp	 $LN74@load_jpeg_
$LN73@load_jpeg_:

; 3935 :                     else {
; 3936 :                         for (i=0; i < z->s->img_x; ++i, out += 2) {

  00d26	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00d2e	eb 18		 jmp	 SHORT $LN28@load_jpeg_
$LN26@load_jpeg_:
  00d30	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00d34	ff c0		 inc	 eax
  00d36	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  00d3a	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  00d3f	48 83 c0 02	 add	 rax, 2
  00d43	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
$LN28@load_jpeg_:
  00d48	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d50	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d53	8b 00		 mov	 eax, DWORD PTR [rax]
  00d55	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00d59	0f 83 8f 00 00
	00		 jae	 $LN27@load_jpeg_

; 3937 :                             out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00d5f	b8 08 00 00 00	 mov	 eax, 8
  00d64	48 6b c0 02	 imul	 rax, rax, 2
  00d68	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00d6c	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00d74	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00d78	b9 08 00 00 00	 mov	 ecx, 8
  00d7d	48 6b c9 01	 imul	 rcx, rcx, 1
  00d81	8b 54 24 30	 mov	 edx, DWORD PTR i$1[rsp]
  00d85	48 8b 8c 0c e8
	00 00 00	 mov	 rcx, QWORD PTR coutput$17[rsp+rcx]
  00d8d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00d91	ba 08 00 00 00	 mov	 edx, 8
  00d96	48 6b d2 00	 imul	 rdx, rdx, 0
  00d9a	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$1[rsp]
  00d9f	48 8b 94 14 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$17[rsp+rdx]
  00da7	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00dac	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv548[rsp], edx
  00db3	44 8b c0	 mov	 r8d, eax
  00db6	8b d1		 mov	 edx, ecx
  00db8	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv548[rsp]
  00dbf	8b c8		 mov	 ecx, eax
  00dc1	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00dc6	b9 01 00 00 00	 mov	 ecx, 1
  00dcb	48 6b c9 00	 imul	 rcx, rcx, 0
  00dcf	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00dd4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3938 :                             out[1] = 255;

  00dd7	b8 01 00 00 00	 mov	 eax, 1
  00ddc	48 6b c0 01	 imul	 rax, rax, 1
  00de0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00de5	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3939 :                         }

  00de9	e9 42 ff ff ff	 jmp	 $LN26@load_jpeg_
$LN27@load_jpeg_:
$LN74@load_jpeg_:

; 3940 :                     }

  00dee	e9 09 03 00 00	 jmp	 $LN72@load_jpeg_
$LN71@load_jpeg_:

; 3941 :                 } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {

  00df3	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00dfb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00dfe	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00e02	0f 85 3d 01 00
	00		 jne	 $LN75@load_jpeg_
  00e08	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e10	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00e17	0f 85 28 01 00
	00		 jne	 $LN75@load_jpeg_

; 3942 :                     for (i=0; i < z->s->img_x; ++i) {

  00e1d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00e25	eb 0a		 jmp	 SHORT $LN31@load_jpeg_
$LN29@load_jpeg_:
  00e27	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00e2b	ff c0		 inc	 eax
  00e2d	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN31@load_jpeg_:
  00e31	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e39	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e3c	8b 00		 mov	 eax, DWORD PTR [rax]
  00e3e	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00e42	0f 83 f8 00 00
	00		 jae	 $LN30@load_jpeg_

; 3943 :                         stbi_uc m = coutput[3][i];

  00e48	b8 08 00 00 00	 mov	 eax, 8
  00e4d	48 6b c0 03	 imul	 rax, rax, 3
  00e51	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00e55	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00e5d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00e61	88 44 24 46	 mov	 BYTE PTR m$6[rsp], al

; 3944 :                         stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);

  00e65	b8 08 00 00 00	 mov	 eax, 8
  00e6a	48 6b c0 00	 imul	 rax, rax, 0
  00e6e	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00e72	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00e7a	0f b6 54 24 46	 movzx	 edx, BYTE PTR m$6[rsp]
  00e7f	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00e83	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00e88	88 44 24 62	 mov	 BYTE PTR r$11[rsp], al

; 3945 :                         stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);

  00e8c	b8 08 00 00 00	 mov	 eax, 8
  00e91	48 6b c0 01	 imul	 rax, rax, 1
  00e95	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00e99	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00ea1	0f b6 54 24 46	 movzx	 edx, BYTE PTR m$6[rsp]
  00ea6	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00eaa	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00eaf	88 44 24 61	 mov	 BYTE PTR g$10[rsp], al

; 3946 :                         stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);

  00eb3	b8 08 00 00 00	 mov	 eax, 8
  00eb8	48 6b c0 02	 imul	 rax, rax, 2
  00ebc	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00ec0	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00ec8	0f b6 54 24 46	 movzx	 edx, BYTE PTR m$6[rsp]
  00ecd	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00ed1	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00ed6	88 44 24 60	 mov	 BYTE PTR b$9[rsp], al

; 3947 :                         out[0] = stbi__compute_y(r, g, b);

  00eda	0f b6 44 24 60	 movzx	 eax, BYTE PTR b$9[rsp]
  00edf	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR g$10[rsp]
  00ee4	0f b6 54 24 62	 movzx	 edx, BYTE PTR r$11[rsp]
  00ee9	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv629[rsp], edx
  00ef0	44 8b c0	 mov	 r8d, eax
  00ef3	8b d1		 mov	 edx, ecx
  00ef5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv629[rsp]
  00efc	8b c8		 mov	 ecx, eax
  00efe	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00f03	b9 01 00 00 00	 mov	 ecx, 1
  00f08	48 6b c9 00	 imul	 rcx, rcx, 0
  00f0c	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00f11	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3948 :                         out[1] = 255;

  00f14	b8 01 00 00 00	 mov	 eax, 1
  00f19	48 6b c0 01	 imul	 rax, rax, 1
  00f1d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00f22	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3949 :                         out += n;

  00f26	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00f2b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00f30	48 03 c8	 add	 rcx, rax
  00f33	48 8b c1	 mov	 rax, rcx
  00f36	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3950 :                     }

  00f3b	e9 e7 fe ff ff	 jmp	 $LN29@load_jpeg_
$LN30@load_jpeg_:

; 3951 :                 } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {

  00f40	e9 b7 01 00 00	 jmp	 $LN76@load_jpeg_
$LN75@load_jpeg_:
  00f45	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f4d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f50	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00f54	0f 85 d8 00 00
	00		 jne	 $LN77@load_jpeg_
  00f5a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f62	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  00f69	0f 85 c3 00 00
	00		 jne	 $LN77@load_jpeg_

; 3952 :                     for (i=0; i < z->s->img_x; ++i) {

  00f6f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00f77	eb 0a		 jmp	 SHORT $LN34@load_jpeg_
$LN32@load_jpeg_:
  00f79	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00f7d	ff c0		 inc	 eax
  00f7f	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN34@load_jpeg_:
  00f83	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f8b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f8e	8b 00		 mov	 eax, DWORD PTR [rax]
  00f90	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00f94	0f 83 93 00 00
	00		 jae	 $LN33@load_jpeg_

; 3953 :                         out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);

  00f9a	b8 08 00 00 00	 mov	 eax, 8
  00f9f	48 6b c0 03	 imul	 rax, rax, 3
  00fa3	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00fa7	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00faf	ba 08 00 00 00	 mov	 edx, 8
  00fb4	48 6b d2 00	 imul	 rdx, rdx, 0
  00fb8	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$1[rsp]
  00fbd	48 8b 94 14 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$17[rsp+rdx]
  00fc5	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00fca	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00fd0	44 2b c2	 sub	 r8d, edx
  00fd3	41 8b d0	 mov	 edx, r8d
  00fd6	89 94 24 b4 00
	00 00		 mov	 DWORD PTR tv659[rsp], edx
  00fdd	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00fe1	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv659[rsp]
  00fe8	0f b6 c8	 movzx	 ecx, al
  00feb	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00ff0	b9 01 00 00 00	 mov	 ecx, 1
  00ff5	48 6b c9 00	 imul	 rcx, rcx, 0
  00ff9	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00ffe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3954 :                         out[1] = 255;

  01001	b8 01 00 00 00	 mov	 eax, 1
  01006	48 6b c0 01	 imul	 rax, rax, 1
  0100a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0100f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3955 :                         out += n;

  01013	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  01018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0101d	48 03 c8	 add	 rcx, rax
  01020	48 8b c1	 mov	 rax, rcx
  01023	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3956 :                     }

  01028	e9 4c ff ff ff	 jmp	 $LN32@load_jpeg_
$LN33@load_jpeg_:

; 3957 :                 } else {

  0102d	e9 ca 00 00 00	 jmp	 $LN78@load_jpeg_
$LN77@load_jpeg_:

; 3958 :                     stbi_uc *y = coutput[0];

  01032	b8 08 00 00 00	 mov	 eax, 8
  01037	48 6b c0 00	 imul	 rax, rax, 0
  0103b	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  01043	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR y$16[rsp], rax

; 3959 :                     if (n == 1)

  0104b	83 7c 24 48 01	 cmp	 DWORD PTR n$[rsp], 1
  01050	75 48		 jne	 SHORT $LN79@load_jpeg_

; 3960 :                         for (i=0; i < z->s->img_x; ++i) out[i] = y[i];

  01052	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0105a	eb 0a		 jmp	 SHORT $LN37@load_jpeg_
$LN35@load_jpeg_:
  0105c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  01060	ff c0		 inc	 eax
  01062	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN37@load_jpeg_:
  01066	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0106e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01071	8b 00		 mov	 eax, DWORD PTR [rax]
  01073	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  01077	73 1f		 jae	 SHORT $LN36@load_jpeg_
  01079	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0107d	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  01081	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  01086	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR y$16[rsp]
  0108e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01093	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01096	eb c4		 jmp	 SHORT $LN35@load_jpeg_
$LN36@load_jpeg_:
  01098	eb 62		 jmp	 SHORT $LN80@load_jpeg_
$LN79@load_jpeg_:

; 3961 :                     else
; 3962 :                         for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }

  0109a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  010a2	eb 0a		 jmp	 SHORT $LN40@load_jpeg_
$LN38@load_jpeg_:
  010a4	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  010a8	ff c0		 inc	 eax
  010aa	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN40@load_jpeg_:
  010ae	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  010b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010b9	8b 00		 mov	 eax, DWORD PTR [rax]
  010bb	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  010bf	73 3b		 jae	 SHORT $LN39@load_jpeg_
  010c1	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  010c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  010ca	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR y$16[rsp]
  010d2	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  010d6	88 01		 mov	 BYTE PTR [rcx], al
  010d8	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  010dd	48 ff c0	 inc	 rax
  010e0	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
  010e5	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  010ea	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  010ed	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  010f2	48 ff c0	 inc	 rax
  010f5	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
  010fa	eb a8		 jmp	 SHORT $LN38@load_jpeg_
$LN39@load_jpeg_:
$LN80@load_jpeg_:
$LN78@load_jpeg_:
$LN76@load_jpeg_:
$LN72@load_jpeg_:
$LN60@load_jpeg_:

; 3963 :                 }
; 3964 :             }
; 3965 :         }

  010fc	e9 e4 f3 ff ff	 jmp	 $LN5@load_jpeg_
$LN6@load_jpeg_:

; 3966 :         stbi__cleanup_jpeg(z);

  01101	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01109	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg

; 3967 :         *out_x = z->s->img_x;

  0110e	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01116	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01119	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR out_x$[rsp]
  01121	8b 00		 mov	 eax, DWORD PTR [rax]
  01123	89 01		 mov	 DWORD PTR [rcx], eax

; 3968 :         *out_y = z->s->img_y;

  01125	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0112d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01130	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR out_y$[rsp]
  01138	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0113b	89 01		 mov	 DWORD PTR [rcx], eax

; 3969 :         if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

  0113d	48 83 bc 24 08
	02 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  01146	74 3a		 je	 SHORT $LN81@load_jpeg_
  01148	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01150	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01153	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  01157	7c 0d		 jl	 SHORT $LN103@load_jpeg_
  01159	c7 84 24 8c 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv697[rsp], 3
  01164	eb 0b		 jmp	 SHORT $LN104@load_jpeg_
$LN103@load_jpeg_:
  01166	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv697[rsp], 1
$LN104@load_jpeg_:
  01171	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  01179	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv697[rsp]
  01180	89 08		 mov	 DWORD PTR [rax], ecx
$LN81@load_jpeg_:

; 3970 :         return output;

  01182	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR output$15[rsp]
$LN1@load_jpeg_:

; 3971 :     }
; 3972 : }

  0118a	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01192	48 33 cc	 xor	 rcx, rsp
  01195	e8 00 00 00 00	 call	 __security_check_cookie
  0119a	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  011a1	c3		 ret	 0
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ENDP	; load_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
t$ = 0
x$ = 32
y$ = 40
?stbi__blinn_8x8@@YAEEE@Z PROC				; stbi__blinn_8x8

; 3806 : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	48 83 ec 18	 sub	 rsp, 24

; 3807 :     unsigned int t = x*y + 128;

  0000c	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00011	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR y$[rsp]
  00016	0f af c1	 imul	 eax, ecx
  00019	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0001e	89 04 24	 mov	 DWORD PTR t$[rsp], eax

; 3808 :     return (stbi_uc) ((t + (t >>8)) >> 8);

  00021	8b 04 24	 mov	 eax, DWORD PTR t$[rsp]
  00024	c1 e8 08	 shr	 eax, 8
  00027	8b 0c 24	 mov	 ecx, DWORD PTR t$[rsp]
  0002a	03 c8		 add	 ecx, eax
  0002c	8b c1		 mov	 eax, ecx
  0002e	c1 e8 08	 shr	 eax, 8

; 3809 : }

  00031	48 83 c4 18	 add	 rsp, 24
  00035	c3		 ret	 0
?stbi__blinn_8x8@@YAEEE@Z ENDP				; stbi__blinn_8x8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
j$ = 48
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__cleanup_jpeg

; 3790 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3791 :     stbi__free_jpeg_components(j, j->s->img_n, 0);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	45 33 c0	 xor	 r8d, r8d
  00014	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR j$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components

; 3792 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__cleanup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
j$ = 48
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__setup_jpeg

; 3768 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3769 :     j->idct_block_kernel = stbi__idct_block;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__idct_block@@YAXPEAEHQEAF@Z ; stbi__idct_block
  00015	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3770 :     j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_row
  00028	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3771 :     j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2
  0003b	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx

; 3772 :     
; 3773 : #ifdef STBI_SSE2
; 3774 :     if (stbi__sse2_available()) {

  00042	e8 00 00 00 00	 call	 ?stbi__sse2_available@@YAHXZ ; stbi__sse2_available
  00047	85 c0		 test	 eax, eax
  00049	74 39		 je	 SHORT $LN2@stbi__setu

; 3775 :         j->idct_block_kernel = stbi__idct_simd;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__idct_simd@@YAXPEAEHQEAF@Z ; stbi__idct_simd
  00057	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3776 :         j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_simd
  0006a	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3777 :         j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2_simd
  0007d	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx
$LN2@stbi__setu:

; 3778 :     }
; 3779 : #endif
; 3780 :     
; 3781 : #ifdef STBI_NEON
; 3782 :     j->idct_block_kernel = stbi__idct_simd;
; 3783 :     j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3784 :     j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3785 : #endif
; 3786 : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__setup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
r$1 = 4
g$2 = 8
b$3 = 12
y_fixed$4 = 16
cr$5 = 20
cb$6 = 24
yws$7 = 32
signflip$8 = 48
cbw$9 = 64
crw$10 = 80
brb$11 = 96
gxb$12 = 112
t0$13 = 128
t1$14 = 144
$T15 = 160
$T16 = 176
$T17 = 192
$T18 = 208
$T19 = 224
$T20 = 240
$T21 = 256
$T22 = 272
$T23 = 288
$T24 = 304
cr_bytes$25 = 320
$T26 = 336
cb_bytes$27 = 352
$T28 = 368
y_bias$29 = 384
y_bytes$30 = 400
$T31 = 416
$T32 = 432
cr_biased$33 = 448
$T34 = 464
$T35 = 480
cb_biased$36 = 496
$T37 = 512
yw$38 = 528
$T39 = 544
cr_const0$40 = 560
$T41 = 576
cb_const0$42 = 592
$T43 = 608
cb_const1$44 = 624
$T45 = 640
cr_const1$46 = 656
$T47 = 672
cr0$48 = 688
$T49 = 704
cb0$50 = 720
$T51 = 736
cb1$52 = 752
$T53 = 768
gwt$54 = 784
cr1$55 = 800
$T56 = 816
rws$57 = 832
$T58 = 848
bws$59 = 864
$T60 = 880
gws$61 = 896
$T62 = 912
rw$63 = 928
bw$64 = 944
$T65 = 960
gw$66 = 976
xw$67 = 992
$T68 = 1008
$T69 = 1024
$T70 = 1040
$T71 = 1056
$T72 = 1072
o0$73 = 1088
o1$74 = 1104
out$ = 1136
y$ = 1144
pcb$ = 1152
pcr$ = 1160
count$ = 1168
step$ = 1176
?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z PROC	; stbi__YCbCr_to_RGB_simd

; 3633 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 04
	00 00		 sub	 rsp, 1128		; 00000468H

; 3634 :     int i = 0;

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0

; 3635 :     
; 3636 : #ifdef STBI_SSE2
; 3637 :     // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3638 :     // it's useful in practice (you wouldn't use it for textures, for example).
; 3639 :     // so just accelerate step == 4 case.
; 3640 :     if (step == 4) {

  00022	83 bc 24 98 04
	00 00 04	 cmp	 DWORD PTR step$[rsp], 4
  0002a	0f 85 c9 05 00
	00		 jne	 $LN8@stbi__YCbC

; 3641 :         // this is a fairly straightforward implementation and not super-optimized.
; 3642 :         __m128i signflip  = _mm_set1_epi8(-0x80);

  00030	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  00038	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR $T15[rsp], xmm0
  00041	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T15[rsp]
  0004a	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR signflip$8[rsp], xmm0

; 3643 :         __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));

  00050	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
  00058	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR $T16[rsp], xmm0
  00061	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T16[rsp]
  0006a	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR cr_const0$40[rsp], xmm0

; 3644 :         __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));

  00073	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
  0007b	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR $T17[rsp], xmm0
  00084	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T17[rsp]
  0008d	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR cr_const1$46[rsp], xmm0

; 3645 :         __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));

  00096	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
  0009e	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR $T18[rsp], xmm0
  000a7	66 0f 6f 84 24
	d0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T18[rsp]
  000b0	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR cb_const0$42[rsp], xmm0

; 3646 :         __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));

  000b9	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
  000c1	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR $T19[rsp], xmm0
  000ca	66 0f 6f 84 24
	e0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T19[rsp]
  000d3	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR cb_const1$44[rsp], xmm0

; 3647 :         __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);

  000dc	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  000e4	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR $T20[rsp], xmm0
  000ed	66 0f 6f 84 24
	f0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T20[rsp]
  000f6	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR y_bias$29[rsp], xmm0

; 3648 :         __m128i xw = _mm_set1_epi16(255); // alpha channel

  000ff	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  00107	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR $T21[rsp], xmm0
  00110	66 0f 6f 84 24
	00 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T21[rsp]
  00119	66 0f 7f 84 24
	e0 03 00 00	 movdqa	 XMMWORD PTR xw$67[rsp], xmm0

; 3649 :         
; 3650 :         for (; i+7 < count; i += 8) {

  00122	eb 09		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  00124	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00127	83 c0 08	 add	 eax, 8
  0012a	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
  0012d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00130	83 c0 07	 add	 eax, 7
  00133	3b 84 24 90 04
	00 00		 cmp	 eax, DWORD PTR count$[rsp]
  0013a	0f 8d b9 04 00
	00		 jge	 $LN3@stbi__YCbC

; 3651 :             // load
; 3652 :             __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));

  00140	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00144	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  0014c	48 03 c8	 add	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00156	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR $T22[rsp], xmm0
  0015f	66 0f 6f 84 24
	10 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T22[rsp]
  00168	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR y_bytes$30[rsp], xmm0

; 3653 :             __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));

  00171	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00175	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR pcr$[rsp]
  0017d	48 03 c8	 add	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00187	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR $T23[rsp], xmm0
  00190	66 0f 6f 84 24
	20 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T23[rsp]
  00199	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR cr_bytes$25[rsp], xmm0

; 3654 :             __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));

  001a2	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001a6	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR pcb$[rsp]
  001ae	48 03 c8	 add	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  001b8	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR $T24[rsp], xmm0
  001c1	66 0f 6f 84 24
	30 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T24[rsp]
  001ca	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR cb_bytes$27[rsp], xmm0

; 3655 :             __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128

  001d3	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR cr_bytes$25[rsp]
  001dc	66 0f ef 44 24
	30		 pxor	 xmm0, XMMWORD PTR signflip$8[rsp]
  001e2	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR $T26[rsp], xmm0
  001eb	66 0f 6f 84 24
	50 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T26[rsp]
  001f4	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR cr_biased$33[rsp], xmm0

; 3656 :             __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

  001fd	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR cb_bytes$27[rsp]
  00206	66 0f ef 44 24
	30		 pxor	 xmm0, XMMWORD PTR signflip$8[rsp]
  0020c	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR $T28[rsp], xmm0
  00215	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T28[rsp]
  0021e	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR cb_biased$36[rsp], xmm0

; 3657 :             
; 3658 :             // unpack to short (and left-shift cr, cb by 8)
; 3659 :             __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);

  00227	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR y_bias$29[rsp]
  00230	66 0f 60 84 24
	90 01 00 00	 punpcklbw xmm0, XMMWORD PTR y_bytes$30[rsp]
  00239	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR $T31[rsp], xmm0
  00242	66 0f 6f 84 24
	a0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T31[rsp]
  0024b	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR yw$38[rsp], xmm0

; 3660 :             __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

  00254	66 0f ef c0	 pxor	 xmm0, xmm0
  00258	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR $T32[rsp], xmm0
  00261	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T32[rsp]
  0026a	66 0f 60 84 24
	c0 01 00 00	 punpcklbw xmm0, XMMWORD PTR cr_biased$33[rsp]
  00273	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR $T34[rsp], xmm0
  0027c	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T34[rsp]
  00285	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR crw$10[rsp], xmm0

; 3661 :             __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

  0028b	66 0f ef c0	 pxor	 xmm0, xmm0
  0028f	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR $T35[rsp], xmm0
  00298	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T35[rsp]
  002a1	66 0f 60 84 24
	f0 01 00 00	 punpcklbw xmm0, XMMWORD PTR cb_biased$36[rsp]
  002aa	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR $T37[rsp], xmm0
  002b3	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T37[rsp]
  002bc	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR cbw$9[rsp], xmm0

; 3662 :             
; 3663 :             // color transform
; 3664 :             __m128i yws = _mm_srli_epi16(yw, 4);

  002c2	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR yw$38[rsp]
  002cb	66 0f 71 d0 04	 psrlw	 xmm0, 4
  002d0	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR $T39[rsp], xmm0
  002d9	66 0f 6f 84 24
	20 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T39[rsp]
  002e2	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR yws$7[rsp], xmm0

; 3665 :             __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

  002e8	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR cr_const0$40[rsp]
  002f1	66 0f e5 44 24
	50		 pmulhw	 xmm0, XMMWORD PTR crw$10[rsp]
  002f7	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR $T41[rsp], xmm0
  00300	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T41[rsp]
  00309	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR cr0$48[rsp], xmm0

; 3666 :             __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);

  00312	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR cb_const0$42[rsp]
  0031b	66 0f e5 44 24
	40		 pmulhw	 xmm0, XMMWORD PTR cbw$9[rsp]
  00321	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR $T43[rsp], xmm0
  0032a	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T43[rsp]
  00333	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR cb0$50[rsp], xmm0

; 3667 :             __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

  0033c	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR cbw$9[rsp]
  00342	66 0f e5 84 24
	70 02 00 00	 pmulhw	 xmm0, XMMWORD PTR cb_const1$44[rsp]
  0034b	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR $T45[rsp], xmm0
  00354	66 0f 6f 84 24
	80 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T45[rsp]
  0035d	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR cb1$52[rsp], xmm0

; 3668 :             __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

  00366	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR crw$10[rsp]
  0036c	66 0f e5 84 24
	90 02 00 00	 pmulhw	 xmm0, XMMWORD PTR cr_const1$46[rsp]
  00375	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR $T47[rsp], xmm0
  0037e	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T47[rsp]
  00387	66 0f 7f 84 24
	20 03 00 00	 movdqa	 XMMWORD PTR cr1$55[rsp], xmm0

; 3669 :             __m128i rws = _mm_add_epi16(cr0, yws);

  00390	66 0f 6f 84 24
	b0 02 00 00	 movdqa	 xmm0, XMMWORD PTR cr0$48[rsp]
  00399	66 0f fd 44 24
	20		 paddw	 xmm0, XMMWORD PTR yws$7[rsp]
  0039f	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR $T49[rsp], xmm0
  003a8	66 0f 6f 84 24
	c0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T49[rsp]
  003b1	66 0f 7f 84 24
	40 03 00 00	 movdqa	 XMMWORD PTR rws$57[rsp], xmm0

; 3670 :             __m128i gwt = _mm_add_epi16(cb0, yws);

  003ba	66 0f 6f 84 24
	d0 02 00 00	 movdqa	 xmm0, XMMWORD PTR cb0$50[rsp]
  003c3	66 0f fd 44 24
	20		 paddw	 xmm0, XMMWORD PTR yws$7[rsp]
  003c9	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR $T51[rsp], xmm0
  003d2	66 0f 6f 84 24
	e0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T51[rsp]
  003db	66 0f 7f 84 24
	10 03 00 00	 movdqa	 XMMWORD PTR gwt$54[rsp], xmm0

; 3671 :             __m128i bws = _mm_add_epi16(yws, cb1);

  003e4	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR yws$7[rsp]
  003ea	66 0f fd 84 24
	f0 02 00 00	 paddw	 xmm0, XMMWORD PTR cb1$52[rsp]
  003f3	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR $T53[rsp], xmm0
  003fc	66 0f 6f 84 24
	00 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T53[rsp]
  00405	66 0f 7f 84 24
	60 03 00 00	 movdqa	 XMMWORD PTR bws$59[rsp], xmm0

; 3672 :             __m128i gws = _mm_add_epi16(gwt, cr1);

  0040e	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR gwt$54[rsp]
  00417	66 0f fd 84 24
	20 03 00 00	 paddw	 xmm0, XMMWORD PTR cr1$55[rsp]
  00420	66 0f 7f 84 24
	30 03 00 00	 movdqa	 XMMWORD PTR $T56[rsp], xmm0
  00429	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T56[rsp]
  00432	66 0f 7f 84 24
	80 03 00 00	 movdqa	 XMMWORD PTR gws$61[rsp], xmm0

; 3673 :             
; 3674 :             // descale
; 3675 :             __m128i rw = _mm_srai_epi16(rws, 4);

  0043b	66 0f 6f 84 24
	40 03 00 00	 movdqa	 xmm0, XMMWORD PTR rws$57[rsp]
  00444	66 0f 71 e0 04	 psraw	 xmm0, 4
  00449	66 0f 7f 84 24
	50 03 00 00	 movdqa	 XMMWORD PTR $T58[rsp], xmm0
  00452	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T58[rsp]
  0045b	66 0f 7f 84 24
	a0 03 00 00	 movdqa	 XMMWORD PTR rw$63[rsp], xmm0

; 3676 :             __m128i bw = _mm_srai_epi16(bws, 4);

  00464	66 0f 6f 84 24
	60 03 00 00	 movdqa	 xmm0, XMMWORD PTR bws$59[rsp]
  0046d	66 0f 71 e0 04	 psraw	 xmm0, 4
  00472	66 0f 7f 84 24
	70 03 00 00	 movdqa	 XMMWORD PTR $T60[rsp], xmm0
  0047b	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T60[rsp]
  00484	66 0f 7f 84 24
	b0 03 00 00	 movdqa	 XMMWORD PTR bw$64[rsp], xmm0

; 3677 :             __m128i gw = _mm_srai_epi16(gws, 4);

  0048d	66 0f 6f 84 24
	80 03 00 00	 movdqa	 xmm0, XMMWORD PTR gws$61[rsp]
  00496	66 0f 71 e0 04	 psraw	 xmm0, 4
  0049b	66 0f 7f 84 24
	90 03 00 00	 movdqa	 XMMWORD PTR $T62[rsp], xmm0
  004a4	66 0f 6f 84 24
	90 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T62[rsp]
  004ad	66 0f 7f 84 24
	d0 03 00 00	 movdqa	 XMMWORD PTR gw$66[rsp], xmm0

; 3678 :             
; 3679 :             // back to byte, set up for transpose
; 3680 :             __m128i brb = _mm_packus_epi16(rw, bw);

  004b6	66 0f 6f 84 24
	a0 03 00 00	 movdqa	 xmm0, XMMWORD PTR rw$63[rsp]
  004bf	66 0f 67 84 24
	b0 03 00 00	 packuswb xmm0, XMMWORD PTR bw$64[rsp]
  004c8	66 0f 7f 84 24
	c0 03 00 00	 movdqa	 XMMWORD PTR $T65[rsp], xmm0
  004d1	66 0f 6f 84 24
	c0 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T65[rsp]
  004da	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR brb$11[rsp], xmm0

; 3681 :             __m128i gxb = _mm_packus_epi16(gw, xw);

  004e0	66 0f 6f 84 24
	d0 03 00 00	 movdqa	 xmm0, XMMWORD PTR gw$66[rsp]
  004e9	66 0f 67 84 24
	e0 03 00 00	 packuswb xmm0, XMMWORD PTR xw$67[rsp]
  004f2	66 0f 7f 84 24
	f0 03 00 00	 movdqa	 XMMWORD PTR $T68[rsp], xmm0
  004fb	66 0f 6f 84 24
	f0 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T68[rsp]
  00504	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR gxb$12[rsp], xmm0

; 3682 :             
; 3683 :             // transpose to interleave channels
; 3684 :             __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

  0050a	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR brb$11[rsp]
  00510	66 0f 60 44 24
	70		 punpcklbw xmm0, XMMWORD PTR gxb$12[rsp]
  00516	66 0f 7f 84 24
	00 04 00 00	 movdqa	 XMMWORD PTR $T69[rsp], xmm0
  0051f	66 0f 6f 84 24
	00 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T69[rsp]
  00528	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR t0$13[rsp], xmm0

; 3685 :             __m128i t1 = _mm_unpackhi_epi8(brb, gxb);

  00531	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR brb$11[rsp]
  00537	66 0f 68 44 24
	70		 punpckhbw xmm0, XMMWORD PTR gxb$12[rsp]
  0053d	66 0f 7f 84 24
	10 04 00 00	 movdqa	 XMMWORD PTR $T70[rsp], xmm0
  00546	66 0f 6f 84 24
	10 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T70[rsp]
  0054f	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR t1$14[rsp], xmm0

; 3686 :             __m128i o0 = _mm_unpacklo_epi16(t0, t1);

  00558	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR t0$13[rsp]
  00561	66 0f 61 84 24
	90 00 00 00	 punpcklwd xmm0, XMMWORD PTR t1$14[rsp]
  0056a	66 0f 7f 84 24
	20 04 00 00	 movdqa	 XMMWORD PTR $T71[rsp], xmm0
  00573	66 0f 6f 84 24
	20 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T71[rsp]
  0057c	66 0f 7f 84 24
	40 04 00 00	 movdqa	 XMMWORD PTR o0$73[rsp], xmm0

; 3687 :             __m128i o1 = _mm_unpackhi_epi16(t0, t1);

  00585	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR t0$13[rsp]
  0058e	66 0f 69 84 24
	90 00 00 00	 punpckhwd xmm0, XMMWORD PTR t1$14[rsp]
  00597	66 0f 7f 84 24
	30 04 00 00	 movdqa	 XMMWORD PTR $T72[rsp], xmm0
  005a0	66 0f 6f 84 24
	30 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T72[rsp]
  005a9	66 0f 7f 84 24
	50 04 00 00	 movdqa	 XMMWORD PTR o1$74[rsp], xmm0

; 3688 :             
; 3689 :             // store
; 3690 :             _mm_storeu_si128((__m128i *) (out + 0), o0);

  005b2	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005ba	66 0f 6f 84 24
	40 04 00 00	 movdqa	 xmm0, XMMWORD PTR o0$73[rsp]
  005c3	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3691 :             _mm_storeu_si128((__m128i *) (out + 16), o1);

  005c7	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005cf	48 83 c0 10	 add	 rax, 16
  005d3	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR o1$74[rsp]
  005dc	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3692 :             out += 32;

  005e0	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005e8	48 83 c0 20	 add	 rax, 32			; 00000020H
  005ec	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR out$[rsp], rax

; 3693 :         }

  005f4	e9 2b fb ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:
$LN8@stbi__YCbC:

; 3694 :     }
; 3695 : #endif
; 3696 :     
; 3697 : #ifdef STBI_NEON
; 3698 :     // in this version, step=3 support would be easy to add. but is there demand?
; 3699 :     if (step == 4) {
; 3700 :         // this is a fairly straightforward implementation and not super-optimized.
; 3701 :         uint8x8_t signflip = vdup_n_u8(0x80);
; 3702 :         int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3703 :         int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3704 :         int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3705 :         int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3706 :         
; 3707 :         for (; i+7 < count; i += 8) {
; 3708 :             // load
; 3709 :             uint8x8_t y_bytes  = vld1_u8(y + i);
; 3710 :             uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3711 :             uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3712 :             int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3713 :             int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3714 :             
; 3715 :             // expand to s16
; 3716 :             int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3717 :             int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3718 :             int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3719 :             
; 3720 :             // color transform
; 3721 :             int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3722 :             int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3723 :             int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3724 :             int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3725 :             int16x8_t rws = vaddq_s16(yws, cr0);
; 3726 :             int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3727 :             int16x8_t bws = vaddq_s16(yws, cb1);
; 3728 :             
; 3729 :             // undo scaling, round, convert to byte
; 3730 :             uint8x8x4_t o;
; 3731 :             o.val[0] = vqrshrun_n_s16(rws, 4);
; 3732 :             o.val[1] = vqrshrun_n_s16(gws, 4);
; 3733 :             o.val[2] = vqrshrun_n_s16(bws, 4);
; 3734 :             o.val[3] = vdup_n_u8(255);
; 3735 :             
; 3736 :             // store, interleaving r/g/b/a
; 3737 :             vst4_u8(out, o);
; 3738 :             out += 8*4;
; 3739 :         }
; 3740 :     }
; 3741 : #endif
; 3742 :     
; 3743 :     for (; i < count; ++i) {

  005f9	eb 08		 jmp	 SHORT $LN7@stbi__YCbC
$LN5@stbi__YCbC:
  005fb	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  005fe	ff c0		 inc	 eax
  00600	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__YCbC:
  00603	8b 84 24 90 04
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0060a	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0060d	0f 8d a7 01 00
	00		 jge	 $LN6@stbi__YCbC

; 3744 :         int y_fixed = (y[i] << 20) + (1<<19); // rounding

  00613	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00617	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  0061f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00623	c1 e0 14	 shl	 eax, 20
  00626	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  0062b	89 44 24 10	 mov	 DWORD PTR y_fixed$4[rsp], eax

; 3745 :         int r,g,b;
; 3746 :         int cr = pcr[i] - 128;

  0062f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00633	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR pcr$[rsp]
  0063b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0063f	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00644	89 44 24 14	 mov	 DWORD PTR cr$5[rsp], eax

; 3747 :         int cb = pcb[i] - 128;

  00648	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0064c	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR pcb$[rsp]
  00654	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00658	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0065d	89 44 24 18	 mov	 DWORD PTR cb$6[rsp], eax

; 3748 :         r = y_fixed + cr* stbi__float2fixed(1.40200f);

  00661	69 44 24 14 00
	6f 16 00	 imul	 eax, DWORD PTR cr$5[rsp], 1470208 ; 00166f00H
  00669	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  0066d	03 c8		 add	 ecx, eax
  0066f	8b c1		 mov	 eax, ecx
  00671	89 44 24 04	 mov	 DWORD PTR r$1[rsp], eax

; 3749 :         g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

  00675	69 44 24 14 00
	93 f4 ff	 imul	 eax, DWORD PTR cr$5[rsp], -748800 ; fffffffffff49300H
  0067d	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  00681	03 c8		 add	 ecx, eax
  00683	8b c1		 mov	 eax, ecx
  00685	69 4c 24 18 00
	7e fa ff	 imul	 ecx, DWORD PTR cb$6[rsp], -360960 ; fffffffffffa7e00H
  0068d	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00693	03 c1		 add	 eax, ecx
  00695	89 44 24 08	 mov	 DWORD PTR g$2[rsp], eax

; 3750 :         b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);

  00699	69 44 24 18 00
	5a 1c 00	 imul	 eax, DWORD PTR cb$6[rsp], 1858048 ; 001c5a00H
  006a1	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  006a5	03 c8		 add	 ecx, eax
  006a7	8b c1		 mov	 eax, ecx
  006a9	89 44 24 0c	 mov	 DWORD PTR b$3[rsp], eax

; 3751 :         r >>= 20;

  006ad	8b 44 24 04	 mov	 eax, DWORD PTR r$1[rsp]
  006b1	c1 f8 14	 sar	 eax, 20
  006b4	89 44 24 04	 mov	 DWORD PTR r$1[rsp], eax

; 3752 :         g >>= 20;

  006b8	8b 44 24 08	 mov	 eax, DWORD PTR g$2[rsp]
  006bc	c1 f8 14	 sar	 eax, 20
  006bf	89 44 24 08	 mov	 DWORD PTR g$2[rsp], eax

; 3753 :         b >>= 20;

  006c3	8b 44 24 0c	 mov	 eax, DWORD PTR b$3[rsp]
  006c7	c1 f8 14	 sar	 eax, 20
  006ca	89 44 24 0c	 mov	 DWORD PTR b$3[rsp], eax

; 3754 :         if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  006ce	81 7c 24 04 ff
	00 00 00	 cmp	 DWORD PTR r$1[rsp], 255	; 000000ffH
  006d6	76 19		 jbe	 SHORT $LN9@stbi__YCbC
  006d8	83 7c 24 04 00	 cmp	 DWORD PTR r$1[rsp], 0
  006dd	7d 0a		 jge	 SHORT $LN10@stbi__YCbC
  006df	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR r$1[rsp], 0
  006e7	eb 08		 jmp	 SHORT $LN11@stbi__YCbC
$LN10@stbi__YCbC:
  006e9	c7 44 24 04 ff
	00 00 00	 mov	 DWORD PTR r$1[rsp], 255	; 000000ffH
$LN11@stbi__YCbC:
$LN9@stbi__YCbC:

; 3755 :         if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  006f1	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR g$2[rsp], 255	; 000000ffH
  006f9	76 19		 jbe	 SHORT $LN12@stbi__YCbC
  006fb	83 7c 24 08 00	 cmp	 DWORD PTR g$2[rsp], 0
  00700	7d 0a		 jge	 SHORT $LN13@stbi__YCbC
  00702	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR g$2[rsp], 0
  0070a	eb 08		 jmp	 SHORT $LN14@stbi__YCbC
$LN13@stbi__YCbC:
  0070c	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR g$2[rsp], 255	; 000000ffH
$LN14@stbi__YCbC:
$LN12@stbi__YCbC:

; 3756 :         if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  00714	81 7c 24 0c ff
	00 00 00	 cmp	 DWORD PTR b$3[rsp], 255	; 000000ffH
  0071c	76 19		 jbe	 SHORT $LN15@stbi__YCbC
  0071e	83 7c 24 0c 00	 cmp	 DWORD PTR b$3[rsp], 0
  00723	7d 0a		 jge	 SHORT $LN16@stbi__YCbC
  00725	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR b$3[rsp], 0
  0072d	eb 08		 jmp	 SHORT $LN17@stbi__YCbC
$LN16@stbi__YCbC:
  0072f	c7 44 24 0c ff
	00 00 00	 mov	 DWORD PTR b$3[rsp], 255	; 000000ffH
$LN17@stbi__YCbC:
$LN15@stbi__YCbC:

; 3757 :         out[0] = (stbi_uc)r;

  00737	b8 01 00 00 00	 mov	 eax, 1
  0073c	48 6b c0 00	 imul	 rax, rax, 0
  00740	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00748	0f b6 54 24 04	 movzx	 edx, BYTE PTR r$1[rsp]
  0074d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3758 :         out[1] = (stbi_uc)g;

  00750	b8 01 00 00 00	 mov	 eax, 1
  00755	48 6b c0 01	 imul	 rax, rax, 1
  00759	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00761	0f b6 54 24 08	 movzx	 edx, BYTE PTR g$2[rsp]
  00766	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3759 :         out[2] = (stbi_uc)b;

  00769	b8 01 00 00 00	 mov	 eax, 1
  0076e	48 6b c0 02	 imul	 rax, rax, 2
  00772	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0077a	0f b6 54 24 0c	 movzx	 edx, BYTE PTR b$3[rsp]
  0077f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3760 :         out[3] = 255;

  00782	b8 01 00 00 00	 mov	 eax, 1
  00787	48 6b c0 03	 imul	 rax, rax, 3
  0078b	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00793	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3761 :         out += step;

  00797	48 63 84 24 98
	04 00 00	 movsxd	 rax, DWORD PTR step$[rsp]
  0079f	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  007a7	48 03 c8	 add	 rcx, rax
  007aa	48 8b c1	 mov	 rax, rcx
  007ad	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR out$[rsp], rax

; 3762 :     }

  007b5	e9 41 fe ff ff	 jmp	 $LN5@stbi__YCbC
$LN6@stbi__YCbC:

; 3763 : }

  007ba	48 81 c4 68 04
	00 00		 add	 rsp, 1128		; 00000468H
  007c1	c3		 ret	 0
?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z ENDP	; stbi__YCbCr_to_RGB_simd
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$1 = 0
g$2 = 4
b$3 = 8
i$ = 12
y_fixed$4 = 16
cr$5 = 20
cb$6 = 24
out$ = 48
y$ = 56
pcb$ = 64
pcr$ = 72
count$ = 80
step$ = 88
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z PROC		; stbi__YCbCr_to_RGB_row

; 3607 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3608 :     int i;
; 3609 :     for (i=0; i < count; ++i) {

  00018	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00020	eb 0a		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  00022	8b 44 24 0c	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 44 24 0c	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
  0002c	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  00030	39 44 24 0c	 cmp	 DWORD PTR i$[rsp], eax
  00034	0f 8d 84 01 00
	00		 jge	 $LN3@stbi__YCbC

; 3610 :         int y_fixed = (y[i] << 20) + (1<<19); // rounding

  0003a	48 63 44 24 0c	 movsxd	 rax, DWORD PTR i$[rsp]
  0003f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR y$[rsp]
  00044	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00048	c1 e0 14	 shl	 eax, 20
  0004b	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  00050	89 44 24 10	 mov	 DWORD PTR y_fixed$4[rsp], eax

; 3611 :         int r,g,b;
; 3612 :         int cr = pcr[i] - 128;

  00054	48 63 44 24 0c	 movsxd	 rax, DWORD PTR i$[rsp]
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pcr$[rsp]
  0005e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00062	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00067	89 44 24 14	 mov	 DWORD PTR cr$5[rsp], eax

; 3613 :         int cb = pcb[i] - 128;

  0006b	48 63 44 24 0c	 movsxd	 rax, DWORD PTR i$[rsp]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pcb$[rsp]
  00075	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00079	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0007e	89 44 24 18	 mov	 DWORD PTR cb$6[rsp], eax

; 3614 :         r = y_fixed +  cr* stbi__float2fixed(1.40200f);

  00082	69 44 24 14 00
	6f 16 00	 imul	 eax, DWORD PTR cr$5[rsp], 1470208 ; 00166f00H
  0008a	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  0008e	03 c8		 add	 ecx, eax
  00090	8b c1		 mov	 eax, ecx
  00092	89 04 24	 mov	 DWORD PTR r$1[rsp], eax

; 3615 :         g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

  00095	69 44 24 14 00
	93 f4 ff	 imul	 eax, DWORD PTR cr$5[rsp], -748800 ; fffffffffff49300H
  0009d	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  000a1	03 c8		 add	 ecx, eax
  000a3	8b c1		 mov	 eax, ecx
  000a5	69 4c 24 18 00
	7e fa ff	 imul	 ecx, DWORD PTR cb$6[rsp], -360960 ; fffffffffffa7e00H
  000ad	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  000b3	03 c1		 add	 eax, ecx
  000b5	89 44 24 04	 mov	 DWORD PTR g$2[rsp], eax

; 3616 :         b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);

  000b9	69 44 24 18 00
	5a 1c 00	 imul	 eax, DWORD PTR cb$6[rsp], 1858048 ; 001c5a00H
  000c1	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  000c5	03 c8		 add	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	89 44 24 08	 mov	 DWORD PTR b$3[rsp], eax

; 3617 :         r >>= 20;

  000cd	8b 04 24	 mov	 eax, DWORD PTR r$1[rsp]
  000d0	c1 f8 14	 sar	 eax, 20
  000d3	89 04 24	 mov	 DWORD PTR r$1[rsp], eax

; 3618 :         g >>= 20;

  000d6	8b 44 24 04	 mov	 eax, DWORD PTR g$2[rsp]
  000da	c1 f8 14	 sar	 eax, 20
  000dd	89 44 24 04	 mov	 DWORD PTR g$2[rsp], eax

; 3619 :         b >>= 20;

  000e1	8b 44 24 08	 mov	 eax, DWORD PTR b$3[rsp]
  000e5	c1 f8 14	 sar	 eax, 20
  000e8	89 44 24 08	 mov	 DWORD PTR b$3[rsp], eax

; 3620 :         if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  000ec	81 3c 24 ff 00
	00 00		 cmp	 DWORD PTR r$1[rsp], 255	; 000000ffH
  000f3	76 16		 jbe	 SHORT $LN5@stbi__YCbC
  000f5	83 3c 24 00	 cmp	 DWORD PTR r$1[rsp], 0
  000f9	7d 09		 jge	 SHORT $LN6@stbi__YCbC
  000fb	c7 04 24 00 00
	00 00		 mov	 DWORD PTR r$1[rsp], 0
  00102	eb 07		 jmp	 SHORT $LN7@stbi__YCbC
$LN6@stbi__YCbC:
  00104	c7 04 24 ff 00
	00 00		 mov	 DWORD PTR r$1[rsp], 255	; 000000ffH
$LN7@stbi__YCbC:
$LN5@stbi__YCbC:

; 3621 :         if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  0010b	81 7c 24 04 ff
	00 00 00	 cmp	 DWORD PTR g$2[rsp], 255	; 000000ffH
  00113	76 19		 jbe	 SHORT $LN8@stbi__YCbC
  00115	83 7c 24 04 00	 cmp	 DWORD PTR g$2[rsp], 0
  0011a	7d 0a		 jge	 SHORT $LN9@stbi__YCbC
  0011c	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR g$2[rsp], 0
  00124	eb 08		 jmp	 SHORT $LN10@stbi__YCbC
$LN9@stbi__YCbC:
  00126	c7 44 24 04 ff
	00 00 00	 mov	 DWORD PTR g$2[rsp], 255	; 000000ffH
$LN10@stbi__YCbC:
$LN8@stbi__YCbC:

; 3622 :         if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  0012e	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR b$3[rsp], 255	; 000000ffH
  00136	76 19		 jbe	 SHORT $LN11@stbi__YCbC
  00138	83 7c 24 08 00	 cmp	 DWORD PTR b$3[rsp], 0
  0013d	7d 0a		 jge	 SHORT $LN12@stbi__YCbC
  0013f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR b$3[rsp], 0
  00147	eb 08		 jmp	 SHORT $LN13@stbi__YCbC
$LN12@stbi__YCbC:
  00149	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR b$3[rsp], 255	; 000000ffH
$LN13@stbi__YCbC:
$LN11@stbi__YCbC:

; 3623 :         out[0] = (stbi_uc)r;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	48 6b c0 00	 imul	 rax, rax, 0
  0015a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0015f	0f b6 14 24	 movzx	 edx, BYTE PTR r$1[rsp]
  00163	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3624 :         out[1] = (stbi_uc)g;

  00166	b8 01 00 00 00	 mov	 eax, 1
  0016b	48 6b c0 01	 imul	 rax, rax, 1
  0016f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00174	0f b6 54 24 04	 movzx	 edx, BYTE PTR g$2[rsp]
  00179	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3625 :         out[2] = (stbi_uc)b;

  0017c	b8 01 00 00 00	 mov	 eax, 1
  00181	48 6b c0 02	 imul	 rax, rax, 2
  00185	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0018a	0f b6 54 24 08	 movzx	 edx, BYTE PTR b$3[rsp]
  0018f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3626 :         out[3] = 255;

  00192	b8 01 00 00 00	 mov	 eax, 1
  00197	48 6b c0 03	 imul	 rax, rax, 3
  0019b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  001a0	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3627 :         out += step;

  001a4	48 63 44 24 58	 movsxd	 rax, DWORD PTR step$[rsp]
  001a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  001ae	48 03 c8	 add	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 3628 :     }

  001b9	e9 64 fe ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:

; 3629 : }

  001be	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001c2	c3		 ret	 0
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ENDP		; stbi__YCbCr_to_RGB_row
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
j$ = 4
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_generic

; 3593 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3594 :     // resample with nearest-neighbor
; 3595 :     int i,j;
; 3596 :     STBI_NOTUSED(in_far);
; 3597 :     for (i=0; i < w; ++i)

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00021	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  0002d	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00030	7d 47		 jge	 SHORT $LN3@stbi__resa

; 3598 :         for (j=0; j < hs; ++j)

  00032	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0003a	eb 0a		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  0003c	8b 44 24 04	 mov	 eax, DWORD PTR j$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 04	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__resa:
  00046	8b 44 24 40	 mov	 eax, DWORD PTR hs$[rsp]
  0004a	39 44 24 04	 cmp	 DWORD PTR j$[rsp], eax
  0004e	7d 27		 jge	 SHORT $LN6@stbi__resa

; 3599 :         out[i*hs+j] = in_near[i];

  00050	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00054	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00057	0f af 4c 24 40	 imul	 ecx, DWORD PTR hs$[rsp]
  0005c	03 4c 24 04	 add	 ecx, DWORD PTR j$[rsp]
  00060	48 63 c9	 movsxd	 rcx, ecx
  00063	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00068	4c 8b 44 24 28	 mov	 r8, QWORD PTR in_near$[rsp]
  0006d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00072	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00075	eb c5		 jmp	 SHORT $LN5@stbi__resa
$LN6@stbi__resa:
  00077	eb a8		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3600 :     return out;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]

; 3601 : }

  0007e	48 83 c4 18	 add	 rsp, 24
  00082	c3		 ret	 0
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_generic
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
t1$ = 4
t0$ = 8
tv78 = 12
curr$1 = 16
zero$2 = 32
nearw$3 = 48
curb$4 = 64
even$5 = 80
odd$6 = 96
$T7 = 112
$T8 = 128
$T9 = 144
farb$10 = 160
$T11 = 176
nearb$12 = 192
$T13 = 208
farw$14 = 224
$T15 = 240
$T16 = 256
nears$17 = 272
diff$18 = 288
$T19 = 304
$T20 = 320
$T21 = 336
prv0$22 = 352
$T23 = 368
nxt0$24 = 384
$T25 = 400
$T26 = 416
$T27 = 432
prev$28 = 448
$T29 = 464
next$30 = 480
$T31 = 496
curs$32 = 512
bias$33 = 528
$T34 = 544
prvd$35 = 560
$T36 = 576
nxtd$37 = 592
$T38 = 608
$T39 = 624
$T40 = 640
int0$41 = 656
$T42 = 672
int1$43 = 688
$T44 = 704
de0$45 = 720
de1$46 = 736
$T47 = 752
outv$48 = 768
out$ = 800
in_near$ = 808
in_far$ = 816
w$ = 824
hs$ = 832
?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_hv_2_simd

; 3477 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 03
	00 00		 sub	 rsp, 792		; 00000318H

; 3478 :     // need to generate 2x2 samples for every one in input
; 3479 :     int i=0,t0,t1;

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0

; 3480 :     
; 3481 :     if (w == 1) {

  00022	83 bc 24 38 03
	00 00 01	 cmp	 DWORD PTR w$[rsp], 1
  0002a	75 77		 jne	 SHORT $LN8@stbi__resa

; 3482 :         out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 00	 imul	 rax, rax, 0
  00035	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	6b c0 03	 imul	 eax, eax, 3
  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	48 6b c9 00	 imul	 rcx, rcx, 0
  0004d	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00055	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00059	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0005d	c1 f8 02	 sar	 eax, 2
  00060	89 44 24 0c	 mov	 DWORD PTR tv78[rsp], eax
  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 01	 imul	 rax, rax, 1
  0006d	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00075	0f b6 54 24 0c	 movzx	 edx, BYTE PTR tv78[rsp]
  0007a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 00	 imul	 rax, rax, 0
  00086	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0008e	0f b6 54 24 0c	 movzx	 edx, BYTE PTR tv78[rsp]
  00093	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3483 :         return out;

  00096	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0009e	e9 ba 05 00 00	 jmp	 $LN1@stbi__resa
$LN8@stbi__resa:

; 3484 :     }
; 3485 :     
; 3486 :     t1 = 3*in_near[0] + in_far[0];

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	48 6b c0 00	 imul	 rax, rax, 0
  000ac	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  000b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b8	6b c0 03	 imul	 eax, eax, 3
  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	48 6b c9 00	 imul	 rcx, rcx, 0
  000c4	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  000cc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d0	03 c1		 add	 eax, ecx
  000d2	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3487 :     // process groups of 8 pixels for as long as we can.
; 3488 :     // note we can't handle the last pixel in a row in this loop
; 3489 :     // because we need to handle the filter boundary conditions.
; 3490 :     for (; i < ((w-1) & ~7); i += 8) {

  000d6	eb 09		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000d8	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000db	83 c0 08	 add	 eax, 8
  000de	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000e1	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  000e8	ff c8		 dec	 eax
  000ea	83 e0 f8	 and	 eax, -8
  000ed	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000f0	0f 8d 4c 04 00
	00		 jge	 $LN3@stbi__resa

; 3491 : #if defined(STBI_SSE2)
; 3492 :         // load and perform the vertical filtering pass
; 3493 :         // this uses 3*x + y = 4*x + (y - x)
; 3494 :         __m128i zero  = _mm_setzero_si128();

  000f6	66 0f ef c0	 pxor	 xmm0, xmm0
  000fa	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR $T7[rsp], xmm0
  00100	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR $T7[rsp]
  00106	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR zero$2[rsp], xmm0

; 3495 :         __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));

  0010c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00110	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR in_far$[rsp]
  00118	48 03 c8	 add	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00122	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR $T8[rsp], xmm0
  0012b	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T8[rsp]
  00134	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR farb$10[rsp], xmm0

; 3496 :         __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));

  0013d	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00141	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  00149	48 03 c8	 add	 rcx, rax
  0014c	48 8b c1	 mov	 rax, rcx
  0014f	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00153	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR $T9[rsp], xmm0
  0015c	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T9[rsp]
  00165	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR nearb$12[rsp], xmm0

; 3497 :         __m128i farw  = _mm_unpacklo_epi8(farb, zero);

  0016e	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR farb$10[rsp]
  00177	66 0f 60 44 24
	20		 punpcklbw xmm0, XMMWORD PTR zero$2[rsp]
  0017d	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR $T11[rsp], xmm0
  00186	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T11[rsp]
  0018f	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR farw$14[rsp], xmm0

; 3498 :         __m128i nearw = _mm_unpacklo_epi8(nearb, zero);

  00198	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR nearb$12[rsp]
  001a1	66 0f 60 44 24
	20		 punpcklbw xmm0, XMMWORD PTR zero$2[rsp]
  001a7	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR $T13[rsp], xmm0
  001b0	66 0f 6f 84 24
	d0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T13[rsp]
  001b9	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR nearw$3[rsp], xmm0

; 3499 :         __m128i diff  = _mm_sub_epi16(farw, nearw);

  001bf	66 0f 6f 84 24
	e0 00 00 00	 movdqa	 xmm0, XMMWORD PTR farw$14[rsp]
  001c8	66 0f f9 44 24
	30		 psubw	 xmm0, XMMWORD PTR nearw$3[rsp]
  001ce	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR $T15[rsp], xmm0
  001d7	66 0f 6f 84 24
	f0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T15[rsp]
  001e0	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR diff$18[rsp], xmm0

; 3500 :         __m128i nears = _mm_slli_epi16(nearw, 2);

  001e9	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR nearw$3[rsp]
  001ef	66 0f 71 f0 02	 psllw	 xmm0, 2
  001f4	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR $T16[rsp], xmm0
  001fd	66 0f 6f 84 24
	00 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T16[rsp]
  00206	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR nears$17[rsp], xmm0

; 3501 :         __m128i curr  = _mm_add_epi16(nears, diff); // current row

  0020f	66 0f 6f 84 24
	10 01 00 00	 movdqa	 xmm0, XMMWORD PTR nears$17[rsp]
  00218	66 0f fd 84 24
	20 01 00 00	 paddw	 xmm0, XMMWORD PTR diff$18[rsp]
  00221	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR $T19[rsp], xmm0
  0022a	66 0f 6f 84 24
	30 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T19[rsp]
  00233	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR curr$1[rsp], xmm0

; 3502 :         
; 3503 :         // horizontal filter works the same based on shifted vers of current
; 3504 :         // row. "prev" is current row shifted right by 1 pixel; we need to
; 3505 :         // insert the previous pixel value (from t1).
; 3506 :         // "next" is current row shifted left by 1 pixel, with first pixel
; 3507 :         // of next block of 8 pixels added in.
; 3508 :         __m128i prv0 = _mm_slli_si128(curr, 2);

  00239	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR curr$1[rsp]
  0023f	66 0f 73 f8 02	 pslldq	 xmm0, 2
  00244	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR $T20[rsp], xmm0
  0024d	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T20[rsp]
  00256	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR prv0$22[rsp], xmm0

; 3509 :         __m128i nxt0 = _mm_srli_si128(curr, 2);

  0025f	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR curr$1[rsp]
  00265	66 0f 73 d8 02	 psrldq	 xmm0, 2
  0026a	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR $T21[rsp], xmm0
  00273	66 0f 6f 84 24
	50 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T21[rsp]
  0027c	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR nxt0$24[rsp], xmm0

; 3510 :         __m128i prev = _mm_insert_epi16(prv0, t1, 0);

  00285	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR prv0$22[rsp]
  0028e	66 0f c4 44 24
	04 00		 pinsrw	 xmm0, DWORD PTR t1$[rsp], 0
  00295	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR $T23[rsp], xmm0
  0029e	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T23[rsp]
  002a7	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR prev$28[rsp], xmm0

; 3511 :         __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

  002b0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  002b3	83 c0 08	 add	 eax, 8
  002b6	48 98		 cdqe
  002b8	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  002c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c4	6b c0 03	 imul	 eax, eax, 3
  002c7	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  002ca	83 c1 08	 add	 ecx, 8
  002cd	48 63 c9	 movsxd	 rcx, ecx
  002d0	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  002d8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002dc	03 c1		 add	 eax, ecx
  002de	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR nxt0$24[rsp]
  002e7	66 0f c4 c0 07	 pinsrw	 xmm0, eax, 7
  002ec	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR $T25[rsp], xmm0
  002f5	66 0f 6f 84 24
	90 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T25[rsp]
  002fe	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR next$30[rsp], xmm0

; 3512 :         
; 3513 :         // horizontal filter, polyphase implementation since it's convenient:
; 3514 :         // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3515 :         // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3516 :         // note the shared term.
; 3517 :         __m128i bias  = _mm_set1_epi16(8);

  00307	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00080008000800080008000800080008
  0030f	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR $T26[rsp], xmm0
  00318	66 0f 6f 84 24
	a0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T26[rsp]
  00321	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR bias$33[rsp], xmm0

; 3518 :         __m128i curs = _mm_slli_epi16(curr, 2);

  0032a	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR curr$1[rsp]
  00330	66 0f 71 f0 02	 psllw	 xmm0, 2
  00335	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR $T27[rsp], xmm0
  0033e	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T27[rsp]
  00347	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR curs$32[rsp], xmm0

; 3519 :         __m128i prvd = _mm_sub_epi16(prev, curr);

  00350	66 0f 6f 84 24
	c0 01 00 00	 movdqa	 xmm0, XMMWORD PTR prev$28[rsp]
  00359	66 0f f9 44 24
	10		 psubw	 xmm0, XMMWORD PTR curr$1[rsp]
  0035f	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR $T29[rsp], xmm0
  00368	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T29[rsp]
  00371	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR prvd$35[rsp], xmm0

; 3520 :         __m128i nxtd = _mm_sub_epi16(next, curr);

  0037a	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR next$30[rsp]
  00383	66 0f f9 44 24
	10		 psubw	 xmm0, XMMWORD PTR curr$1[rsp]
  00389	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR $T31[rsp], xmm0
  00392	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T31[rsp]
  0039b	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR nxtd$37[rsp], xmm0

; 3521 :         __m128i curb = _mm_add_epi16(curs, bias);

  003a4	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR curs$32[rsp]
  003ad	66 0f fd 84 24
	10 02 00 00	 paddw	 xmm0, XMMWORD PTR bias$33[rsp]
  003b6	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR $T34[rsp], xmm0
  003bf	66 0f 6f 84 24
	20 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T34[rsp]
  003c8	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR curb$4[rsp], xmm0

; 3522 :         __m128i even = _mm_add_epi16(prvd, curb);

  003ce	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR prvd$35[rsp]
  003d7	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR curb$4[rsp]
  003dd	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR $T36[rsp], xmm0
  003e6	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T36[rsp]
  003ef	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR even$5[rsp], xmm0

; 3523 :         __m128i odd  = _mm_add_epi16(nxtd, curb);

  003f5	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR nxtd$37[rsp]
  003fe	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR curb$4[rsp]
  00404	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR $T38[rsp], xmm0
  0040d	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T38[rsp]
  00416	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR odd$6[rsp], xmm0

; 3524 :         
; 3525 :         // interleave even and odd pixels, then undo scaling.
; 3526 :         __m128i int0 = _mm_unpacklo_epi16(even, odd);

  0041c	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR even$5[rsp]
  00422	66 0f 61 44 24
	60		 punpcklwd xmm0, XMMWORD PTR odd$6[rsp]
  00428	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR $T39[rsp], xmm0
  00431	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T39[rsp]
  0043a	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR int0$41[rsp], xmm0

; 3527 :         __m128i int1 = _mm_unpackhi_epi16(even, odd);

  00443	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR even$5[rsp]
  00449	66 0f 69 44 24
	60		 punpckhwd xmm0, XMMWORD PTR odd$6[rsp]
  0044f	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR $T40[rsp], xmm0
  00458	66 0f 6f 84 24
	80 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T40[rsp]
  00461	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR int1$43[rsp], xmm0

; 3528 :         __m128i de0  = _mm_srli_epi16(int0, 4);

  0046a	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR int0$41[rsp]
  00473	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00478	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR $T42[rsp], xmm0
  00481	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T42[rsp]
  0048a	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR de0$45[rsp], xmm0

; 3529 :         __m128i de1  = _mm_srli_epi16(int1, 4);

  00493	66 0f 6f 84 24
	b0 02 00 00	 movdqa	 xmm0, XMMWORD PTR int1$43[rsp]
  0049c	66 0f 71 d0 04	 psrlw	 xmm0, 4
  004a1	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR $T44[rsp], xmm0
  004aa	66 0f 6f 84 24
	c0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T44[rsp]
  004b3	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR de1$46[rsp], xmm0

; 3530 :         
; 3531 :         // pack and write output
; 3532 :         __m128i outv = _mm_packus_epi16(de0, de1);

  004bc	66 0f 6f 84 24
	d0 02 00 00	 movdqa	 xmm0, XMMWORD PTR de0$45[rsp]
  004c5	66 0f 67 84 24
	e0 02 00 00	 packuswb xmm0, XMMWORD PTR de1$46[rsp]
  004ce	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR $T47[rsp], xmm0
  004d7	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T47[rsp]
  004e0	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR outv$48[rsp], xmm0

; 3533 :         _mm_storeu_si128((__m128i *) (out + i*2), outv);

  004e9	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  004ec	03 c0		 add	 eax, eax
  004ee	48 98		 cdqe
  004f0	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  004f8	48 03 c8	 add	 rcx, rax
  004fb	48 8b c1	 mov	 rax, rcx
  004fe	66 0f 6f 84 24
	00 03 00 00	 movdqa	 xmm0, XMMWORD PTR outv$48[rsp]
  00507	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3534 : #elif defined(STBI_NEON)
; 3535 :         // load and perform the vertical filtering pass
; 3536 :         // this uses 3*x + y = 4*x + (y - x)
; 3537 :         uint8x8_t farb  = vld1_u8(in_far + i);
; 3538 :         uint8x8_t nearb = vld1_u8(in_near + i);
; 3539 :         int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3540 :         int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3541 :         int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3542 :         
; 3543 :         // horizontal filter works the same based on shifted vers of current
; 3544 :         // row. "prev" is current row shifted right by 1 pixel; we need to
; 3545 :         // insert the previous pixel value (from t1).
; 3546 :         // "next" is current row shifted left by 1 pixel, with first pixel
; 3547 :         // of next block of 8 pixels added in.
; 3548 :         int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3549 :         int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3550 :         int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3551 :         int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3552 :         
; 3553 :         // horizontal filter, polyphase implementation since it's convenient:
; 3554 :         // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3555 :         // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3556 :         // note the shared term.
; 3557 :         int16x8_t curs = vshlq_n_s16(curr, 2);
; 3558 :         int16x8_t prvd = vsubq_s16(prev, curr);
; 3559 :         int16x8_t nxtd = vsubq_s16(next, curr);
; 3560 :         int16x8_t even = vaddq_s16(curs, prvd);
; 3561 :         int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3562 :         
; 3563 :         // undo scaling and round, then store with even/odd phases interleaved
; 3564 :         uint8x8x2_t o;
; 3565 :         o.val[0] = vqrshrun_n_s16(even, 4);
; 3566 :         o.val[1] = vqrshrun_n_s16(odd,  4);
; 3567 :         vst2_u8(out + i*2, o);
; 3568 : #endif
; 3569 :         
; 3570 :         // "previous" value for next iter
; 3571 :         t1 = 3*in_near[i+7] + in_far[i+7];

  0050b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0050e	83 c0 07	 add	 eax, 7
  00511	48 98		 cdqe
  00513	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  0051b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051f	6b c0 03	 imul	 eax, eax, 3
  00522	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00525	83 c1 07	 add	 ecx, 7
  00528	48 63 c9	 movsxd	 rcx, ecx
  0052b	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00533	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00537	03 c1		 add	 eax, ecx
  00539	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3572 :     }

  0053d	e9 96 fb ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3573 :     
; 3574 :     t0 = t1;

  00542	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  00546	89 44 24 08	 mov	 DWORD PTR t0$[rsp], eax

; 3575 :     t1 = 3*in_near[i] + in_far[i];

  0054a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0054e	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  00556	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0055a	6b c0 03	 imul	 eax, eax, 3
  0055d	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00561	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00569	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0056d	03 c1		 add	 eax, ecx
  0056f	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3576 :     out[i*2] = stbi__div16(3*t1 + t0 + 8);

  00573	6b 44 24 04 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  00578	8b 4c 24 08	 mov	 ecx, DWORD PTR t0$[rsp]
  0057c	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00580	c1 f8 04	 sar	 eax, 4
  00583	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00586	03 c9		 add	 ecx, ecx
  00588	48 63 c9	 movsxd	 rcx, ecx
  0058b	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00593	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3577 :     
; 3578 :     for (++i; i < w; ++i) {

  00596	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00599	ff c0		 inc	 eax
  0059b	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0059e	eb 08		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  005a0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  005a3	ff c0		 inc	 eax
  005a5	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__resa:
  005a8	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  005af	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  005b2	7d 7e		 jge	 SHORT $LN6@stbi__resa

; 3579 :         t0 = t1;

  005b4	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  005b8	89 44 24 08	 mov	 DWORD PTR t0$[rsp], eax

; 3580 :         t1 = 3*in_near[i]+in_far[i];

  005bc	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  005c0	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  005c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005cc	6b c0 03	 imul	 eax, eax, 3
  005cf	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  005d3	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  005db	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  005df	03 c1		 add	 eax, ecx
  005e1	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3581 :         out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

  005e5	6b 44 24 08 03	 imul	 eax, DWORD PTR t0$[rsp], 3
  005ea	8b 4c 24 04	 mov	 ecx, DWORD PTR t1$[rsp]
  005ee	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  005f2	c1 f8 04	 sar	 eax, 4
  005f5	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  005f8	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  005fc	48 63 c9	 movsxd	 rcx, ecx
  005ff	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00607	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3582 :         out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

  0060a	6b 44 24 04 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  0060f	8b 4c 24 08	 mov	 ecx, DWORD PTR t0$[rsp]
  00613	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00617	c1 f8 04	 sar	 eax, 4
  0061a	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0061d	d1 e1		 shl	 ecx, 1
  0061f	48 63 c9	 movsxd	 rcx, ecx
  00622	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0062a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3583 :     }

  0062d	e9 6e ff ff ff	 jmp	 $LN5@stbi__resa
$LN6@stbi__resa:

; 3584 :     out[w*2-1] = stbi__div4(t1+2);

  00632	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  00636	83 c0 02	 add	 eax, 2
  00639	c1 f8 02	 sar	 eax, 2
  0063c	8b 8c 24 38 03
	00 00		 mov	 ecx, DWORD PTR w$[rsp]
  00643	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  00647	48 63 c9	 movsxd	 rcx, ecx
  0064a	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00652	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3585 :     
; 3586 :     STBI_NOTUSED(hs);
; 3587 :     
; 3588 :     return out;

  00655	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3589 : }

  0065d	48 81 c4 18 03
	00 00		 add	 rsp, 792		; 00000318H
  00664	c3		 ret	 0
?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_hv_2_simd
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
t1$ = 4
tv78 = 8
t0$ = 12
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_hv_2

; 3452 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3453 :     // need to generate 2x2 samples for every one in input
; 3454 :     int i,t0,t1;
; 3455 :     if (w == 1) {

  00018	83 7c 24 38 01	 cmp	 DWORD PTR w$[rsp], 1
  0001d	75 68		 jne	 SHORT $LN5@stbi__resa

; 3456 :         out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 00	 imul	 rax, rax, 0
  00028	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  0002d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00031	6b c0 03	 imul	 eax, eax, 3
  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	48 6b c9 00	 imul	 rcx, rcx, 0
  0003d	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  00042	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00046	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0004a	c1 f8 02	 sar	 eax, 2
  0004d	89 44 24 08	 mov	 DWORD PTR tv78[rsp], eax
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	48 6b c0 01	 imul	 rax, rax, 1
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out$[rsp]
  0005f	0f b6 54 24 08	 movzx	 edx, BYTE PTR tv78[rsp]
  00064	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 00	 imul	 rax, rax, 0
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out$[rsp]
  00075	0f b6 54 24 08	 movzx	 edx, BYTE PTR tv78[rsp]
  0007a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3457 :         return out;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
  00082	e9 f3 00 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 3458 :     }
; 3459 :     
; 3460 :     t1 = 3*in_near[0] + in_far[0];

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	48 6b c0 00	 imul	 rax, rax, 0
  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  00095	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00099	6b c0 03	 imul	 eax, eax, 3
  0009c	b9 01 00 00 00	 mov	 ecx, 1
  000a1	48 6b c9 00	 imul	 rcx, rcx, 0
  000a5	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  000aa	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ae	03 c1		 add	 eax, ecx
  000b0	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3461 :     out[0] = stbi__div4(t1+2);

  000b4	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  000b8	83 c0 02	 add	 eax, 2
  000bb	c1 f8 02	 sar	 eax, 2
  000be	b9 01 00 00 00	 mov	 ecx, 1
  000c3	48 6b c9 00	 imul	 rcx, rcx, 0
  000c7	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  000cc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3462 :     for (i=1; i < w; ++i) {

  000cf	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  000d6	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000d8	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000db	ff c0		 inc	 eax
  000dd	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000e0	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  000e4	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000e7	7d 6f		 jge	 SHORT $LN3@stbi__resa

; 3463 :         t0 = t1;

  000e9	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  000ed	89 44 24 0c	 mov	 DWORD PTR t0$[rsp], eax

; 3464 :         t1 = 3*in_near[i]+in_far[i];

  000f1	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  000fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fe	6b c0 03	 imul	 eax, eax, 3
  00101	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00105	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  0010a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0010e	03 c1		 add	 eax, ecx
  00110	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3465 :         out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

  00114	6b 44 24 0c 03	 imul	 eax, DWORD PTR t0$[rsp], 3
  00119	8b 4c 24 04	 mov	 ecx, DWORD PTR t1$[rsp]
  0011d	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00121	c1 f8 04	 sar	 eax, 4
  00124	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00127	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0012b	48 63 c9	 movsxd	 rcx, ecx
  0012e	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00133	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3466 :         out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

  00136	6b 44 24 04 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  0013b	8b 4c 24 0c	 mov	 ecx, DWORD PTR t0$[rsp]
  0013f	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00143	c1 f8 04	 sar	 eax, 4
  00146	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	48 63 c9	 movsxd	 rcx, ecx
  0014e	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00153	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3467 :     }

  00156	eb 80		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3468 :     out[w*2-1] = stbi__div4(t1+2);

  00158	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  0015c	83 c0 02	 add	 eax, 2
  0015f	c1 f8 02	 sar	 eax, 2
  00162	8b 4c 24 38	 mov	 ecx, DWORD PTR w$[rsp]
  00166	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0016a	48 63 c9	 movsxd	 rcx, ecx
  0016d	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00172	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3469 :     
; 3470 :     STBI_NOTUSED(hs);
; 3471 :     
; 3472 :     return out;

  00175	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3473 : }

  0017a	48 83 c4 18	 add	 rsp, 24
  0017e	c3		 ret	 0
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_hv_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
n$1 = 4
input$ = 8
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_h_2

; 3422 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3423 :     // need to generate two samples horizontally for every one in input
; 3424 :     int i;
; 3425 :     stbi_uc *input = in_near;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR in_near$[rsp]
  0001d	48 89 44 24 08	 mov	 QWORD PTR input$[rsp], rax

; 3426 :     
; 3427 :     if (w == 1) {

  00022	83 7c 24 38 01	 cmp	 DWORD PTR w$[rsp], 1
  00027	75 52		 jne	 SHORT $LN5@stbi__resa

; 3428 :         // if only one sample, can't do any interpolation
; 3429 :         out[0] = out[1] = input[0];

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	48 6b c0 00	 imul	 rax, rax, 0
  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	48 6b c9 01	 imul	 rcx, rcx, 1
  0003b	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00040	4c 8b 44 24 08	 mov	 r8, QWORD PTR input$[rsp]
  00045	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	48 6b c0 01	 imul	 rax, rax, 1
  00056	b9 01 00 00 00	 mov	 ecx, 1
  0005b	48 6b c9 00	 imul	 rcx, rcx, 0
  0005f	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00064	4c 8b 44 24 20	 mov	 r8, QWORD PTR out$[rsp]
  00069	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0006e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3430 :         return out;

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
  00076	e9 5a 01 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 3431 :     }
; 3432 :     
; 3433 :     out[0] = input[0];

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 00	 imul	 rax, rax, 0
  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	48 6b c9 00	 imul	 rcx, rcx, 0
  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00092	4c 8b 44 24 08	 mov	 r8, QWORD PTR input$[rsp]
  00097	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0009c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3434 :     out[1] = stbi__div4(input[0]*3 + input[1] + 2);

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  000ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b1	6b c0 03	 imul	 eax, eax, 3
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 01	 imul	 rcx, rcx, 1
  000bd	48 8b 54 24 08	 mov	 rdx, QWORD PTR input$[rsp]
  000c2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c6	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  000ca	c1 f8 02	 sar	 eax, 2
  000cd	b9 01 00 00 00	 mov	 ecx, 1
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  000db	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3435 :     for (i=1; i < w-1; ++i) {

  000de	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  000e5	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000e7	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000ea	ff c0		 inc	 eax
  000ec	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000ef	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  000f3	ff c8		 dec	 eax
  000f5	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000f8	7d 74		 jge	 SHORT $LN3@stbi__resa

; 3436 :         int n = 3*input[i]+2;

  000fa	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000fe	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	6b c0 03	 imul	 eax, eax, 3
  0010a	83 c0 02	 add	 eax, 2
  0010d	89 44 24 04	 mov	 DWORD PTR n$1[rsp], eax

; 3437 :         out[i*2+0] = stbi__div4(n+input[i-1]);

  00111	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00114	ff c8		 dec	 eax
  00116	48 98		 cdqe
  00118	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  0011d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00121	8b 4c 24 04	 mov	 ecx, DWORD PTR n$1[rsp]
  00125	03 c8		 add	 ecx, eax
  00127	8b c1		 mov	 eax, ecx
  00129	c1 f8 02	 sar	 eax, 2
  0012c	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0012f	03 c9		 add	 ecx, ecx
  00131	48 63 c9	 movsxd	 rcx, ecx
  00134	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00139	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3438 :         out[i*2+1] = stbi__div4(n+input[i+1]);

  0013c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0013f	ff c0		 inc	 eax
  00141	48 98		 cdqe
  00143	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  00148	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014c	8b 4c 24 04	 mov	 ecx, DWORD PTR n$1[rsp]
  00150	03 c8		 add	 ecx, eax
  00152	8b c1		 mov	 eax, ecx
  00154	c1 f8 02	 sar	 eax, 2
  00157	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0015a	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  0015e	48 63 c9	 movsxd	 rcx, ecx
  00161	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00166	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3439 :     }

  00169	e9 79 ff ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3440 :     out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);

  0016e	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  00172	83 e8 02	 sub	 eax, 2
  00175	48 98		 cdqe
  00177	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  0017c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00180	6b c0 03	 imul	 eax, eax, 3
  00183	8b 4c 24 38	 mov	 ecx, DWORD PTR w$[rsp]
  00187	ff c9		 dec	 ecx
  00189	48 63 c9	 movsxd	 rcx, ecx
  0018c	48 8b 54 24 08	 mov	 rdx, QWORD PTR input$[rsp]
  00191	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00195	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00199	c1 f8 02	 sar	 eax, 2
  0019c	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0019f	03 c9		 add	 ecx, ecx
  001a1	48 63 c9	 movsxd	 rcx, ecx
  001a4	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  001a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3441 :     out[i*2+1] = input[w-1];

  001ac	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  001b0	ff c8		 dec	 eax
  001b2	48 98		 cdqe
  001b4	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  001b7	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  001bb	48 63 c9	 movsxd	 rcx, ecx
  001be	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  001c3	4c 8b 44 24 08	 mov	 r8, QWORD PTR input$[rsp]
  001c8	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001cd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3442 :     
; 3443 :     STBI_NOTUSED(in_far);
; 3444 :     STBI_NOTUSED(hs);
; 3445 :     
; 3446 :     return out;

  001d0	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3447 : }

  001d5	48 83 c4 18	 add	 rsp, 24
  001d9	c3		 ret	 0
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_h_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_v_2

; 3412 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3413 :     // need to generate two samples vertically for every one in input
; 3414 :     int i;
; 3415 :     STBI_NOTUSED(hs);
; 3416 :     for (i=0; i < w; ++i)

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00021	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  0002d	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00030	7d 32		 jge	 SHORT $LN3@stbi__resa

; 3417 :         out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

  00032	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	6b c0 03	 imul	 eax, eax, 3
  00042	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  0004b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0004f	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00053	c1 f8 02	 sar	 eax, 2
  00056	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0005a	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  0005f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00062	eb bd		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3418 :     return out;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]

; 3419 : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_v_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
out$ = 8
in_near$ = 16
in_far$ = 24
w$ = 32
hs$ = 40
?resample_row_1@@YAPEAEPEAE00HH@Z PROC			; resample_row_1

; 3403 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3404 :     STBI_NOTUSED(out);
; 3405 :     STBI_NOTUSED(in_far);
; 3406 :     STBI_NOTUSED(w);
; 3407 :     STBI_NOTUSED(hs);
; 3408 :     return in_near;

  00014	48 8b 44 24 10	 mov	 rax, QWORD PTR in_near$[rsp]

; 3409 : }

  00019	c3		 ret	 0
?resample_row_1@@YAPEAEPEAE00HH@Z ENDP			; resample_row_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
m$ = 32
x$1 = 36
Ld$2 = 40
NL$3 = 44
j$ = 64
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__decode_jpeg_image

; 3356 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3357 :     int m;
; 3358 :     for (m = 0; m < 4; m++) {

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR m$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@stbi__deco
$LN2@stbi__deco:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN4@stbi__deco:
  0001d	83 7c 24 20 04	 cmp	 DWORD PTR m$[rsp], 4
  00022	7d 36		 jge	 SHORT $LN3@stbi__deco

; 3359 :         j->img_comp[m].raw_data = NULL;

  00024	48 63 44 24 20	 movsxd	 rax, DWORD PTR m$[rsp]
  00029	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00032	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 3360 :         j->img_comp[m].raw_coeff = NULL;

  0003e	48 63 44 24 20	 movsxd	 rax, DWORD PTR m$[rsp]
  00043	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0004c	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3361 :     }

  00058	eb b9		 jmp	 SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 3362 :     j->restart_interval = 0;

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0005f	c7 80 68 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18536], 0

; 3363 :     if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

  00069	33 d2		 xor	 edx, edx
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00070	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
  00075	85 c0		 test	 eax, eax
  00077	75 07		 jne	 SHORT $LN9@stbi__deco
  00079	33 c0		 xor	 eax, eax
  0007b	e9 62 01 00 00	 jmp	 $LN1@stbi__deco
$LN9@stbi__deco:

; 3364 :     m = stbi__get_marker(j);

  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00085	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  0008a	0f b6 c0	 movzx	 eax, al
  0008d	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN5@stbi__deco:

; 3365 :     while (!stbi__EOI(m)) {

  00091	81 7c 24 20 d9
	00 00 00	 cmp	 DWORD PTR m$[rsp], 217	; 000000d9H
  00099	0f 84 26 01 00
	00		 je	 $LN6@stbi__deco

; 3366 :         if (stbi__SOS(m)) {

  0009f	81 7c 24 20 da
	00 00 00	 cmp	 DWORD PTR m$[rsp], 218	; 000000daH
  000a7	0f 85 8a 00 00
	00		 jne	 $LN10@stbi__deco

; 3367 :             if (!stbi__process_scan_header(j)) return 0;

  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000b2	e8 00 00 00 00	 call	 ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ; stbi__process_scan_header
  000b7	85 c0		 test	 eax, eax
  000b9	75 07		 jne	 SHORT $LN12@stbi__deco
  000bb	33 c0		 xor	 eax, eax
  000bd	e9 20 01 00 00	 jmp	 $LN1@stbi__deco
$LN12@stbi__deco:

; 3368 :             if (!stbi__parse_entropy_coded_data(j)) return 0;

  000c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000c7	e8 00 00 00 00	 call	 ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ; stbi__parse_entropy_coded_data
  000cc	85 c0		 test	 eax, eax
  000ce	75 07		 jne	 SHORT $LN13@stbi__deco
  000d0	33 c0		 xor	 eax, eax
  000d2	e9 0b 01 00 00	 jmp	 $LN1@stbi__deco
$LN13@stbi__deco:

; 3369 :             if (j->marker == STBI__MARKER_none ) {

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000dc	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  000e3	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000e8	75 4b		 jne	 SHORT $LN14@stbi__deco
$LN7@stbi__deco:

; 3370 :                 // handle 0s at the end of image data from IP Kamera 9060
; 3371 :                 while (!stbi__at_eof(j->s)) {

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ef	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f2	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000f7	85 c0		 test	 eax, eax
  000f9	75 3a		 jne	 SHORT $LN8@stbi__deco

; 3372 :                     int x = stbi__get8(j->s);

  000fb	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00100	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00103	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00108	0f b6 c0	 movzx	 eax, al
  0010b	89 44 24 24	 mov	 DWORD PTR x$1[rsp], eax

; 3373 :                     if (x == 255) {

  0010f	81 7c 24 24 ff
	00 00 00	 cmp	 DWORD PTR x$1[rsp], 255	; 000000ffH
  00117	75 1a		 jne	 SHORT $LN15@stbi__deco

; 3374 :                         j->marker = stbi__get8(j->s);

  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0011e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00121	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0012b	88 81 28 48 00
	00		 mov	 BYTE PTR [rcx+18472], al

; 3375 :                         break;

  00131	eb 02		 jmp	 SHORT $LN8@stbi__deco
$LN15@stbi__deco:

; 3376 :                     }
; 3377 :                 }

  00133	eb b5		 jmp	 SHORT $LN7@stbi__deco
$LN8@stbi__deco:
$LN14@stbi__deco:

; 3378 :                 // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3379 :             }

  00135	eb 78		 jmp	 SHORT $LN11@stbi__deco
$LN10@stbi__deco:

; 3380 :         } else if (stbi__DNL(m)) {

  00137	81 7c 24 20 dc
	00 00 00	 cmp	 DWORD PTR m$[rsp], 220	; 000000dcH
  0013f	75 58		 jne	 SHORT $LN16@stbi__deco

; 3381 :             int Ld = stbi__get16be(j->s);

  00141	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00146	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00149	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0014e	89 44 24 28	 mov	 DWORD PTR Ld$2[rsp], eax

; 3382 :             stbi__uint32 NL = stbi__get16be(j->s);

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00157	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0015f	89 44 24 2c	 mov	 DWORD PTR NL$3[rsp], eax

; 3383 :             if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");

  00163	83 7c 24 28 04	 cmp	 DWORD PTR Ld$2[rsp], 4
  00168	74 0e		 je	 SHORT $LN18@stbi__deco
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37799
  00171	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00176	eb 6a		 jmp	 SHORT $LN1@stbi__deco
$LN18@stbi__deco:

; 3384 :             if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");

  00178	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0017d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00180	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00183	39 44 24 2c	 cmp	 DWORD PTR NL$3[rsp], eax
  00187	74 0e		 je	 SHORT $LN19@stbi__deco
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37801
  00190	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00195	eb 4b		 jmp	 SHORT $LN1@stbi__deco
$LN19@stbi__deco:

; 3385 :         } else {

  00197	eb 16		 jmp	 SHORT $LN17@stbi__deco
$LN16@stbi__deco:

; 3386 :             if (!stbi__process_marker(j, m)) return 0;

  00199	8b 54 24 20	 mov	 edx, DWORD PTR m$[rsp]
  0019d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001a2	e8 00 00 00 00	 call	 ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
  001a7	85 c0		 test	 eax, eax
  001a9	75 04		 jne	 SHORT $LN20@stbi__deco
  001ab	33 c0		 xor	 eax, eax
  001ad	eb 33		 jmp	 SHORT $LN1@stbi__deco
$LN20@stbi__deco:
$LN17@stbi__deco:
$LN11@stbi__deco:

; 3387 :         }
; 3388 :         m = stbi__get_marker(j);

  001af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001b4	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  001b9	0f b6 c0	 movzx	 eax, al
  001bc	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3389 :     }

  001c0	e9 cc fe ff ff	 jmp	 $LN5@stbi__deco
$LN6@stbi__deco:

; 3390 :     if (j->progressive)

  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  001ca	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  001d1	74 0a		 je	 SHORT $LN21@stbi__deco

; 3391 :         stbi__jpeg_finish(j);

  001d3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001d8	e8 00 00 00 00	 call	 ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_finish
$LN21@stbi__deco:

; 3392 :     return 1;

  001dd	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 3393 : }

  001e2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001e6	c3		 ret	 0
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__decode_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
m$ = 32
tv131 = 36
z$ = 64
scan$ = 72
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__decode_jpeg_header

; 3331 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3332 :     int m;
; 3333 :     z->jfif = 0;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00012	c7 80 48 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18504], 0

; 3334 :     z->app14_color_transform = -1; // valid values are 0,1,2

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00021	c7 80 4c 48 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+18508], -1

; 3335 :     z->marker = STBI__MARKER_none; // initialize cached marker to empty

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00030	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 3336 :     m = stbi__get_marker(z);

  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0003c	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  00041	0f b6 c0	 movzx	 eax, al
  00044	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3337 :     if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

  00048	81 7c 24 20 d8
	00 00 00	 cmp	 DWORD PTR m$[rsp], 216	; 000000d8H
  00050	74 11		 je	 SHORT $LN6@stbi__deco
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37769
  00059	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005e	e9 f1 00 00 00	 jmp	 $LN1@stbi__deco
$LN6@stbi__deco:

; 3338 :     if (scan == STBI__SCAN_type) return 1;

  00063	83 7c 24 48 01	 cmp	 DWORD PTR scan$[rsp], 1
  00068	75 0a		 jne	 SHORT $LN7@stbi__deco
  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	e9 e0 00 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 3339 :     m = stbi__get_marker(z);

  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00079	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  0007e	0f b6 c0	 movzx	 eax, al
  00081	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN2@stbi__deco:

; 3340 :     while (!stbi__SOF(m)) {

  00085	81 7c 24 20 c0
	00 00 00	 cmp	 DWORD PTR m$[rsp], 192	; 000000c0H
  0008d	74 7f		 je	 SHORT $LN3@stbi__deco
  0008f	81 7c 24 20 c1
	00 00 00	 cmp	 DWORD PTR m$[rsp], 193	; 000000c1H
  00097	74 75		 je	 SHORT $LN3@stbi__deco
  00099	81 7c 24 20 c2
	00 00 00	 cmp	 DWORD PTR m$[rsp], 194	; 000000c2H
  000a1	74 6b		 je	 SHORT $LN3@stbi__deco

; 3341 :         if (!stbi__process_marker(z,m)) return 0;

  000a3	8b 54 24 20	 mov	 edx, DWORD PTR m$[rsp]
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000ac	e8 00 00 00 00	 call	 ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
  000b1	85 c0		 test	 eax, eax
  000b3	75 07		 jne	 SHORT $LN8@stbi__deco
  000b5	33 c0		 xor	 eax, eax
  000b7	e9 98 00 00 00	 jmp	 $LN1@stbi__deco
$LN8@stbi__deco:

; 3342 :         m = stbi__get_marker(z);

  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000c1	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  000c6	0f b6 c0	 movzx	 eax, al
  000c9	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN4@stbi__deco:

; 3343 :         while (m == STBI__MARKER_none) {

  000cd	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR m$[rsp], 255	; 000000ffH
  000d5	75 32		 jne	 SHORT $LN5@stbi__deco

; 3344 :             // some files have extra padding after their blocks, so ok, we'll scan
; 3345 :             if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  000dc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000df	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000e4	85 c0		 test	 eax, eax
  000e6	74 0e		 je	 SHORT $LN9@stbi__deco
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37773
  000ef	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000f4	eb 5e		 jmp	 SHORT $LN1@stbi__deco
$LN9@stbi__deco:

; 3346 :             m = stbi__get_marker(z);

  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000fb	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  00100	0f b6 c0	 movzx	 eax, al
  00103	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3347 :         }

  00107	eb c4		 jmp	 SHORT $LN4@stbi__deco
$LN5@stbi__deco:

; 3348 :     }

  00109	e9 77 ff ff ff	 jmp	 $LN2@stbi__deco
$LN3@stbi__deco:

; 3349 :     z->progressive = stbi__SOF_progressive(m);

  0010e	81 7c 24 20 c2
	00 00 00	 cmp	 DWORD PTR m$[rsp], 194	; 000000c2H
  00116	75 0a		 jne	 SHORT $LN12@stbi__deco
  00118	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  00120	eb 08		 jmp	 SHORT $LN13@stbi__deco
$LN12@stbi__deco:
  00122	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN13@stbi__deco:
  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0012f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv131[rsp]
  00133	89 88 30 48 00
	00		 mov	 DWORD PTR [rax+18480], ecx

; 3350 :     if (!stbi__process_frame_header(z, scan)) return 0;

  00139	8b 54 24 48	 mov	 edx, DWORD PTR scan$[rsp]
  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00142	e8 00 00 00 00	 call	 ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_frame_header
  00147	85 c0		 test	 eax, eax
  00149	75 04		 jne	 SHORT $LN10@stbi__deco
  0014b	33 c0		 xor	 eax, eax
  0014d	eb 05		 jmp	 SHORT $LN1@stbi__deco
$LN10@stbi__deco:

; 3351 :     return 1;

  0014f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 3352 : }

  00154	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00158	c3		 ret	 0
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__decode_jpeg_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 40
h_max$ = 48
v_max$ = 52
c$ = 56
Lf$ = 60
q$ = 64
p$ = 68
tv285 = 72
tv294 = 80
z$ = 112
scan$ = 120
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z PROC ; stbi__process_frame_header

; 3230 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3231 :     stbi__context *s = z->s;

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  00012	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00015	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3232 :     int Lf,p,i,q, h_max=1,v_max=1,c;

  0001a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR h_max$[rsp], 1
  00022	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR v_max$[rsp], 1

; 3233 :     Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG

  0002a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00034	89 44 24 3c	 mov	 DWORD PTR Lf$[rsp], eax
  00038	83 7c 24 3c 0b	 cmp	 DWORD PTR Lf$[rsp], 11
  0003d	7d 11		 jge	 SHORT $LN17@stbi__proc
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37721
  00046	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0004b	e9 b9 08 00 00	 jmp	 $LN1@stbi__proc
$LN17@stbi__proc:

; 3234 :     p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00055	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0005a	0f b6 c0	 movzx	 eax, al
  0005d	89 44 24 44	 mov	 DWORD PTR p$[rsp], eax
  00061	83 7c 24 44 08	 cmp	 DWORD PTR p$[rsp], 8
  00066	74 11		 je	 SHORT $LN18@stbi__proc
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37723
  0006f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00074	e9 90 08 00 00	 jmp	 $LN1@stbi__proc
$LN18@stbi__proc:

; 3235 :     s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0007e	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00088	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00090	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00094	75 11		 jne	 SHORT $LN19@stbi__proc
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37725
  0009d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a2	e9 62 08 00 00	 jmp	 $LN1@stbi__proc
$LN19@stbi__proc:

; 3236 :     s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires

  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000ac	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000b6	89 01		 mov	 DWORD PTR [rcx], eax
  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000bd	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c0	75 11		 jne	 SHORT $LN20@stbi__proc
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37727
  000c9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000ce	e9 36 08 00 00	 jmp	 $LN1@stbi__proc
$LN20@stbi__proc:

; 3237 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000d8	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  000df	76 11		 jbe	 SHORT $LN21@stbi__proc
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37729
  000e8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000ed	e9 17 08 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 3238 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000f7	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  000fd	76 11		 jbe	 SHORT $LN22@stbi__proc
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37731
  00106	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0010b	e9 f9 07 00 00	 jmp	 $LN1@stbi__proc
$LN22@stbi__proc:

; 3239 :     c = stbi__get8(s);

  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00115	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0011a	0f b6 c0	 movzx	 eax, al
  0011d	89 44 24 38	 mov	 DWORD PTR c$[rsp], eax

; 3240 :     if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");

  00121	83 7c 24 38 03	 cmp	 DWORD PTR c$[rsp], 3
  00126	74 1f		 je	 SHORT $LN23@stbi__proc
  00128	83 7c 24 38 01	 cmp	 DWORD PTR c$[rsp], 1
  0012d	74 18		 je	 SHORT $LN23@stbi__proc
  0012f	83 7c 24 38 04	 cmp	 DWORD PTR c$[rsp], 4
  00134	74 11		 je	 SHORT $LN23@stbi__proc
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37733
  0013d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00142	e9 c2 07 00 00	 jmp	 $LN1@stbi__proc
$LN23@stbi__proc:

; 3241 :     s->img_n = c;

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0014c	8b 4c 24 38	 mov	 ecx, DWORD PTR c$[rsp]
  00150	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 3242 :     for (i=0; i < c; ++i) {

  00153	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0015b	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  0015d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00161	ff c0		 inc	 eax
  00163	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
  00167	8b 44 24 38	 mov	 eax, DWORD PTR c$[rsp]
  0016b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0016f	7d 36		 jge	 SHORT $LN3@stbi__proc

; 3243 :         z->img_comp[i].data = NULL;

  00171	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00176	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0017a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0017f	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0

; 3244 :         z->img_comp[i].linebuf = NULL;

  0018b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00190	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00194	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00199	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 3245 :     }

  001a5	eb b6		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 3246 :     
; 3247 :     if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001ac	6b 40 08 03	 imul	 eax, DWORD PTR [rax+8], 3
  001b0	83 c0 08	 add	 eax, 8
  001b3	39 44 24 3c	 cmp	 DWORD PTR Lf$[rsp], eax
  001b7	74 11		 je	 SHORT $LN24@stbi__proc
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37735
  001c0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c5	e9 3f 07 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 3248 :     
; 3249 :     z->rgb = 0;

  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  001cf	c7 80 50 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18512], 0

; 3250 :     for (i=0; i < s->img_n; ++i) {

  001d9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e1	eb 0a		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  001e3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__proc:
  001ed	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001f2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001f5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001f9	0f 8d 87 01 00
	00		 jge	 $LN6@stbi__proc

; 3251 :         static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3252 :         z->img_comp[i].id = stbi__get8(s);

  001ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00204	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00209	0f b6 c0	 movzx	 eax, al
  0020c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00211	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00215	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0021a	89 84 0a a0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18080], eax

; 3253 :         if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

  00221	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00226	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  0022a	75 3f		 jne	 SHORT $LN25@stbi__proc
  0022c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00231	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00235	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
  00241	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00245	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0024a	39 8c 02 a0 46
	00 00		 cmp	 DWORD PTR [rdx+rax+18080], ecx
  00251	75 18		 jne	 SHORT $LN25@stbi__proc

; 3254 :             ++z->rgb;

  00253	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  00258	8b 80 50 48 00
	00		 mov	 eax, DWORD PTR [rax+18512]
  0025e	ff c0		 inc	 eax
  00260	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00265	89 81 50 48 00
	00		 mov	 DWORD PTR [rcx+18512], eax
$LN25@stbi__proc:

; 3255 :         q = stbi__get8(s);

  0026b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00270	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00275	0f b6 c0	 movzx	 eax, al
  00278	89 44 24 40	 mov	 DWORD PTR q$[rsp], eax

; 3256 :         z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");

  0027c	8b 44 24 40	 mov	 eax, DWORD PTR q$[rsp]
  00280	c1 f8 04	 sar	 eax, 4
  00283	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00288	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0028c	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00291	89 84 0a a4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18084], eax
  00298	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0029d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002a1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  002a6	83 bc 01 a4 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18084], 0
  002ae	74 18		 je	 SHORT $LN27@stbi__proc
  002b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002b5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  002be	83 bc 01 a4 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18084], 4
  002c6	7e 11		 jle	 SHORT $LN26@stbi__proc
$LN27@stbi__proc:
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37739
  002cf	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002d4	e9 30 06 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 3257 :         z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");

  002d9	8b 44 24 40	 mov	 eax, DWORD PTR q$[rsp]
  002dd	83 e0 0f	 and	 eax, 15
  002e0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e5	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  002e9	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  002ee	89 84 0a a8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18088], eax
  002f5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002fa	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00303	83 bc 01 a8 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18088], 0
  0030b	74 18		 je	 SHORT $LN29@stbi__proc
  0030d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00312	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00316	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0031b	83 bc 01 a8 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18088], 4
  00323	7e 11		 jle	 SHORT $LN28@stbi__proc
$LN29@stbi__proc:
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37742
  0032c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00331	e9 d3 05 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 3258 :         z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");

  00336	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0033b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00340	0f b6 c0	 movzx	 eax, al
  00343	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00348	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0034c	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00351	89 84 0a ac 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18092], eax
  00358	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0035d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00361	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00366	83 bc 01 ac 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18092], 3
  0036e	7e 11		 jle	 SHORT $LN30@stbi__proc
  00370	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37744
  00377	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0037c	e9 88 05 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 3259 :     }

  00381	e9 5d fe ff ff	 jmp	 $LN5@stbi__proc
$LN6@stbi__proc:

; 3260 :     
; 3261 :     if (scan != STBI__SCAN_load) return 1;

  00386	83 7c 24 78 00	 cmp	 DWORD PTR scan$[rsp], 0
  0038b	74 0a		 je	 SHORT $LN31@stbi__proc
  0038d	b8 01 00 00 00	 mov	 eax, 1
  00392	e9 72 05 00 00	 jmp	 $LN1@stbi__proc
$LN31@stbi__proc:

; 3262 :     
; 3263 :     if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

  00397	45 33 c9	 xor	 r9d, r9d
  0039a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0039f	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  003a3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003a8	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  003ab	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003b0	8b 08		 mov	 ecx, DWORD PTR [rax]
  003b2	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  003b7	85 c0		 test	 eax, eax
  003b9	75 11		 jne	 SHORT $LN32@stbi__proc
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37747
  003c2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003c7	e9 3d 05 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 3264 :     
; 3265 :     for (i=0; i < s->img_n; ++i) {

  003cc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003d4	eb 0a		 jmp	 SHORT $LN10@stbi__proc
$LN8@stbi__proc:
  003d6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003da	ff c0		 inc	 eax
  003dc	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__proc:
  003e0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003e5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003e8	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  003ec	7d 6d		 jge	 SHORT $LN9@stbi__proc

; 3266 :         if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

  003ee	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003f3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  003fc	8b 54 24 30	 mov	 edx, DWORD PTR h_max$[rsp]
  00400	39 94 01 a4 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18084], edx
  00407	7e 19		 jle	 SHORT $LN33@stbi__proc
  00409	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0040e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00412	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00417	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  0041e	89 44 24 30	 mov	 DWORD PTR h_max$[rsp], eax
$LN33@stbi__proc:

; 3267 :         if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

  00422	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00427	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0042b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00430	8b 54 24 34	 mov	 edx, DWORD PTR v_max$[rsp]
  00434	39 94 01 a8 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18088], edx
  0043b	7e 19		 jle	 SHORT $LN34@stbi__proc
  0043d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00442	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00446	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0044b	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00452	89 44 24 34	 mov	 DWORD PTR v_max$[rsp], eax
$LN34@stbi__proc:

; 3268 :     }

  00456	e9 7b ff ff ff	 jmp	 $LN8@stbi__proc
$LN9@stbi__proc:

; 3269 :     
; 3270 :     // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3271 :     // and I've never seen a non-corrupted JPEG file actually use them
; 3272 :     for (i=0; i < s->img_n; ++i) {

  0045b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00463	eb 0a		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  00465	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00469	ff c0		 inc	 eax
  0046b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@stbi__proc:
  0046f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00474	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00477	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0047b	7d 7d		 jge	 SHORT $LN12@stbi__proc

; 3273 :         if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");

  0047d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00482	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00486	48 89 44 24 48	 mov	 QWORD PTR tv285[rsp], rax
  0048b	8b 44 24 30	 mov	 eax, DWORD PTR h_max$[rsp]
  0048f	99		 cdq
  00490	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00495	4c 8b 44 24 48	 mov	 r8, QWORD PTR tv285[rsp]
  0049a	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  004a2	8b c2		 mov	 eax, edx
  004a4	85 c0		 test	 eax, eax
  004a6	74 11		 je	 SHORT $LN35@stbi__proc
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37751
  004af	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004b4	e9 50 04 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 3274 :         if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");

  004b9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  004be	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004c2	48 89 44 24 50	 mov	 QWORD PTR tv294[rsp], rax
  004c7	8b 44 24 34	 mov	 eax, DWORD PTR v_max$[rsp]
  004cb	99		 cdq
  004cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  004d1	4c 8b 44 24 50	 mov	 r8, QWORD PTR tv294[rsp]
  004d6	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  004de	8b c2		 mov	 eax, edx
  004e0	85 c0		 test	 eax, eax
  004e2	74 11		 je	 SHORT $LN36@stbi__proc
  004e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37753
  004eb	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004f0	e9 14 04 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 3275 :     }

  004f5	e9 6b ff ff ff	 jmp	 $LN11@stbi__proc
$LN12@stbi__proc:

; 3276 :     
; 3277 :     // compute interleaved mcu info
; 3278 :     z->img_h_max = h_max;

  004fa	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  004ff	8b 4c 24 30	 mov	 ecx, DWORD PTR h_max$[rsp]
  00503	89 88 88 46 00
	00		 mov	 DWORD PTR [rax+18056], ecx

; 3279 :     z->img_v_max = v_max;

  00509	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  0050e	8b 4c 24 34	 mov	 ecx, DWORD PTR v_max$[rsp]
  00512	89 88 8c 46 00
	00		 mov	 DWORD PTR [rax+18060], ecx

; 3280 :     z->img_mcu_w = h_max * 8;

  00518	8b 44 24 30	 mov	 eax, DWORD PTR h_max$[rsp]
  0051c	c1 e0 03	 shl	 eax, 3
  0051f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00524	89 81 98 46 00
	00		 mov	 DWORD PTR [rcx+18072], eax

; 3281 :     z->img_mcu_h = v_max * 8;

  0052a	8b 44 24 34	 mov	 eax, DWORD PTR v_max$[rsp]
  0052e	c1 e0 03	 shl	 eax, 3
  00531	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00536	89 81 9c 46 00
	00		 mov	 DWORD PTR [rcx+18076], eax

; 3282 :     // these sizes can't be more than 17 bits
; 3283 :     z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;

  0053c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00541	8b 00		 mov	 eax, DWORD PTR [rax]
  00543	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00548	8b 89 98 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18072]
  0054e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00552	33 d2		 xor	 edx, edx
  00554	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00559	f7 b1 98 46 00
	00		 div	 DWORD PTR [rcx+18072]
  0055f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00564	89 81 90 46 00
	00		 mov	 DWORD PTR [rcx+18064], eax

; 3284 :     z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

  0056a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0056f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00572	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00577	8b 89 9c 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18076]
  0057d	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00581	33 d2		 xor	 edx, edx
  00583	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00588	f7 b1 9c 46 00
	00		 div	 DWORD PTR [rcx+18076]
  0058e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00593	89 81 94 46 00
	00		 mov	 DWORD PTR [rcx+18068], eax

; 3285 :     
; 3286 :     for (i=0; i < s->img_n; ++i) {

  00599	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a1	eb 0a		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  005a3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  005a7	ff c0		 inc	 eax
  005a9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN16@stbi__proc:
  005ad	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005b2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  005b5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  005b9	0f 8d 45 03 00
	00		 jge	 $LN15@stbi__proc

; 3287 :         // number of effective pixels (e.g. for non-interleaved MCU)
; 3288 :         z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;

  005bf	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  005c4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  005c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  005cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  005d2	8b 09		 mov	 ecx, DWORD PTR [rcx]
  005d4	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  005dc	8b c1		 mov	 eax, ecx
  005de	8b 4c 24 30	 mov	 ecx, DWORD PTR h_max$[rsp]
  005e2	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  005e6	33 d2		 xor	 edx, edx
  005e8	f7 74 24 30	 div	 DWORD PTR h_max$[rsp]
  005ec	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  005f1	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  005f5	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  005fa	89 84 0a bc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18108], eax

; 3289 :         z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;

  00601	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00606	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0060a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0060f	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00614	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00617	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  0061f	8b c1		 mov	 eax, ecx
  00621	8b 4c 24 34	 mov	 ecx, DWORD PTR v_max$[rsp]
  00625	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00629	33 d2		 xor	 edx, edx
  0062b	f7 74 24 34	 div	 DWORD PTR v_max$[rsp]
  0062f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00634	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00638	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0063d	89 84 0a c0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18112], eax

; 3290 :         // to simplify generation, we'll allocate enough memory to decode
; 3291 :         // the bogus oversized data from using interleaved MCUs and their
; 3292 :         // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3293 :         // discard the extra data until colorspace conversion
; 3294 :         //
; 3295 :         // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3296 :         // so these muls can't overflow with 32-bit ints (which we require)
; 3297 :         z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

  00644	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00649	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0064d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00652	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00657	8b 89 90 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18064]
  0065d	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  00665	8b c1		 mov	 eax, ecx
  00667	c1 e0 03	 shl	 eax, 3
  0066a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0066f	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00673	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00678	89 84 0a c4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18116], eax

; 3298 :         z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

  0067f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00684	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00688	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0068d	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00692	8b 89 94 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18068]
  00698	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  006a0	8b c1		 mov	 eax, ecx
  006a2	c1 e0 03	 shl	 eax, 3
  006a5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  006aa	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  006ae	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  006b3	89 84 0a c8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18120], eax

; 3299 :         z->img_comp[i].coeff = 0;

  006ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  006bf	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  006c8	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0

; 3300 :         z->img_comp[i].raw_coeff = 0;

  006d4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  006d9	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  006e2	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3301 :         z->img_comp[i].linebuf = NULL;

  006ee	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  006f3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  006fc	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 3302 :         z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

  00708	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0070d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00711	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00716	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0071a	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00720	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00725	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  0072c	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  00731	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00738	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  0073d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00742	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00746	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0074b	48 89 84 0a d8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18136], rax

; 3303 :         if (z->img_comp[i].raw_data == NULL)

  00753	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00758	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0075c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00761	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  0076a	75 26		 jne	 SHORT $LN37@stbi__proc

; 3304 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

  0076c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37755
  00773	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00778	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0077c	ff c1		 inc	 ecx
  0077e	44 8b c0	 mov	 r8d, eax
  00781	8b d1		 mov	 edx, ecx
  00783	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00788	e8 00 00 00 00	 call	 ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
  0078d	e9 77 01 00 00	 jmp	 $LN1@stbi__proc
$LN37@stbi__proc:

; 3305 :         // align blocks for idct using mmx/sse
; 3306 :         z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);

  00792	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00797	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0079b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  007a0	48 8b 84 01 d8
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18136]
  007a8	48 83 c0 0f	 add	 rax, 15
  007ac	48 83 e0 f0	 and	 rax, -16
  007b0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  007b5	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  007b9	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  007be	48 89 84 0a d0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18128], rax

; 3307 :         if (z->progressive) {

  007c6	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  007cb	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  007d2	0f 84 27 01 00
	00		 je	 $LN38@stbi__proc

; 3308 :             // w2, h2 are multiples of 8 (see above)
; 3309 :             z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

  007d8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  007dd	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  007e6	8b 84 01 c4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18116]
  007ed	99		 cdq
  007ee	83 e2 07	 and	 edx, 7
  007f1	03 c2		 add	 eax, edx
  007f3	c1 f8 03	 sar	 eax, 3
  007f6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  007fb	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  007ff	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00804	89 84 0a f8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18168], eax

; 3310 :             z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

  0080b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00810	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00814	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00819	8b 84 01 c8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18120]
  00820	99		 cdq
  00821	83 e2 07	 and	 edx, 7
  00824	03 c2		 add	 eax, edx
  00826	c1 f8 03	 sar	 eax, 3
  00829	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0082e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00832	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00837	89 84 0a fc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18172], eax

; 3311 :             z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

  0083e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00843	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00847	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0084c	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00850	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00856	41 b8 02 00 00
	00		 mov	 r8d, 2
  0085c	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00861	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  00868	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  0086d	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00874	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00879	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0087e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00882	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00887	48 89 84 0a e0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18144], rax

; 3312 :             if (z->img_comp[i].raw_coeff == NULL)

  0088f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00894	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00898	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0089d	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  008a6	75 23		 jne	 SHORT $LN39@stbi__proc

; 3313 :                 return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

  008a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37758
  008af	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  008b4	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  008b8	ff c1		 inc	 ecx
  008ba	44 8b c0	 mov	 r8d, eax
  008bd	8b d1		 mov	 edx, ecx
  008bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  008c4	e8 00 00 00 00	 call	 ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
  008c9	eb 3e		 jmp	 SHORT $LN1@stbi__proc
$LN39@stbi__proc:

; 3314 :             z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);

  008cb	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  008d0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  008d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  008d9	48 8b 84 01 e0
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18144]
  008e1	48 83 c0 0f	 add	 rax, 15
  008e5	48 83 e0 f0	 and	 rax, -16
  008e9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  008ee	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  008f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  008f7	48 89 84 0a f0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18160], rax
$LN38@stbi__proc:

; 3315 :         }
; 3316 :     }

  008ff	e9 9f fc ff ff	 jmp	 $LN14@stbi__proc
$LN15@stbi__proc:

; 3317 :     
; 3318 :     return 1;

  00904	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 3319 : }

  00909	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0090d	c3		 ret	 0
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ENDP ; stbi__process_frame_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
z$ = 64
ncomp$ = 72
why$ = 80
?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z PROC ; stbi__free_jpeg_components

; 3208 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3209 :     int i;
; 3210 :     for (i=0; i < ncomp; ++i) {

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN4@stbi__free
$LN2@stbi__free:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__free:
  00026	8b 44 24 48	 mov	 eax, DWORD PTR ncomp$[rsp]
  0002a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0002e	0f 8d 23 01 00
	00		 jge	 $LN3@stbi__free

; 3211 :         if (z->img_comp[i].raw_data) {

  00034	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00042	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  0004b	74 4f		 je	 SHORT $LN5@stbi__free

; 3212 :             STBI_FREE(z->img_comp[i].raw_data);

  0004d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00052	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0005b	48 8b 8c 01 d8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18136]
  00063	e8 00 00 00 00	 call	 free

; 3213 :             z->img_comp[i].raw_data = NULL;

  00068	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00076	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 3214 :             z->img_comp[i].data = NULL;

  00082	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00087	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00090	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0
$LN5@stbi__free:

; 3215 :         }
; 3216 :         if (z->img_comp[i].raw_coeff) {

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000aa	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  000b3	74 4f		 je	 SHORT $LN6@stbi__free

; 3217 :             STBI_FREE(z->img_comp[i].raw_coeff);

  000b5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ba	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000c3	48 8b 8c 01 e0
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18144]
  000cb	e8 00 00 00 00	 call	 free

; 3218 :             z->img_comp[i].raw_coeff = 0;

  000d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000de	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3219 :             z->img_comp[i].coeff = 0;

  000ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ef	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000f8	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0
$LN6@stbi__free:

; 3220 :         }
; 3221 :         if (z->img_comp[i].linebuf) {

  00104	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00109	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00112	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  0011b	74 35		 je	 SHORT $LN7@stbi__free

; 3222 :             STBI_FREE(z->img_comp[i].linebuf);

  0011d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00122	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0012b	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00133	e8 00 00 00 00	 call	 free

; 3223 :             z->img_comp[i].linebuf = NULL;

  00138	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0013d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00146	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0
$LN7@stbi__free:

; 3224 :         }
; 3225 :     }

  00152	e9 c5 fe ff ff	 jmp	 $LN2@stbi__free
$LN3@stbi__free:

; 3226 :     return why;

  00157	8b 44 24 50	 mov	 eax, DWORD PTR why$[rsp]

; 3227 : }

  0015b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015f	c3		 ret	 0
?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ENDP ; stbi__free_jpeg_components
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
which$1 = 32
i$ = 36
q$2 = 40
aa$3 = 44
Ls$ = 48
id$4 = 52
z$ = 80
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__process_scan_header

; 3169 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3170 :     int i;
; 3171 :     int Ls = stbi__get16be(z->s);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00016	89 44 24 30	 mov	 DWORD PTR Ls$[rsp], eax

; 3172 :     z->scan_n = stbi__get8(z->s);

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00027	0f b6 c0	 movzx	 eax, al
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0002f	89 81 54 48 00
	00		 mov	 DWORD PTR [rcx+18516], eax

; 3173 :     if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0003a	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  00041	7c 26		 jl	 SHORT $LN9@stbi__proc
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00048	83 b8 54 48 00
	00 04		 cmp	 DWORD PTR [rax+18516], 4
  0004f	7f 18		 jg	 SHORT $LN9@stbi__proc
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0005e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00061	39 81 54 48 00
	00		 cmp	 DWORD PTR [rcx+18516], eax
  00067	7e 11		 jle	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37655
  00070	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00075	e9 ad 02 00 00	 jmp	 $LN1@stbi__proc
$LN8@stbi__proc:

; 3174 :     if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0007f	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00085	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00089	39 44 24 30	 cmp	 DWORD PTR Ls$[rsp], eax
  0008d	74 11		 je	 SHORT $LN10@stbi__proc
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37657
  00096	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0009b	e9 87 02 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 3175 :     for (i=0; i < z->scan_n; ++i) {

  000a0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a8	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  000aa	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ae	ff c0		 inc	 eax
  000b0	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000b9	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  000bf	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c3	0f 8d 28 01 00
	00		 jge	 $LN3@stbi__proc

; 3176 :         int id = stbi__get8(z->s), which;

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000ce	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d1	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	89 44 24 34	 mov	 DWORD PTR id$4[rsp], eax

; 3177 :         int q = stbi__get8(z->s);

  000dd	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000e2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e5	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ea	0f b6 c0	 movzx	 eax, al
  000ed	89 44 24 28	 mov	 DWORD PTR q$2[rsp], eax

; 3178 :         for (which = 0; which < z->s->img_n; ++which)

  000f1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR which$1[rsp], 0
  000f9	eb 0a		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  000fb	8b 44 24 20	 mov	 eax, DWORD PTR which$1[rsp]
  000ff	ff c0		 inc	 eax
  00101	89 44 24 20	 mov	 DWORD PTR which$1[rsp], eax
$LN7@stbi__proc:
  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0010a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00110	39 44 24 20	 cmp	 DWORD PTR which$1[rsp], eax
  00114	7d 1f		 jge	 SHORT $LN6@stbi__proc

; 3179 :             if (z->img_comp[which].id == id)

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR which$1[rsp]
  0011b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00124	8b 54 24 34	 mov	 edx, DWORD PTR id$4[rsp]
  00128	39 94 01 a0 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18080], edx
  0012f	75 02		 jne	 SHORT $LN11@stbi__proc

; 3180 :             break;

  00131	eb 02		 jmp	 SHORT $LN6@stbi__proc
$LN11@stbi__proc:
  00133	eb c6		 jmp	 SHORT $LN5@stbi__proc
$LN6@stbi__proc:

; 3181 :         if (which == z->s->img_n) return 0; // no match

  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0013a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00140	39 44 24 20	 cmp	 DWORD PTR which$1[rsp], eax
  00144	75 07		 jne	 SHORT $LN12@stbi__proc
  00146	33 c0		 xor	 eax, eax
  00148	e9 da 01 00 00	 jmp	 $LN1@stbi__proc
$LN12@stbi__proc:

; 3182 :         z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");

  0014d	8b 44 24 28	 mov	 eax, DWORD PTR q$2[rsp]
  00151	c1 f8 04	 sar	 eax, 4
  00154	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR which$1[rsp]
  00159	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0015d	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  00162	89 84 0a b0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18096], eax
  00169	48 63 44 24 20	 movsxd	 rax, DWORD PTR which$1[rsp]
  0016e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00177	83 bc 01 b0 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18096], 3
  0017f	7e 11		 jle	 SHORT $LN13@stbi__proc
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37661
  00188	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0018d	e9 95 01 00 00	 jmp	 $LN1@stbi__proc
$LN13@stbi__proc:

; 3183 :         z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

  00192	8b 44 24 28	 mov	 eax, DWORD PTR q$2[rsp]
  00196	83 e0 0f	 and	 eax, 15
  00199	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR which$1[rsp]
  0019e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  001a2	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  001a7	89 84 0a b4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18100], eax
  001ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR which$1[rsp]
  001b3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  001bc	83 bc 01 b4 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18100], 3
  001c4	7e 11		 jle	 SHORT $LN14@stbi__proc
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37663
  001cd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001d2	e9 50 01 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:

; 3184 :         z->order[i] = which;

  001d7	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  001e1	8b 54 24 20	 mov	 edx, DWORD PTR which$1[rsp]
  001e5	89 94 81 58 48
	00 00		 mov	 DWORD PTR [rcx+rax*4+18520], edx

; 3185 :     }

  001ec	e9 b9 fe ff ff	 jmp	 $LN2@stbi__proc
$LN3@stbi__proc:

; 3186 :     
; 3187 :     {
; 3188 :         int aa;
; 3189 :         z->spec_start = stbi__get8(z->s);

  001f1	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001f6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001f9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001fe	0f b6 c0	 movzx	 eax, al
  00201	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00206	89 81 34 48 00
	00		 mov	 DWORD PTR [rcx+18484], eax

; 3190 :         z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0

  0020c	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00211	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00214	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00219	0f b6 c0	 movzx	 eax, al
  0021c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00221	89 81 38 48 00
	00		 mov	 DWORD PTR [rcx+18488], eax

; 3191 :         aa = stbi__get8(z->s);

  00227	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0022c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0022f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00234	0f b6 c0	 movzx	 eax, al
  00237	89 44 24 2c	 mov	 DWORD PTR aa$3[rsp], eax

; 3192 :         z->succ_high = (aa >> 4);

  0023b	8b 44 24 2c	 mov	 eax, DWORD PTR aa$3[rsp]
  0023f	c1 f8 04	 sar	 eax, 4
  00242	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00247	89 81 3c 48 00
	00		 mov	 DWORD PTR [rcx+18492], eax

; 3193 :         z->succ_low  = (aa & 15);

  0024d	8b 44 24 2c	 mov	 eax, DWORD PTR aa$3[rsp]
  00251	83 e0 0f	 and	 eax, 15
  00254	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00259	89 81 40 48 00
	00		 mov	 DWORD PTR [rcx+18496], eax

; 3194 :         if (z->progressive) {

  0025f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00264	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  0026b	74 60		 je	 SHORT $LN15@stbi__proc

; 3195 :             if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

  0026d	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00272	83 b8 34 48 00
	00 3f		 cmp	 DWORD PTR [rax+18484], 63 ; 0000003fH
  00279	7f 42		 jg	 SHORT $LN18@stbi__proc
  0027b	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00280	83 b8 38 48 00
	00 3f		 cmp	 DWORD PTR [rax+18488], 63 ; 0000003fH
  00287	7f 34		 jg	 SHORT $LN18@stbi__proc
  00289	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0028e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00293	8b 89 38 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18488]
  00299	39 88 34 48 00
	00		 cmp	 DWORD PTR [rax+18484], ecx
  0029f	7f 1c		 jg	 SHORT $LN18@stbi__proc
  002a1	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002a6	83 b8 3c 48 00
	00 0d		 cmp	 DWORD PTR [rax+18492], 13
  002ad	7f 0e		 jg	 SHORT $LN18@stbi__proc
  002af	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002b4	83 b8 40 48 00
	00 0d		 cmp	 DWORD PTR [rax+18496], 13
  002bb	7e 0e		 jle	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 3196 :                 return stbi__err("bad SOS", "Corrupt JPEG");

  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37668
  002c4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002c9	eb 5c		 jmp	 SHORT $LN1@stbi__proc
$LN17@stbi__proc:

; 3197 :         } else {

  002cb	eb 55		 jmp	 SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 3198 :             if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");

  002cd	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002d2	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  002d9	74 0e		 je	 SHORT $LN19@stbi__proc
  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37670
  002e2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002e7	eb 3e		 jmp	 SHORT $LN1@stbi__proc
$LN19@stbi__proc:

; 3199 :             if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");

  002e9	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002ee	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  002f5	75 0e		 jne	 SHORT $LN21@stbi__proc
  002f7	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002fc	83 b8 40 48 00
	00 00		 cmp	 DWORD PTR [rax+18496], 0
  00303	74 0e		 je	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37673
  0030c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00311	eb 14		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:

; 3200 :             z->spec_end = 63;

  00313	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00318	c7 80 38 48 00
	00 3f 00 00 00	 mov	 DWORD PTR [rax+18488], 63 ; 0000003fH
$LN16@stbi__proc:

; 3201 :         }
; 3202 :     }
; 3203 :     
; 3204 :     return 1;

  00322	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 3205 : }

  00327	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0032b	c3		 ret	 0
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__process_scan_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
L$ = 32
i$1 = 36
th$2 = 40
tv64 = 44
i$3 = 48
n$4 = 52
i$5 = 56
i$6 = 60
p$7 = 64
tc$8 = 68
tv88 = 72
q$9 = 76
t$10 = 80
tv149 = 84
sixteen$11 = 88
tv152 = 92
tv155 = 96
q$12 = 100
tv233 = 104
ok$13 = 108
ok$14 = 112
v$15 = 120
sizes$16 = 128
__$ArrayPad$ = 192
z$ = 224
m$ = 232
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__process_marker

; 3066 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3067 :     int L;
; 3068 :     switch (m) {

  00022	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR m$[rsp]
  00029	89 44 24 2c	 mov	 DWORD PTR tv64[rsp], eax
  0002d	81 7c 24 2c c4
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 196 ; 000000c4H
  00035	0f 84 ff 01 00
	00		 je	 $LN29@stbi__proc
  0003b	81 7c 24 2c db
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 219 ; 000000dbH
  00043	74 78		 je	 SHORT $LN26@stbi__proc
  00045	81 7c 24 2c dd
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 221 ; 000000ddH
  0004d	74 20		 je	 SHORT $LN24@stbi__proc
  0004f	81 7c 24 2c ff
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 255 ; 000000ffH
  00057	74 05		 je	 SHORT $LN23@stbi__proc
  00059	e9 22 04 00 00	 jmp	 $LN2@stbi__proc
$LN23@stbi__proc:

; 3069 :         case STBI__MARKER_none: // no marker found
; 3070 :         return stbi__err("expected marker","Corrupt JPEG");

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37603
  00065	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0006a	e9 2d 06 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 3071 :         
; 3072 :         case 0xDD: // DRI - specify restart interval
; 3073 :         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");

  0006f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00077	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0007f	83 f8 04	 cmp	 eax, 4
  00082	74 11		 je	 SHORT $LN25@stbi__proc
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37606
  0008b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00090	e9 07 06 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:

; 3074 :         z->restart_interval = stbi__get16be(z->s);

  00095	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0009d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a0	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000a5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000ad	89 81 68 48 00
	00		 mov	 DWORD PTR [rcx+18536], eax

; 3075 :         return 1;

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	e9 df 05 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 3076 :         
; 3077 :         case 0xDB: // DQT - define quantization table
; 3078 :         L = stbi__get16be(z->s)-2;

  000bd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000c5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c8	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000cd	83 e8 02	 sub	 eax, 2
  000d0	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN4@stbi__proc:

; 3079 :         while (L > 0) {

  000d4	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  000d9	0f 8e 39 01 00
	00		 jle	 $LN5@stbi__proc

; 3080 :             int q = stbi__get8(z->s);

  000df	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000e7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ea	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	89 44 24 4c	 mov	 DWORD PTR q$9[rsp], eax

; 3081 :             int p = q >> 4, sixteen = (p != 0);

  000f6	8b 44 24 4c	 mov	 eax, DWORD PTR q$9[rsp]
  000fa	c1 f8 04	 sar	 eax, 4
  000fd	89 44 24 40	 mov	 DWORD PTR p$7[rsp], eax
  00101	83 7c 24 40 00	 cmp	 DWORD PTR p$7[rsp], 0
  00106	74 0a		 je	 SHORT $LN51@stbi__proc
  00108	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00110	eb 08		 jmp	 SHORT $LN52@stbi__proc
$LN51@stbi__proc:
  00112	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN52@stbi__proc:
  0011a	8b 44 24 48	 mov	 eax, DWORD PTR tv88[rsp]
  0011e	89 44 24 58	 mov	 DWORD PTR sixteen$11[rsp], eax

; 3082 :             int t = q & 15,i;

  00122	8b 44 24 4c	 mov	 eax, DWORD PTR q$9[rsp]
  00126	83 e0 0f	 and	 eax, 15
  00129	89 44 24 50	 mov	 DWORD PTR t$10[rsp], eax

; 3083 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");

  0012d	83 7c 24 40 00	 cmp	 DWORD PTR p$7[rsp], 0
  00132	74 18		 je	 SHORT $LN27@stbi__proc
  00134	83 7c 24 40 01	 cmp	 DWORD PTR p$7[rsp], 1
  00139	74 11		 je	 SHORT $LN27@stbi__proc
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37609
  00142	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00147	e9 50 05 00 00	 jmp	 $LN1@stbi__proc
$LN27@stbi__proc:

; 3084 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

  0014c	83 7c 24 50 03	 cmp	 DWORD PTR t$10[rsp], 3
  00151	7e 11		 jle	 SHORT $LN28@stbi__proc
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37611
  0015a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015f	e9 38 05 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 3085 :             
; 3086 :             for (i=0; i < 64; ++i)

  00164	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  0016c	eb 0a		 jmp	 SHORT $LN8@stbi__proc
$LN6@stbi__proc:
  0016e	8b 44 24 30	 mov	 eax, DWORD PTR i$3[rsp]
  00172	ff c0		 inc	 eax
  00174	89 44 24 30	 mov	 DWORD PTR i$3[rsp], eax
$LN8@stbi__proc:
  00178	83 7c 24 30 40	 cmp	 DWORD PTR i$3[rsp], 64	; 00000040H
  0017d	7d 6b		 jge	 SHORT $LN7@stbi__proc

; 3087 :                 z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

  0017f	83 7c 24 58 00	 cmp	 DWORD PTR sixteen$11[rsp], 0
  00184	74 16		 je	 SHORT $LN53@stbi__proc
  00186	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0018e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00191	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00196	89 44 24 54	 mov	 DWORD PTR tv149[rsp], eax
  0019a	eb 17		 jmp	 SHORT $LN54@stbi__proc
$LN53@stbi__proc:
  0019c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  001a4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001a7	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001ac	0f b6 c0	 movzx	 eax, al
  001af	89 44 24 54	 mov	 DWORD PTR tv149[rsp], eax
$LN54@stbi__proc:
  001b3	48 63 44 24 50	 movsxd	 rax, DWORD PTR t$10[rsp]
  001b8	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  001bf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001c7	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  001cf	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$3[rsp]
  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  001db	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001df	0f b7 54 24 54	 movzx	 edx, WORD PTR tv149[rsp]
  001e4	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  001e8	eb 84		 jmp	 SHORT $LN6@stbi__proc
$LN7@stbi__proc:

; 3088 :             L -= (sixteen ? 129 : 65);

  001ea	83 7c 24 58 00	 cmp	 DWORD PTR sixteen$11[rsp], 0
  001ef	74 0a		 je	 SHORT $LN55@stbi__proc
  001f1	c7 44 24 5c 81
	00 00 00	 mov	 DWORD PTR tv152[rsp], 129 ; 00000081H
  001f9	eb 08		 jmp	 SHORT $LN56@stbi__proc
$LN55@stbi__proc:
  001fb	c7 44 24 5c 41
	00 00 00	 mov	 DWORD PTR tv152[rsp], 65 ; 00000041H
$LN56@stbi__proc:
  00203	8b 44 24 5c	 mov	 eax, DWORD PTR tv152[rsp]
  00207	8b 4c 24 20	 mov	 ecx, DWORD PTR L$[rsp]
  0020b	2b c8		 sub	 ecx, eax
  0020d	8b c1		 mov	 eax, ecx
  0020f	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3089 :         }

  00213	e9 bc fe ff ff	 jmp	 $LN4@stbi__proc
$LN5@stbi__proc:

; 3090 :         return L==0;

  00218	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  0021d	75 0a		 jne	 SHORT $LN57@stbi__proc
  0021f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  00227	eb 08		 jmp	 SHORT $LN58@stbi__proc
$LN57@stbi__proc:
  00229	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN58@stbi__proc:
  00231	8b 44 24 60	 mov	 eax, DWORD PTR tv155[rsp]
  00235	e9 62 04 00 00	 jmp	 $LN1@stbi__proc
$LN29@stbi__proc:

; 3091 :         
; 3092 :         case 0xC4: // DHT - define huffman table
; 3093 :         L = stbi__get16be(z->s)-2;

  0023a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00242	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00245	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0024a	83 e8 02	 sub	 eax, 2
  0024d	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN9@stbi__proc:

; 3094 :         while (L > 0) {

  00251	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  00256	0f 8e 02 02 00
	00		 jle	 $LN10@stbi__proc

; 3095 :             stbi_uc *v;
; 3096 :             int sizes[16],i,n=0;

  0025c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR n$4[rsp], 0

; 3097 :             int q = stbi__get8(z->s);

  00264	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0026c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0026f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00274	0f b6 c0	 movzx	 eax, al
  00277	89 44 24 64	 mov	 DWORD PTR q$12[rsp], eax

; 3098 :             int tc = q >> 4;

  0027b	8b 44 24 64	 mov	 eax, DWORD PTR q$12[rsp]
  0027f	c1 f8 04	 sar	 eax, 4
  00282	89 44 24 44	 mov	 DWORD PTR tc$8[rsp], eax

; 3099 :             int th = q & 15;

  00286	8b 44 24 64	 mov	 eax, DWORD PTR q$12[rsp]
  0028a	83 e0 0f	 and	 eax, 15
  0028d	89 44 24 28	 mov	 DWORD PTR th$2[rsp], eax

; 3100 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");

  00291	83 7c 24 44 01	 cmp	 DWORD PTR tc$8[rsp], 1
  00296	7f 07		 jg	 SHORT $LN31@stbi__proc
  00298	83 7c 24 28 03	 cmp	 DWORD PTR th$2[rsp], 3
  0029d	7e 11		 jle	 SHORT $LN30@stbi__proc
$LN31@stbi__proc:
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37615
  002a6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002ab	e9 ec 03 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 3101 :             for (i=0; i < 16; ++i) {

  002b0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  002b8	eb 0a		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  002ba	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  002be	ff c0		 inc	 eax
  002c0	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN13@stbi__proc:
  002c4	83 7c 24 24 10	 cmp	 DWORD PTR i$1[rsp], 16
  002c9	7d 39		 jge	 SHORT $LN12@stbi__proc

; 3102 :                 sizes[i] = stbi__get8(z->s);

  002cb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002d3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002d6	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  002db	0f b6 c0	 movzx	 eax, al
  002de	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  002e3	89 84 8c 80 00
	00 00		 mov	 DWORD PTR sizes$16[rsp+rcx*4], eax

; 3103 :                 n += sizes[i];

  002ea	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  002ef	8b 84 84 80 00
	00 00		 mov	 eax, DWORD PTR sizes$16[rsp+rax*4]
  002f6	8b 4c 24 34	 mov	 ecx, DWORD PTR n$4[rsp]
  002fa	03 c8		 add	 ecx, eax
  002fc	8b c1		 mov	 eax, ecx
  002fe	89 44 24 34	 mov	 DWORD PTR n$4[rsp], eax

; 3104 :             }

  00302	eb b6		 jmp	 SHORT $LN11@stbi__proc
$LN12@stbi__proc:

; 3105 :             L -= 17;

  00304	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00308	83 e8 11	 sub	 eax, 17
  0030b	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3106 :             if (tc == 0) {

  0030f	83 7c 24 44 00	 cmp	 DWORD PTR tc$8[rsp], 0
  00314	75 57		 jne	 SHORT $LN32@stbi__proc

; 3107 :                 if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;

  00316	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  0031b	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00322	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0032a	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0032f	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR sizes$16[rsp]
  00337	48 8b c8	 mov	 rcx, rax
  0033a	e8 00 00 00 00	 call	 ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
  0033f	85 c0		 test	 eax, eax
  00341	75 07		 jne	 SHORT $LN34@stbi__proc
  00343	33 c0		 xor	 eax, eax
  00345	e9 52 03 00 00	 jmp	 $LN1@stbi__proc
$LN34@stbi__proc:

; 3108 :                 v = z->huff_dc[th].values;

  0034a	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  0034f	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00356	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0035e	48 8d 84 01 08
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1032]
  00366	48 89 44 24 78	 mov	 QWORD PTR v$15[rsp], rax

; 3109 :             } else {

  0036b	eb 58		 jmp	 SHORT $LN33@stbi__proc
$LN32@stbi__proc:

; 3110 :                 if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;

  0036d	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  00372	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00379	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00381	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  00389	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR sizes$16[rsp]
  00391	48 8b c8	 mov	 rcx, rax
  00394	e8 00 00 00 00	 call	 ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
  00399	85 c0		 test	 eax, eax
  0039b	75 07		 jne	 SHORT $LN35@stbi__proc
  0039d	33 c0		 xor	 eax, eax
  0039f	e9 f8 02 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 3111 :                 v = z->huff_ac[th].values;

  003a4	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  003a9	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  003b0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003b8	48 8d 84 01 48
	1e 00 00	 lea	 rax, QWORD PTR [rcx+rax+7752]
  003c0	48 89 44 24 78	 mov	 QWORD PTR v$15[rsp], rax
$LN33@stbi__proc:

; 3112 :             }
; 3113 :             for (i=0; i < n; ++i)

  003c5	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  003cd	eb 0a		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  003cf	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  003d3	ff c0		 inc	 eax
  003d5	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN16@stbi__proc:
  003d9	8b 44 24 34	 mov	 eax, DWORD PTR n$4[rsp]
  003dd	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  003e1	7d 1f		 jge	 SHORT $LN15@stbi__proc

; 3114 :                 v[i] = stbi__get8(z->s);

  003e3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003eb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003ee	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  003f3	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  003f8	48 8b 54 24 78	 mov	 rdx, QWORD PTR v$15[rsp]
  003fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00400	eb cd		 jmp	 SHORT $LN14@stbi__proc
$LN15@stbi__proc:

; 3115 :             if (tc != 0)

  00402	83 7c 24 44 00	 cmp	 DWORD PTR tc$8[rsp], 0
  00407	74 40		 je	 SHORT $LN36@stbi__proc

; 3116 :                 stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

  00409	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  0040e	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00415	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0041d	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  00425	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR th$2[rsp]
  0042a	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  00431	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00439	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  00441	48 8b d0	 mov	 rdx, rax
  00444	e8 00 00 00 00	 call	 ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ; stbi__build_fast_ac
$LN36@stbi__proc:

; 3117 :             L -= n;

  00449	8b 44 24 34	 mov	 eax, DWORD PTR n$4[rsp]
  0044d	8b 4c 24 20	 mov	 ecx, DWORD PTR L$[rsp]
  00451	2b c8		 sub	 ecx, eax
  00453	8b c1		 mov	 eax, ecx
  00455	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3118 :         }

  00459	e9 f3 fd ff ff	 jmp	 $LN9@stbi__proc
$LN10@stbi__proc:

; 3119 :         return L==0;

  0045e	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  00463	75 0a		 jne	 SHORT $LN59@stbi__proc
  00465	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  0046d	eb 08		 jmp	 SHORT $LN60@stbi__proc
$LN59@stbi__proc:
  0046f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
$LN60@stbi__proc:
  00477	8b 44 24 68	 mov	 eax, DWORD PTR tv233[rsp]
  0047b	e9 1c 02 00 00	 jmp	 $LN1@stbi__proc
$LN2@stbi__proc:

; 3120 :     }
; 3121 :     
; 3122 :     // check for comment block or APP blocks
; 3123 :     if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

  00480	81 bc 24 e8 00
	00 00 e0 00 00
	00		 cmp	 DWORD PTR m$[rsp], 224	; 000000e0H
  0048b	7c 0d		 jl	 SHORT $LN39@stbi__proc
  0048d	81 bc 24 e8 00
	00 00 ef 00 00
	00		 cmp	 DWORD PTR m$[rsp], 239	; 000000efH
  00498	7e 11		 jle	 SHORT $LN38@stbi__proc
$LN39@stbi__proc:
  0049a	81 bc 24 e8 00
	00 00 fe 00 00
	00		 cmp	 DWORD PTR m$[rsp], 254	; 000000feH
  004a5	0f 85 e5 01 00
	00		 jne	 $LN37@stbi__proc
$LN38@stbi__proc:

; 3124 :         L = stbi__get16be(z->s);

  004ab	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  004b3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004b6	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  004bb	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3125 :         if (L < 2) {

  004bf	83 7c 24 20 02	 cmp	 DWORD PTR L$[rsp], 2
  004c4	7d 31		 jge	 SHORT $LN40@stbi__proc

; 3126 :             if (m == 0xFE)

  004c6	81 bc 24 e8 00
	00 00 fe 00 00
	00		 cmp	 DWORD PTR m$[rsp], 254	; 000000feH
  004d1	75 13		 jne	 SHORT $LN41@stbi__proc

; 3127 :                 return stbi__err("bad COM len","Corrupt JPEG");

  004d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37627
  004da	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004df	e9 b8 01 00 00	 jmp	 $LN1@stbi__proc
  004e4	eb 11		 jmp	 SHORT $LN42@stbi__proc
$LN41@stbi__proc:

; 3128 :             else
; 3129 :                 return stbi__err("bad APP len","Corrupt JPEG");

  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37628
  004ed	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004f2	e9 a5 01 00 00	 jmp	 $LN1@stbi__proc
$LN42@stbi__proc:
$LN40@stbi__proc:

; 3130 :         }
; 3131 :         L -= 2;

  004f7	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  004fb	83 e8 02	 sub	 eax, 2
  004fe	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3132 :         
; 3133 :         if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

  00502	81 bc 24 e8 00
	00 00 e0 00 00
	00		 cmp	 DWORD PTR m$[rsp], 224	; 000000e0H
  0050d	0f 85 84 00 00
	00		 jne	 $LN43@stbi__proc
  00513	83 7c 24 20 05	 cmp	 DWORD PTR L$[rsp], 5
  00518	7c 7d		 jl	 SHORT $LN43@stbi__proc

; 3134 :             static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3135 :             int ok = 1;

  0051a	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR ok$13[rsp], 1

; 3136 :             int i;
; 3137 :             for (i=0; i < 5; ++i)

  00522	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$5[rsp], 0
  0052a	eb 0a		 jmp	 SHORT $LN19@stbi__proc
$LN17@stbi__proc:
  0052c	8b 44 24 38	 mov	 eax, DWORD PTR i$5[rsp]
  00530	ff c0		 inc	 eax
  00532	89 44 24 38	 mov	 DWORD PTR i$5[rsp], eax
$LN19@stbi__proc:
  00536	83 7c 24 38 05	 cmp	 DWORD PTR i$5[rsp], 5
  0053b	7d 31		 jge	 SHORT $LN18@stbi__proc

; 3138 :                 if (stbi__get8(z->s) != tag[i])

  0053d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00545	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00548	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0054d	0f b6 c0	 movzx	 eax, al
  00550	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR i$5[rsp]
  00555	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?CL@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
  0055c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00560	3b c1		 cmp	 eax, ecx
  00562	74 08		 je	 SHORT $LN45@stbi__proc

; 3139 :                 ok = 0;

  00564	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ok$13[rsp], 0
$LN45@stbi__proc:
  0056c	eb be		 jmp	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 3140 :             L -= 5;

  0056e	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00572	83 e8 05	 sub	 eax, 5
  00575	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3141 :             if (ok)

  00579	83 7c 24 6c 00	 cmp	 DWORD PTR ok$13[rsp], 0
  0057e	74 12		 je	 SHORT $LN46@stbi__proc

; 3142 :                 z->jfif = 1;

  00580	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00588	c7 80 48 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18504], 1
$LN46@stbi__proc:
  00592	e9 de 00 00 00	 jmp	 $LN44@stbi__proc
$LN43@stbi__proc:

; 3143 :         } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

  00597	81 bc 24 e8 00
	00 00 ee 00 00
	00		 cmp	 DWORD PTR m$[rsp], 238	; 000000eeH
  005a2	0f 85 cd 00 00
	00		 jne	 $LN47@stbi__proc
  005a8	83 7c 24 20 0c	 cmp	 DWORD PTR L$[rsp], 12
  005ad	0f 8c c2 00 00
	00		 jl	 $LN47@stbi__proc

; 3144 :             static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3145 :             int ok = 1;

  005b3	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR ok$14[rsp], 1

; 3146 :             int i;
; 3147 :             for (i=0; i < 6; ++i)

  005bb	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  005c3	eb 0a		 jmp	 SHORT $LN22@stbi__proc
$LN20@stbi__proc:
  005c5	8b 44 24 3c	 mov	 eax, DWORD PTR i$6[rsp]
  005c9	ff c0		 inc	 eax
  005cb	89 44 24 3c	 mov	 DWORD PTR i$6[rsp], eax
$LN22@stbi__proc:
  005cf	83 7c 24 3c 06	 cmp	 DWORD PTR i$6[rsp], 6
  005d4	7d 31		 jge	 SHORT $LN21@stbi__proc

; 3148 :                 if (stbi__get8(z->s) != tag[i])

  005d6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005de	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005e1	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  005e6	0f b6 c0	 movzx	 eax, al
  005e9	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR i$6[rsp]
  005ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?DE@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
  005f5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  005f9	3b c1		 cmp	 eax, ecx
  005fb	74 08		 je	 SHORT $LN48@stbi__proc

; 3149 :                 ok = 0;

  005fd	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR ok$14[rsp], 0
$LN48@stbi__proc:
  00605	eb be		 jmp	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:

; 3150 :             L -= 6;

  00607	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  0060b	83 e8 06	 sub	 eax, 6
  0060e	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3151 :             if (ok) {

  00612	83 7c 24 70 00	 cmp	 DWORD PTR ok$14[rsp], 0
  00617	74 5c		 je	 SHORT $LN49@stbi__proc

; 3152 :                 stbi__get8(z->s); // version

  00619	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00621	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00624	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 3153 :                 stbi__get16be(z->s); // flags0

  00629	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00631	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00634	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3154 :                 stbi__get16be(z->s); // flags1

  00639	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00641	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00644	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3155 :                 z->app14_color_transform = stbi__get8(z->s); // color transform

  00649	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00651	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00654	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00659	0f b6 c0	 movzx	 eax, al
  0065c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00664	89 81 4c 48 00
	00		 mov	 DWORD PTR [rcx+18508], eax

; 3156 :                 L -= 6;

  0066a	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  0066e	83 e8 06	 sub	 eax, 6
  00671	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN49@stbi__proc:
$LN47@stbi__proc:
$LN44@stbi__proc:

; 3157 :             }
; 3158 :         }
; 3159 :         
; 3160 :         stbi__skip(z->s, L);

  00675	8b 54 24 20	 mov	 edx, DWORD PTR L$[rsp]
  00679	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00681	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00684	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 3161 :         return 1;

  00689	b8 01 00 00 00	 mov	 eax, 1
  0068e	eb 0c		 jmp	 SHORT $LN1@stbi__proc
$LN37@stbi__proc:

; 3162 :     }
; 3163 :     
; 3164 :     return stbi__err("unknown marker","Corrupt JPEG");

  00690	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG37636
  00697	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
$LN1@stbi__proc:

; 3165 : }

  0069c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006a4	48 33 cc	 xor	 rcx, rsp
  006a7	e8 00 00 00 00	 call	 __security_check_cookie
  006ac	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006b3	c3		 ret	 0
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__process_marker
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
n$1 = 32
j$2 = 36
i$3 = 40
h$4 = 44
w$5 = 48
data$6 = 56
z$ = 80
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_finish

; 3047 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3048 :     if (z->progressive) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0000e	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00015	0f 84 a9 01 00
	00		 je	 $LN11@stbi__jpeg

; 3049 :         // dequantize and idct the data
; 3050 :         int i,j,n;
; 3051 :         for (n=0; n < z->s->img_n; ++n) {

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  00023	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00025	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax
$LN4@stbi__jpeg:
  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 20	 cmp	 DWORD PTR n$1[rsp], eax
  0003e	0f 8d 80 01 00
	00		 jge	 $LN3@stbi__jpeg

; 3052 :             int w = (z->img_comp[n].x+7) >> 3;

  00044	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00049	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00052	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  00059	83 c0 07	 add	 eax, 7
  0005c	c1 f8 03	 sar	 eax, 3
  0005f	89 44 24 30	 mov	 DWORD PTR w$5[rsp], eax

; 3053 :             int h = (z->img_comp[n].y+7) >> 3;

  00063	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00068	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00071	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00078	83 c0 07	 add	 eax, 7
  0007b	c1 f8 03	 sar	 eax, 3
  0007e	89 44 24 2c	 mov	 DWORD PTR h$4[rsp], eax

; 3054 :             for (j=0; j < h; ++j) {

  00082	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$2[rsp], 0
  0008a	eb 0a		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  0008c	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  00090	ff c0		 inc	 eax
  00092	89 44 24 24	 mov	 DWORD PTR j$2[rsp], eax
$LN7@stbi__jpeg:
  00096	8b 44 24 2c	 mov	 eax, DWORD PTR h$4[rsp]
  0009a	39 44 24 24	 cmp	 DWORD PTR j$2[rsp], eax
  0009e	0f 8d 1b 01 00
	00		 jge	 $LN6@stbi__jpeg

; 3055 :                 for (i=0; i < w; ++i) {

  000a4	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN10@stbi__jpeg
$LN8@stbi__jpeg:
  000ae	8b 44 24 28	 mov	 eax, DWORD PTR i$3[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 28	 mov	 DWORD PTR i$3[rsp], eax
$LN10@stbi__jpeg:
  000b8	8b 44 24 30	 mov	 eax, DWORD PTR w$5[rsp]
  000bc	39 44 24 28	 cmp	 DWORD PTR i$3[rsp], eax
  000c0	0f 8d f4 00 00
	00		 jge	 $LN9@stbi__jpeg

; 3056 :                     short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  000cb	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000cf	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR n$1[rsp]
  000d4	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  000d8	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  000dd	44 8b 44 24 24	 mov	 r8d, DWORD PTR j$2[rsp]
  000e2	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  000eb	41 8b c8	 mov	 ecx, r8d
  000ee	8b 54 24 28	 mov	 edx, DWORD PTR i$3[rsp]
  000f2	03 d1		 add	 edx, ecx
  000f4	8b ca		 mov	 ecx, edx
  000f6	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  000f9	48 63 c9	 movsxd	 rcx, ecx
  000fc	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  00101	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00109	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  0010d	48 89 44 24 38	 mov	 QWORD PTR data$6[rsp], rax

; 3057 :                     stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

  00112	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00117	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00120	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  00128	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00134	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  0013c	48 8b d0	 mov	 rdx, rax
  0013f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$6[rsp]
  00144	e8 00 00 00 00	 call	 ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z ; stbi__jpeg_dequantize

; 3058 :                     z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

  00149	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  0014e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00152	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR n$1[rsp]
  00157	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0015b	48 63 54 24 20	 movsxd	 rdx, DWORD PTR n$1[rsp]
  00160	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  00164	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00169	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  00171	0f af 54 24 24	 imul	 edx, DWORD PTR j$2[rsp]
  00176	c1 e2 03	 shl	 edx, 3
  00179	48 63 d2	 movsxd	 rdx, edx
  0017c	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00181	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  00189	48 03 ca	 add	 rcx, rdx
  0018c	8b 54 24 28	 mov	 edx, DWORD PTR i$3[rsp]
  00190	c1 e2 03	 shl	 edx, 3
  00193	48 63 d2	 movsxd	 rdx, edx
  00196	48 03 ca	 add	 rcx, rdx
  00199	4c 8b 44 24 38	 mov	 r8, QWORD PTR data$6[rsp]
  0019e	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  001a3	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001af	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 3059 :                 }

  001b5	e9 f4 fe ff ff	 jmp	 $LN8@stbi__jpeg
$LN9@stbi__jpeg:

; 3060 :             }

  001ba	e9 cd fe ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 3061 :         }

  001bf	e9 61 fe ff ff	 jmp	 $LN2@stbi__jpeg
$LN3@stbi__jpeg:
$LN11@stbi__jpeg:

; 3062 :     }
; 3063 : }

  001c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c8	c3		 ret	 0
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_finish
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 0
data$ = 32
dequant$ = 40
?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z PROC		; stbi__jpeg_dequantize

; 3040 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 3041 :     int i;
; 3042 :     for (i=0; i < 64; ++i)

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00015	eb 08		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00017	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__jpeg:
  0001f	83 3c 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00023	7d 2c		 jge	 SHORT $LN3@stbi__jpeg

; 3043 :         data[i] *= dequant[i];

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0002d	48 8b 54 24 28	 mov	 rdx, QWORD PTR dequant$[rsp]
  00032	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  00036	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0003b	0f bf 04 42	 movsx	 eax, WORD PTR [rdx+rax*2]
  0003f	0f af c1	 imul	 eax, ecx
  00042	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0004b	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  0004f	eb c6		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 3044 : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z ENDP		; stbi__jpeg_dequantize
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
n$1 = 64
n$2 = 68
n$3 = 72
n$4 = 76
j$5 = 80
i$6 = 84
k$7 = 88
i$8 = 92
x$9 = 96
j$10 = 100
y$11 = 104
j$12 = 108
i$13 = 112
k$14 = 116
i$15 = 120
x$16 = 124
j$17 = 128
y$18 = 132
ha$19 = 136
tv190 = 140
ha$20 = 144
tv311 = 148
ha$21 = 152
tv400 = 156
tv518 = 160
h$22 = 164
w$23 = 168
y2$24 = 172
x2$25 = 176
h$26 = 180
w$27 = 184
y2$28 = 188
x2$29 = 192
data$30 = 200
data$31 = 208
data$32 = 224
data$33 = 352
__$ArrayPad$ = 480
z$ = 512
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z PROC ; stbi__parse_entropy_coded_data

; 2916 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2917 :     stbi__jpeg_reset(z);

  0001e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00026	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset

; 2918 :     if (!z->progressive) {

  0002b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00033	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  0003a	0f 85 68 06 00
	00		 jne	 $LN44@stbi__pars

; 2919 :         if (z->scan_n == 1) {

  00040	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00048	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  0004f	0f 85 ca 02 00
	00		 jne	 $LN46@stbi__pars

; 2920 :             int i,j;
; 2921 :             STBI_SIMD_ALIGN(short, data[64]);
; 2922 :             int n = z->order[0];

  00055	b8 04 00 00 00	 mov	 eax, 4
  0005a	48 6b c0 00	 imul	 rax, rax, 0
  0005e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00066	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  0006d	89 44 24 44	 mov	 DWORD PTR n$2[rsp], eax

; 2923 :             // non-interleaved data, we just need to process one block at a time,
; 2924 :             // in trivial scanline order
; 2925 :             // number of blocks to do just depends on how many actual "pixels" this
; 2926 :             // component has, independent of interleaved MCU blocking and such
; 2927 :             int w = (z->img_comp[n].x+7) >> 3;

  00071	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  00076	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0007a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00082	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  00089	83 c0 07	 add	 eax, 7
  0008c	c1 f8 03	 sar	 eax, 3
  0008f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR w$23[rsp], eax

; 2928 :             int h = (z->img_comp[n].y+7) >> 3;

  00096	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  0009b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0009f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000a7	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  000ae	83 c0 07	 add	 eax, 7
  000b1	c1 f8 03	 sar	 eax, 3
  000b4	89 84 24 a4 00
	00 00		 mov	 DWORD PTR h$22[rsp], eax

; 2929 :             for (j=0; j < h; ++j) {

  000bb	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR j$5[rsp], 0
  000c3	eb 0a		 jmp	 SHORT $LN4@stbi__pars
$LN2@stbi__pars:
  000c5	8b 44 24 50	 mov	 eax, DWORD PTR j$5[rsp]
  000c9	ff c0		 inc	 eax
  000cb	89 44 24 50	 mov	 DWORD PTR j$5[rsp], eax
$LN4@stbi__pars:
  000cf	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR h$22[rsp]
  000d6	39 44 24 50	 cmp	 DWORD PTR j$5[rsp], eax
  000da	0f 8d 30 02 00
	00		 jge	 $LN3@stbi__pars

; 2930 :                 for (i=0; i < w; ++i) {

  000e0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  000e8	eb 0a		 jmp	 SHORT $LN7@stbi__pars
$LN5@stbi__pars:
  000ea	8b 44 24 54	 mov	 eax, DWORD PTR i$6[rsp]
  000ee	ff c0		 inc	 eax
  000f0	89 44 24 54	 mov	 DWORD PTR i$6[rsp], eax
$LN7@stbi__pars:
  000f4	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR w$23[rsp]
  000fb	39 44 24 54	 cmp	 DWORD PTR i$6[rsp], eax
  000ff	0f 8d 06 02 00
	00		 jge	 $LN6@stbi__pars

; 2931 :                     int ha = z->img_comp[n].ha;

  00105	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  0010a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0010e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00116	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  0011d	89 84 24 88 00
	00 00		 mov	 DWORD PTR ha$19[rsp], eax

; 2932 :                     if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  00124	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  00129	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0012d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00135	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  0013d	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00144	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0014c	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00154	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR ha$19[rsp]
  0015c	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  00163	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0016b	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  00173	48 63 94 24 88
	00 00 00	 movsxd	 rdx, DWORD PTR ha$19[rsp]
  0017b	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  00182	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  0018a	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  00192	4c 63 44 24 44	 movsxd	 r8, DWORD PTR n$2[rsp]
  00197	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  0019b	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  001a3	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  001ab	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  001b2	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  001ba	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  001bf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001c4	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  001c8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001cc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d1	4c 8b ca	 mov	 r9, rdx
  001d4	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR data$32[rsp]
  001dc	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001e4	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ; stbi__jpeg_decode_block
  001e9	85 c0		 test	 eax, eax
  001eb	75 07		 jne	 SHORT $LN48@stbi__pars
  001ed	33 c0		 xor	 eax, eax
  001ef	e9 48 0a 00 00	 jmp	 $LN1@stbi__pars
$LN48@stbi__pars:

; 2933 :                     z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

  001f4	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  001f9	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001fd	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR n$2[rsp]
  00202	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00206	48 63 54 24 44	 movsxd	 rdx, DWORD PTR n$2[rsp]
  0020b	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0020f	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00217	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0021f	0f af 54 24 50	 imul	 edx, DWORD PTR j$5[rsp]
  00224	c1 e2 03	 shl	 edx, 3
  00227	48 63 d2	 movsxd	 rdx, edx
  0022a	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00232	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  0023a	48 03 ca	 add	 rcx, rdx
  0023d	8b 54 24 54	 mov	 edx, DWORD PTR i$6[rsp]
  00241	c1 e2 03	 shl	 edx, 3
  00244	48 63 d2	 movsxd	 rdx, edx
  00247	48 03 ca	 add	 rcx, rdx
  0024a	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR data$32[rsp]
  00252	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0025a	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  00261	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00269	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2934 :                     // every data block is an MCU, so countdown the restart interval
; 2935 :                     if (--z->todo <= 0) {

  0026f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00277	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  0027d	ff c8		 dec	 eax
  0027f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv190[rsp], eax
  00286	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0028e	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  00295	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  0029b	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv190[rsp], 0
  002a3	7f 61		 jg	 SHORT $LN49@stbi__pars

; 2936 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  002a5	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002ad	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  002b4	7d 0d		 jge	 SHORT $LN50@stbi__pars
  002b6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002be	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN50@stbi__pars:

; 2937 :                         // if it's NOT a restart, then just bail, so we get corrupt data
; 2938 :                         // rather than no data
; 2939 :                         if (!STBI__RESTART(z->marker)) return 1;

  002c3	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002cb	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  002d2	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  002d7	7c 16		 jl	 SHORT $LN52@stbi__pars
  002d9	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002e1	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  002e8	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  002ed	7e 0a		 jle	 SHORT $LN51@stbi__pars
$LN52@stbi__pars:
  002ef	b8 01 00 00 00	 mov	 eax, 1
  002f4	e9 43 09 00 00	 jmp	 $LN1@stbi__pars
$LN51@stbi__pars:

; 2940 :                         stbi__jpeg_reset(z);

  002f9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00301	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN49@stbi__pars:

; 2941 :                     }
; 2942 :                 }

  00306	e9 df fd ff ff	 jmp	 $LN5@stbi__pars
$LN6@stbi__pars:

; 2943 :             }

  0030b	e9 b5 fd ff ff	 jmp	 $LN2@stbi__pars
$LN3@stbi__pars:

; 2944 :             return 1;

  00310	b8 01 00 00 00	 mov	 eax, 1
  00315	e9 22 09 00 00	 jmp	 $LN1@stbi__pars

; 2945 :         } else { // interleaved

  0031a	e9 84 03 00 00	 jmp	 $LN47@stbi__pars
$LN46@stbi__pars:

; 2946 :             int i,j,k,x,y;
; 2947 :             STBI_SIMD_ALIGN(short, data[64]);
; 2948 :             for (j=0; j < z->img_mcu_y; ++j) {

  0031f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$10[rsp], 0
  00327	eb 0a		 jmp	 SHORT $LN10@stbi__pars
$LN8@stbi__pars:
  00329	8b 44 24 64	 mov	 eax, DWORD PTR j$10[rsp]
  0032d	ff c0		 inc	 eax
  0032f	89 44 24 64	 mov	 DWORD PTR j$10[rsp], eax
$LN10@stbi__pars:
  00333	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0033b	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  00341	39 44 24 64	 cmp	 DWORD PTR j$10[rsp], eax
  00345	0f 8d 4e 03 00
	00		 jge	 $LN9@stbi__pars

; 2949 :                 for (i=0; i < z->img_mcu_x; ++i) {

  0034b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  00353	eb 0a		 jmp	 SHORT $LN13@stbi__pars
$LN11@stbi__pars:
  00355	8b 44 24 5c	 mov	 eax, DWORD PTR i$8[rsp]
  00359	ff c0		 inc	 eax
  0035b	89 44 24 5c	 mov	 DWORD PTR i$8[rsp], eax
$LN13@stbi__pars:
  0035f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00367	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  0036d	39 44 24 5c	 cmp	 DWORD PTR i$8[rsp], eax
  00371	0f 8d 1d 03 00
	00		 jge	 $LN12@stbi__pars

; 2950 :                     // scan an interleaved mcu... process scan_n components in order
; 2951 :                     for (k=0; k < z->scan_n; ++k) {

  00377	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR k$7[rsp], 0
  0037f	eb 0a		 jmp	 SHORT $LN16@stbi__pars
$LN14@stbi__pars:
  00381	8b 44 24 58	 mov	 eax, DWORD PTR k$7[rsp]
  00385	ff c0		 inc	 eax
  00387	89 44 24 58	 mov	 DWORD PTR k$7[rsp], eax
$LN16@stbi__pars:
  0038b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00393	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00399	39 44 24 58	 cmp	 DWORD PTR k$7[rsp], eax
  0039d	0f 8d 55 02 00
	00		 jge	 $LN15@stbi__pars

; 2952 :                         int n = z->order[k];

  003a3	48 63 44 24 58	 movsxd	 rax, DWORD PTR k$7[rsp]
  003a8	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003b0	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  003b7	89 44 24 40	 mov	 DWORD PTR n$1[rsp], eax

; 2953 :                         // scan out an mcu's worth of this component; that's just determined
; 2954 :                         // by the basic H and V specified for the component
; 2955 :                         for (y=0; y < z->img_comp[n].v; ++y) {

  003bb	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR y$11[rsp], 0
  003c3	eb 0a		 jmp	 SHORT $LN19@stbi__pars
$LN17@stbi__pars:
  003c5	8b 44 24 68	 mov	 eax, DWORD PTR y$11[rsp]
  003c9	ff c0		 inc	 eax
  003cb	89 44 24 68	 mov	 DWORD PTR y$11[rsp], eax
$LN19@stbi__pars:
  003cf	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  003d4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003d8	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003e0	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  003e7	39 44 24 68	 cmp	 DWORD PTR y$11[rsp], eax
  003eb	0f 8d 02 02 00
	00		 jge	 $LN18@stbi__pars

; 2956 :                             for (x=0; x < z->img_comp[n].h; ++x) {

  003f1	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR x$9[rsp], 0
  003f9	eb 0a		 jmp	 SHORT $LN22@stbi__pars
$LN20@stbi__pars:
  003fb	8b 44 24 60	 mov	 eax, DWORD PTR x$9[rsp]
  003ff	ff c0		 inc	 eax
  00401	89 44 24 60	 mov	 DWORD PTR x$9[rsp], eax
$LN22@stbi__pars:
  00405	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  0040a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0040e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00416	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  0041d	39 44 24 60	 cmp	 DWORD PTR x$9[rsp], eax
  00421	0f 8d c7 01 00
	00		 jge	 $LN21@stbi__pars

; 2957 :                                 int x2 = (i*z->img_comp[n].h + x)*8;

  00427	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  0042c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00430	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00438	8b 54 24 5c	 mov	 edx, DWORD PTR i$8[rsp]
  0043c	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  00444	8b c2		 mov	 eax, edx
  00446	03 44 24 60	 add	 eax, DWORD PTR x$9[rsp]
  0044a	c1 e0 03	 shl	 eax, 3
  0044d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR x2$25[rsp], eax

; 2958 :                                 int y2 = (j*z->img_comp[n].v + y)*8;

  00454	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  00459	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0045d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00465	8b 54 24 64	 mov	 edx, DWORD PTR j$10[rsp]
  00469	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00471	8b c2		 mov	 eax, edx
  00473	03 44 24 68	 add	 eax, DWORD PTR y$11[rsp]
  00477	c1 e0 03	 shl	 eax, 3
  0047a	89 84 24 ac 00
	00 00		 mov	 DWORD PTR y2$24[rsp], eax

; 2959 :                                 int ha = z->img_comp[n].ha;

  00481	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  00486	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0048a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00492	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  00499	89 84 24 90 00
	00 00		 mov	 DWORD PTR ha$20[rsp], eax

; 2960 :                                 if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  004a0	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  004a5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004a9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004b1	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  004b9	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  004c0	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004c8	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  004d0	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ha$20[rsp]
  004d8	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  004df	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  004e7	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  004ef	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR ha$20[rsp]
  004f7	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  004fe	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00506	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  0050e	4c 63 44 24 40	 movsxd	 r8, DWORD PTR n$1[rsp]
  00513	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  00517	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  0051f	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  00527	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  0052e	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  00536	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  0053b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00540	8b 44 24 40	 mov	 eax, DWORD PTR n$1[rsp]
  00544	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00548	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0054d	4c 8b ca	 mov	 r9, rdx
  00550	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR data$33[rsp]
  00558	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00560	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ; stbi__jpeg_decode_block
  00565	85 c0		 test	 eax, eax
  00567	75 07		 jne	 SHORT $LN53@stbi__pars
  00569	33 c0		 xor	 eax, eax
  0056b	e9 cc 06 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 2961 :                                 z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);

  00570	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  00575	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00579	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR n$1[rsp]
  0057e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00582	48 63 54 24 40	 movsxd	 rdx, DWORD PTR n$1[rsp]
  00587	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0058b	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00593	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0059b	0f af 94 24 ac
	00 00 00	 imul	 edx, DWORD PTR y2$24[rsp]
  005a3	48 63 d2	 movsxd	 rdx, edx
  005a6	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  005ae	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  005b6	48 03 ca	 add	 rcx, rdx
  005b9	48 63 94 24 b0
	00 00 00	 movsxd	 rdx, DWORD PTR x2$25[rsp]
  005c1	48 03 ca	 add	 rcx, rdx
  005c4	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR data$33[rsp]
  005cc	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  005d4	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  005db	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005e3	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2962 :                             }

  005e9	e9 0d fe ff ff	 jmp	 $LN20@stbi__pars
$LN21@stbi__pars:

; 2963 :                         }

  005ee	e9 d2 fd ff ff	 jmp	 $LN17@stbi__pars
$LN18@stbi__pars:

; 2964 :                     }

  005f3	e9 89 fd ff ff	 jmp	 $LN14@stbi__pars
$LN15@stbi__pars:

; 2965 :                     // after all interleaved components, that's an interleaved MCU,
; 2966 :                     // so now count down the restart interval
; 2967 :                     if (--z->todo <= 0) {

  005f8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00600	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00606	ff c8		 dec	 eax
  00608	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv311[rsp], eax
  0060f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00617	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv311[rsp]
  0061e	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00624	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv311[rsp], 0
  0062c	7f 61		 jg	 SHORT $LN54@stbi__pars

; 2968 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  0062e	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00636	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  0063d	7d 0d		 jge	 SHORT $LN55@stbi__pars
  0063f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00647	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN55@stbi__pars:

; 2969 :                         if (!STBI__RESTART(z->marker)) return 1;

  0064c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00654	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  0065b	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00660	7c 16		 jl	 SHORT $LN57@stbi__pars
  00662	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0066a	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00671	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00676	7e 0a		 jle	 SHORT $LN56@stbi__pars
$LN57@stbi__pars:
  00678	b8 01 00 00 00	 mov	 eax, 1
  0067d	e9 ba 05 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 2970 :                         stbi__jpeg_reset(z);

  00682	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0068a	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN54@stbi__pars:

; 2971 :                     }
; 2972 :                 }

  0068f	e9 c1 fc ff ff	 jmp	 $LN11@stbi__pars
$LN12@stbi__pars:

; 2973 :             }

  00694	e9 90 fc ff ff	 jmp	 $LN8@stbi__pars
$LN9@stbi__pars:

; 2974 :             return 1;

  00699	b8 01 00 00 00	 mov	 eax, 1
  0069e	e9 99 05 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 2975 :         }
; 2976 :     } else {

  006a3	e9 94 05 00 00	 jmp	 $LN45@stbi__pars
$LN44@stbi__pars:

; 2977 :         if (z->scan_n == 1) {

  006a8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006b0	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  006b7	0f 85 a3 02 00
	00		 jne	 $LN58@stbi__pars

; 2978 :             int i,j;
; 2979 :             int n = z->order[0];

  006bd	b8 04 00 00 00	 mov	 eax, 4
  006c2	48 6b c0 00	 imul	 rax, rax, 0
  006c6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006ce	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  006d5	89 44 24 4c	 mov	 DWORD PTR n$4[rsp], eax

; 2980 :             // non-interleaved data, we just need to process one block at a time,
; 2981 :             // in trivial scanline order
; 2982 :             // number of blocks to do just depends on how many actual "pixels" this
; 2983 :             // component has, independent of interleaved MCU blocking and such
; 2984 :             int w = (z->img_comp[n].x+7) >> 3;

  006d9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  006de	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006e2	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006ea	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  006f1	83 c0 07	 add	 eax, 7
  006f4	c1 f8 03	 sar	 eax, 3
  006f7	89 84 24 b8 00
	00 00		 mov	 DWORD PTR w$27[rsp], eax

; 2985 :             int h = (z->img_comp[n].y+7) >> 3;

  006fe	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  00703	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00707	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0070f	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00716	83 c0 07	 add	 eax, 7
  00719	c1 f8 03	 sar	 eax, 3
  0071c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR h$26[rsp], eax

; 2986 :             for (j=0; j < h; ++j) {

  00723	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR j$12[rsp], 0
  0072b	eb 0a		 jmp	 SHORT $LN25@stbi__pars
$LN23@stbi__pars:
  0072d	8b 44 24 6c	 mov	 eax, DWORD PTR j$12[rsp]
  00731	ff c0		 inc	 eax
  00733	89 44 24 6c	 mov	 DWORD PTR j$12[rsp], eax
$LN25@stbi__pars:
  00737	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR h$26[rsp]
  0073e	39 44 24 6c	 cmp	 DWORD PTR j$12[rsp], eax
  00742	0f 8d 09 02 00
	00		 jge	 $LN24@stbi__pars

; 2987 :                 for (i=0; i < w; ++i) {

  00748	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$13[rsp], 0
  00750	eb 0a		 jmp	 SHORT $LN28@stbi__pars
$LN26@stbi__pars:
  00752	8b 44 24 70	 mov	 eax, DWORD PTR i$13[rsp]
  00756	ff c0		 inc	 eax
  00758	89 44 24 70	 mov	 DWORD PTR i$13[rsp], eax
$LN28@stbi__pars:
  0075c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR w$27[rsp]
  00763	39 44 24 70	 cmp	 DWORD PTR i$13[rsp], eax
  00767	0f 8d df 01 00
	00		 jge	 $LN27@stbi__pars

; 2988 :                     short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  0076d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  00772	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00776	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR n$4[rsp]
  0077b	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0077f	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00787	44 8b 44 24 6c	 mov	 r8d, DWORD PTR j$12[rsp]
  0078c	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00795	41 8b c8	 mov	 ecx, r8d
  00798	8b 54 24 70	 mov	 edx, DWORD PTR i$13[rsp]
  0079c	03 d1		 add	 edx, ecx
  0079e	8b ca		 mov	 ecx, edx
  007a0	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  007a3	48 63 c9	 movsxd	 rcx, ecx
  007a6	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  007ae	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  007b6	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  007ba	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR data$30[rsp], rax

; 2989 :                     if (z->spec_start == 0) {

  007c2	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  007ca	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  007d1	75 5a		 jne	 SHORT $LN60@stbi__pars

; 2990 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  007d3	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  007d8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007dc	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007e4	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  007ec	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  007f3	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007fb	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00800	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR n$4[rsp]
  00805	4c 8b c0	 mov	 r8, rax
  00808	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR data$30[rsp]
  00810	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00818	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
  0081d	85 c0		 test	 eax, eax
  0081f	75 07		 jne	 SHORT $LN62@stbi__pars

; 2991 :                             return 0;

  00821	33 c0		 xor	 eax, eax
  00823	e9 14 04 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 2992 :                     } else {

  00828	e9 83 00 00 00	 jmp	 $LN61@stbi__pars
$LN60@stbi__pars:

; 2993 :                         int ha = z->img_comp[n].ha;

  0082d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  00832	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00836	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0083e	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  00845	89 84 24 98 00
	00 00		 mov	 DWORD PTR ha$21[rsp], eax

; 2994 :                         if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

  0084c	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR ha$21[rsp]
  00854	48 69 c0 00 04
	00 00		 imul	 rax, rax, 1024		; 00000400H
  0085b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00863	48 8d 84 01 88
	36 00 00	 lea	 rax, QWORD PTR [rcx+rax+13960]
  0086b	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR ha$21[rsp]
  00873	48 69 c9 90 06
	00 00		 imul	 rcx, rcx, 1680		; 00000690H
  0087a	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00882	48 8d 8c 0a 48
	1a 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+6728]
  0088a	4c 8b c8	 mov	 r9, rax
  0088d	4c 8b c1	 mov	 r8, rcx
  00890	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR data$30[rsp]
  00898	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008a0	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ; stbi__jpeg_decode_block_prog_ac
  008a5	85 c0		 test	 eax, eax
  008a7	75 07		 jne	 SHORT $LN63@stbi__pars

; 2995 :                             return 0;

  008a9	33 c0		 xor	 eax, eax
  008ab	e9 8c 03 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:
$LN61@stbi__pars:

; 2996 :                     }
; 2997 :                     // every data block is an MCU, so countdown the restart interval
; 2998 :                     if (--z->todo <= 0) {

  008b0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008b8	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  008be	ff c8		 dec	 eax
  008c0	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv400[rsp], eax
  008c7	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008cf	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv400[rsp]
  008d6	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  008dc	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv400[rsp], 0
  008e4	7f 61		 jg	 SHORT $LN64@stbi__pars

; 2999 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  008e6	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008ee	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  008f5	7d 0d		 jge	 SHORT $LN65@stbi__pars
  008f7	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008ff	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN65@stbi__pars:

; 3000 :                         if (!STBI__RESTART(z->marker)) return 1;

  00904	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0090c	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00913	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00918	7c 16		 jl	 SHORT $LN67@stbi__pars
  0091a	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00922	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00929	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  0092e	7e 0a		 jle	 SHORT $LN66@stbi__pars
$LN67@stbi__pars:
  00930	b8 01 00 00 00	 mov	 eax, 1
  00935	e9 02 03 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 3001 :                         stbi__jpeg_reset(z);

  0093a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00942	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN64@stbi__pars:

; 3002 :                     }
; 3003 :                 }

  00947	e9 06 fe ff ff	 jmp	 $LN26@stbi__pars
$LN27@stbi__pars:

; 3004 :             }

  0094c	e9 dc fd ff ff	 jmp	 $LN23@stbi__pars
$LN24@stbi__pars:

; 3005 :             return 1;

  00951	b8 01 00 00 00	 mov	 eax, 1
  00956	e9 e1 02 00 00	 jmp	 $LN1@stbi__pars

; 3006 :         } else { // interleaved

  0095b	e9 dc 02 00 00	 jmp	 $LN59@stbi__pars
$LN58@stbi__pars:

; 3007 :             int i,j,k,x,y;
; 3008 :             for (j=0; j < z->img_mcu_y; ++j) {

  00960	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$17[rsp], 0
  0096b	eb 10		 jmp	 SHORT $LN31@stbi__pars
$LN29@stbi__pars:
  0096d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR j$17[rsp]
  00974	ff c0		 inc	 eax
  00976	89 84 24 80 00
	00 00		 mov	 DWORD PTR j$17[rsp], eax
$LN31@stbi__pars:
  0097d	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00985	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  0098b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR j$17[rsp], eax
  00992	0f 8d 9f 02 00
	00		 jge	 $LN30@stbi__pars

; 3009 :                 for (i=0; i < z->img_mcu_x; ++i) {

  00998	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR i$15[rsp], 0
  009a0	eb 0a		 jmp	 SHORT $LN34@stbi__pars
$LN32@stbi__pars:
  009a2	8b 44 24 78	 mov	 eax, DWORD PTR i$15[rsp]
  009a6	ff c0		 inc	 eax
  009a8	89 44 24 78	 mov	 DWORD PTR i$15[rsp], eax
$LN34@stbi__pars:
  009ac	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009b4	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  009ba	39 44 24 78	 cmp	 DWORD PTR i$15[rsp], eax
  009be	0f 8d 6e 02 00
	00		 jge	 $LN33@stbi__pars

; 3010 :                     // scan an interleaved mcu... process scan_n components in order
; 3011 :                     for (k=0; k < z->scan_n; ++k) {

  009c4	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR k$14[rsp], 0
  009cc	eb 0a		 jmp	 SHORT $LN37@stbi__pars
$LN35@stbi__pars:
  009ce	8b 44 24 74	 mov	 eax, DWORD PTR k$14[rsp]
  009d2	ff c0		 inc	 eax
  009d4	89 44 24 74	 mov	 DWORD PTR k$14[rsp], eax
$LN37@stbi__pars:
  009d8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009e0	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  009e6	39 44 24 74	 cmp	 DWORD PTR k$14[rsp], eax
  009ea	0f 8d a9 01 00
	00		 jge	 $LN36@stbi__pars

; 3012 :                         int n = z->order[k];

  009f0	48 63 44 24 74	 movsxd	 rax, DWORD PTR k$14[rsp]
  009f5	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009fd	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  00a04	89 44 24 48	 mov	 DWORD PTR n$3[rsp], eax

; 3013 :                         // scan out an mcu's worth of this component; that's just determined
; 3014 :                         // by the basic H and V specified for the component
; 3015 :                         for (y=0; y < z->img_comp[n].v; ++y) {

  00a08	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR y$18[rsp], 0
  00a13	eb 10		 jmp	 SHORT $LN40@stbi__pars
$LN38@stbi__pars:
  00a15	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR y$18[rsp]
  00a1c	ff c0		 inc	 eax
  00a1e	89 84 24 84 00
	00 00		 mov	 DWORD PTR y$18[rsp], eax
$LN40@stbi__pars:
  00a25	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00a2a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a2e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a36	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00a3d	39 84 24 84 00
	00 00		 cmp	 DWORD PTR y$18[rsp], eax
  00a44	0f 8d 4a 01 00
	00		 jge	 $LN39@stbi__pars

; 3016 :                             for (x=0; x < z->img_comp[n].h; ++x) {

  00a4a	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR x$16[rsp], 0
  00a52	eb 0a		 jmp	 SHORT $LN43@stbi__pars
$LN41@stbi__pars:
  00a54	8b 44 24 7c	 mov	 eax, DWORD PTR x$16[rsp]
  00a58	ff c0		 inc	 eax
  00a5a	89 44 24 7c	 mov	 DWORD PTR x$16[rsp], eax
$LN43@stbi__pars:
  00a5e	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00a63	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a67	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a6f	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  00a76	39 44 24 7c	 cmp	 DWORD PTR x$16[rsp], eax
  00a7a	0f 8d 0f 01 00
	00		 jge	 $LN42@stbi__pars

; 3017 :                                 int x2 = (i*z->img_comp[n].h + x);

  00a80	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00a85	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a89	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a91	8b 54 24 78	 mov	 edx, DWORD PTR i$15[rsp]
  00a95	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  00a9d	8b c2		 mov	 eax, edx
  00a9f	03 44 24 7c	 add	 eax, DWORD PTR x$16[rsp]
  00aa3	89 84 24 c0 00
	00 00		 mov	 DWORD PTR x2$29[rsp], eax

; 3018 :                                 int y2 = (j*z->img_comp[n].v + y);

  00aaa	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00aaf	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ab3	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00abb	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR j$17[rsp]
  00ac2	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00aca	8b c2		 mov	 eax, edx
  00acc	03 84 24 84 00
	00 00		 add	 eax, DWORD PTR y$18[rsp]
  00ad3	89 84 24 bc 00
	00 00		 mov	 DWORD PTR y2$28[rsp], eax

; 3019 :                                 short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

  00ada	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00adf	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ae3	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR n$3[rsp]
  00ae8	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00aec	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00af4	44 8b 84 24 bc
	00 00 00	 mov	 r8d, DWORD PTR y2$28[rsp]
  00afc	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00b05	41 8b c8	 mov	 ecx, r8d
  00b08	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR x2$29[rsp]
  00b0f	03 d1		 add	 edx, ecx
  00b11	8b ca		 mov	 ecx, edx
  00b13	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00b16	48 63 c9	 movsxd	 rcx, ecx
  00b19	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00b21	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00b29	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00b2d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR data$31[rsp], rax

; 3020 :                                 if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  00b35	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00b3a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b3e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b46	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  00b4e	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00b55	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b5d	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00b62	44 8b 4c 24 48	 mov	 r9d, DWORD PTR n$3[rsp]
  00b67	4c 8b c0	 mov	 r8, rax
  00b6a	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR data$31[rsp]
  00b72	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b7a	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
  00b7f	85 c0		 test	 eax, eax
  00b81	75 07		 jne	 SHORT $LN68@stbi__pars

; 3021 :                                     return 0;

  00b83	33 c0		 xor	 eax, eax
  00b85	e9 b2 00 00 00	 jmp	 $LN1@stbi__pars
$LN68@stbi__pars:

; 3022 :                             }

  00b8a	e9 c5 fe ff ff	 jmp	 $LN41@stbi__pars
$LN42@stbi__pars:

; 3023 :                         }

  00b8f	e9 81 fe ff ff	 jmp	 $LN38@stbi__pars
$LN39@stbi__pars:

; 3024 :                     }

  00b94	e9 35 fe ff ff	 jmp	 $LN35@stbi__pars
$LN36@stbi__pars:

; 3025 :                     // after all interleaved components, that's an interleaved MCU,
; 3026 :                     // so now count down the restart interval
; 3027 :                     if (--z->todo <= 0) {

  00b99	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00ba1	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00ba7	ff c8		 dec	 eax
  00ba9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv518[rsp], eax
  00bb0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bb8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv518[rsp]
  00bbf	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00bc5	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv518[rsp], 0
  00bcd	7f 5e		 jg	 SHORT $LN69@stbi__pars

; 3028 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  00bcf	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bd7	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  00bde	7d 0d		 jge	 SHORT $LN70@stbi__pars
  00be0	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00be8	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN70@stbi__pars:

; 3029 :                         if (!STBI__RESTART(z->marker)) return 1;

  00bed	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bf5	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00bfc	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00c01	7c 16		 jl	 SHORT $LN72@stbi__pars
  00c03	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c0b	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00c12	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00c17	7e 07		 jle	 SHORT $LN71@stbi__pars
$LN72@stbi__pars:
  00c19	b8 01 00 00 00	 mov	 eax, 1
  00c1e	eb 1c		 jmp	 SHORT $LN1@stbi__pars
$LN71@stbi__pars:

; 3030 :                         stbi__jpeg_reset(z);

  00c20	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c28	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN69@stbi__pars:

; 3031 :                     }
; 3032 :                 }

  00c2d	e9 70 fd ff ff	 jmp	 $LN32@stbi__pars
$LN33@stbi__pars:

; 3033 :             }

  00c32	e9 36 fd ff ff	 jmp	 $LN29@stbi__pars
$LN30@stbi__pars:

; 3034 :             return 1;

  00c37	b8 01 00 00 00	 mov	 eax, 1
$LN59@stbi__pars:
$LN45@stbi__pars:
$LN1@stbi__pars:

; 3035 :         }
; 3036 :     }
; 3037 : }

  00c3c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c44	48 33 cc	 xor	 rcx, rsp
  00c47	e8 00 00 00 00	 call	 __security_check_cookie
  00c4c	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00c53	c3		 ret	 0
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ENDP ; stbi__parse_entropy_coded_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv88 = 0
j$ = 32
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_reset

; 2903 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 2904 :     j->code_bits = 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0000e	c7 80 24 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18468], 0

; 2905 :     j->code_buffer = 0;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0001d	c7 80 20 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18464], 0

; 2906 :     j->nomore = 0;

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0002c	c7 80 2c 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18476], 0

; 2907 :     j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

  00036	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0003b	48 6b c0 03	 imul	 rax, rax, 3
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  00044	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  0004f	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00054	48 6b c0 02	 imul	 rax, rax, 2
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  0005d	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  00068	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0006d	48 6b c0 01	 imul	 rax, rax, 1
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  00076	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  00081	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00086	48 6b c0 00	 imul	 rax, rax, 0
  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  0008f	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0

; 2908 :     j->marker = STBI__MARKER_none;

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0009f	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 2909 :     j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000ab	83 b8 68 48 00
	00 00		 cmp	 DWORD PTR [rax+18536], 0
  000b2	74 10		 je	 SHORT $LN3@stbi__jpeg
  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000b9	8b 80 68 48 00
	00		 mov	 eax, DWORD PTR [rax+18536]
  000bf	89 04 24	 mov	 DWORD PTR tv88[rsp], eax
  000c2	eb 07		 jmp	 SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
  000c4	c7 04 24 ff ff
	ff 7f		 mov	 DWORD PTR tv88[rsp], 2147483647 ; 7fffffffH
$LN4@stbi__jpeg:
  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000d0	8b 0c 24	 mov	 ecx, DWORD PTR tv88[rsp]
  000d3	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx

; 2910 :     j->eob_run = 0;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000de	c7 80 44 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18500], 0

; 2911 :     // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2912 :     // since we don't even allow 1<<30 pixels
; 2913 : }

  000e8	48 83 c4 18	 add	 rsp, 24
  000ec	c3		 ret	 0
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
x$ = 32
j$ = 64
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z PROC		; stbi__get_marker

; 2886 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2887 :     stbi_uc x;
; 2888 :     if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00015	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0001a	74 23		 je	 SHORT $LN4@stbi__get_
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00021	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00028	88 44 24 20	 mov	 BYTE PTR x$[rsp], al
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00031	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH
  00038	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  0003d	eb 45		 jmp	 SHORT $LN1@stbi__get_
$LN4@stbi__get_:

; 2889 :     x = stbi__get8(j->s);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00044	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00047	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0004c	88 44 24 20	 mov	 BYTE PTR x$[rsp], al

; 2890 :     if (x != 0xff) return STBI__MARKER_none;

  00050	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00055	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0005a	74 04		 je	 SHORT $LN5@stbi__get_
  0005c	b0 ff		 mov	 al, 255			; 000000ffH
  0005e	eb 24		 jmp	 SHORT $LN1@stbi__get_
$LN5@stbi__get_:
$LN2@stbi__get_:

; 2891 :     while (x == 0xff)

  00060	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00065	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0006a	75 13		 jne	 SHORT $LN3@stbi__get_

; 2892 :         x = stbi__get8(j->s); // consume repeated 0xff fill bytes

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00071	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00074	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00079	88 44 24 20	 mov	 BYTE PTR x$[rsp], al
  0007d	eb e1		 jmp	 SHORT $LN2@stbi__get_
$LN3@stbi__get_:

; 2893 :     return x;

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
$LN1@stbi__get_:

; 2894 : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ENDP		; stbi__get_marker
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tmp$ = 0
row1$ = 16
row3$ = 32
row5$ = 48
row7$ = 64
row0$ = 80
row2$ = 96
row4$ = 112
row6$ = 128
p0$1 = 144
p2$2 = 160
p1$3 = 176
p3$4 = 192
bias_0$ = 208
bias_1$ = 224
rot0_0$ = 240
rot0_1$ = 256
rot2_0$ = 272
rot2_1$ = 288
rot3_0$ = 304
rot3_1$ = 320
rot1_0$ = 336
rot1_1$ = 352
rot0_0lo$5 = 368
rot0_0hi$6 = 384
sum04$7 = 400
dif04$8 = 416
t0e_l$9 = 432
t3e_l$10 = 448
t0e_h$11 = 464
t3e_h$12 = 480
t1e_l$13 = 496
t2e_l$14 = 512
t1e_h$15 = 528
t2e_h$16 = 544
rot2_0lo$17 = 560
rot2_0hi$18 = 576
rot3_0lo$19 = 592
rot3_0hi$20 = 608
sum17$21 = 624
sum35$22 = 640
rot1_0lo$23 = 656
rot1_0hi$24 = 672
y5o_l$25 = 688
y5o_h$26 = 704
y4o_l$27 = 720
y4o_h$28 = 736
abiased_l$29 = 752
x7_l$30 = 768
abiased_h$31 = 784
x7_h$32 = 800
abiased_l$33 = 816
x6_l$34 = 832
abiased_h$35 = 848
x6_h$36 = 864
abiased_l$37 = 880
x5_l$38 = 896
abiased_h$39 = 912
x5_h$40 = 928
abiased_l$41 = 944
x4_l$42 = 960
abiased_h$43 = 976
x4_h$44 = 992
rot0_0lo$45 = 1008
rot0_0hi$46 = 1024
sum04$47 = 1040
dif04$48 = 1056
t0e_l$49 = 1072
t3e_l$50 = 1088
t0e_h$51 = 1104
t3e_h$52 = 1120
t1e_l$53 = 1136
t2e_l$54 = 1152
t1e_h$55 = 1168
t2e_h$56 = 1184
rot2_0lo$57 = 1200
rot2_0hi$58 = 1216
rot3_0lo$59 = 1232
rot3_0hi$60 = 1248
sum17$61 = 1264
sum35$62 = 1280
rot1_0lo$63 = 1296
rot1_0hi$64 = 1312
y5o_l$65 = 1328
y5o_h$66 = 1344
y4o_l$67 = 1360
y4o_h$68 = 1376
abiased_l$69 = 1392
x7_l$70 = 1408
abiased_h$71 = 1424
x7_h$72 = 1440
abiased_l$73 = 1456
x6_l$74 = 1472
abiased_h$75 = 1488
x6_h$76 = 1504
abiased_l$77 = 1520
x5_l$78 = 1536
abiased_h$79 = 1552
x5_h$80 = 1568
abiased_l$81 = 1584
x4_l$82 = 1600
abiased_h$83 = 1616
x4_h$84 = 1632
$T85 = 1648
$T86 = 1664
$T87 = 1680
$T88 = 1696
$T89 = 1712
$T90 = 1728
$T91 = 1744
$T92 = 1760
$T93 = 1776
$T94 = 1792
$T95 = 1808
$T96 = 1824
$T97 = 1840
$T98 = 1856
$T99 = 1872
$T100 = 1888
$T101 = 1904
$T102 = 1920
$T103 = 1936
$T104 = 1952
$T105 = 1968
$T106 = 1984
$T107 = 2000
$T108 = 2016
$T109 = 2032
$T110 = 2048
$T111 = 2064
$T112 = 2080
$T113 = 2096
$T114 = 2112
$T115 = 2128
$T116 = 2144
$T117 = 2160
$T118 = 2176
$T119 = 2192
$T120 = 2208
$T121 = 2224
$T122 = 2240
$T123 = 2256
$T124 = 2272
$T125 = 2288
$T126 = 2304
$T127 = 2320
$T128 = 2336
$T129 = 2352
$T130 = 2368
$T131 = 2384
$T132 = 2400
$T133 = 2416
$T134 = 2432
$T135 = 2448
$T136 = 2464
$T137 = 2480
$T138 = 2496
$T139 = 2512
$T140 = 2528
$T141 = 2544
$T142 = 2560
$T143 = 2576
$T144 = 2592
$T145 = 2608
$T146 = 2624
$T147 = 2640
$T148 = 2656
$T149 = 2672
$T150 = 2688
y0o_l$151 = 2704
$T152 = 2720
y0o_h$153 = 2736
$T154 = 2752
y1o_l$155 = 2768
$T156 = 2784
y1o_h$157 = 2800
$T158 = 2816
y2o_l$159 = 2832
$T160 = 2848
y2o_h$161 = 2864
$T162 = 2880
y3o_l$163 = 2896
$T164 = 2912
y3o_h$165 = 2928
$T166 = 2944
x0_l$167 = 2960
$T168 = 2976
x0_h$169 = 2992
$T170 = 3008
$T171 = 3024
$T172 = 3040
$T173 = 3056
$T174 = 3072
sum_h$175 = 3088
sum_l$176 = 3104
$T177 = 3120
$T178 = 3136
$T179 = 3152
dif_h$180 = 3168
dif_l$181 = 3184
$T182 = 3200
$T183 = 3216
$T184 = 3232
x1_l$185 = 3248
$T186 = 3264
x1_h$187 = 3280
$T188 = 3296
$T189 = 3312
$T190 = 3328
$T191 = 3344
$T192 = 3360
sum_h$193 = 3376
sum_l$194 = 3392
$T195 = 3408
$T196 = 3424
$T197 = 3440
dif_h$198 = 3456
dif_l$199 = 3472
$T200 = 3488
$T201 = 3504
$T202 = 3520
x2_l$203 = 3536
$T204 = 3552
x2_h$205 = 3568
$T206 = 3584
$T207 = 3600
$T208 = 3616
$T209 = 3632
$T210 = 3648
sum_h$211 = 3664
sum_l$212 = 3680
$T213 = 3696
$T214 = 3712
$T215 = 3728
dif_h$216 = 3744
dif_l$217 = 3760
$T218 = 3776
$T219 = 3792
$T220 = 3808
x3_l$221 = 3824
$T222 = 3840
x3_h$223 = 3856
$T224 = 3872
$T225 = 3888
$T226 = 3904
$T227 = 3920
$T228 = 3936
sum_h$229 = 3952
sum_l$230 = 3968
$T231 = 3984
$T232 = 4000
$T233 = 4016
dif_h$234 = 4032
dif_l$235 = 4048
$T236 = 4064
$T237 = 4080
$T238 = 4096
$T239 = 4112
$T240 = 4128
$T241 = 4144
$T242 = 4160
$T243 = 4176
$T244 = 4192
$T245 = 4208
$T246 = 4224
$T247 = 4240
$T248 = 4256
$T249 = 4272
$T250 = 4288
$T251 = 4304
$T252 = 4320
$T253 = 4336
$T254 = 4352
$T255 = 4368
$T256 = 4384
$T257 = 4400
$T258 = 4416
$T259 = 4432
$T260 = 4448
$T261 = 4464
$T262 = 4480
$T263 = 4496
$T264 = 4512
$T265 = 4528
$T266 = 4544
$T267 = 4560
$T268 = 4576
$T269 = 4592
$T270 = 4608
$T271 = 4624
$T272 = 4640
$T273 = 4656
$T274 = 4672
$T275 = 4688
$T276 = 4704
$T277 = 4720
$T278 = 4736
$T279 = 4752
$T280 = 4768
$T281 = 4784
$T282 = 4800
$T283 = 4816
$T284 = 4832
$T285 = 4848
$T286 = 4864
$T287 = 4880
$T288 = 4896
$T289 = 4912
$T290 = 4928
$T291 = 4944
$T292 = 4960
$T293 = 4976
$T294 = 4992
$T295 = 5008
$T296 = 5024
$T297 = 5040
$T298 = 5056
$T299 = 5072
$T300 = 5088
$T301 = 5104
$T302 = 5120
$T303 = 5136
$T304 = 5152
$T305 = 5168
$T306 = 5184
$T307 = 5200
$T308 = 5216
$T309 = 5232
$T310 = 5248
y0o_l$311 = 5264
$T312 = 5280
y0o_h$313 = 5296
$T314 = 5312
y1o_l$315 = 5328
$T316 = 5344
y1o_h$317 = 5360
$T318 = 5376
y2o_l$319 = 5392
$T320 = 5408
y2o_h$321 = 5424
$T322 = 5440
y3o_l$323 = 5456
$T324 = 5472
y3o_h$325 = 5488
$T326 = 5504
x0_l$327 = 5520
$T328 = 5536
x0_h$329 = 5552
$T330 = 5568
$T331 = 5584
$T332 = 5600
$T333 = 5616
$T334 = 5632
sum_h$335 = 5648
sum_l$336 = 5664
$T337 = 5680
$T338 = 5696
$T339 = 5712
dif_h$340 = 5728
dif_l$341 = 5744
$T342 = 5760
$T343 = 5776
$T344 = 5792
x1_l$345 = 5808
$T346 = 5824
x1_h$347 = 5840
$T348 = 5856
$T349 = 5872
$T350 = 5888
$T351 = 5904
$T352 = 5920
sum_h$353 = 5936
sum_l$354 = 5952
$T355 = 5968
$T356 = 5984
$T357 = 6000
dif_h$358 = 6016
dif_l$359 = 6032
$T360 = 6048
$T361 = 6064
$T362 = 6080
x2_l$363 = 6096
$T364 = 6112
x2_h$365 = 6128
$T366 = 6144
$T367 = 6160
$T368 = 6176
$T369 = 6192
$T370 = 6208
sum_h$371 = 6224
sum_l$372 = 6240
$T373 = 6256
$T374 = 6272
$T375 = 6288
dif_h$376 = 6304
dif_l$377 = 6320
$T378 = 6336
$T379 = 6352
$T380 = 6368
x3_l$381 = 6384
$T382 = 6400
x3_h$383 = 6416
$T384 = 6432
$T385 = 6448
$T386 = 6464
$T387 = 6480
$T388 = 6496
sum_h$389 = 6512
sum_l$390 = 6528
$T391 = 6544
$T392 = 6560
$T393 = 6576
dif_h$394 = 6592
dif_l$395 = 6608
$T396 = 6624
$T397 = 6640
$T398 = 6656
$T399 = 6672
$T400 = 6688
$T401 = 6704
$T402 = 6720
$T403 = 6736
$T404 = 6752
$T405 = 6768
$T406 = 6784
$T407 = 6800
$T408 = 6816
$T409 = 6832
$T410 = 6848
$T411 = 6864
$T412 = 6880
$T413 = 6896
$T414 = 6912
$T415 = 6928
$T416 = 6944
$T417 = 6960
$T418 = 6976
out$ = 7008
out_stride$ = 7016
data$ = 7024
?stbi__idct_simd@@YAXPEAEHQEAF@Z PROC			; stbi__idct_simd

; 2497 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	b8 58 1b 00 00	 mov	 eax, 7000		; 00001b58H
  00013	e8 00 00 00 00	 call	 __chkstk
  00018	48 2b e0	 sub	 rsp, rax

; 2498 :     // This is constructed to match our regular (generic) integer IDCT exactly.
; 2499 :     __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2500 :     __m128i tmp;
; 2501 :     
; 2502 :     // dot product constant: even elems=x, odd elems=y
; 2503 : #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2504 :     
; 2505 :     // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2506 :     // out(1) = c1[even]*x + c1[odd]*y
; 2507 : #define dct_rot(out0,out1, x,y,c0,c1) \
; 2508 : __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2509 : __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2510 : __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2511 : __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2512 : __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2513 : __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2514 :     
; 2515 :     // out = in << 12  (in 16-bit, out 32-bit)
; 2516 : #define dct_widen(out, in) \
; 2517 : __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2518 : __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2519 :     
; 2520 :     // wide add
; 2521 : #define dct_wadd(out, a, b) \
; 2522 : __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2523 : __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2524 :     
; 2525 :     // wide sub
; 2526 : #define dct_wsub(out, a, b) \
; 2527 : __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2528 : __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2529 :     
; 2530 :     // butterfly a/b, add bias, then shift by "s" and pack
; 2531 : #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2532 : { \
; 2533 : __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2534 : __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2535 : dct_wadd(sum, abiased, b); \
; 2536 : dct_wsub(dif, abiased, b); \
; 2537 : out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2538 : out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2539 : }
; 2540 :     
; 2541 :     // 8-bit interleave step (for transposes)
; 2542 : #define dct_interleave8(a, b) \
; 2543 : tmp = a; \
; 2544 : a = _mm_unpacklo_epi8(a, b); \
; 2545 : b = _mm_unpackhi_epi8(tmp, b)
; 2546 :     
; 2547 :     // 16-bit interleave step (for transposes)
; 2548 : #define dct_interleave16(a, b) \
; 2549 : tmp = a; \
; 2550 : a = _mm_unpacklo_epi16(a, b); \
; 2551 : b = _mm_unpackhi_epi16(tmp, b)
; 2552 :     
; 2553 : #define dct_pass(bias,shift) \
; 2554 : { \
; 2555 : /* even part */ \
; 2556 : dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2557 : __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2558 : __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2559 : dct_widen(t0e, sum04); \
; 2560 : dct_widen(t1e, dif04); \
; 2561 : dct_wadd(x0, t0e, t3e); \
; 2562 : dct_wsub(x3, t0e, t3e); \
; 2563 : dct_wadd(x1, t1e, t2e); \
; 2564 : dct_wsub(x2, t1e, t2e); \
; 2565 : /* odd part */ \
; 2566 : dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2567 : dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2568 : __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2569 : __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2570 : dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2571 : dct_wadd(x4, y0o, y4o); \
; 2572 : dct_wadd(x5, y1o, y5o); \
; 2573 : dct_wadd(x6, y2o, y5o); \
; 2574 : dct_wadd(x7, y3o, y4o); \
; 2575 : dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2576 : dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2577 : dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2578 : dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2579 : }
; 2580 :     
; 2581 :     __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));

  0001b	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
  00023	66 0f 7f 84 24
	70 06 00 00	 movdqa	 XMMWORD PTR $T85[rsp], xmm0
  0002c	66 0f 6f 84 24
	70 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T85[rsp]
  00035	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR rot0_0$[rsp], xmm0

; 2582 :     __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));

  0003e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
  00046	66 0f 7f 84 24
	80 06 00 00	 movdqa	 XMMWORD PTR $T86[rsp], xmm0
  0004f	66 0f 6f 84 24
	80 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T86[rsp]
  00058	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR rot0_1$[rsp], xmm0

; 2583 :     __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));

  00061	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
  00069	66 0f 7f 84 24
	90 06 00 00	 movdqa	 XMMWORD PTR $T87[rsp], xmm0
  00072	66 0f 6f 84 24
	90 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T87[rsp]
  0007b	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR rot1_0$[rsp], xmm0

; 2584 :     __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));

  00084	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
  0008c	66 0f 7f 84 24
	a0 06 00 00	 movdqa	 XMMWORD PTR $T88[rsp], xmm0
  00095	66 0f 6f 84 24
	a0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T88[rsp]
  0009e	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR rot1_1$[rsp], xmm0

; 2585 :     __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));

  000a7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
  000af	66 0f 7f 84 24
	b0 06 00 00	 movdqa	 XMMWORD PTR $T89[rsp], xmm0
  000b8	66 0f 6f 84 24
	b0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T89[rsp]
  000c1	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR rot2_0$[rsp], xmm0

; 2586 :     __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));

  000ca	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
  000d2	66 0f 7f 84 24
	c0 06 00 00	 movdqa	 XMMWORD PTR $T90[rsp], xmm0
  000db	66 0f 6f 84 24
	c0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T90[rsp]
  000e4	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR rot2_1$[rsp], xmm0

; 2587 :     __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));

  000ed	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
  000f5	66 0f 7f 84 24
	d0 06 00 00	 movdqa	 XMMWORD PTR $T91[rsp], xmm0
  000fe	66 0f 6f 84 24
	d0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T91[rsp]
  00107	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR rot3_0$[rsp], xmm0

; 2588 :     __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

  00110	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
  00118	66 0f 7f 84 24
	e0 06 00 00	 movdqa	 XMMWORD PTR $T92[rsp], xmm0
  00121	66 0f 6f 84 24
	e0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T92[rsp]
  0012a	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR rot3_1$[rsp], xmm0

; 2589 :     
; 2590 :     // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2591 :     __m128i bias_0 = _mm_set1_epi32(512);

  00133	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000200000002000000020000000200
  0013b	66 0f 7f 84 24
	f0 06 00 00	 movdqa	 XMMWORD PTR $T93[rsp], xmm0
  00144	66 0f 6f 84 24
	f0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T93[rsp]
  0014d	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR bias_0$[rsp], xmm0

; 2592 :     __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

  00156	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@01010000010100000101000001010000
  0015e	66 0f 7f 84 24
	00 07 00 00	 movdqa	 XMMWORD PTR $T94[rsp], xmm0
  00167	66 0f 6f 84 24
	00 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T94[rsp]
  00170	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR bias_1$[rsp], xmm0

; 2593 :     
; 2594 :     // load
; 2595 :     row0 = _mm_load_si128((const __m128i *) (data + 0*8));

  00179	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00181	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00185	66 0f 7f 84 24
	10 07 00 00	 movdqa	 XMMWORD PTR $T95[rsp], xmm0
  0018e	66 0f 6f 84 24
	10 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T95[rsp]
  00197	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0

; 2596 :     row1 = _mm_load_si128((const __m128i *) (data + 1*8));

  0019d	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001a5	48 83 c0 10	 add	 rax, 16
  001a9	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  001ad	66 0f 7f 84 24
	20 07 00 00	 movdqa	 XMMWORD PTR $T96[rsp], xmm0
  001b6	66 0f 6f 84 24
	20 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T96[rsp]
  001bf	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0

; 2597 :     row2 = _mm_load_si128((const __m128i *) (data + 2*8));

  001c5	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001cd	48 83 c0 20	 add	 rax, 32			; 00000020H
  001d1	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  001d5	66 0f 7f 84 24
	30 07 00 00	 movdqa	 XMMWORD PTR $T97[rsp], xmm0
  001de	66 0f 6f 84 24
	30 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T97[rsp]
  001e7	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0

; 2598 :     row3 = _mm_load_si128((const __m128i *) (data + 3*8));

  001ed	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001f5	48 83 c0 30	 add	 rax, 48			; 00000030H
  001f9	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  001fd	66 0f 7f 84 24
	40 07 00 00	 movdqa	 XMMWORD PTR $T98[rsp], xmm0
  00206	66 0f 6f 84 24
	40 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T98[rsp]
  0020f	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2599 :     row4 = _mm_load_si128((const __m128i *) (data + 4*8));

  00215	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0021d	48 83 c0 40	 add	 rax, 64			; 00000040H
  00221	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00225	66 0f 7f 84 24
	50 07 00 00	 movdqa	 XMMWORD PTR $T99[rsp], xmm0
  0022e	66 0f 6f 84 24
	50 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T99[rsp]
  00237	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2600 :     row5 = _mm_load_si128((const __m128i *) (data + 5*8));

  0023d	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00245	48 83 c0 50	 add	 rax, 80			; 00000050H
  00249	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  0024d	66 0f 7f 84 24
	60 07 00 00	 movdqa	 XMMWORD PTR $T100[rsp], xmm0
  00256	66 0f 6f 84 24
	60 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T100[rsp]
  0025f	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2601 :     row6 = _mm_load_si128((const __m128i *) (data + 6*8));

  00265	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0026d	48 83 c0 60	 add	 rax, 96			; 00000060H
  00271	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00275	66 0f 7f 84 24
	70 07 00 00	 movdqa	 XMMWORD PTR $T101[rsp], xmm0
  0027e	66 0f 6f 84 24
	70 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T101[rsp]
  00287	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2602 :     row7 = _mm_load_si128((const __m128i *) (data + 7*8));

  00290	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00298	48 83 c0 70	 add	 rax, 112		; 00000070H
  0029c	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  002a0	66 0f 7f 84 24
	80 07 00 00	 movdqa	 XMMWORD PTR $T102[rsp], xmm0
  002a9	66 0f 6f 84 24
	80 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T102[rsp]
  002b2	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2603 :     
; 2604 :     // column pass
; 2605 :     dct_pass(bias_0, 10);

  002b8	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  002be	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  002c7	66 0f 7f 84 24
	90 07 00 00	 movdqa	 XMMWORD PTR $T103[rsp], xmm0
  002d0	66 0f 6f 84 24
	90 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T103[rsp]
  002d9	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR rot0_0lo$5[rsp], xmm0
  002e2	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  002e8	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  002f1	66 0f 7f 84 24
	a0 07 00 00	 movdqa	 XMMWORD PTR $T104[rsp], xmm0
  002fa	66 0f 6f 84 24
	a0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T104[rsp]
  00303	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR rot0_0hi$6[rsp], xmm0
  0030c	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$5[rsp]
  00315	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  0031e	66 0f 7f 84 24
	b0 07 00 00	 movdqa	 XMMWORD PTR $T105[rsp], xmm0
  00327	66 0f 6f 84 24
	b0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T105[rsp]
  00330	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR t2e_l$14[rsp], xmm0
  00339	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$6[rsp]
  00342	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  0034b	66 0f 7f 84 24
	c0 07 00 00	 movdqa	 XMMWORD PTR $T106[rsp], xmm0
  00354	66 0f 6f 84 24
	c0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T106[rsp]
  0035d	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR t2e_h$16[rsp], xmm0
  00366	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$5[rsp]
  0036f	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  00378	66 0f 7f 84 24
	d0 07 00 00	 movdqa	 XMMWORD PTR $T107[rsp], xmm0
  00381	66 0f 6f 84 24
	d0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T107[rsp]
  0038a	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR t3e_l$10[rsp], xmm0
  00393	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$6[rsp]
  0039c	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  003a5	66 0f 7f 84 24
	e0 07 00 00	 movdqa	 XMMWORD PTR $T108[rsp], xmm0
  003ae	66 0f 6f 84 24
	e0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T108[rsp]
  003b7	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR t3e_h$12[rsp], xmm0
  003c0	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  003c6	66 0f fd 44 24
	70		 paddw	 xmm0, XMMWORD PTR row4$[rsp]
  003cc	66 0f 7f 84 24
	f0 07 00 00	 movdqa	 XMMWORD PTR $T109[rsp], xmm0
  003d5	66 0f 6f 84 24
	f0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T109[rsp]
  003de	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR sum04$7[rsp], xmm0
  003e7	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  003ed	66 0f f9 44 24
	70		 psubw	 xmm0, XMMWORD PTR row4$[rsp]
  003f3	66 0f 7f 84 24
	00 08 00 00	 movdqa	 XMMWORD PTR $T110[rsp], xmm0
  003fc	66 0f 6f 84 24
	00 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T110[rsp]
  00405	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR dif04$8[rsp], xmm0
  0040e	66 0f ef c0	 pxor	 xmm0, xmm0
  00412	66 0f 7f 84 24
	10 08 00 00	 movdqa	 XMMWORD PTR $T111[rsp], xmm0
  0041b	66 0f 6f 84 24
	10 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T111[rsp]
  00424	66 0f 61 84 24
	90 01 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$7[rsp]
  0042d	66 0f 7f 84 24
	20 08 00 00	 movdqa	 XMMWORD PTR $T112[rsp], xmm0
  00436	66 0f 6f 84 24
	20 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T112[rsp]
  0043f	66 0f 72 e0 04	 psrad	 xmm0, 4
  00444	66 0f 7f 84 24
	30 08 00 00	 movdqa	 XMMWORD PTR $T113[rsp], xmm0
  0044d	66 0f 6f 84 24
	30 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T113[rsp]
  00456	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR t0e_l$9[rsp], xmm0
  0045f	66 0f ef c0	 pxor	 xmm0, xmm0
  00463	66 0f 7f 84 24
	40 08 00 00	 movdqa	 XMMWORD PTR $T114[rsp], xmm0
  0046c	66 0f 6f 84 24
	40 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T114[rsp]
  00475	66 0f 69 84 24
	90 01 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$7[rsp]
  0047e	66 0f 7f 84 24
	50 08 00 00	 movdqa	 XMMWORD PTR $T115[rsp], xmm0
  00487	66 0f 6f 84 24
	50 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T115[rsp]
  00490	66 0f 72 e0 04	 psrad	 xmm0, 4
  00495	66 0f 7f 84 24
	60 08 00 00	 movdqa	 XMMWORD PTR $T116[rsp], xmm0
  0049e	66 0f 6f 84 24
	60 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T116[rsp]
  004a7	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR t0e_h$11[rsp], xmm0
  004b0	66 0f ef c0	 pxor	 xmm0, xmm0
  004b4	66 0f 7f 84 24
	70 08 00 00	 movdqa	 XMMWORD PTR $T117[rsp], xmm0
  004bd	66 0f 6f 84 24
	70 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T117[rsp]
  004c6	66 0f 61 84 24
	a0 01 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$8[rsp]
  004cf	66 0f 7f 84 24
	80 08 00 00	 movdqa	 XMMWORD PTR $T118[rsp], xmm0
  004d8	66 0f 6f 84 24
	80 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T118[rsp]
  004e1	66 0f 72 e0 04	 psrad	 xmm0, 4
  004e6	66 0f 7f 84 24
	90 08 00 00	 movdqa	 XMMWORD PTR $T119[rsp], xmm0
  004ef	66 0f 6f 84 24
	90 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T119[rsp]
  004f8	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR t1e_l$13[rsp], xmm0
  00501	66 0f ef c0	 pxor	 xmm0, xmm0
  00505	66 0f 7f 84 24
	a0 08 00 00	 movdqa	 XMMWORD PTR $T120[rsp], xmm0
  0050e	66 0f 6f 84 24
	a0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T120[rsp]
  00517	66 0f 69 84 24
	a0 01 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$8[rsp]
  00520	66 0f 7f 84 24
	b0 08 00 00	 movdqa	 XMMWORD PTR $T121[rsp], xmm0
  00529	66 0f 6f 84 24
	b0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T121[rsp]
  00532	66 0f 72 e0 04	 psrad	 xmm0, 4
  00537	66 0f 7f 84 24
	c0 08 00 00	 movdqa	 XMMWORD PTR $T122[rsp], xmm0
  00540	66 0f 6f 84 24
	c0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T122[rsp]
  00549	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR t1e_h$15[rsp], xmm0
  00552	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rsp]
  0055b	66 0f fe 84 24
	c0 01 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$10[rsp]
  00564	66 0f 7f 84 24
	d0 08 00 00	 movdqa	 XMMWORD PTR $T123[rsp], xmm0
  0056d	66 0f 6f 84 24
	d0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T123[rsp]
  00576	66 0f 7f 84 24
	90 0b 00 00	 movdqa	 XMMWORD PTR x0_l$167[rsp], xmm0
  0057f	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$11[rsp]
  00588	66 0f fe 84 24
	e0 01 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$12[rsp]
  00591	66 0f 7f 84 24
	e0 08 00 00	 movdqa	 XMMWORD PTR $T124[rsp], xmm0
  0059a	66 0f 6f 84 24
	e0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T124[rsp]
  005a3	66 0f 7f 84 24
	b0 0b 00 00	 movdqa	 XMMWORD PTR x0_h$169[rsp], xmm0
  005ac	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rsp]
  005b5	66 0f fa 84 24
	c0 01 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$10[rsp]
  005be	66 0f 7f 84 24
	f0 08 00 00	 movdqa	 XMMWORD PTR $T125[rsp], xmm0
  005c7	66 0f 6f 84 24
	f0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T125[rsp]
  005d0	66 0f 7f 84 24
	f0 0e 00 00	 movdqa	 XMMWORD PTR x3_l$221[rsp], xmm0
  005d9	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$11[rsp]
  005e2	66 0f fa 84 24
	e0 01 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$12[rsp]
  005eb	66 0f 7f 84 24
	00 09 00 00	 movdqa	 XMMWORD PTR $T126[rsp], xmm0
  005f4	66 0f 6f 84 24
	00 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T126[rsp]
  005fd	66 0f 7f 84 24
	10 0f 00 00	 movdqa	 XMMWORD PTR x3_h$223[rsp], xmm0
  00606	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$13[rsp]
  0060f	66 0f fe 84 24
	00 02 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$14[rsp]
  00618	66 0f 7f 84 24
	10 09 00 00	 movdqa	 XMMWORD PTR $T127[rsp], xmm0
  00621	66 0f 6f 84 24
	10 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T127[rsp]
  0062a	66 0f 7f 84 24
	b0 0c 00 00	 movdqa	 XMMWORD PTR x1_l$185[rsp], xmm0
  00633	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$15[rsp]
  0063c	66 0f fe 84 24
	20 02 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$16[rsp]
  00645	66 0f 7f 84 24
	20 09 00 00	 movdqa	 XMMWORD PTR $T128[rsp], xmm0
  0064e	66 0f 6f 84 24
	20 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T128[rsp]
  00657	66 0f 7f 84 24
	d0 0c 00 00	 movdqa	 XMMWORD PTR x1_h$187[rsp], xmm0
  00660	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$13[rsp]
  00669	66 0f fa 84 24
	00 02 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$14[rsp]
  00672	66 0f 7f 84 24
	30 09 00 00	 movdqa	 XMMWORD PTR $T129[rsp], xmm0
  0067b	66 0f 6f 84 24
	30 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T129[rsp]
  00684	66 0f 7f 84 24
	d0 0d 00 00	 movdqa	 XMMWORD PTR x2_l$203[rsp], xmm0
  0068d	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$15[rsp]
  00696	66 0f fa 84 24
	20 02 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$16[rsp]
  0069f	66 0f 7f 84 24
	40 09 00 00	 movdqa	 XMMWORD PTR $T130[rsp], xmm0
  006a8	66 0f 6f 84 24
	40 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T130[rsp]
  006b1	66 0f 7f 84 24
	f0 0d 00 00	 movdqa	 XMMWORD PTR x2_h$205[rsp], xmm0
  006ba	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  006c0	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  006c6	66 0f 7f 84 24
	50 09 00 00	 movdqa	 XMMWORD PTR $T131[rsp], xmm0
  006cf	66 0f 6f 84 24
	50 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T131[rsp]
  006d8	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR rot2_0lo$17[rsp], xmm0
  006e1	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  006e7	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  006ed	66 0f 7f 84 24
	60 09 00 00	 movdqa	 XMMWORD PTR $T132[rsp], xmm0
  006f6	66 0f 6f 84 24
	60 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T132[rsp]
  006ff	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR rot2_0hi$18[rsp], xmm0
  00708	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$17[rsp]
  00711	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  0071a	66 0f 7f 84 24
	70 09 00 00	 movdqa	 XMMWORD PTR $T133[rsp], xmm0
  00723	66 0f 6f 84 24
	70 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T133[rsp]
  0072c	66 0f 7f 84 24
	90 0a 00 00	 movdqa	 XMMWORD PTR y0o_l$151[rsp], xmm0
  00735	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$18[rsp]
  0073e	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  00747	66 0f 7f 84 24
	80 09 00 00	 movdqa	 XMMWORD PTR $T134[rsp], xmm0
  00750	66 0f 6f 84 24
	80 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T134[rsp]
  00759	66 0f 7f 84 24
	b0 0a 00 00	 movdqa	 XMMWORD PTR y0o_h$153[rsp], xmm0
  00762	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$17[rsp]
  0076b	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  00774	66 0f 7f 84 24
	90 09 00 00	 movdqa	 XMMWORD PTR $T135[rsp], xmm0
  0077d	66 0f 6f 84 24
	90 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T135[rsp]
  00786	66 0f 7f 84 24
	10 0b 00 00	 movdqa	 XMMWORD PTR y2o_l$159[rsp], xmm0
  0078f	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$18[rsp]
  00798	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  007a1	66 0f 7f 84 24
	a0 09 00 00	 movdqa	 XMMWORD PTR $T136[rsp], xmm0
  007aa	66 0f 6f 84 24
	a0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T136[rsp]
  007b3	66 0f 7f 84 24
	30 0b 00 00	 movdqa	 XMMWORD PTR y2o_h$161[rsp], xmm0
  007bc	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  007c2	66 0f 61 44 24
	10		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  007c8	66 0f 7f 84 24
	b0 09 00 00	 movdqa	 XMMWORD PTR $T137[rsp], xmm0
  007d1	66 0f 6f 84 24
	b0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T137[rsp]
  007da	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR rot3_0lo$19[rsp], xmm0
  007e3	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  007e9	66 0f 69 44 24
	10		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  007ef	66 0f 7f 84 24
	c0 09 00 00	 movdqa	 XMMWORD PTR $T138[rsp], xmm0
  007f8	66 0f 6f 84 24
	c0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T138[rsp]
  00801	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR rot3_0hi$20[rsp], xmm0
  0080a	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$19[rsp]
  00813	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  0081c	66 0f 7f 84 24
	d0 09 00 00	 movdqa	 XMMWORD PTR $T139[rsp], xmm0
  00825	66 0f 6f 84 24
	d0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T139[rsp]
  0082e	66 0f 7f 84 24
	d0 0a 00 00	 movdqa	 XMMWORD PTR y1o_l$155[rsp], xmm0
  00837	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$20[rsp]
  00840	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  00849	66 0f 7f 84 24
	e0 09 00 00	 movdqa	 XMMWORD PTR $T140[rsp], xmm0
  00852	66 0f 6f 84 24
	e0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T140[rsp]
  0085b	66 0f 7f 84 24
	f0 0a 00 00	 movdqa	 XMMWORD PTR y1o_h$157[rsp], xmm0
  00864	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$19[rsp]
  0086d	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  00876	66 0f 7f 84 24
	f0 09 00 00	 movdqa	 XMMWORD PTR $T141[rsp], xmm0
  0087f	66 0f 6f 84 24
	f0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T141[rsp]
  00888	66 0f 7f 84 24
	50 0b 00 00	 movdqa	 XMMWORD PTR y3o_l$163[rsp], xmm0
  00891	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$20[rsp]
  0089a	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  008a3	66 0f 7f 84 24
	00 0a 00 00	 movdqa	 XMMWORD PTR $T142[rsp], xmm0
  008ac	66 0f 6f 84 24
	00 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T142[rsp]
  008b5	66 0f 7f 84 24
	70 0b 00 00	 movdqa	 XMMWORD PTR y3o_h$165[rsp], xmm0
  008be	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  008c4	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR row7$[rsp]
  008ca	66 0f 7f 84 24
	10 0a 00 00	 movdqa	 XMMWORD PTR $T143[rsp], xmm0
  008d3	66 0f 6f 84 24
	10 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T143[rsp]
  008dc	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR sum17$21[rsp], xmm0
  008e5	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  008eb	66 0f fd 44 24
	30		 paddw	 xmm0, XMMWORD PTR row5$[rsp]
  008f1	66 0f 7f 84 24
	20 0a 00 00	 movdqa	 XMMWORD PTR $T144[rsp], xmm0
  008fa	66 0f 6f 84 24
	20 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T144[rsp]
  00903	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR sum35$22[rsp], xmm0
  0090c	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$21[rsp]
  00915	66 0f 61 84 24
	80 02 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$22[rsp]
  0091e	66 0f 7f 84 24
	30 0a 00 00	 movdqa	 XMMWORD PTR $T145[rsp], xmm0
  00927	66 0f 6f 84 24
	30 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T145[rsp]
  00930	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR rot1_0lo$23[rsp], xmm0
  00939	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$21[rsp]
  00942	66 0f 69 84 24
	80 02 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$22[rsp]
  0094b	66 0f 7f 84 24
	40 0a 00 00	 movdqa	 XMMWORD PTR $T146[rsp], xmm0
  00954	66 0f 6f 84 24
	40 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T146[rsp]
  0095d	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR rot1_0hi$24[rsp], xmm0
  00966	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$23[rsp]
  0096f	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  00978	66 0f 7f 84 24
	50 0a 00 00	 movdqa	 XMMWORD PTR $T147[rsp], xmm0
  00981	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T147[rsp]
  0098a	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR y4o_l$27[rsp], xmm0
  00993	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$24[rsp]
  0099c	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  009a5	66 0f 7f 84 24
	60 0a 00 00	 movdqa	 XMMWORD PTR $T148[rsp], xmm0
  009ae	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T148[rsp]
  009b7	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR y4o_h$28[rsp], xmm0
  009c0	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$23[rsp]
  009c9	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  009d2	66 0f 7f 84 24
	70 0a 00 00	 movdqa	 XMMWORD PTR $T149[rsp], xmm0
  009db	66 0f 6f 84 24
	70 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T149[rsp]
  009e4	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR y5o_l$25[rsp], xmm0
  009ed	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$24[rsp]
  009f6	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  009ff	66 0f 7f 84 24
	80 0a 00 00	 movdqa	 XMMWORD PTR $T150[rsp], xmm0
  00a08	66 0f 6f 84 24
	80 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T150[rsp]
  00a11	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR y5o_h$26[rsp], xmm0
  00a1a	66 0f 6f 84 24
	90 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$151[rsp]
  00a23	66 0f fe 84 24
	d0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$27[rsp]
  00a2c	66 0f 7f 84 24
	a0 0a 00 00	 movdqa	 XMMWORD PTR $T152[rsp], xmm0
  00a35	66 0f 6f 84 24
	a0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T152[rsp]
  00a3e	66 0f 7f 84 24
	c0 03 00 00	 movdqa	 XMMWORD PTR x4_l$42[rsp], xmm0
  00a47	66 0f 6f 84 24
	b0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$153[rsp]
  00a50	66 0f fe 84 24
	e0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$28[rsp]
  00a59	66 0f 7f 84 24
	c0 0a 00 00	 movdqa	 XMMWORD PTR $T154[rsp], xmm0
  00a62	66 0f 6f 84 24
	c0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T154[rsp]
  00a6b	66 0f 7f 84 24
	e0 03 00 00	 movdqa	 XMMWORD PTR x4_h$44[rsp], xmm0
  00a74	66 0f 6f 84 24
	d0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$155[rsp]
  00a7d	66 0f fe 84 24
	b0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$25[rsp]
  00a86	66 0f 7f 84 24
	e0 0a 00 00	 movdqa	 XMMWORD PTR $T156[rsp], xmm0
  00a8f	66 0f 6f 84 24
	e0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T156[rsp]
  00a98	66 0f 7f 84 24
	80 03 00 00	 movdqa	 XMMWORD PTR x5_l$38[rsp], xmm0
  00aa1	66 0f 6f 84 24
	f0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$157[rsp]
  00aaa	66 0f fe 84 24
	c0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$26[rsp]
  00ab3	66 0f 7f 84 24
	00 0b 00 00	 movdqa	 XMMWORD PTR $T158[rsp], xmm0
  00abc	66 0f 6f 84 24
	00 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T158[rsp]
  00ac5	66 0f 7f 84 24
	a0 03 00 00	 movdqa	 XMMWORD PTR x5_h$40[rsp], xmm0
  00ace	66 0f 6f 84 24
	10 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$159[rsp]
  00ad7	66 0f fe 84 24
	b0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$25[rsp]
  00ae0	66 0f 7f 84 24
	20 0b 00 00	 movdqa	 XMMWORD PTR $T160[rsp], xmm0
  00ae9	66 0f 6f 84 24
	20 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T160[rsp]
  00af2	66 0f 7f 84 24
	40 03 00 00	 movdqa	 XMMWORD PTR x6_l$34[rsp], xmm0
  00afb	66 0f 6f 84 24
	30 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$161[rsp]
  00b04	66 0f fe 84 24
	c0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$26[rsp]
  00b0d	66 0f 7f 84 24
	40 0b 00 00	 movdqa	 XMMWORD PTR $T162[rsp], xmm0
  00b16	66 0f 6f 84 24
	40 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T162[rsp]
  00b1f	66 0f 7f 84 24
	60 03 00 00	 movdqa	 XMMWORD PTR x6_h$36[rsp], xmm0
  00b28	66 0f 6f 84 24
	50 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$163[rsp]
  00b31	66 0f fe 84 24
	d0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$27[rsp]
  00b3a	66 0f 7f 84 24
	60 0b 00 00	 movdqa	 XMMWORD PTR $T164[rsp], xmm0
  00b43	66 0f 6f 84 24
	60 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T164[rsp]
  00b4c	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR x7_l$30[rsp], xmm0
  00b55	66 0f 6f 84 24
	70 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$165[rsp]
  00b5e	66 0f fe 84 24
	e0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$28[rsp]
  00b67	66 0f 7f 84 24
	80 0b 00 00	 movdqa	 XMMWORD PTR $T166[rsp], xmm0
  00b70	66 0f 6f 84 24
	80 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T166[rsp]
  00b79	66 0f 7f 84 24
	20 03 00 00	 movdqa	 XMMWORD PTR x7_h$32[rsp], xmm0
  00b82	66 0f 6f 84 24
	90 0b 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$167[rsp]
  00b8b	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00b94	66 0f 7f 84 24
	a0 0b 00 00	 movdqa	 XMMWORD PTR $T168[rsp], xmm0
  00b9d	66 0f 6f 84 24
	a0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T168[rsp]
  00ba6	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR abiased_l$29[rsp], xmm0
  00baf	66 0f 6f 84 24
	b0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$169[rsp]
  00bb8	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00bc1	66 0f 7f 84 24
	c0 0b 00 00	 movdqa	 XMMWORD PTR $T170[rsp], xmm0
  00bca	66 0f 6f 84 24
	c0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T170[rsp]
  00bd3	66 0f 7f 84 24
	10 03 00 00	 movdqa	 XMMWORD PTR abiased_h$31[rsp], xmm0
  00bdc	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$29[rsp]
  00be5	66 0f fe 84 24
	00 03 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$30[rsp]
  00bee	66 0f 7f 84 24
	d0 0b 00 00	 movdqa	 XMMWORD PTR $T171[rsp], xmm0
  00bf7	66 0f 6f 84 24
	d0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T171[rsp]
  00c00	66 0f 7f 84 24
	20 0c 00 00	 movdqa	 XMMWORD PTR sum_l$176[rsp], xmm0
  00c09	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$31[rsp]
  00c12	66 0f fe 84 24
	20 03 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$32[rsp]
  00c1b	66 0f 7f 84 24
	e0 0b 00 00	 movdqa	 XMMWORD PTR $T172[rsp], xmm0
  00c24	66 0f 6f 84 24
	e0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T172[rsp]
  00c2d	66 0f 7f 84 24
	10 0c 00 00	 movdqa	 XMMWORD PTR sum_h$175[rsp], xmm0
  00c36	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$29[rsp]
  00c3f	66 0f fa 84 24
	00 03 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$30[rsp]
  00c48	66 0f 7f 84 24
	f0 0b 00 00	 movdqa	 XMMWORD PTR $T173[rsp], xmm0
  00c51	66 0f 6f 84 24
	f0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T173[rsp]
  00c5a	66 0f 7f 84 24
	70 0c 00 00	 movdqa	 XMMWORD PTR dif_l$181[rsp], xmm0
  00c63	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$31[rsp]
  00c6c	66 0f fa 84 24
	20 03 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$32[rsp]
  00c75	66 0f 7f 84 24
	00 0c 00 00	 movdqa	 XMMWORD PTR $T174[rsp], xmm0
  00c7e	66 0f 6f 84 24
	00 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T174[rsp]
  00c87	66 0f 7f 84 24
	60 0c 00 00	 movdqa	 XMMWORD PTR dif_h$180[rsp], xmm0
  00c90	66 0f 6f 84 24
	10 0c 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$175[rsp]
  00c99	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00c9e	66 0f 7f 84 24
	40 0c 00 00	 movdqa	 XMMWORD PTR $T178[rsp], xmm0
  00ca7	66 0f 6f 84 24
	20 0c 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$176[rsp]
  00cb0	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00cb5	66 0f 7f 84 24
	30 0c 00 00	 movdqa	 XMMWORD PTR $T177[rsp], xmm0
  00cbe	66 0f 6f 84 24
	30 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T177[rsp]
  00cc7	66 0f 6b 84 24
	40 0c 00 00	 packssdw xmm0, XMMWORD PTR $T178[rsp]
  00cd0	66 0f 7f 84 24
	50 0c 00 00	 movdqa	 XMMWORD PTR $T179[rsp], xmm0
  00cd9	66 0f 6f 84 24
	50 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T179[rsp]
  00ce2	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  00ce8	66 0f 6f 84 24
	60 0c 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$180[rsp]
  00cf1	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00cf6	66 0f 7f 84 24
	90 0c 00 00	 movdqa	 XMMWORD PTR $T183[rsp], xmm0
  00cff	66 0f 6f 84 24
	70 0c 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$181[rsp]
  00d08	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00d0d	66 0f 7f 84 24
	80 0c 00 00	 movdqa	 XMMWORD PTR $T182[rsp], xmm0
  00d16	66 0f 6f 84 24
	80 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T182[rsp]
  00d1f	66 0f 6b 84 24
	90 0c 00 00	 packssdw xmm0, XMMWORD PTR $T183[rsp]
  00d28	66 0f 7f 84 24
	a0 0c 00 00	 movdqa	 XMMWORD PTR $T184[rsp], xmm0
  00d31	66 0f 6f 84 24
	a0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T184[rsp]
  00d3a	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0
  00d40	66 0f 6f 84 24
	b0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$185[rsp]
  00d49	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00d52	66 0f 7f 84 24
	c0 0c 00 00	 movdqa	 XMMWORD PTR $T186[rsp], xmm0
  00d5b	66 0f 6f 84 24
	c0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T186[rsp]
  00d64	66 0f 7f 84 24
	30 03 00 00	 movdqa	 XMMWORD PTR abiased_l$33[rsp], xmm0
  00d6d	66 0f 6f 84 24
	d0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$187[rsp]
  00d76	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00d7f	66 0f 7f 84 24
	e0 0c 00 00	 movdqa	 XMMWORD PTR $T188[rsp], xmm0
  00d88	66 0f 6f 84 24
	e0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T188[rsp]
  00d91	66 0f 7f 84 24
	50 03 00 00	 movdqa	 XMMWORD PTR abiased_h$35[rsp], xmm0
  00d9a	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$33[rsp]
  00da3	66 0f fe 84 24
	40 03 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$34[rsp]
  00dac	66 0f 7f 84 24
	f0 0c 00 00	 movdqa	 XMMWORD PTR $T189[rsp], xmm0
  00db5	66 0f 6f 84 24
	f0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T189[rsp]
  00dbe	66 0f 7f 84 24
	40 0d 00 00	 movdqa	 XMMWORD PTR sum_l$194[rsp], xmm0
  00dc7	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$35[rsp]
  00dd0	66 0f fe 84 24
	60 03 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$36[rsp]
  00dd9	66 0f 7f 84 24
	00 0d 00 00	 movdqa	 XMMWORD PTR $T190[rsp], xmm0
  00de2	66 0f 6f 84 24
	00 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T190[rsp]
  00deb	66 0f 7f 84 24
	30 0d 00 00	 movdqa	 XMMWORD PTR sum_h$193[rsp], xmm0
  00df4	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$33[rsp]
  00dfd	66 0f fa 84 24
	40 03 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$34[rsp]
  00e06	66 0f 7f 84 24
	10 0d 00 00	 movdqa	 XMMWORD PTR $T191[rsp], xmm0
  00e0f	66 0f 6f 84 24
	10 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T191[rsp]
  00e18	66 0f 7f 84 24
	90 0d 00 00	 movdqa	 XMMWORD PTR dif_l$199[rsp], xmm0
  00e21	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$35[rsp]
  00e2a	66 0f fa 84 24
	60 03 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$36[rsp]
  00e33	66 0f 7f 84 24
	20 0d 00 00	 movdqa	 XMMWORD PTR $T192[rsp], xmm0
  00e3c	66 0f 6f 84 24
	20 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T192[rsp]
  00e45	66 0f 7f 84 24
	80 0d 00 00	 movdqa	 XMMWORD PTR dif_h$198[rsp], xmm0
  00e4e	66 0f 6f 84 24
	30 0d 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$193[rsp]
  00e57	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00e5c	66 0f 7f 84 24
	60 0d 00 00	 movdqa	 XMMWORD PTR $T196[rsp], xmm0
  00e65	66 0f 6f 84 24
	40 0d 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$194[rsp]
  00e6e	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00e73	66 0f 7f 84 24
	50 0d 00 00	 movdqa	 XMMWORD PTR $T195[rsp], xmm0
  00e7c	66 0f 6f 84 24
	50 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T195[rsp]
  00e85	66 0f 6b 84 24
	60 0d 00 00	 packssdw xmm0, XMMWORD PTR $T196[rsp]
  00e8e	66 0f 7f 84 24
	70 0d 00 00	 movdqa	 XMMWORD PTR $T197[rsp], xmm0
  00e97	66 0f 6f 84 24
	70 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T197[rsp]
  00ea0	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  00ea6	66 0f 6f 84 24
	80 0d 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$198[rsp]
  00eaf	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00eb4	66 0f 7f 84 24
	b0 0d 00 00	 movdqa	 XMMWORD PTR $T201[rsp], xmm0
  00ebd	66 0f 6f 84 24
	90 0d 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$199[rsp]
  00ec6	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00ecb	66 0f 7f 84 24
	a0 0d 00 00	 movdqa	 XMMWORD PTR $T200[rsp], xmm0
  00ed4	66 0f 6f 84 24
	a0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T200[rsp]
  00edd	66 0f 6b 84 24
	b0 0d 00 00	 packssdw xmm0, XMMWORD PTR $T201[rsp]
  00ee6	66 0f 7f 84 24
	c0 0d 00 00	 movdqa	 XMMWORD PTR $T202[rsp], xmm0
  00eef	66 0f 6f 84 24
	c0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T202[rsp]
  00ef8	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  00f01	66 0f 6f 84 24
	d0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$203[rsp]
  00f0a	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00f13	66 0f 7f 84 24
	e0 0d 00 00	 movdqa	 XMMWORD PTR $T204[rsp], xmm0
  00f1c	66 0f 6f 84 24
	e0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T204[rsp]
  00f25	66 0f 7f 84 24
	70 03 00 00	 movdqa	 XMMWORD PTR abiased_l$37[rsp], xmm0
  00f2e	66 0f 6f 84 24
	f0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$205[rsp]
  00f37	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00f40	66 0f 7f 84 24
	00 0e 00 00	 movdqa	 XMMWORD PTR $T206[rsp], xmm0
  00f49	66 0f 6f 84 24
	00 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T206[rsp]
  00f52	66 0f 7f 84 24
	90 03 00 00	 movdqa	 XMMWORD PTR abiased_h$39[rsp], xmm0
  00f5b	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$37[rsp]
  00f64	66 0f fe 84 24
	80 03 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$38[rsp]
  00f6d	66 0f 7f 84 24
	10 0e 00 00	 movdqa	 XMMWORD PTR $T207[rsp], xmm0
  00f76	66 0f 6f 84 24
	10 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T207[rsp]
  00f7f	66 0f 7f 84 24
	60 0e 00 00	 movdqa	 XMMWORD PTR sum_l$212[rsp], xmm0
  00f88	66 0f 6f 84 24
	90 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$39[rsp]
  00f91	66 0f fe 84 24
	a0 03 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$40[rsp]
  00f9a	66 0f 7f 84 24
	20 0e 00 00	 movdqa	 XMMWORD PTR $T208[rsp], xmm0
  00fa3	66 0f 6f 84 24
	20 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T208[rsp]
  00fac	66 0f 7f 84 24
	50 0e 00 00	 movdqa	 XMMWORD PTR sum_h$211[rsp], xmm0
  00fb5	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$37[rsp]
  00fbe	66 0f fa 84 24
	80 03 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$38[rsp]
  00fc7	66 0f 7f 84 24
	30 0e 00 00	 movdqa	 XMMWORD PTR $T209[rsp], xmm0
  00fd0	66 0f 6f 84 24
	30 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T209[rsp]
  00fd9	66 0f 7f 84 24
	b0 0e 00 00	 movdqa	 XMMWORD PTR dif_l$217[rsp], xmm0
  00fe2	66 0f 6f 84 24
	90 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$39[rsp]
  00feb	66 0f fa 84 24
	a0 03 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$40[rsp]
  00ff4	66 0f 7f 84 24
	40 0e 00 00	 movdqa	 XMMWORD PTR $T210[rsp], xmm0
  00ffd	66 0f 6f 84 24
	40 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T210[rsp]
  01006	66 0f 7f 84 24
	a0 0e 00 00	 movdqa	 XMMWORD PTR dif_h$216[rsp], xmm0
  0100f	66 0f 6f 84 24
	50 0e 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$211[rsp]
  01018	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0101d	66 0f 7f 84 24
	80 0e 00 00	 movdqa	 XMMWORD PTR $T214[rsp], xmm0
  01026	66 0f 6f 84 24
	60 0e 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$212[rsp]
  0102f	66 0f 72 e0 0a	 psrad	 xmm0, 10
  01034	66 0f 7f 84 24
	70 0e 00 00	 movdqa	 XMMWORD PTR $T213[rsp], xmm0
  0103d	66 0f 6f 84 24
	70 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T213[rsp]
  01046	66 0f 6b 84 24
	80 0e 00 00	 packssdw xmm0, XMMWORD PTR $T214[rsp]
  0104f	66 0f 7f 84 24
	90 0e 00 00	 movdqa	 XMMWORD PTR $T215[rsp], xmm0
  01058	66 0f 6f 84 24
	90 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T215[rsp]
  01061	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  01067	66 0f 6f 84 24
	a0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$216[rsp]
  01070	66 0f 72 e0 0a	 psrad	 xmm0, 10
  01075	66 0f 7f 84 24
	d0 0e 00 00	 movdqa	 XMMWORD PTR $T219[rsp], xmm0
  0107e	66 0f 6f 84 24
	b0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$217[rsp]
  01087	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0108c	66 0f 7f 84 24
	c0 0e 00 00	 movdqa	 XMMWORD PTR $T218[rsp], xmm0
  01095	66 0f 6f 84 24
	c0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T218[rsp]
  0109e	66 0f 6b 84 24
	d0 0e 00 00	 packssdw xmm0, XMMWORD PTR $T219[rsp]
  010a7	66 0f 7f 84 24
	e0 0e 00 00	 movdqa	 XMMWORD PTR $T220[rsp], xmm0
  010b0	66 0f 6f 84 24
	e0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T220[rsp]
  010b9	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  010bf	66 0f 6f 84 24
	f0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$221[rsp]
  010c8	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  010d1	66 0f 7f 84 24
	00 0f 00 00	 movdqa	 XMMWORD PTR $T222[rsp], xmm0
  010da	66 0f 6f 84 24
	00 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T222[rsp]
  010e3	66 0f 7f 84 24
	b0 03 00 00	 movdqa	 XMMWORD PTR abiased_l$41[rsp], xmm0
  010ec	66 0f 6f 84 24
	10 0f 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$223[rsp]
  010f5	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  010fe	66 0f 7f 84 24
	20 0f 00 00	 movdqa	 XMMWORD PTR $T224[rsp], xmm0
  01107	66 0f 6f 84 24
	20 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T224[rsp]
  01110	66 0f 7f 84 24
	d0 03 00 00	 movdqa	 XMMWORD PTR abiased_h$43[rsp], xmm0
  01119	66 0f 6f 84 24
	b0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$41[rsp]
  01122	66 0f fe 84 24
	c0 03 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$42[rsp]
  0112b	66 0f 7f 84 24
	30 0f 00 00	 movdqa	 XMMWORD PTR $T225[rsp], xmm0
  01134	66 0f 6f 84 24
	30 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T225[rsp]
  0113d	66 0f 7f 84 24
	80 0f 00 00	 movdqa	 XMMWORD PTR sum_l$230[rsp], xmm0
  01146	66 0f 6f 84 24
	d0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$43[rsp]
  0114f	66 0f fe 84 24
	e0 03 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$44[rsp]
  01158	66 0f 7f 84 24
	40 0f 00 00	 movdqa	 XMMWORD PTR $T226[rsp], xmm0
  01161	66 0f 6f 84 24
	40 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T226[rsp]
  0116a	66 0f 7f 84 24
	70 0f 00 00	 movdqa	 XMMWORD PTR sum_h$229[rsp], xmm0
  01173	66 0f 6f 84 24
	b0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$41[rsp]
  0117c	66 0f fa 84 24
	c0 03 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$42[rsp]
  01185	66 0f 7f 84 24
	50 0f 00 00	 movdqa	 XMMWORD PTR $T227[rsp], xmm0
  0118e	66 0f 6f 84 24
	50 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T227[rsp]
  01197	66 0f 7f 84 24
	d0 0f 00 00	 movdqa	 XMMWORD PTR dif_l$235[rsp], xmm0
  011a0	66 0f 6f 84 24
	d0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$43[rsp]
  011a9	66 0f fa 84 24
	e0 03 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$44[rsp]
  011b2	66 0f 7f 84 24
	60 0f 00 00	 movdqa	 XMMWORD PTR $T228[rsp], xmm0
  011bb	66 0f 6f 84 24
	60 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T228[rsp]
  011c4	66 0f 7f 84 24
	c0 0f 00 00	 movdqa	 XMMWORD PTR dif_h$234[rsp], xmm0
  011cd	66 0f 6f 84 24
	70 0f 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$229[rsp]
  011d6	66 0f 72 e0 0a	 psrad	 xmm0, 10
  011db	66 0f 7f 84 24
	a0 0f 00 00	 movdqa	 XMMWORD PTR $T232[rsp], xmm0
  011e4	66 0f 6f 84 24
	80 0f 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$230[rsp]
  011ed	66 0f 72 e0 0a	 psrad	 xmm0, 10
  011f2	66 0f 7f 84 24
	90 0f 00 00	 movdqa	 XMMWORD PTR $T231[rsp], xmm0
  011fb	66 0f 6f 84 24
	90 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T231[rsp]
  01204	66 0f 6b 84 24
	a0 0f 00 00	 packssdw xmm0, XMMWORD PTR $T232[rsp]
  0120d	66 0f 7f 84 24
	b0 0f 00 00	 movdqa	 XMMWORD PTR $T233[rsp], xmm0
  01216	66 0f 6f 84 24
	b0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T233[rsp]
  0121f	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  01225	66 0f 6f 84 24
	c0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$234[rsp]
  0122e	66 0f 72 e0 0a	 psrad	 xmm0, 10
  01233	66 0f 7f 84 24
	f0 0f 00 00	 movdqa	 XMMWORD PTR $T237[rsp], xmm0
  0123c	66 0f 6f 84 24
	d0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$235[rsp]
  01245	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0124a	66 0f 7f 84 24
	e0 0f 00 00	 movdqa	 XMMWORD PTR $T236[rsp], xmm0
  01253	66 0f 6f 84 24
	e0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T236[rsp]
  0125c	66 0f 6b 84 24
	f0 0f 00 00	 packssdw xmm0, XMMWORD PTR $T237[rsp]
  01265	66 0f 7f 84 24
	00 10 00 00	 movdqa	 XMMWORD PTR $T238[rsp], xmm0
  0126e	66 0f 6f 84 24
	00 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T238[rsp]
  01277	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2606 :     
; 2607 :     {
; 2608 :         // 16bit 8x8 transpose pass 1
; 2609 :         dct_interleave16(row0, row4);

  0127d	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  01283	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01288	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  0128e	66 0f 61 44 24
	70		 punpcklwd xmm0, XMMWORD PTR row4$[rsp]
  01294	66 0f 7f 84 24
	10 10 00 00	 movdqa	 XMMWORD PTR $T239[rsp], xmm0
  0129d	66 0f 6f 84 24
	10 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T239[rsp]
  012a6	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  012ac	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  012b1	66 0f 69 44 24
	70		 punpckhwd xmm0, XMMWORD PTR row4$[rsp]
  012b7	66 0f 7f 84 24
	20 10 00 00	 movdqa	 XMMWORD PTR $T240[rsp], xmm0
  012c0	66 0f 6f 84 24
	20 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T240[rsp]
  012c9	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2610 :         dct_interleave16(row1, row5);

  012cf	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  012d5	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  012da	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  012e0	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row5$[rsp]
  012e6	66 0f 7f 84 24
	30 10 00 00	 movdqa	 XMMWORD PTR $T241[rsp], xmm0
  012ef	66 0f 6f 84 24
	30 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T241[rsp]
  012f8	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  012fe	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01303	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row5$[rsp]
  01309	66 0f 7f 84 24
	40 10 00 00	 movdqa	 XMMWORD PTR $T242[rsp], xmm0
  01312	66 0f 6f 84 24
	40 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T242[rsp]
  0131b	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2611 :         dct_interleave16(row2, row6);

  01321	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01327	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0132c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01332	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0133b	66 0f 7f 84 24
	50 10 00 00	 movdqa	 XMMWORD PTR $T243[rsp], xmm0
  01344	66 0f 6f 84 24
	50 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T243[rsp]
  0134d	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  01353	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01358	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  01361	66 0f 7f 84 24
	60 10 00 00	 movdqa	 XMMWORD PTR $T244[rsp], xmm0
  0136a	66 0f 6f 84 24
	60 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T244[rsp]
  01373	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2612 :         dct_interleave16(row3, row7);

  0137c	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  01382	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01387	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  0138d	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  01393	66 0f 7f 84 24
	70 10 00 00	 movdqa	 XMMWORD PTR $T245[rsp], xmm0
  0139c	66 0f 6f 84 24
	70 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T245[rsp]
  013a5	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  013ab	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  013b0	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  013b6	66 0f 7f 84 24
	80 10 00 00	 movdqa	 XMMWORD PTR $T246[rsp], xmm0
  013bf	66 0f 6f 84 24
	80 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T246[rsp]
  013c8	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2613 :         
; 2614 :         // transpose pass 2
; 2615 :         dct_interleave16(row0, row2);

  013ce	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  013d4	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  013d9	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  013df	66 0f 61 44 24
	60		 punpcklwd xmm0, XMMWORD PTR row2$[rsp]
  013e5	66 0f 7f 84 24
	90 10 00 00	 movdqa	 XMMWORD PTR $T247[rsp], xmm0
  013ee	66 0f 6f 84 24
	90 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T247[rsp]
  013f7	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  013fd	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01402	66 0f 69 44 24
	60		 punpckhwd xmm0, XMMWORD PTR row2$[rsp]
  01408	66 0f 7f 84 24
	a0 10 00 00	 movdqa	 XMMWORD PTR $T248[rsp], xmm0
  01411	66 0f 6f 84 24
	a0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T248[rsp]
  0141a	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0

; 2616 :         dct_interleave16(row1, row3);

  01420	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  01426	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0142b	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  01431	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  01437	66 0f 7f 84 24
	b0 10 00 00	 movdqa	 XMMWORD PTR $T249[rsp], xmm0
  01440	66 0f 6f 84 24
	b0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T249[rsp]
  01449	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  0144f	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01454	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  0145a	66 0f 7f 84 24
	c0 10 00 00	 movdqa	 XMMWORD PTR $T250[rsp], xmm0
  01463	66 0f 6f 84 24
	c0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T250[rsp]
  0146c	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2617 :         dct_interleave16(row4, row6);

  01472	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  01478	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0147d	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  01483	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0148c	66 0f 7f 84 24
	d0 10 00 00	 movdqa	 XMMWORD PTR $T251[rsp], xmm0
  01495	66 0f 6f 84 24
	d0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T251[rsp]
  0149e	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0
  014a4	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  014a9	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  014b2	66 0f 7f 84 24
	e0 10 00 00	 movdqa	 XMMWORD PTR $T252[rsp], xmm0
  014bb	66 0f 6f 84 24
	e0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T252[rsp]
  014c4	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2618 :         dct_interleave16(row5, row7);

  014cd	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  014d3	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  014d8	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  014de	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  014e4	66 0f 7f 84 24
	f0 10 00 00	 movdqa	 XMMWORD PTR $T253[rsp], xmm0
  014ed	66 0f 6f 84 24
	f0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T253[rsp]
  014f6	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  014fc	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01501	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  01507	66 0f 7f 84 24
	00 11 00 00	 movdqa	 XMMWORD PTR $T254[rsp], xmm0
  01510	66 0f 6f 84 24
	00 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T254[rsp]
  01519	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2619 :         
; 2620 :         // transpose pass 3
; 2621 :         dct_interleave16(row0, row1);

  0151f	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  01525	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0152a	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  01530	66 0f 61 44 24
	10		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  01536	66 0f 7f 84 24
	10 11 00 00	 movdqa	 XMMWORD PTR $T255[rsp], xmm0
  0153f	66 0f 6f 84 24
	10 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T255[rsp]
  01548	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  0154e	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01553	66 0f 69 44 24
	10		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  01559	66 0f 7f 84 24
	20 11 00 00	 movdqa	 XMMWORD PTR $T256[rsp], xmm0
  01562	66 0f 6f 84 24
	20 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T256[rsp]
  0156b	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0

; 2622 :         dct_interleave16(row2, row3);

  01571	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01577	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0157c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01582	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  01588	66 0f 7f 84 24
	30 11 00 00	 movdqa	 XMMWORD PTR $T257[rsp], xmm0
  01591	66 0f 6f 84 24
	30 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T257[rsp]
  0159a	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  015a0	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  015a5	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  015ab	66 0f 7f 84 24
	40 11 00 00	 movdqa	 XMMWORD PTR $T258[rsp], xmm0
  015b4	66 0f 6f 84 24
	40 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T258[rsp]
  015bd	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2623 :         dct_interleave16(row4, row5);

  015c3	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  015c9	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  015ce	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  015d4	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row5$[rsp]
  015da	66 0f 7f 84 24
	50 11 00 00	 movdqa	 XMMWORD PTR $T259[rsp], xmm0
  015e3	66 0f 6f 84 24
	50 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T259[rsp]
  015ec	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0
  015f2	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  015f7	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row5$[rsp]
  015fd	66 0f 7f 84 24
	60 11 00 00	 movdqa	 XMMWORD PTR $T260[rsp], xmm0
  01606	66 0f 6f 84 24
	60 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T260[rsp]
  0160f	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2624 :         dct_interleave16(row6, row7);

  01615	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  0161e	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01623	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  0162c	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  01632	66 0f 7f 84 24
	70 11 00 00	 movdqa	 XMMWORD PTR $T261[rsp], xmm0
  0163b	66 0f 6f 84 24
	70 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T261[rsp]
  01644	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  0164d	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01652	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  01658	66 0f 7f 84 24
	80 11 00 00	 movdqa	 XMMWORD PTR $T262[rsp], xmm0
  01661	66 0f 6f 84 24
	80 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T262[rsp]
  0166a	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2625 :     }
; 2626 :     
; 2627 :     // row pass
; 2628 :     dct_pass(bias_1, 17);

  01670	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01676	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0167f	66 0f 7f 84 24
	90 11 00 00	 movdqa	 XMMWORD PTR $T263[rsp], xmm0
  01688	66 0f 6f 84 24
	90 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T263[rsp]
  01691	66 0f 7f 84 24
	f0 03 00 00	 movdqa	 XMMWORD PTR rot0_0lo$45[rsp], xmm0
  0169a	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  016a0	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  016a9	66 0f 7f 84 24
	a0 11 00 00	 movdqa	 XMMWORD PTR $T264[rsp], xmm0
  016b2	66 0f 6f 84 24
	a0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T264[rsp]
  016bb	66 0f 7f 84 24
	00 04 00 00	 movdqa	 XMMWORD PTR rot0_0hi$46[rsp], xmm0
  016c4	66 0f 6f 84 24
	f0 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$45[rsp]
  016cd	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  016d6	66 0f 7f 84 24
	b0 11 00 00	 movdqa	 XMMWORD PTR $T265[rsp], xmm0
  016df	66 0f 6f 84 24
	b0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T265[rsp]
  016e8	66 0f 7f 84 24
	80 04 00 00	 movdqa	 XMMWORD PTR t2e_l$54[rsp], xmm0
  016f1	66 0f 6f 84 24
	00 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$46[rsp]
  016fa	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  01703	66 0f 7f 84 24
	c0 11 00 00	 movdqa	 XMMWORD PTR $T266[rsp], xmm0
  0170c	66 0f 6f 84 24
	c0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T266[rsp]
  01715	66 0f 7f 84 24
	a0 04 00 00	 movdqa	 XMMWORD PTR t2e_h$56[rsp], xmm0
  0171e	66 0f 6f 84 24
	f0 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$45[rsp]
  01727	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  01730	66 0f 7f 84 24
	d0 11 00 00	 movdqa	 XMMWORD PTR $T267[rsp], xmm0
  01739	66 0f 6f 84 24
	d0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T267[rsp]
  01742	66 0f 7f 84 24
	40 04 00 00	 movdqa	 XMMWORD PTR t3e_l$50[rsp], xmm0
  0174b	66 0f 6f 84 24
	00 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$46[rsp]
  01754	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  0175d	66 0f 7f 84 24
	e0 11 00 00	 movdqa	 XMMWORD PTR $T268[rsp], xmm0
  01766	66 0f 6f 84 24
	e0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T268[rsp]
  0176f	66 0f 7f 84 24
	60 04 00 00	 movdqa	 XMMWORD PTR t3e_h$52[rsp], xmm0
  01778	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  0177e	66 0f fd 44 24
	70		 paddw	 xmm0, XMMWORD PTR row4$[rsp]
  01784	66 0f 7f 84 24
	f0 11 00 00	 movdqa	 XMMWORD PTR $T269[rsp], xmm0
  0178d	66 0f 6f 84 24
	f0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T269[rsp]
  01796	66 0f 7f 84 24
	10 04 00 00	 movdqa	 XMMWORD PTR sum04$47[rsp], xmm0
  0179f	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  017a5	66 0f f9 44 24
	70		 psubw	 xmm0, XMMWORD PTR row4$[rsp]
  017ab	66 0f 7f 84 24
	00 12 00 00	 movdqa	 XMMWORD PTR $T270[rsp], xmm0
  017b4	66 0f 6f 84 24
	00 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T270[rsp]
  017bd	66 0f 7f 84 24
	20 04 00 00	 movdqa	 XMMWORD PTR dif04$48[rsp], xmm0
  017c6	66 0f ef c0	 pxor	 xmm0, xmm0
  017ca	66 0f 7f 84 24
	10 12 00 00	 movdqa	 XMMWORD PTR $T271[rsp], xmm0
  017d3	66 0f 6f 84 24
	10 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T271[rsp]
  017dc	66 0f 61 84 24
	10 04 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$47[rsp]
  017e5	66 0f 7f 84 24
	20 12 00 00	 movdqa	 XMMWORD PTR $T272[rsp], xmm0
  017ee	66 0f 6f 84 24
	20 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T272[rsp]
  017f7	66 0f 72 e0 04	 psrad	 xmm0, 4
  017fc	66 0f 7f 84 24
	30 12 00 00	 movdqa	 XMMWORD PTR $T273[rsp], xmm0
  01805	66 0f 6f 84 24
	30 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T273[rsp]
  0180e	66 0f 7f 84 24
	30 04 00 00	 movdqa	 XMMWORD PTR t0e_l$49[rsp], xmm0
  01817	66 0f ef c0	 pxor	 xmm0, xmm0
  0181b	66 0f 7f 84 24
	40 12 00 00	 movdqa	 XMMWORD PTR $T274[rsp], xmm0
  01824	66 0f 6f 84 24
	40 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T274[rsp]
  0182d	66 0f 69 84 24
	10 04 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$47[rsp]
  01836	66 0f 7f 84 24
	50 12 00 00	 movdqa	 XMMWORD PTR $T275[rsp], xmm0
  0183f	66 0f 6f 84 24
	50 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T275[rsp]
  01848	66 0f 72 e0 04	 psrad	 xmm0, 4
  0184d	66 0f 7f 84 24
	60 12 00 00	 movdqa	 XMMWORD PTR $T276[rsp], xmm0
  01856	66 0f 6f 84 24
	60 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T276[rsp]
  0185f	66 0f 7f 84 24
	50 04 00 00	 movdqa	 XMMWORD PTR t0e_h$51[rsp], xmm0
  01868	66 0f ef c0	 pxor	 xmm0, xmm0
  0186c	66 0f 7f 84 24
	70 12 00 00	 movdqa	 XMMWORD PTR $T277[rsp], xmm0
  01875	66 0f 6f 84 24
	70 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T277[rsp]
  0187e	66 0f 61 84 24
	20 04 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$48[rsp]
  01887	66 0f 7f 84 24
	80 12 00 00	 movdqa	 XMMWORD PTR $T278[rsp], xmm0
  01890	66 0f 6f 84 24
	80 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T278[rsp]
  01899	66 0f 72 e0 04	 psrad	 xmm0, 4
  0189e	66 0f 7f 84 24
	90 12 00 00	 movdqa	 XMMWORD PTR $T279[rsp], xmm0
  018a7	66 0f 6f 84 24
	90 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T279[rsp]
  018b0	66 0f 7f 84 24
	70 04 00 00	 movdqa	 XMMWORD PTR t1e_l$53[rsp], xmm0
  018b9	66 0f ef c0	 pxor	 xmm0, xmm0
  018bd	66 0f 7f 84 24
	a0 12 00 00	 movdqa	 XMMWORD PTR $T280[rsp], xmm0
  018c6	66 0f 6f 84 24
	a0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T280[rsp]
  018cf	66 0f 69 84 24
	20 04 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$48[rsp]
  018d8	66 0f 7f 84 24
	b0 12 00 00	 movdqa	 XMMWORD PTR $T281[rsp], xmm0
  018e1	66 0f 6f 84 24
	b0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T281[rsp]
  018ea	66 0f 72 e0 04	 psrad	 xmm0, 4
  018ef	66 0f 7f 84 24
	c0 12 00 00	 movdqa	 XMMWORD PTR $T282[rsp], xmm0
  018f8	66 0f 6f 84 24
	c0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T282[rsp]
  01901	66 0f 7f 84 24
	90 04 00 00	 movdqa	 XMMWORD PTR t1e_h$55[rsp], xmm0
  0190a	66 0f 6f 84 24
	30 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$49[rsp]
  01913	66 0f fe 84 24
	40 04 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$50[rsp]
  0191c	66 0f 7f 84 24
	d0 12 00 00	 movdqa	 XMMWORD PTR $T283[rsp], xmm0
  01925	66 0f 6f 84 24
	d0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T283[rsp]
  0192e	66 0f 7f 84 24
	90 15 00 00	 movdqa	 XMMWORD PTR x0_l$327[rsp], xmm0
  01937	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$51[rsp]
  01940	66 0f fe 84 24
	60 04 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$52[rsp]
  01949	66 0f 7f 84 24
	e0 12 00 00	 movdqa	 XMMWORD PTR $T284[rsp], xmm0
  01952	66 0f 6f 84 24
	e0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T284[rsp]
  0195b	66 0f 7f 84 24
	b0 15 00 00	 movdqa	 XMMWORD PTR x0_h$329[rsp], xmm0
  01964	66 0f 6f 84 24
	30 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$49[rsp]
  0196d	66 0f fa 84 24
	40 04 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$50[rsp]
  01976	66 0f 7f 84 24
	f0 12 00 00	 movdqa	 XMMWORD PTR $T285[rsp], xmm0
  0197f	66 0f 6f 84 24
	f0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T285[rsp]
  01988	66 0f 7f 84 24
	f0 18 00 00	 movdqa	 XMMWORD PTR x3_l$381[rsp], xmm0
  01991	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$51[rsp]
  0199a	66 0f fa 84 24
	60 04 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$52[rsp]
  019a3	66 0f 7f 84 24
	00 13 00 00	 movdqa	 XMMWORD PTR $T286[rsp], xmm0
  019ac	66 0f 6f 84 24
	00 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T286[rsp]
  019b5	66 0f 7f 84 24
	10 19 00 00	 movdqa	 XMMWORD PTR x3_h$383[rsp], xmm0
  019be	66 0f 6f 84 24
	70 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$53[rsp]
  019c7	66 0f fe 84 24
	80 04 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$54[rsp]
  019d0	66 0f 7f 84 24
	10 13 00 00	 movdqa	 XMMWORD PTR $T287[rsp], xmm0
  019d9	66 0f 6f 84 24
	10 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T287[rsp]
  019e2	66 0f 7f 84 24
	b0 16 00 00	 movdqa	 XMMWORD PTR x1_l$345[rsp], xmm0
  019eb	66 0f 6f 84 24
	90 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$55[rsp]
  019f4	66 0f fe 84 24
	a0 04 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$56[rsp]
  019fd	66 0f 7f 84 24
	20 13 00 00	 movdqa	 XMMWORD PTR $T288[rsp], xmm0
  01a06	66 0f 6f 84 24
	20 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T288[rsp]
  01a0f	66 0f 7f 84 24
	d0 16 00 00	 movdqa	 XMMWORD PTR x1_h$347[rsp], xmm0
  01a18	66 0f 6f 84 24
	70 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$53[rsp]
  01a21	66 0f fa 84 24
	80 04 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$54[rsp]
  01a2a	66 0f 7f 84 24
	30 13 00 00	 movdqa	 XMMWORD PTR $T289[rsp], xmm0
  01a33	66 0f 6f 84 24
	30 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T289[rsp]
  01a3c	66 0f 7f 84 24
	d0 17 00 00	 movdqa	 XMMWORD PTR x2_l$363[rsp], xmm0
  01a45	66 0f 6f 84 24
	90 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$55[rsp]
  01a4e	66 0f fa 84 24
	a0 04 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$56[rsp]
  01a57	66 0f 7f 84 24
	40 13 00 00	 movdqa	 XMMWORD PTR $T290[rsp], xmm0
  01a60	66 0f 6f 84 24
	40 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T290[rsp]
  01a69	66 0f 7f 84 24
	f0 17 00 00	 movdqa	 XMMWORD PTR x2_h$365[rsp], xmm0
  01a72	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  01a78	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  01a7e	66 0f 7f 84 24
	50 13 00 00	 movdqa	 XMMWORD PTR $T291[rsp], xmm0
  01a87	66 0f 6f 84 24
	50 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T291[rsp]
  01a90	66 0f 7f 84 24
	b0 04 00 00	 movdqa	 XMMWORD PTR rot2_0lo$57[rsp], xmm0
  01a99	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  01a9f	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  01aa5	66 0f 7f 84 24
	60 13 00 00	 movdqa	 XMMWORD PTR $T292[rsp], xmm0
  01aae	66 0f 6f 84 24
	60 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T292[rsp]
  01ab7	66 0f 7f 84 24
	c0 04 00 00	 movdqa	 XMMWORD PTR rot2_0hi$58[rsp], xmm0
  01ac0	66 0f 6f 84 24
	b0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$57[rsp]
  01ac9	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  01ad2	66 0f 7f 84 24
	70 13 00 00	 movdqa	 XMMWORD PTR $T293[rsp], xmm0
  01adb	66 0f 6f 84 24
	70 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T293[rsp]
  01ae4	66 0f 7f 84 24
	90 14 00 00	 movdqa	 XMMWORD PTR y0o_l$311[rsp], xmm0
  01aed	66 0f 6f 84 24
	c0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$58[rsp]
  01af6	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  01aff	66 0f 7f 84 24
	80 13 00 00	 movdqa	 XMMWORD PTR $T294[rsp], xmm0
  01b08	66 0f 6f 84 24
	80 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T294[rsp]
  01b11	66 0f 7f 84 24
	b0 14 00 00	 movdqa	 XMMWORD PTR y0o_h$313[rsp], xmm0
  01b1a	66 0f 6f 84 24
	b0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$57[rsp]
  01b23	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  01b2c	66 0f 7f 84 24
	90 13 00 00	 movdqa	 XMMWORD PTR $T295[rsp], xmm0
  01b35	66 0f 6f 84 24
	90 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T295[rsp]
  01b3e	66 0f 7f 84 24
	10 15 00 00	 movdqa	 XMMWORD PTR y2o_l$319[rsp], xmm0
  01b47	66 0f 6f 84 24
	c0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$58[rsp]
  01b50	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  01b59	66 0f 7f 84 24
	a0 13 00 00	 movdqa	 XMMWORD PTR $T296[rsp], xmm0
  01b62	66 0f 6f 84 24
	a0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T296[rsp]
  01b6b	66 0f 7f 84 24
	30 15 00 00	 movdqa	 XMMWORD PTR y2o_h$321[rsp], xmm0
  01b74	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  01b7a	66 0f 61 44 24
	10		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  01b80	66 0f 7f 84 24
	b0 13 00 00	 movdqa	 XMMWORD PTR $T297[rsp], xmm0
  01b89	66 0f 6f 84 24
	b0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T297[rsp]
  01b92	66 0f 7f 84 24
	d0 04 00 00	 movdqa	 XMMWORD PTR rot3_0lo$59[rsp], xmm0
  01b9b	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  01ba1	66 0f 69 44 24
	10		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  01ba7	66 0f 7f 84 24
	c0 13 00 00	 movdqa	 XMMWORD PTR $T298[rsp], xmm0
  01bb0	66 0f 6f 84 24
	c0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T298[rsp]
  01bb9	66 0f 7f 84 24
	e0 04 00 00	 movdqa	 XMMWORD PTR rot3_0hi$60[rsp], xmm0
  01bc2	66 0f 6f 84 24
	d0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$59[rsp]
  01bcb	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  01bd4	66 0f 7f 84 24
	d0 13 00 00	 movdqa	 XMMWORD PTR $T299[rsp], xmm0
  01bdd	66 0f 6f 84 24
	d0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T299[rsp]
  01be6	66 0f 7f 84 24
	d0 14 00 00	 movdqa	 XMMWORD PTR y1o_l$315[rsp], xmm0
  01bef	66 0f 6f 84 24
	e0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$60[rsp]
  01bf8	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  01c01	66 0f 7f 84 24
	e0 13 00 00	 movdqa	 XMMWORD PTR $T300[rsp], xmm0
  01c0a	66 0f 6f 84 24
	e0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T300[rsp]
  01c13	66 0f 7f 84 24
	f0 14 00 00	 movdqa	 XMMWORD PTR y1o_h$317[rsp], xmm0
  01c1c	66 0f 6f 84 24
	d0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$59[rsp]
  01c25	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  01c2e	66 0f 7f 84 24
	f0 13 00 00	 movdqa	 XMMWORD PTR $T301[rsp], xmm0
  01c37	66 0f 6f 84 24
	f0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T301[rsp]
  01c40	66 0f 7f 84 24
	50 15 00 00	 movdqa	 XMMWORD PTR y3o_l$323[rsp], xmm0
  01c49	66 0f 6f 84 24
	e0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$60[rsp]
  01c52	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  01c5b	66 0f 7f 84 24
	00 14 00 00	 movdqa	 XMMWORD PTR $T302[rsp], xmm0
  01c64	66 0f 6f 84 24
	00 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T302[rsp]
  01c6d	66 0f 7f 84 24
	70 15 00 00	 movdqa	 XMMWORD PTR y3o_h$325[rsp], xmm0
  01c76	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  01c7c	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR row7$[rsp]
  01c82	66 0f 7f 84 24
	10 14 00 00	 movdqa	 XMMWORD PTR $T303[rsp], xmm0
  01c8b	66 0f 6f 84 24
	10 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T303[rsp]
  01c94	66 0f 7f 84 24
	f0 04 00 00	 movdqa	 XMMWORD PTR sum17$61[rsp], xmm0
  01c9d	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  01ca3	66 0f fd 44 24
	30		 paddw	 xmm0, XMMWORD PTR row5$[rsp]
  01ca9	66 0f 7f 84 24
	20 14 00 00	 movdqa	 XMMWORD PTR $T304[rsp], xmm0
  01cb2	66 0f 6f 84 24
	20 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T304[rsp]
  01cbb	66 0f 7f 84 24
	00 05 00 00	 movdqa	 XMMWORD PTR sum35$62[rsp], xmm0
  01cc4	66 0f 6f 84 24
	f0 04 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$61[rsp]
  01ccd	66 0f 61 84 24
	00 05 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$62[rsp]
  01cd6	66 0f 7f 84 24
	30 14 00 00	 movdqa	 XMMWORD PTR $T305[rsp], xmm0
  01cdf	66 0f 6f 84 24
	30 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T305[rsp]
  01ce8	66 0f 7f 84 24
	10 05 00 00	 movdqa	 XMMWORD PTR rot1_0lo$63[rsp], xmm0
  01cf1	66 0f 6f 84 24
	f0 04 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$61[rsp]
  01cfa	66 0f 69 84 24
	00 05 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$62[rsp]
  01d03	66 0f 7f 84 24
	40 14 00 00	 movdqa	 XMMWORD PTR $T306[rsp], xmm0
  01d0c	66 0f 6f 84 24
	40 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T306[rsp]
  01d15	66 0f 7f 84 24
	20 05 00 00	 movdqa	 XMMWORD PTR rot1_0hi$64[rsp], xmm0
  01d1e	66 0f 6f 84 24
	10 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$63[rsp]
  01d27	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  01d30	66 0f 7f 84 24
	50 14 00 00	 movdqa	 XMMWORD PTR $T307[rsp], xmm0
  01d39	66 0f 6f 84 24
	50 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T307[rsp]
  01d42	66 0f 7f 84 24
	50 05 00 00	 movdqa	 XMMWORD PTR y4o_l$67[rsp], xmm0
  01d4b	66 0f 6f 84 24
	20 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$64[rsp]
  01d54	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  01d5d	66 0f 7f 84 24
	60 14 00 00	 movdqa	 XMMWORD PTR $T308[rsp], xmm0
  01d66	66 0f 6f 84 24
	60 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T308[rsp]
  01d6f	66 0f 7f 84 24
	60 05 00 00	 movdqa	 XMMWORD PTR y4o_h$68[rsp], xmm0
  01d78	66 0f 6f 84 24
	10 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$63[rsp]
  01d81	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  01d8a	66 0f 7f 84 24
	70 14 00 00	 movdqa	 XMMWORD PTR $T309[rsp], xmm0
  01d93	66 0f 6f 84 24
	70 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T309[rsp]
  01d9c	66 0f 7f 84 24
	30 05 00 00	 movdqa	 XMMWORD PTR y5o_l$65[rsp], xmm0
  01da5	66 0f 6f 84 24
	20 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$64[rsp]
  01dae	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  01db7	66 0f 7f 84 24
	80 14 00 00	 movdqa	 XMMWORD PTR $T310[rsp], xmm0
  01dc0	66 0f 6f 84 24
	80 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T310[rsp]
  01dc9	66 0f 7f 84 24
	40 05 00 00	 movdqa	 XMMWORD PTR y5o_h$66[rsp], xmm0
  01dd2	66 0f 6f 84 24
	90 14 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$311[rsp]
  01ddb	66 0f fe 84 24
	50 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$67[rsp]
  01de4	66 0f 7f 84 24
	a0 14 00 00	 movdqa	 XMMWORD PTR $T312[rsp], xmm0
  01ded	66 0f 6f 84 24
	a0 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T312[rsp]
  01df6	66 0f 7f 84 24
	40 06 00 00	 movdqa	 XMMWORD PTR x4_l$82[rsp], xmm0
  01dff	66 0f 6f 84 24
	b0 14 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$313[rsp]
  01e08	66 0f fe 84 24
	60 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$68[rsp]
  01e11	66 0f 7f 84 24
	c0 14 00 00	 movdqa	 XMMWORD PTR $T314[rsp], xmm0
  01e1a	66 0f 6f 84 24
	c0 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T314[rsp]
  01e23	66 0f 7f 84 24
	60 06 00 00	 movdqa	 XMMWORD PTR x4_h$84[rsp], xmm0
  01e2c	66 0f 6f 84 24
	d0 14 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$315[rsp]
  01e35	66 0f fe 84 24
	30 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$65[rsp]
  01e3e	66 0f 7f 84 24
	e0 14 00 00	 movdqa	 XMMWORD PTR $T316[rsp], xmm0
  01e47	66 0f 6f 84 24
	e0 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T316[rsp]
  01e50	66 0f 7f 84 24
	00 06 00 00	 movdqa	 XMMWORD PTR x5_l$78[rsp], xmm0
  01e59	66 0f 6f 84 24
	f0 14 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$317[rsp]
  01e62	66 0f fe 84 24
	40 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$66[rsp]
  01e6b	66 0f 7f 84 24
	00 15 00 00	 movdqa	 XMMWORD PTR $T318[rsp], xmm0
  01e74	66 0f 6f 84 24
	00 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T318[rsp]
  01e7d	66 0f 7f 84 24
	20 06 00 00	 movdqa	 XMMWORD PTR x5_h$80[rsp], xmm0
  01e86	66 0f 6f 84 24
	10 15 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$319[rsp]
  01e8f	66 0f fe 84 24
	30 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$65[rsp]
  01e98	66 0f 7f 84 24
	20 15 00 00	 movdqa	 XMMWORD PTR $T320[rsp], xmm0
  01ea1	66 0f 6f 84 24
	20 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T320[rsp]
  01eaa	66 0f 7f 84 24
	c0 05 00 00	 movdqa	 XMMWORD PTR x6_l$74[rsp], xmm0
  01eb3	66 0f 6f 84 24
	30 15 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$321[rsp]
  01ebc	66 0f fe 84 24
	40 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$66[rsp]
  01ec5	66 0f 7f 84 24
	40 15 00 00	 movdqa	 XMMWORD PTR $T322[rsp], xmm0
  01ece	66 0f 6f 84 24
	40 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T322[rsp]
  01ed7	66 0f 7f 84 24
	e0 05 00 00	 movdqa	 XMMWORD PTR x6_h$76[rsp], xmm0
  01ee0	66 0f 6f 84 24
	50 15 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$323[rsp]
  01ee9	66 0f fe 84 24
	50 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$67[rsp]
  01ef2	66 0f 7f 84 24
	60 15 00 00	 movdqa	 XMMWORD PTR $T324[rsp], xmm0
  01efb	66 0f 6f 84 24
	60 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T324[rsp]
  01f04	66 0f 7f 84 24
	80 05 00 00	 movdqa	 XMMWORD PTR x7_l$70[rsp], xmm0
  01f0d	66 0f 6f 84 24
	70 15 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$325[rsp]
  01f16	66 0f fe 84 24
	60 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$68[rsp]
  01f1f	66 0f 7f 84 24
	80 15 00 00	 movdqa	 XMMWORD PTR $T326[rsp], xmm0
  01f28	66 0f 6f 84 24
	80 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T326[rsp]
  01f31	66 0f 7f 84 24
	a0 05 00 00	 movdqa	 XMMWORD PTR x7_h$72[rsp], xmm0
  01f3a	66 0f 6f 84 24
	90 15 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$327[rsp]
  01f43	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  01f4c	66 0f 7f 84 24
	a0 15 00 00	 movdqa	 XMMWORD PTR $T328[rsp], xmm0
  01f55	66 0f 6f 84 24
	a0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T328[rsp]
  01f5e	66 0f 7f 84 24
	70 05 00 00	 movdqa	 XMMWORD PTR abiased_l$69[rsp], xmm0
  01f67	66 0f 6f 84 24
	b0 15 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$329[rsp]
  01f70	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  01f79	66 0f 7f 84 24
	c0 15 00 00	 movdqa	 XMMWORD PTR $T330[rsp], xmm0
  01f82	66 0f 6f 84 24
	c0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T330[rsp]
  01f8b	66 0f 7f 84 24
	90 05 00 00	 movdqa	 XMMWORD PTR abiased_h$71[rsp], xmm0
  01f94	66 0f 6f 84 24
	70 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$69[rsp]
  01f9d	66 0f fe 84 24
	80 05 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$70[rsp]
  01fa6	66 0f 7f 84 24
	d0 15 00 00	 movdqa	 XMMWORD PTR $T331[rsp], xmm0
  01faf	66 0f 6f 84 24
	d0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T331[rsp]
  01fb8	66 0f 7f 84 24
	20 16 00 00	 movdqa	 XMMWORD PTR sum_l$336[rsp], xmm0
  01fc1	66 0f 6f 84 24
	90 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$71[rsp]
  01fca	66 0f fe 84 24
	a0 05 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$72[rsp]
  01fd3	66 0f 7f 84 24
	e0 15 00 00	 movdqa	 XMMWORD PTR $T332[rsp], xmm0
  01fdc	66 0f 6f 84 24
	e0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T332[rsp]
  01fe5	66 0f 7f 84 24
	10 16 00 00	 movdqa	 XMMWORD PTR sum_h$335[rsp], xmm0
  01fee	66 0f 6f 84 24
	70 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$69[rsp]
  01ff7	66 0f fa 84 24
	80 05 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$70[rsp]
  02000	66 0f 7f 84 24
	f0 15 00 00	 movdqa	 XMMWORD PTR $T333[rsp], xmm0
  02009	66 0f 6f 84 24
	f0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T333[rsp]
  02012	66 0f 7f 84 24
	70 16 00 00	 movdqa	 XMMWORD PTR dif_l$341[rsp], xmm0
  0201b	66 0f 6f 84 24
	90 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$71[rsp]
  02024	66 0f fa 84 24
	a0 05 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$72[rsp]
  0202d	66 0f 7f 84 24
	00 16 00 00	 movdqa	 XMMWORD PTR $T334[rsp], xmm0
  02036	66 0f 6f 84 24
	00 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T334[rsp]
  0203f	66 0f 7f 84 24
	60 16 00 00	 movdqa	 XMMWORD PTR dif_h$340[rsp], xmm0
  02048	66 0f 6f 84 24
	10 16 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$335[rsp]
  02051	66 0f 72 e0 11	 psrad	 xmm0, 17
  02056	66 0f 7f 84 24
	40 16 00 00	 movdqa	 XMMWORD PTR $T338[rsp], xmm0
  0205f	66 0f 6f 84 24
	20 16 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$336[rsp]
  02068	66 0f 72 e0 11	 psrad	 xmm0, 17
  0206d	66 0f 7f 84 24
	30 16 00 00	 movdqa	 XMMWORD PTR $T337[rsp], xmm0
  02076	66 0f 6f 84 24
	30 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T337[rsp]
  0207f	66 0f 6b 84 24
	40 16 00 00	 packssdw xmm0, XMMWORD PTR $T338[rsp]
  02088	66 0f 7f 84 24
	50 16 00 00	 movdqa	 XMMWORD PTR $T339[rsp], xmm0
  02091	66 0f 6f 84 24
	50 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T339[rsp]
  0209a	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  020a0	66 0f 6f 84 24
	60 16 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$340[rsp]
  020a9	66 0f 72 e0 11	 psrad	 xmm0, 17
  020ae	66 0f 7f 84 24
	90 16 00 00	 movdqa	 XMMWORD PTR $T343[rsp], xmm0
  020b7	66 0f 6f 84 24
	70 16 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$341[rsp]
  020c0	66 0f 72 e0 11	 psrad	 xmm0, 17
  020c5	66 0f 7f 84 24
	80 16 00 00	 movdqa	 XMMWORD PTR $T342[rsp], xmm0
  020ce	66 0f 6f 84 24
	80 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T342[rsp]
  020d7	66 0f 6b 84 24
	90 16 00 00	 packssdw xmm0, XMMWORD PTR $T343[rsp]
  020e0	66 0f 7f 84 24
	a0 16 00 00	 movdqa	 XMMWORD PTR $T344[rsp], xmm0
  020e9	66 0f 6f 84 24
	a0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T344[rsp]
  020f2	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0
  020f8	66 0f 6f 84 24
	b0 16 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$345[rsp]
  02101	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  0210a	66 0f 7f 84 24
	c0 16 00 00	 movdqa	 XMMWORD PTR $T346[rsp], xmm0
  02113	66 0f 6f 84 24
	c0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T346[rsp]
  0211c	66 0f 7f 84 24
	b0 05 00 00	 movdqa	 XMMWORD PTR abiased_l$73[rsp], xmm0
  02125	66 0f 6f 84 24
	d0 16 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$347[rsp]
  0212e	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  02137	66 0f 7f 84 24
	e0 16 00 00	 movdqa	 XMMWORD PTR $T348[rsp], xmm0
  02140	66 0f 6f 84 24
	e0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T348[rsp]
  02149	66 0f 7f 84 24
	d0 05 00 00	 movdqa	 XMMWORD PTR abiased_h$75[rsp], xmm0
  02152	66 0f 6f 84 24
	b0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$73[rsp]
  0215b	66 0f fe 84 24
	c0 05 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$74[rsp]
  02164	66 0f 7f 84 24
	f0 16 00 00	 movdqa	 XMMWORD PTR $T349[rsp], xmm0
  0216d	66 0f 6f 84 24
	f0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T349[rsp]
  02176	66 0f 7f 84 24
	40 17 00 00	 movdqa	 XMMWORD PTR sum_l$354[rsp], xmm0
  0217f	66 0f 6f 84 24
	d0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$75[rsp]
  02188	66 0f fe 84 24
	e0 05 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$76[rsp]
  02191	66 0f 7f 84 24
	00 17 00 00	 movdqa	 XMMWORD PTR $T350[rsp], xmm0
  0219a	66 0f 6f 84 24
	00 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T350[rsp]
  021a3	66 0f 7f 84 24
	30 17 00 00	 movdqa	 XMMWORD PTR sum_h$353[rsp], xmm0
  021ac	66 0f 6f 84 24
	b0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$73[rsp]
  021b5	66 0f fa 84 24
	c0 05 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$74[rsp]
  021be	66 0f 7f 84 24
	10 17 00 00	 movdqa	 XMMWORD PTR $T351[rsp], xmm0
  021c7	66 0f 6f 84 24
	10 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T351[rsp]
  021d0	66 0f 7f 84 24
	90 17 00 00	 movdqa	 XMMWORD PTR dif_l$359[rsp], xmm0
  021d9	66 0f 6f 84 24
	d0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$75[rsp]
  021e2	66 0f fa 84 24
	e0 05 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$76[rsp]
  021eb	66 0f 7f 84 24
	20 17 00 00	 movdqa	 XMMWORD PTR $T352[rsp], xmm0
  021f4	66 0f 6f 84 24
	20 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T352[rsp]
  021fd	66 0f 7f 84 24
	80 17 00 00	 movdqa	 XMMWORD PTR dif_h$358[rsp], xmm0
  02206	66 0f 6f 84 24
	30 17 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$353[rsp]
  0220f	66 0f 72 e0 11	 psrad	 xmm0, 17
  02214	66 0f 7f 84 24
	60 17 00 00	 movdqa	 XMMWORD PTR $T356[rsp], xmm0
  0221d	66 0f 6f 84 24
	40 17 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$354[rsp]
  02226	66 0f 72 e0 11	 psrad	 xmm0, 17
  0222b	66 0f 7f 84 24
	50 17 00 00	 movdqa	 XMMWORD PTR $T355[rsp], xmm0
  02234	66 0f 6f 84 24
	50 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T355[rsp]
  0223d	66 0f 6b 84 24
	60 17 00 00	 packssdw xmm0, XMMWORD PTR $T356[rsp]
  02246	66 0f 7f 84 24
	70 17 00 00	 movdqa	 XMMWORD PTR $T357[rsp], xmm0
  0224f	66 0f 6f 84 24
	70 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T357[rsp]
  02258	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  0225e	66 0f 6f 84 24
	80 17 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$358[rsp]
  02267	66 0f 72 e0 11	 psrad	 xmm0, 17
  0226c	66 0f 7f 84 24
	b0 17 00 00	 movdqa	 XMMWORD PTR $T361[rsp], xmm0
  02275	66 0f 6f 84 24
	90 17 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$359[rsp]
  0227e	66 0f 72 e0 11	 psrad	 xmm0, 17
  02283	66 0f 7f 84 24
	a0 17 00 00	 movdqa	 XMMWORD PTR $T360[rsp], xmm0
  0228c	66 0f 6f 84 24
	a0 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T360[rsp]
  02295	66 0f 6b 84 24
	b0 17 00 00	 packssdw xmm0, XMMWORD PTR $T361[rsp]
  0229e	66 0f 7f 84 24
	c0 17 00 00	 movdqa	 XMMWORD PTR $T362[rsp], xmm0
  022a7	66 0f 6f 84 24
	c0 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T362[rsp]
  022b0	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  022b9	66 0f 6f 84 24
	d0 17 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$363[rsp]
  022c2	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  022cb	66 0f 7f 84 24
	e0 17 00 00	 movdqa	 XMMWORD PTR $T364[rsp], xmm0
  022d4	66 0f 6f 84 24
	e0 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T364[rsp]
  022dd	66 0f 7f 84 24
	f0 05 00 00	 movdqa	 XMMWORD PTR abiased_l$77[rsp], xmm0
  022e6	66 0f 6f 84 24
	f0 17 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$365[rsp]
  022ef	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  022f8	66 0f 7f 84 24
	00 18 00 00	 movdqa	 XMMWORD PTR $T366[rsp], xmm0
  02301	66 0f 6f 84 24
	00 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T366[rsp]
  0230a	66 0f 7f 84 24
	10 06 00 00	 movdqa	 XMMWORD PTR abiased_h$79[rsp], xmm0
  02313	66 0f 6f 84 24
	f0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$77[rsp]
  0231c	66 0f fe 84 24
	00 06 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$78[rsp]
  02325	66 0f 7f 84 24
	10 18 00 00	 movdqa	 XMMWORD PTR $T367[rsp], xmm0
  0232e	66 0f 6f 84 24
	10 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T367[rsp]
  02337	66 0f 7f 84 24
	60 18 00 00	 movdqa	 XMMWORD PTR sum_l$372[rsp], xmm0
  02340	66 0f 6f 84 24
	10 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$79[rsp]
  02349	66 0f fe 84 24
	20 06 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$80[rsp]
  02352	66 0f 7f 84 24
	20 18 00 00	 movdqa	 XMMWORD PTR $T368[rsp], xmm0
  0235b	66 0f 6f 84 24
	20 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T368[rsp]
  02364	66 0f 7f 84 24
	50 18 00 00	 movdqa	 XMMWORD PTR sum_h$371[rsp], xmm0
  0236d	66 0f 6f 84 24
	f0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$77[rsp]
  02376	66 0f fa 84 24
	00 06 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$78[rsp]
  0237f	66 0f 7f 84 24
	30 18 00 00	 movdqa	 XMMWORD PTR $T369[rsp], xmm0
  02388	66 0f 6f 84 24
	30 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T369[rsp]
  02391	66 0f 7f 84 24
	b0 18 00 00	 movdqa	 XMMWORD PTR dif_l$377[rsp], xmm0
  0239a	66 0f 6f 84 24
	10 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$79[rsp]
  023a3	66 0f fa 84 24
	20 06 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$80[rsp]
  023ac	66 0f 7f 84 24
	40 18 00 00	 movdqa	 XMMWORD PTR $T370[rsp], xmm0
  023b5	66 0f 6f 84 24
	40 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T370[rsp]
  023be	66 0f 7f 84 24
	a0 18 00 00	 movdqa	 XMMWORD PTR dif_h$376[rsp], xmm0
  023c7	66 0f 6f 84 24
	50 18 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$371[rsp]
  023d0	66 0f 72 e0 11	 psrad	 xmm0, 17
  023d5	66 0f 7f 84 24
	80 18 00 00	 movdqa	 XMMWORD PTR $T374[rsp], xmm0
  023de	66 0f 6f 84 24
	60 18 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$372[rsp]
  023e7	66 0f 72 e0 11	 psrad	 xmm0, 17
  023ec	66 0f 7f 84 24
	70 18 00 00	 movdqa	 XMMWORD PTR $T373[rsp], xmm0
  023f5	66 0f 6f 84 24
	70 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T373[rsp]
  023fe	66 0f 6b 84 24
	80 18 00 00	 packssdw xmm0, XMMWORD PTR $T374[rsp]
  02407	66 0f 7f 84 24
	90 18 00 00	 movdqa	 XMMWORD PTR $T375[rsp], xmm0
  02410	66 0f 6f 84 24
	90 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T375[rsp]
  02419	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  0241f	66 0f 6f 84 24
	a0 18 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$376[rsp]
  02428	66 0f 72 e0 11	 psrad	 xmm0, 17
  0242d	66 0f 7f 84 24
	d0 18 00 00	 movdqa	 XMMWORD PTR $T379[rsp], xmm0
  02436	66 0f 6f 84 24
	b0 18 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$377[rsp]
  0243f	66 0f 72 e0 11	 psrad	 xmm0, 17
  02444	66 0f 7f 84 24
	c0 18 00 00	 movdqa	 XMMWORD PTR $T378[rsp], xmm0
  0244d	66 0f 6f 84 24
	c0 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T378[rsp]
  02456	66 0f 6b 84 24
	d0 18 00 00	 packssdw xmm0, XMMWORD PTR $T379[rsp]
  0245f	66 0f 7f 84 24
	e0 18 00 00	 movdqa	 XMMWORD PTR $T380[rsp], xmm0
  02468	66 0f 6f 84 24
	e0 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T380[rsp]
  02471	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  02477	66 0f 6f 84 24
	f0 18 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$381[rsp]
  02480	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  02489	66 0f 7f 84 24
	00 19 00 00	 movdqa	 XMMWORD PTR $T382[rsp], xmm0
  02492	66 0f 6f 84 24
	00 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T382[rsp]
  0249b	66 0f 7f 84 24
	30 06 00 00	 movdqa	 XMMWORD PTR abiased_l$81[rsp], xmm0
  024a4	66 0f 6f 84 24
	10 19 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$383[rsp]
  024ad	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  024b6	66 0f 7f 84 24
	20 19 00 00	 movdqa	 XMMWORD PTR $T384[rsp], xmm0
  024bf	66 0f 6f 84 24
	20 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T384[rsp]
  024c8	66 0f 7f 84 24
	50 06 00 00	 movdqa	 XMMWORD PTR abiased_h$83[rsp], xmm0
  024d1	66 0f 6f 84 24
	30 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$81[rsp]
  024da	66 0f fe 84 24
	40 06 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$82[rsp]
  024e3	66 0f 7f 84 24
	30 19 00 00	 movdqa	 XMMWORD PTR $T385[rsp], xmm0
  024ec	66 0f 6f 84 24
	30 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T385[rsp]
  024f5	66 0f 7f 84 24
	80 19 00 00	 movdqa	 XMMWORD PTR sum_l$390[rsp], xmm0
  024fe	66 0f 6f 84 24
	50 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$83[rsp]
  02507	66 0f fe 84 24
	60 06 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$84[rsp]
  02510	66 0f 7f 84 24
	40 19 00 00	 movdqa	 XMMWORD PTR $T386[rsp], xmm0
  02519	66 0f 6f 84 24
	40 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T386[rsp]
  02522	66 0f 7f 84 24
	70 19 00 00	 movdqa	 XMMWORD PTR sum_h$389[rsp], xmm0
  0252b	66 0f 6f 84 24
	30 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$81[rsp]
  02534	66 0f fa 84 24
	40 06 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$82[rsp]
  0253d	66 0f 7f 84 24
	50 19 00 00	 movdqa	 XMMWORD PTR $T387[rsp], xmm0
  02546	66 0f 6f 84 24
	50 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T387[rsp]
  0254f	66 0f 7f 84 24
	d0 19 00 00	 movdqa	 XMMWORD PTR dif_l$395[rsp], xmm0
  02558	66 0f 6f 84 24
	50 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$83[rsp]
  02561	66 0f fa 84 24
	60 06 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$84[rsp]
  0256a	66 0f 7f 84 24
	60 19 00 00	 movdqa	 XMMWORD PTR $T388[rsp], xmm0
  02573	66 0f 6f 84 24
	60 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T388[rsp]
  0257c	66 0f 7f 84 24
	c0 19 00 00	 movdqa	 XMMWORD PTR dif_h$394[rsp], xmm0
  02585	66 0f 6f 84 24
	70 19 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$389[rsp]
  0258e	66 0f 72 e0 11	 psrad	 xmm0, 17
  02593	66 0f 7f 84 24
	a0 19 00 00	 movdqa	 XMMWORD PTR $T392[rsp], xmm0
  0259c	66 0f 6f 84 24
	80 19 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$390[rsp]
  025a5	66 0f 72 e0 11	 psrad	 xmm0, 17
  025aa	66 0f 7f 84 24
	90 19 00 00	 movdqa	 XMMWORD PTR $T391[rsp], xmm0
  025b3	66 0f 6f 84 24
	90 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T391[rsp]
  025bc	66 0f 6b 84 24
	a0 19 00 00	 packssdw xmm0, XMMWORD PTR $T392[rsp]
  025c5	66 0f 7f 84 24
	b0 19 00 00	 movdqa	 XMMWORD PTR $T393[rsp], xmm0
  025ce	66 0f 6f 84 24
	b0 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T393[rsp]
  025d7	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  025dd	66 0f 6f 84 24
	c0 19 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$394[rsp]
  025e6	66 0f 72 e0 11	 psrad	 xmm0, 17
  025eb	66 0f 7f 84 24
	f0 19 00 00	 movdqa	 XMMWORD PTR $T397[rsp], xmm0
  025f4	66 0f 6f 84 24
	d0 19 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$395[rsp]
  025fd	66 0f 72 e0 11	 psrad	 xmm0, 17
  02602	66 0f 7f 84 24
	e0 19 00 00	 movdqa	 XMMWORD PTR $T396[rsp], xmm0
  0260b	66 0f 6f 84 24
	e0 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T396[rsp]
  02614	66 0f 6b 84 24
	f0 19 00 00	 packssdw xmm0, XMMWORD PTR $T397[rsp]
  0261d	66 0f 7f 84 24
	00 1a 00 00	 movdqa	 XMMWORD PTR $T398[rsp], xmm0
  02626	66 0f 6f 84 24
	00 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T398[rsp]
  0262f	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2629 :     
; 2630 :     {
; 2631 :         // pack
; 2632 :         __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

  02635	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  0263b	66 0f 67 44 24
	10		 packuswb xmm0, XMMWORD PTR row1$[rsp]
  02641	66 0f 7f 84 24
	10 1a 00 00	 movdqa	 XMMWORD PTR $T399[rsp], xmm0
  0264a	66 0f 6f 84 24
	10 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T399[rsp]
  02653	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0

; 2633 :         __m128i p1 = _mm_packus_epi16(row2, row3);

  0265c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  02662	66 0f 67 44 24
	20		 packuswb xmm0, XMMWORD PTR row3$[rsp]
  02668	66 0f 7f 84 24
	20 1a 00 00	 movdqa	 XMMWORD PTR $T400[rsp], xmm0
  02671	66 0f 6f 84 24
	20 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T400[rsp]
  0267a	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0

; 2634 :         __m128i p2 = _mm_packus_epi16(row4, row5);

  02683	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  02689	66 0f 67 44 24
	30		 packuswb xmm0, XMMWORD PTR row5$[rsp]
  0268f	66 0f 7f 84 24
	30 1a 00 00	 movdqa	 XMMWORD PTR $T401[rsp], xmm0
  02698	66 0f 6f 84 24
	30 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T401[rsp]
  026a1	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0

; 2635 :         __m128i p3 = _mm_packus_epi16(row6, row7);

  026aa	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  026b3	66 0f 67 44 24
	40		 packuswb xmm0, XMMWORD PTR row7$[rsp]
  026b9	66 0f 7f 84 24
	40 1a 00 00	 movdqa	 XMMWORD PTR $T402[rsp], xmm0
  026c2	66 0f 6f 84 24
	40 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T402[rsp]
  026cb	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2636 :         
; 2637 :         // 8bit 8x8 transpose pass 1
; 2638 :         dct_interleave8(p0, p2); // a0e0a1e1...

  026d4	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  026dd	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  026e2	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  026eb	66 0f 60 84 24
	a0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p2$2[rsp]
  026f4	66 0f 7f 84 24
	50 1a 00 00	 movdqa	 XMMWORD PTR $T403[rsp], xmm0
  026fd	66 0f 6f 84 24
	50 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T403[rsp]
  02706	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0
  0270f	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02714	66 0f 68 84 24
	a0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p2$2[rsp]
  0271d	66 0f 7f 84 24
	60 1a 00 00	 movdqa	 XMMWORD PTR $T404[rsp], xmm0
  02726	66 0f 6f 84 24
	60 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T404[rsp]
  0272f	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0

; 2639 :         dct_interleave8(p1, p3); // c0g0c1g1...

  02738	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  02741	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  02746	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  0274f	66 0f 60 84 24
	c0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p3$4[rsp]
  02758	66 0f 7f 84 24
	70 1a 00 00	 movdqa	 XMMWORD PTR $T405[rsp], xmm0
  02761	66 0f 6f 84 24
	70 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T405[rsp]
  0276a	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0
  02773	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02778	66 0f 68 84 24
	c0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p3$4[rsp]
  02781	66 0f 7f 84 24
	80 1a 00 00	 movdqa	 XMMWORD PTR $T406[rsp], xmm0
  0278a	66 0f 6f 84 24
	80 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T406[rsp]
  02793	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2640 :         
; 2641 :         // transpose pass 2
; 2642 :         dct_interleave8(p0, p1); // a0c0e0g0...

  0279c	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  027a5	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  027aa	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  027b3	66 0f 60 84 24
	b0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p1$3[rsp]
  027bc	66 0f 7f 84 24
	90 1a 00 00	 movdqa	 XMMWORD PTR $T407[rsp], xmm0
  027c5	66 0f 6f 84 24
	90 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T407[rsp]
  027ce	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0
  027d7	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  027dc	66 0f 68 84 24
	b0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p1$3[rsp]
  027e5	66 0f 7f 84 24
	a0 1a 00 00	 movdqa	 XMMWORD PTR $T408[rsp], xmm0
  027ee	66 0f 6f 84 24
	a0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T408[rsp]
  027f7	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0

; 2643 :         dct_interleave8(p2, p3); // b0d0f0h0...

  02800	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  02809	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0280e	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  02817	66 0f 60 84 24
	c0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p3$4[rsp]
  02820	66 0f 7f 84 24
	b0 1a 00 00	 movdqa	 XMMWORD PTR $T409[rsp], xmm0
  02829	66 0f 6f 84 24
	b0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T409[rsp]
  02832	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0
  0283b	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02840	66 0f 68 84 24
	c0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p3$4[rsp]
  02849	66 0f 7f 84 24
	c0 1a 00 00	 movdqa	 XMMWORD PTR $T410[rsp], xmm0
  02852	66 0f 6f 84 24
	c0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T410[rsp]
  0285b	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2644 :         
; 2645 :         // transpose pass 3
; 2646 :         dct_interleave8(p0, p2); // a0b0c0d0...

  02864	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  0286d	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  02872	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  0287b	66 0f 60 84 24
	a0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p2$2[rsp]
  02884	66 0f 7f 84 24
	d0 1a 00 00	 movdqa	 XMMWORD PTR $T411[rsp], xmm0
  0288d	66 0f 6f 84 24
	d0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T411[rsp]
  02896	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0
  0289f	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  028a4	66 0f 68 84 24
	a0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p2$2[rsp]
  028ad	66 0f 7f 84 24
	e0 1a 00 00	 movdqa	 XMMWORD PTR $T412[rsp], xmm0
  028b6	66 0f 6f 84 24
	e0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T412[rsp]
  028bf	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0

; 2647 :         dct_interleave8(p1, p3); // a4b4c4d4...

  028c8	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  028d1	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  028d6	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  028df	66 0f 60 84 24
	c0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p3$4[rsp]
  028e8	66 0f 7f 84 24
	f0 1a 00 00	 movdqa	 XMMWORD PTR $T413[rsp], xmm0
  028f1	66 0f 6f 84 24
	f0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T413[rsp]
  028fa	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0
  02903	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02908	66 0f 68 84 24
	c0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p3$4[rsp]
  02911	66 0f 7f 84 24
	00 1b 00 00	 movdqa	 XMMWORD PTR $T414[rsp], xmm0
  0291a	66 0f 6f 84 24
	00 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T414[rsp]
  02923	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2648 :         
; 2649 :         // store
; 2650 :         _mm_storel_epi64((__m128i *) out, p0); out += out_stride;

  0292c	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02934	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  0293d	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02941	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02949	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02951	48 03 c8	 add	 rcx, rax
  02954	48 8b c1	 mov	 rax, rcx
  02957	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2651 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

  0295f	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  02968	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  0296d	66 0f 7f 84 24
	10 1b 00 00	 movdqa	 XMMWORD PTR $T415[rsp], xmm0
  02976	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0297e	66 0f 6f 84 24
	10 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T415[rsp]
  02987	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  0298b	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02993	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0299b	48 03 c8	 add	 rcx, rax
  0299e	48 8b c1	 mov	 rax, rcx
  029a1	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2652 :         _mm_storel_epi64((__m128i *) out, p2); out += out_stride;

  029a9	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  029b1	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  029ba	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  029be	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  029c6	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  029ce	48 03 c8	 add	 rcx, rax
  029d1	48 8b c1	 mov	 rax, rcx
  029d4	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2653 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

  029dc	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  029e5	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  029ea	66 0f 7f 84 24
	20 1b 00 00	 movdqa	 XMMWORD PTR $T416[rsp], xmm0
  029f3	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  029fb	66 0f 6f 84 24
	20 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T416[rsp]
  02a04	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02a08	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02a10	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02a18	48 03 c8	 add	 rcx, rax
  02a1b	48 8b c1	 mov	 rax, rcx
  02a1e	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2654 :         _mm_storel_epi64((__m128i *) out, p1); out += out_stride;

  02a26	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02a2e	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  02a37	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02a3b	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02a43	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02a4b	48 03 c8	 add	 rcx, rax
  02a4e	48 8b c1	 mov	 rax, rcx
  02a51	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2655 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

  02a59	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  02a62	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  02a67	66 0f 7f 84 24
	30 1b 00 00	 movdqa	 XMMWORD PTR $T417[rsp], xmm0
  02a70	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02a78	66 0f 6f 84 24
	30 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T417[rsp]
  02a81	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02a85	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02a8d	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02a95	48 03 c8	 add	 rcx, rax
  02a98	48 8b c1	 mov	 rax, rcx
  02a9b	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2656 :         _mm_storel_epi64((__m128i *) out, p3); out += out_stride;

  02aa3	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02aab	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p3$4[rsp]
  02ab4	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02ab8	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02ac0	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02ac8	48 03 c8	 add	 rcx, rax
  02acb	48 8b c1	 mov	 rax, rcx
  02ace	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2657 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));

  02ad6	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p3$4[rsp]
  02adf	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  02ae4	66 0f 7f 84 24
	40 1b 00 00	 movdqa	 XMMWORD PTR $T418[rsp], xmm0
  02aed	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02af5	66 0f 6f 84 24
	40 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T418[rsp]
  02afe	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0

; 2658 :     }
; 2659 :     
; 2660 : #undef dct_const
; 2661 : #undef dct_rot
; 2662 : #undef dct_widen
; 2663 : #undef dct_wadd
; 2664 : #undef dct_wsub
; 2665 : #undef dct_bfly32o
; 2666 : #undef dct_interleave8
; 2667 : #undef dct_interleave16
; 2668 : #undef dct_pass
; 2669 : }

  02b02	48 81 c4 58 1b
	00 00		 add	 rsp, 7000		; 00001b58H
  02b09	c3		 ret	 0
?stbi__idct_simd@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_simd
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
v$ = 32
p3$1 = 40
t3$2 = 44
t2$3 = 48
t1$4 = 52
t0$5 = 56
p3$6 = 60
t3$7 = 64
t2$8 = 68
t1$9 = 72
t0$10 = 76
p2$11 = 80
p2$12 = 84
d$ = 88
dcterm$13 = 96
p1$14 = 100
i$ = 104
p1$15 = 108
p4$16 = 112
p4$17 = 116
o$ = 120
x0$18 = 128
x1$19 = 132
x2$20 = 136
x3$21 = 140
x0$22 = 144
x1$23 = 148
x2$24 = 152
x3$25 = 156
p5$26 = 160
p5$27 = 164
val$ = 176
__$ArrayPad$ = 432
out$ = 464
out_stride$ = 472
data$ = 480
?stbi__idct_block@@YAXPEAEHQEAF@Z PROC			; stbi__idct_block

; 2434 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2435 :     int i,val[64],*v=val;

  00027	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR val$[rsp]
  0002f	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2436 :     stbi_uc *o;
; 2437 :     short *d = data;

  00034	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0003c	48 89 44 24 58	 mov	 QWORD PTR d$[rsp], rax

; 2438 :     
; 2439 :     // columns
; 2440 :     for (i=0; i < 8; ++i,++d, ++v) {

  00041	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00049	eb 26		 jmp	 SHORT $LN4@stbi__idct
$LN2@stbi__idct:
  0004b	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0004f	ff c0		 inc	 eax
  00051	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00055	48 8b 44 24 58	 mov	 rax, QWORD PTR d$[rsp]
  0005a	48 83 c0 02	 add	 rax, 2
  0005e	48 89 44 24 58	 mov	 QWORD PTR d$[rsp], rax
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN4@stbi__idct:
  00071	83 7c 24 68 08	 cmp	 DWORD PTR i$[rsp], 8
  00076	0f 8d 7a 05 00
	00		 jge	 $LN3@stbi__idct

; 2441 :         // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2442 :         if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2443 :             && d[40]==0 && d[48]==0 && d[56]==0) {

  0007c	b8 02 00 00 00	 mov	 eax, 2
  00081	48 6b c0 08	 imul	 rax, rax, 8
  00085	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0008a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0008e	85 c0		 test	 eax, eax
  00090	0f 85 62 01 00
	00		 jne	 $LN8@stbi__idct
  00096	b8 02 00 00 00	 mov	 eax, 2
  0009b	48 6b c0 10	 imul	 rax, rax, 16
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000a4	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000a8	85 c0		 test	 eax, eax
  000aa	0f 85 48 01 00
	00		 jne	 $LN8@stbi__idct
  000b0	b8 02 00 00 00	 mov	 eax, 2
  000b5	48 6b c0 18	 imul	 rax, rax, 24
  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000be	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000c2	85 c0		 test	 eax, eax
  000c4	0f 85 2e 01 00
	00		 jne	 $LN8@stbi__idct
  000ca	b8 02 00 00 00	 mov	 eax, 2
  000cf	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  000d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000d8	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000dc	85 c0		 test	 eax, eax
  000de	0f 85 14 01 00
	00		 jne	 $LN8@stbi__idct
  000e4	b8 02 00 00 00	 mov	 eax, 2
  000e9	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000f2	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000f6	85 c0		 test	 eax, eax
  000f8	0f 85 fa 00 00
	00		 jne	 $LN8@stbi__idct
  000fe	b8 02 00 00 00	 mov	 eax, 2
  00103	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00107	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0010c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00110	85 c0		 test	 eax, eax
  00112	0f 85 e0 00 00
	00		 jne	 $LN8@stbi__idct
  00118	b8 02 00 00 00	 mov	 eax, 2
  0011d	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00126	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0012a	85 c0		 test	 eax, eax
  0012c	0f 85 c6 00 00
	00		 jne	 $LN8@stbi__idct

; 2444 :             //    no shortcut                 0     seconds
; 2445 :             //    (1|2|3|4|5|6|7)==0          0     seconds
; 2446 :             //    all separate               -0.047 seconds
; 2447 :             //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2448 :             int dcterm = d[0]*4;

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	48 6b c0 00	 imul	 rax, rax, 0
  0013b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00140	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00144	c1 e0 02	 shl	 eax, 2
  00147	89 44 24 60	 mov	 DWORD PTR dcterm$13[rsp], eax

; 2449 :             v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

  0014b	b8 04 00 00 00	 mov	 eax, 4
  00150	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00159	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  0015d	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00160	b8 04 00 00 00	 mov	 eax, 4
  00165	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00169	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0016e	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  00172	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00175	b8 04 00 00 00	 mov	 eax, 4
  0017a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0017e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00183	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  00187	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0018a	b8 04 00 00 00	 mov	 eax, 4
  0018f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00193	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00198	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  0019c	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0019f	b8 04 00 00 00	 mov	 eax, 4
  001a4	48 6b c0 18	 imul	 rax, rax, 24
  001a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001ad	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001b1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001b4	b8 04 00 00 00	 mov	 eax, 4
  001b9	48 6b c0 10	 imul	 rax, rax, 16
  001bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001c2	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001c6	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001c9	b8 04 00 00 00	 mov	 eax, 4
  001ce	48 6b c0 08	 imul	 rax, rax, 8
  001d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001d7	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001db	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001de	b8 04 00 00 00	 mov	 eax, 4
  001e3	48 6b c0 00	 imul	 rax, rax, 0
  001e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001ec	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001f0	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 2450 :         } else {

  001f3	e9 f9 03 00 00	 jmp	 $LN9@stbi__idct
$LN8@stbi__idct:

; 2451 :             STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

  001f8	b8 02 00 00 00	 mov	 eax, 2
  001fd	48 6b c0 10	 imul	 rax, rax, 16
  00201	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00206	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0020a	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  0020e	b8 02 00 00 00	 mov	 eax, 2
  00213	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00217	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0021c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00220	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  00224	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00228	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  0022c	03 c8		 add	 ecx, eax
  0022e	8b c1		 mov	 eax, ecx
  00230	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  00236	89 44 24 64	 mov	 DWORD PTR p1$14[rsp], eax
  0023a	69 44 24 28 71
	e2 ff ff	 imul	 eax, DWORD PTR p3$1[rsp], -7567 ; ffffffffffffe271H
  00242	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  00246	03 c8		 add	 ecx, eax
  00248	8b c1		 mov	 eax, ecx
  0024a	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  0024e	69 44 24 50 3f
	0c 00 00	 imul	 eax, DWORD PTR p2$11[rsp], 3135 ; 00000c3fH
  00256	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  0025a	03 c8		 add	 ecx, eax
  0025c	8b c1		 mov	 eax, ecx
  0025e	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  00262	b8 02 00 00 00	 mov	 eax, 2
  00267	48 6b c0 00	 imul	 rax, rax, 0
  0026b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00270	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00274	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  00278	b8 02 00 00 00	 mov	 eax, 2
  0027d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00286	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0028a	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  0028e	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00292	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  00296	03 c8		 add	 ecx, eax
  00298	8b c1		 mov	 eax, ecx
  0029a	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  002a0	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax
  002a4	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  002a8	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  002ac	2b c8		 sub	 ecx, eax
  002ae	8b c1		 mov	 eax, ecx
  002b0	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  002b6	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  002ba	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  002be	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  002c2	03 c8		 add	 ecx, eax
  002c4	8b c1		 mov	 eax, ecx
  002c6	89 84 24 80 00
	00 00		 mov	 DWORD PTR x0$18[rsp], eax
  002cd	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  002d1	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  002d5	2b c8		 sub	 ecx, eax
  002d7	8b c1		 mov	 eax, ecx
  002d9	89 84 24 8c 00
	00 00		 mov	 DWORD PTR x3$21[rsp], eax
  002e0	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  002e4	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  002e8	03 c8		 add	 ecx, eax
  002ea	8b c1		 mov	 eax, ecx
  002ec	89 84 24 84 00
	00 00		 mov	 DWORD PTR x1$19[rsp], eax
  002f3	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  002f7	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  002fb	2b c8		 sub	 ecx, eax
  002fd	8b c1		 mov	 eax, ecx
  002ff	89 84 24 88 00
	00 00		 mov	 DWORD PTR x2$20[rsp], eax
  00306	b8 02 00 00 00	 mov	 eax, 2
  0030b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0030f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00314	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00318	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax
  0031c	b8 02 00 00 00	 mov	 eax, 2
  00321	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00325	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0032a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0032e	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  00332	b8 02 00 00 00	 mov	 eax, 2
  00337	48 6b c0 18	 imul	 rax, rax, 24
  0033b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00340	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00344	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  00348	b8 02 00 00 00	 mov	 eax, 2
  0034d	48 6b c0 08	 imul	 rax, rax, 8
  00351	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00356	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0035a	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  0035e	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00362	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  00366	03 c8		 add	 ecx, eax
  00368	8b c1		 mov	 eax, ecx
  0036a	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  0036e	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  00372	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  00376	03 c8		 add	 ecx, eax
  00378	8b c1		 mov	 eax, ecx
  0037a	89 44 24 70	 mov	 DWORD PTR p4$16[rsp], eax
  0037e	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  00382	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  00386	03 c8		 add	 ecx, eax
  00388	8b c1		 mov	 eax, ecx
  0038a	89 44 24 64	 mov	 DWORD PTR p1$14[rsp], eax
  0038e	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00392	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  00396	03 c8		 add	 ecx, eax
  00398	8b c1		 mov	 eax, ecx
  0039a	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  0039e	8b 44 24 70	 mov	 eax, DWORD PTR p4$16[rsp]
  003a2	8b 4c 24 28	 mov	 ecx, DWORD PTR p3$1[rsp]
  003a6	03 c8		 add	 ecx, eax
  003a8	8b c1		 mov	 eax, ecx
  003aa	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  003b0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR p5$26[rsp], eax
  003b7	69 44 24 38 c7
	04 00 00	 imul	 eax, DWORD PTR t0$5[rsp], 1223 ; 000004c7H
  003bf	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax
  003c3	69 44 24 34 da
	20 00 00	 imul	 eax, DWORD PTR t1$4[rsp], 8410 ; 000020daH
  003cb	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  003cf	69 44 24 30 2a
	31 00 00	 imul	 eax, DWORD PTR t2$3[rsp], 12586 ; 0000312aH
  003d7	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  003db	69 44 24 2c 05
	18 00 00	 imul	 eax, DWORD PTR t3$2[rsp], 6149 ; 00001805H
  003e3	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  003e7	69 44 24 64 9b
	f1 ff ff	 imul	 eax, DWORD PTR p1$14[rsp], -3685 ; fffffffffffff19bH
  003ef	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p5$26[rsp]
  003f6	03 c8		 add	 ecx, eax
  003f8	8b c1		 mov	 eax, ecx
  003fa	89 44 24 64	 mov	 DWORD PTR p1$14[rsp], eax
  003fe	69 44 24 50 ff
	d6 ff ff	 imul	 eax, DWORD PTR p2$11[rsp], -10497 ; ffffffffffffd6ffH
  00406	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p5$26[rsp]
  0040d	03 c8		 add	 ecx, eax
  0040f	8b c1		 mov	 eax, ecx
  00411	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  00415	69 44 24 28 9e
	e0 ff ff	 imul	 eax, DWORD PTR p3$1[rsp], -8034 ; ffffffffffffe09eH
  0041d	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  00421	69 44 24 70 c3
	f9 ff ff	 imul	 eax, DWORD PTR p4$16[rsp], -1597 ; fffffffffffff9c3H
  00429	89 44 24 70	 mov	 DWORD PTR p4$16[rsp], eax
  0042d	8b 44 24 70	 mov	 eax, DWORD PTR p4$16[rsp]
  00431	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  00435	03 c8		 add	 ecx, eax
  00437	8b c1		 mov	 eax, ecx
  00439	8b 4c 24 2c	 mov	 ecx, DWORD PTR t3$2[rsp]
  0043d	03 c8		 add	 ecx, eax
  0043f	8b c1		 mov	 eax, ecx
  00441	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  00445	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00449	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  0044d	03 c8		 add	 ecx, eax
  0044f	8b c1		 mov	 eax, ecx
  00451	8b 4c 24 30	 mov	 ecx, DWORD PTR t2$3[rsp]
  00455	03 c8		 add	 ecx, eax
  00457	8b c1		 mov	 eax, ecx
  00459	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  0045d	8b 44 24 70	 mov	 eax, DWORD PTR p4$16[rsp]
  00461	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  00465	03 c8		 add	 ecx, eax
  00467	8b c1		 mov	 eax, ecx
  00469	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  0046d	03 c8		 add	 ecx, eax
  0046f	8b c1		 mov	 eax, ecx
  00471	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  00475	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00479	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  0047d	03 c8		 add	 ecx, eax
  0047f	8b c1		 mov	 eax, ecx
  00481	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  00485	03 c8		 add	 ecx, eax
  00487	8b c1		 mov	 eax, ecx
  00489	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax

; 2452 :                 // constants scaled things up by 1<<12; let's bring them back
; 2453 :                 // down, but keep 2 extra bits of precision
; 2454 :                 x0 += 512; x1 += 512; x2 += 512; x3 += 512;

  0048d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR x0$18[rsp]
  00494	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00499	89 84 24 80 00
	00 00		 mov	 DWORD PTR x0$18[rsp], eax
  004a0	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR x1$19[rsp]
  004a7	05 00 02 00 00	 add	 eax, 512		; 00000200H
  004ac	89 84 24 84 00
	00 00		 mov	 DWORD PTR x1$19[rsp], eax
  004b3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x2$20[rsp]
  004ba	05 00 02 00 00	 add	 eax, 512		; 00000200H
  004bf	89 84 24 88 00
	00 00		 mov	 DWORD PTR x2$20[rsp], eax
  004c6	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x3$21[rsp]
  004cd	05 00 02 00 00	 add	 eax, 512		; 00000200H
  004d2	89 84 24 8c 00
	00 00		 mov	 DWORD PTR x3$21[rsp], eax

; 2455 :             v[ 0] = (x0+t3) >> 10;

  004d9	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  004dd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x0$18[rsp]
  004e4	03 c8		 add	 ecx, eax
  004e6	8b c1		 mov	 eax, ecx
  004e8	c1 f8 0a	 sar	 eax, 10
  004eb	b9 04 00 00 00	 mov	 ecx, 4
  004f0	48 6b c9 00	 imul	 rcx, rcx, 0
  004f4	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  004f9	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2456 :             v[56] = (x0-t3) >> 10;

  004fc	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  00500	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x0$18[rsp]
  00507	2b c8		 sub	 ecx, eax
  00509	8b c1		 mov	 eax, ecx
  0050b	c1 f8 0a	 sar	 eax, 10
  0050e	b9 04 00 00 00	 mov	 ecx, 4
  00513	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  00517	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  0051c	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2457 :             v[ 8] = (x1+t2) >> 10;

  0051f	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00523	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR x1$19[rsp]
  0052a	03 c8		 add	 ecx, eax
  0052c	8b c1		 mov	 eax, ecx
  0052e	c1 f8 0a	 sar	 eax, 10
  00531	b9 04 00 00 00	 mov	 ecx, 4
  00536	48 6b c9 08	 imul	 rcx, rcx, 8
  0053a	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  0053f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2458 :             v[48] = (x1-t2) >> 10;

  00542	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00546	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR x1$19[rsp]
  0054d	2b c8		 sub	 ecx, eax
  0054f	8b c1		 mov	 eax, ecx
  00551	c1 f8 0a	 sar	 eax, 10
  00554	b9 04 00 00 00	 mov	 ecx, 4
  00559	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  0055d	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  00562	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2459 :             v[16] = (x2+t1) >> 10;

  00565	8b 44 24 34	 mov	 eax, DWORD PTR t1$4[rsp]
  00569	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR x2$20[rsp]
  00570	03 c8		 add	 ecx, eax
  00572	8b c1		 mov	 eax, ecx
  00574	c1 f8 0a	 sar	 eax, 10
  00577	b9 04 00 00 00	 mov	 ecx, 4
  0057c	48 6b c9 10	 imul	 rcx, rcx, 16
  00580	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  00585	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2460 :             v[40] = (x2-t1) >> 10;

  00588	8b 44 24 34	 mov	 eax, DWORD PTR t1$4[rsp]
  0058c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR x2$20[rsp]
  00593	2b c8		 sub	 ecx, eax
  00595	8b c1		 mov	 eax, ecx
  00597	c1 f8 0a	 sar	 eax, 10
  0059a	b9 04 00 00 00	 mov	 ecx, 4
  0059f	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  005a3	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  005a8	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2461 :             v[24] = (x3+t0) >> 10;

  005ab	8b 44 24 38	 mov	 eax, DWORD PTR t0$5[rsp]
  005af	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR x3$21[rsp]
  005b6	03 c8		 add	 ecx, eax
  005b8	8b c1		 mov	 eax, ecx
  005ba	c1 f8 0a	 sar	 eax, 10
  005bd	b9 04 00 00 00	 mov	 ecx, 4
  005c2	48 6b c9 18	 imul	 rcx, rcx, 24
  005c6	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  005cb	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2462 :             v[32] = (x3-t0) >> 10;

  005ce	8b 44 24 38	 mov	 eax, DWORD PTR t0$5[rsp]
  005d2	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR x3$21[rsp]
  005d9	2b c8		 sub	 ecx, eax
  005db	8b c1		 mov	 eax, ecx
  005dd	c1 f8 0a	 sar	 eax, 10
  005e0	b9 04 00 00 00	 mov	 ecx, 4
  005e5	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  005e9	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  005ee	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN9@stbi__idct:

; 2463 :         }
; 2464 :     }

  005f1	e9 55 fa ff ff	 jmp	 $LN2@stbi__idct
$LN3@stbi__idct:

; 2465 :     
; 2466 :     for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

  005f6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005fe	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR val$[rsp]
  00606	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
  0060b	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00613	48 89 44 24 78	 mov	 QWORD PTR o$[rsp], rax
  00618	eb 30		 jmp	 SHORT $LN7@stbi__idct
$LN5@stbi__idct:
  0061a	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0061e	ff c0		 inc	 eax
  00620	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00624	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00629	48 83 c0 20	 add	 rax, 32			; 00000020H
  0062d	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
  00632	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  0063a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR o$[rsp]
  0063f	48 03 c8	 add	 rcx, rax
  00642	48 8b c1	 mov	 rax, rcx
  00645	48 89 44 24 78	 mov	 QWORD PTR o$[rsp], rax
$LN7@stbi__idct:
  0064a	83 7c 24 68 08	 cmp	 DWORD PTR i$[rsp], 8
  0064f	0f 8d 2e 04 00
	00		 jge	 $LN6@stbi__idct

; 2467 :         // no fast case since the first 1D IDCT spread components out
; 2468 :         STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

  00655	b8 04 00 00 00	 mov	 eax, 4
  0065a	48 6b c0 02	 imul	 rax, rax, 2
  0065e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00663	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00666	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  0066a	b8 04 00 00 00	 mov	 eax, 4
  0066f	48 6b c0 06	 imul	 rax, rax, 6
  00673	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00678	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0067b	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  0067f	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  00683	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  00687	03 c8		 add	 ecx, eax
  00689	8b c1		 mov	 eax, ecx
  0068b	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  00691	89 44 24 6c	 mov	 DWORD PTR p1$15[rsp], eax
  00695	69 44 24 3c 71
	e2 ff ff	 imul	 eax, DWORD PTR p3$6[rsp], -7567 ; ffffffffffffe271H
  0069d	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  006a1	03 c8		 add	 ecx, eax
  006a3	8b c1		 mov	 eax, ecx
  006a5	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  006a9	69 44 24 54 3f
	0c 00 00	 imul	 eax, DWORD PTR p2$12[rsp], 3135 ; 00000c3fH
  006b1	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  006b5	03 c8		 add	 ecx, eax
  006b7	8b c1		 mov	 eax, ecx
  006b9	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  006bd	b8 04 00 00 00	 mov	 eax, 4
  006c2	48 6b c0 00	 imul	 rax, rax, 0
  006c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  006cb	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  006ce	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  006d2	b8 04 00 00 00	 mov	 eax, 4
  006d7	48 6b c0 04	 imul	 rax, rax, 4
  006db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  006e0	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  006e3	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  006e7	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  006eb	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  006ef	03 c8		 add	 ecx, eax
  006f1	8b c1		 mov	 eax, ecx
  006f3	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  006f9	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax
  006fd	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  00701	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  00705	2b c8		 sub	 ecx, eax
  00707	8b c1		 mov	 eax, ecx
  00709	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  0070f	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  00713	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  00717	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  0071b	03 c8		 add	 ecx, eax
  0071d	8b c1		 mov	 eax, ecx
  0071f	89 84 24 90 00
	00 00		 mov	 DWORD PTR x0$22[rsp], eax
  00726	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  0072a	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  0072e	2b c8		 sub	 ecx, eax
  00730	8b c1		 mov	 eax, ecx
  00732	89 84 24 9c 00
	00 00		 mov	 DWORD PTR x3$25[rsp], eax
  00739	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  0073d	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  00741	03 c8		 add	 ecx, eax
  00743	8b c1		 mov	 eax, ecx
  00745	89 84 24 94 00
	00 00		 mov	 DWORD PTR x1$23[rsp], eax
  0074c	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  00750	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  00754	2b c8		 sub	 ecx, eax
  00756	8b c1		 mov	 eax, ecx
  00758	89 84 24 98 00
	00 00		 mov	 DWORD PTR x2$24[rsp], eax
  0075f	b8 04 00 00 00	 mov	 eax, 4
  00764	48 6b c0 07	 imul	 rax, rax, 7
  00768	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0076d	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00770	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax
  00774	b8 04 00 00 00	 mov	 eax, 4
  00779	48 6b c0 05	 imul	 rax, rax, 5
  0077d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00782	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00785	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  00789	b8 04 00 00 00	 mov	 eax, 4
  0078e	48 6b c0 03	 imul	 rax, rax, 3
  00792	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00797	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0079a	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  0079e	b8 04 00 00 00	 mov	 eax, 4
  007a3	48 6b c0 01	 imul	 rax, rax, 1
  007a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  007ac	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  007af	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  007b3	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  007b7	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  007bb	03 c8		 add	 ecx, eax
  007bd	8b c1		 mov	 eax, ecx
  007bf	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  007c3	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  007c7	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  007cb	03 c8		 add	 ecx, eax
  007cd	8b c1		 mov	 eax, ecx
  007cf	89 44 24 74	 mov	 DWORD PTR p4$17[rsp], eax
  007d3	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  007d7	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  007db	03 c8		 add	 ecx, eax
  007dd	8b c1		 mov	 eax, ecx
  007df	89 44 24 6c	 mov	 DWORD PTR p1$15[rsp], eax
  007e3	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  007e7	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  007eb	03 c8		 add	 ecx, eax
  007ed	8b c1		 mov	 eax, ecx
  007ef	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  007f3	8b 44 24 74	 mov	 eax, DWORD PTR p4$17[rsp]
  007f7	8b 4c 24 3c	 mov	 ecx, DWORD PTR p3$6[rsp]
  007fb	03 c8		 add	 ecx, eax
  007fd	8b c1		 mov	 eax, ecx
  007ff	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  00805	89 84 24 a4 00
	00 00		 mov	 DWORD PTR p5$27[rsp], eax
  0080c	69 44 24 4c c7
	04 00 00	 imul	 eax, DWORD PTR t0$10[rsp], 1223 ; 000004c7H
  00814	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax
  00818	69 44 24 48 da
	20 00 00	 imul	 eax, DWORD PTR t1$9[rsp], 8410 ; 000020daH
  00820	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  00824	69 44 24 44 2a
	31 00 00	 imul	 eax, DWORD PTR t2$8[rsp], 12586 ; 0000312aH
  0082c	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  00830	69 44 24 40 05
	18 00 00	 imul	 eax, DWORD PTR t3$7[rsp], 6149 ; 00001805H
  00838	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  0083c	69 44 24 6c 9b
	f1 ff ff	 imul	 eax, DWORD PTR p1$15[rsp], -3685 ; fffffffffffff19bH
  00844	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR p5$27[rsp]
  0084b	03 c8		 add	 ecx, eax
  0084d	8b c1		 mov	 eax, ecx
  0084f	89 44 24 6c	 mov	 DWORD PTR p1$15[rsp], eax
  00853	69 44 24 54 ff
	d6 ff ff	 imul	 eax, DWORD PTR p2$12[rsp], -10497 ; ffffffffffffd6ffH
  0085b	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR p5$27[rsp]
  00862	03 c8		 add	 ecx, eax
  00864	8b c1		 mov	 eax, ecx
  00866	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  0086a	69 44 24 3c 9e
	e0 ff ff	 imul	 eax, DWORD PTR p3$6[rsp], -8034 ; ffffffffffffe09eH
  00872	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  00876	69 44 24 74 c3
	f9 ff ff	 imul	 eax, DWORD PTR p4$17[rsp], -1597 ; fffffffffffff9c3H
  0087e	89 44 24 74	 mov	 DWORD PTR p4$17[rsp], eax
  00882	8b 44 24 74	 mov	 eax, DWORD PTR p4$17[rsp]
  00886	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  0088a	03 c8		 add	 ecx, eax
  0088c	8b c1		 mov	 eax, ecx
  0088e	8b 4c 24 40	 mov	 ecx, DWORD PTR t3$7[rsp]
  00892	03 c8		 add	 ecx, eax
  00894	8b c1		 mov	 eax, ecx
  00896	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  0089a	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  0089e	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  008a2	03 c8		 add	 ecx, eax
  008a4	8b c1		 mov	 eax, ecx
  008a6	8b 4c 24 44	 mov	 ecx, DWORD PTR t2$8[rsp]
  008aa	03 c8		 add	 ecx, eax
  008ac	8b c1		 mov	 eax, ecx
  008ae	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  008b2	8b 44 24 74	 mov	 eax, DWORD PTR p4$17[rsp]
  008b6	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  008ba	03 c8		 add	 ecx, eax
  008bc	8b c1		 mov	 eax, ecx
  008be	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  008c2	03 c8		 add	 ecx, eax
  008c4	8b c1		 mov	 eax, ecx
  008c6	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  008ca	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  008ce	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  008d2	03 c8		 add	 ecx, eax
  008d4	8b c1		 mov	 eax, ecx
  008d6	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  008da	03 c8		 add	 ecx, eax
  008dc	8b c1		 mov	 eax, ecx
  008de	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax

; 2469 :             // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2470 :             // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2471 :             // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2472 :             // so we want to round that, which means adding 0.5 * 1<<17,
; 2473 :             // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2474 :             // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2475 :             x0 += 65536 + (128<<17);

  008e2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR x0$22[rsp]
  008e9	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  008ee	89 84 24 90 00
	00 00		 mov	 DWORD PTR x0$22[rsp], eax

; 2476 :         x1 += 65536 + (128<<17);

  008f5	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR x1$23[rsp]
  008fc	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00901	89 84 24 94 00
	00 00		 mov	 DWORD PTR x1$23[rsp], eax

; 2477 :         x2 += 65536 + (128<<17);

  00908	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x2$24[rsp]
  0090f	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00914	89 84 24 98 00
	00 00		 mov	 DWORD PTR x2$24[rsp], eax

; 2478 :         x3 += 65536 + (128<<17);

  0091b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR x3$25[rsp]
  00922	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00927	89 84 24 9c 00
	00 00		 mov	 DWORD PTR x3$25[rsp], eax

; 2479 :         // tried computing the shifts into temps, or'ing the temps to see
; 2480 :         // if any were out of range, but that was slower
; 2481 :         o[0] = stbi__clamp((x0+t3) >> 17);

  0092e	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  00932	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR x0$22[rsp]
  00939	03 c8		 add	 ecx, eax
  0093b	8b c1		 mov	 eax, ecx
  0093d	c1 f8 11	 sar	 eax, 17
  00940	8b c8		 mov	 ecx, eax
  00942	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00947	b9 01 00 00 00	 mov	 ecx, 1
  0094c	48 6b c9 00	 imul	 rcx, rcx, 0
  00950	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00955	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2482 :         o[7] = stbi__clamp((x0-t3) >> 17);

  00958	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  0095c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR x0$22[rsp]
  00963	2b c8		 sub	 ecx, eax
  00965	8b c1		 mov	 eax, ecx
  00967	c1 f8 11	 sar	 eax, 17
  0096a	8b c8		 mov	 ecx, eax
  0096c	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00971	b9 01 00 00 00	 mov	 ecx, 1
  00976	48 6b c9 07	 imul	 rcx, rcx, 7
  0097a	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  0097f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2483 :         o[1] = stbi__clamp((x1+t2) >> 17);

  00982	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  00986	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR x1$23[rsp]
  0098d	03 c8		 add	 ecx, eax
  0098f	8b c1		 mov	 eax, ecx
  00991	c1 f8 11	 sar	 eax, 17
  00994	8b c8		 mov	 ecx, eax
  00996	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  0099b	b9 01 00 00 00	 mov	 ecx, 1
  009a0	48 6b c9 01	 imul	 rcx, rcx, 1
  009a4	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  009a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2484 :         o[6] = stbi__clamp((x1-t2) >> 17);

  009ac	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  009b0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR x1$23[rsp]
  009b7	2b c8		 sub	 ecx, eax
  009b9	8b c1		 mov	 eax, ecx
  009bb	c1 f8 11	 sar	 eax, 17
  009be	8b c8		 mov	 ecx, eax
  009c0	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  009c5	b9 01 00 00 00	 mov	 ecx, 1
  009ca	48 6b c9 06	 imul	 rcx, rcx, 6
  009ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  009d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2485 :         o[2] = stbi__clamp((x2+t1) >> 17);

  009d6	8b 44 24 48	 mov	 eax, DWORD PTR t1$9[rsp]
  009da	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR x2$24[rsp]
  009e1	03 c8		 add	 ecx, eax
  009e3	8b c1		 mov	 eax, ecx
  009e5	c1 f8 11	 sar	 eax, 17
  009e8	8b c8		 mov	 ecx, eax
  009ea	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  009ef	b9 01 00 00 00	 mov	 ecx, 1
  009f4	48 6b c9 02	 imul	 rcx, rcx, 2
  009f8	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  009fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2486 :         o[5] = stbi__clamp((x2-t1) >> 17);

  00a00	8b 44 24 48	 mov	 eax, DWORD PTR t1$9[rsp]
  00a04	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR x2$24[rsp]
  00a0b	2b c8		 sub	 ecx, eax
  00a0d	8b c1		 mov	 eax, ecx
  00a0f	c1 f8 11	 sar	 eax, 17
  00a12	8b c8		 mov	 ecx, eax
  00a14	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00a19	b9 01 00 00 00	 mov	 ecx, 1
  00a1e	48 6b c9 05	 imul	 rcx, rcx, 5
  00a22	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00a27	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2487 :         o[3] = stbi__clamp((x3+t0) >> 17);

  00a2a	8b 44 24 4c	 mov	 eax, DWORD PTR t0$10[rsp]
  00a2e	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR x3$25[rsp]
  00a35	03 c8		 add	 ecx, eax
  00a37	8b c1		 mov	 eax, ecx
  00a39	c1 f8 11	 sar	 eax, 17
  00a3c	8b c8		 mov	 ecx, eax
  00a3e	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00a43	b9 01 00 00 00	 mov	 ecx, 1
  00a48	48 6b c9 03	 imul	 rcx, rcx, 3
  00a4c	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00a51	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2488 :         o[4] = stbi__clamp((x3-t0) >> 17);

  00a54	8b 44 24 4c	 mov	 eax, DWORD PTR t0$10[rsp]
  00a58	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR x3$25[rsp]
  00a5f	2b c8		 sub	 ecx, eax
  00a61	8b c1		 mov	 eax, ecx
  00a63	c1 f8 11	 sar	 eax, 17
  00a66	8b c8		 mov	 ecx, eax
  00a68	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00a6d	b9 01 00 00 00	 mov	 ecx, 1
  00a72	48 6b c9 04	 imul	 rcx, rcx, 4
  00a76	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00a7b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2489 :     }

  00a7e	e9 97 fb ff ff	 jmp	 $LN5@stbi__idct
$LN6@stbi__idct:

; 2490 : }

  00a83	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a8b	48 33 cc	 xor	 rcx, rsp
  00a8e	e8 00 00 00 00	 call	 __security_check_cookie
  00a93	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00a9a	c3		 ret	 0
?stbi__idct_block@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
x$ = 8
?stbi__clamp@@YAEH@Z PROC				; stbi__clamp

; 2383 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 2384 :     // trick to use a single test to catch both cases
; 2385 :     if ((unsigned int) x > 255) {

  00004	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  0000c	76 19		 jbe	 SHORT $LN2@stbi__clam

; 2386 :         if (x < 0) return 0;

  0000e	83 7c 24 08 00	 cmp	 DWORD PTR x$[rsp], 0
  00013	7d 04		 jge	 SHORT $LN3@stbi__clam
  00015	32 c0		 xor	 al, al
  00017	eb 13		 jmp	 SHORT $LN1@stbi__clam
$LN3@stbi__clam:

; 2387 :         if (x > 255) return 255;

  00019	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00021	7e 04		 jle	 SHORT $LN4@stbi__clam
  00023	b0 ff		 mov	 al, 255			; 000000ffH
  00025	eb 05		 jmp	 SHORT $LN1@stbi__clam
$LN4@stbi__clam:
$LN2@stbi__clam:

; 2388 :     }
; 2389 :     return (stbi_uc) x;

  00027	0f b6 44 24 08	 movzx	 eax, BYTE PTR x$[rsp]
$LN1@stbi__clam:

; 2390 : }

  0002c	c3		 ret	 0
?stbi__clamp@@YAEH@Z ENDP				; stbi__clamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
bit$1 = 36
r$2 = 40
r$3 = 44
s$4 = 48
s$5 = 52
p$6 = 56
rs$7 = 64
zig$8 = 68
rs$9 = 72
p$10 = 80
shift$11 = 88
c$12 = 92
tv362 = 96
tv384 = 100
tv411 = 104
tv345 = 112
j$ = 144
data$ = 152
hac$ = 160
fac$ = 168
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z PROC ; stbi__jpeg_decode_block_prog_ac

; 2263 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2264 :     int k;
; 2265 :     if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  0001b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00023	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  0002a	75 11		 jne	 SHORT $LN13@stbi__jpeg
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36341
  00033	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00038	e9 0d 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 2266 :     
; 2267 :     if (j->succ_high == 0) {

  0003d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00045	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  0004c	0f 85 ce 02 00
	00		 jne	 $LN14@stbi__jpeg

; 2268 :         int shift = j->succ_low;

  00052	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0005a	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00060	89 44 24 58	 mov	 DWORD PTR shift$11[rsp], eax

; 2269 :         
; 2270 :         if (j->eob_run) {

  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0006c	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  00073	74 28		 je	 SHORT $LN16@stbi__jpeg

; 2271 :             --j->eob_run;

  00075	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0007d	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00083	ff c8		 dec	 eax
  00085	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0008d	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2272 :             return 1;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	e9 ad 05 00 00	 jmp	 $LN1@stbi__jpeg
$LN16@stbi__jpeg:

; 2273 :         }
; 2274 :         
; 2275 :         k = j->spec_start;

  0009d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000a5	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  000ab	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 2276 :         do {
; 2277 :             unsigned int zig;
; 2278 :             int c,r,s;
; 2279 :             if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  000af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000b7	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  000be	7d 0d		 jge	 SHORT $LN17@stbi__jpeg
  000c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  000c8	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN17@stbi__jpeg:

; 2280 :             c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  000cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000d5	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000db	c1 e8 17	 shr	 eax, 23
  000de	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000e3	89 44 24 5c	 mov	 DWORD PTR c$12[rsp], eax

; 2281 :             r = fac[c];

  000e7	48 63 44 24 5c	 movsxd	 rax, DWORD PTR c$12[rsp]
  000ec	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fac$[rsp]
  000f4	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  000f8	89 44 24 28	 mov	 DWORD PTR r$2[rsp], eax

; 2282 :             if (r) { // fast-AC path

  000fc	83 7c 24 28 00	 cmp	 DWORD PTR r$2[rsp], 0
  00101	0f 84 bc 00 00
	00		 je	 $LN18@stbi__jpeg

; 2283 :                 k += (r >> 4) & 15; // run

  00107	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  0010b	c1 f8 04	 sar	 eax, 4
  0010e	83 e0 0f	 and	 eax, 15
  00111	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00115	03 c8		 add	 ecx, eax
  00117	8b c1		 mov	 eax, ecx
  00119	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2284 :                 s = r & 15; // combined length

  0011d	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  00121	83 e0 0f	 and	 eax, 15
  00124	89 44 24 30	 mov	 DWORD PTR s$4[rsp], eax

; 2285 :                 j->code_buffer <<= s;

  00128	8b 44 24 30	 mov	 eax, DWORD PTR s$4[rsp]
  0012c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00134	48 89 4c 24 70	 mov	 QWORD PTR tv345[rsp], rcx
  00139	0f b6 c8	 movzx	 ecx, al
  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR tv345[rsp]
  00141	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00147	d3 e0		 shl	 eax, cl
  00149	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00151	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2286 :                 j->code_bits -= s;

  00157	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0015f	8b 4c 24 30	 mov	 ecx, DWORD PTR s$4[rsp]
  00163	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00169	2b c1		 sub	 eax, ecx
  0016b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00173	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2287 :                 zig = stbi__jpeg_dezigzag[k++];

  00179	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  00185	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00189	89 44 24 44	 mov	 DWORD PTR zig$8[rsp], eax
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00191	ff c0		 inc	 eax
  00193	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2288 :                 data[zig] = (short) ((r >> 8) * (1 << shift));

  00197	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  0019b	c1 f8 08	 sar	 eax, 8
  0019e	8b 4c 24 58	 mov	 ecx, DWORD PTR shift$11[rsp]
  001a2	ba 01 00 00 00	 mov	 edx, 1
  001a7	d3 e2		 shl	 edx, cl
  001a9	8b ca		 mov	 ecx, edx
  001ab	0f af c1	 imul	 eax, ecx
  001ae	8b 4c 24 44	 mov	 ecx, DWORD PTR zig$8[rsp]
  001b2	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  001ba	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 2289 :             } else {

  001be	e9 40 01 00 00	 jmp	 $LN19@stbi__jpeg
$LN18@stbi__jpeg:

; 2290 :                 int rs = stbi__jpeg_huff_decode(j, hac);

  001c3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  001cb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001d3	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  001d8	89 44 24 40	 mov	 DWORD PTR rs$7[rsp], eax

; 2291 :                 if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  001dc	83 7c 24 40 00	 cmp	 DWORD PTR rs$7[rsp], 0
  001e1	7d 11		 jge	 SHORT $LN20@stbi__jpeg
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36349
  001ea	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001ef	e9 56 04 00 00	 jmp	 $LN1@stbi__jpeg
$LN20@stbi__jpeg:

; 2292 :                 s = rs & 15;

  001f4	8b 44 24 40	 mov	 eax, DWORD PTR rs$7[rsp]
  001f8	83 e0 0f	 and	 eax, 15
  001fb	89 44 24 30	 mov	 DWORD PTR s$4[rsp], eax

; 2293 :                 r = rs >> 4;

  001ff	8b 44 24 40	 mov	 eax, DWORD PTR rs$7[rsp]
  00203	c1 f8 04	 sar	 eax, 4
  00206	89 44 24 28	 mov	 DWORD PTR r$2[rsp], eax

; 2294 :                 if (s == 0) {

  0020a	83 7c 24 30 00	 cmp	 DWORD PTR s$4[rsp], 0
  0020f	0f 85 8f 00 00
	00		 jne	 $LN21@stbi__jpeg

; 2295 :                     if (r < 15) {

  00215	83 7c 24 28 0f	 cmp	 DWORD PTR r$2[rsp], 15
  0021a	7d 7b		 jge	 SHORT $LN23@stbi__jpeg

; 2296 :                         j->eob_run = (1 << r);

  0021c	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  00220	b9 01 00 00 00	 mov	 ecx, 1
  00225	89 4c 24 60	 mov	 DWORD PTR tv362[rsp], ecx
  00229	0f b6 c8	 movzx	 ecx, al
  0022c	8b 44 24 60	 mov	 eax, DWORD PTR tv362[rsp]
  00230	d3 e0		 shl	 eax, cl
  00232	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0023a	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2297 :                         if (r)

  00240	83 7c 24 28 00	 cmp	 DWORD PTR r$2[rsp], 0
  00245	74 2d		 je	 SHORT $LN24@stbi__jpeg

; 2298 :                             j->eob_run += stbi__jpeg_get_bits(j, r);

  00247	8b 54 24 28	 mov	 edx, DWORD PTR r$2[rsp]
  0024b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00253	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
  00258	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00260	03 81 44 48 00
	00		 add	 eax, DWORD PTR [rcx+18500]
  00266	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0026e	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN24@stbi__jpeg:

; 2299 :                         --j->eob_run;

  00274	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0027c	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00282	ff c8		 dec	 eax
  00284	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0028c	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2300 :                         break;

  00292	e9 84 00 00 00	 jmp	 $LN3@stbi__jpeg
$LN23@stbi__jpeg:

; 2301 :                     }
; 2302 :                     k += 16;

  00297	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0029b	83 c0 10	 add	 eax, 16
  0029e	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2303 :                 } else {

  002a2	eb 5f		 jmp	 SHORT $LN22@stbi__jpeg
$LN21@stbi__jpeg:

; 2304 :                     k += r;

  002a4	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  002a8	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  002ac	03 c8		 add	 ecx, eax
  002ae	8b c1		 mov	 eax, ecx
  002b0	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2305 :                     zig = stbi__jpeg_dezigzag[k++];

  002b4	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  002b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  002c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c4	89 44 24 44	 mov	 DWORD PTR zig$8[rsp], eax
  002c8	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  002cc	ff c0		 inc	 eax
  002ce	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2306 :                     data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));

  002d2	8b 54 24 30	 mov	 edx, DWORD PTR s$4[rsp]
  002d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  002de	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  002e3	8b 4c 24 58	 mov	 ecx, DWORD PTR shift$11[rsp]
  002e7	ba 01 00 00 00	 mov	 edx, 1
  002ec	d3 e2		 shl	 edx, cl
  002ee	8b ca		 mov	 ecx, edx
  002f0	0f af c1	 imul	 eax, ecx
  002f3	8b 4c 24 44	 mov	 ecx, DWORD PTR zig$8[rsp]
  002f7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  002ff	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN22@stbi__jpeg:
$LN19@stbi__jpeg:

; 2307 :                 }
; 2308 :             }
; 2309 :         } while (k <= j->spec_end);

  00303	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0030b	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  00311	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00315	0f 8e 94 fd ff
	ff		 jle	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2310 :     } else {

  0031b	e9 25 03 00 00	 jmp	 $LN15@stbi__jpeg
$LN14@stbi__jpeg:

; 2311 :         // refinement scan for these AC coefficients
; 2312 :         
; 2313 :         short bit = (short) (1 << j->succ_low);

  00320	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00328	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  0032e	b9 01 00 00 00	 mov	 ecx, 1
  00333	89 4c 24 64	 mov	 DWORD PTR tv384[rsp], ecx
  00337	0f b6 c8	 movzx	 ecx, al
  0033a	8b 44 24 64	 mov	 eax, DWORD PTR tv384[rsp]
  0033e	d3 e0		 shl	 eax, cl
  00340	66 89 44 24 24	 mov	 WORD PTR bit$1[rsp], ax

; 2314 :         
; 2315 :         if (j->eob_run) {

  00345	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0034d	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  00354	0f 84 ef 00 00
	00		 je	 $LN25@stbi__jpeg

; 2316 :             --j->eob_run;

  0035a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00362	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00368	ff c8		 dec	 eax
  0036a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00372	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2317 :             for (k = j->spec_start; k <= j->spec_end; ++k) {

  00378	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00380	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  00386	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  0038a	eb 0a		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  0038c	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00390	ff c0		 inc	 eax
  00392	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__jpeg:
  00396	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0039e	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  003a4	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  003a8	0f 8f 96 00 00
	00		 jg	 $LN6@stbi__jpeg

; 2318 :                 short *p = &data[stbi__jpeg_dezigzag[k]];

  003ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  003ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  003c6	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  003ca	48 89 44 24 50	 mov	 QWORD PTR p$10[rsp], rax

; 2319 :                 if (*p != 0)

  003cf	48 8b 44 24 50	 mov	 rax, QWORD PTR p$10[rsp]
  003d4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  003d7	85 c0		 test	 eax, eax
  003d9	74 64		 je	 SHORT $LN27@stbi__jpeg

; 2320 :                     if (stbi__jpeg_get_bit(j))

  003db	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  003e3	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  003e8	85 c0		 test	 eax, eax
  003ea	74 53		 je	 SHORT $LN28@stbi__jpeg

; 2321 :                     if ((*p & bit)==0) {

  003ec	48 8b 44 24 50	 mov	 rax, QWORD PTR p$10[rsp]
  003f1	0f bf 00	 movsx	 eax, WORD PTR [rax]
  003f4	0f bf 4c 24 24	 movsx	 ecx, WORD PTR bit$1[rsp]
  003f9	23 c1		 and	 eax, ecx
  003fb	85 c0		 test	 eax, eax
  003fd	75 40		 jne	 SHORT $LN29@stbi__jpeg

; 2322 :                     if (*p > 0)

  003ff	48 8b 44 24 50	 mov	 rax, QWORD PTR p$10[rsp]
  00404	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00407	85 c0		 test	 eax, eax
  00409	7e 1b		 jle	 SHORT $LN30@stbi__jpeg

; 2323 :                         *p += bit;

  0040b	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00410	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  00415	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00418	03 c8		 add	 ecx, eax
  0041a	8b c1		 mov	 eax, ecx
  0041c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  00421	66 89 01	 mov	 WORD PTR [rcx], ax
  00424	eb 19		 jmp	 SHORT $LN31@stbi__jpeg
$LN30@stbi__jpeg:

; 2324 :                     else
; 2325 :                         *p -= bit;

  00426	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  0042b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  00430	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00433	2b c8		 sub	 ecx, eax
  00435	8b c1		 mov	 eax, ecx
  00437	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  0043c	66 89 01	 mov	 WORD PTR [rcx], ax
$LN31@stbi__jpeg:
$LN29@stbi__jpeg:
$LN28@stbi__jpeg:
$LN27@stbi__jpeg:

; 2326 :                 }
; 2327 :             }

  0043f	e9 48 ff ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2328 :         } else {

  00444	e9 fc 01 00 00	 jmp	 $LN26@stbi__jpeg
$LN25@stbi__jpeg:

; 2329 :             k = j->spec_start;

  00449	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00451	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  00457	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN10@stbi__jpeg:

; 2330 :             do {
; 2331 :                 int r,s;
; 2332 :                 int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

  0045b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00463	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0046b	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  00470	89 44 24 48	 mov	 DWORD PTR rs$9[rsp], eax

; 2333 :                 if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  00474	83 7c 24 48 00	 cmp	 DWORD PTR rs$9[rsp], 0
  00479	7d 11		 jge	 SHORT $LN32@stbi__jpeg
  0047b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36362
  00482	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00487	e9 be 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN32@stbi__jpeg:

; 2334 :                 s = rs & 15;

  0048c	8b 44 24 48	 mov	 eax, DWORD PTR rs$9[rsp]
  00490	83 e0 0f	 and	 eax, 15
  00493	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax

; 2335 :                 r = rs >> 4;

  00497	8b 44 24 48	 mov	 eax, DWORD PTR rs$9[rsp]
  0049b	c1 f8 04	 sar	 eax, 4
  0049e	89 44 24 2c	 mov	 DWORD PTR r$3[rsp], eax

; 2336 :                 if (s == 0) {

  004a2	83 7c 24 34 00	 cmp	 DWORD PTR s$5[rsp], 0
  004a7	75 6b		 jne	 SHORT $LN33@stbi__jpeg

; 2337 :                     if (r < 15) {

  004a9	83 7c 24 2c 0f	 cmp	 DWORD PTR r$3[rsp], 15
  004ae	7d 62		 jge	 SHORT $LN35@stbi__jpeg

; 2338 :                         j->eob_run = (1 << r) - 1;

  004b0	8b 44 24 2c	 mov	 eax, DWORD PTR r$3[rsp]
  004b4	b9 01 00 00 00	 mov	 ecx, 1
  004b9	89 4c 24 68	 mov	 DWORD PTR tv411[rsp], ecx
  004bd	0f b6 c8	 movzx	 ecx, al
  004c0	8b 44 24 68	 mov	 eax, DWORD PTR tv411[rsp]
  004c4	d3 e0		 shl	 eax, cl
  004c6	ff c8		 dec	 eax
  004c8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  004d0	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2339 :                         if (r)

  004d6	83 7c 24 2c 00	 cmp	 DWORD PTR r$3[rsp], 0
  004db	74 2d		 je	 SHORT $LN37@stbi__jpeg

; 2340 :                             j->eob_run += stbi__jpeg_get_bits(j, r);

  004dd	8b 54 24 2c	 mov	 edx, DWORD PTR r$3[rsp]
  004e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  004e9	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
  004ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  004f6	03 81 44 48 00
	00		 add	 eax, DWORD PTR [rcx+18500]
  004fc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00504	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN37@stbi__jpeg:

; 2341 :                         r = 64; // force end of block

  0050a	c7 44 24 2c 40
	00 00 00	 mov	 DWORD PTR r$3[rsp], 64	; 00000040H
$LN35@stbi__jpeg:

; 2342 :                     } else {
; 2343 :                         // r=15 s=0 should write 16 0s, so we just do
; 2344 :                         // a run of 15 0s and then write s (which is 0),
; 2345 :                         // so we don't have to do anything special here
; 2346 :                     }
; 2347 :                 } else {

  00512	eb 3f		 jmp	 SHORT $LN34@stbi__jpeg
$LN33@stbi__jpeg:

; 2348 :                     if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

  00514	83 7c 24 34 01	 cmp	 DWORD PTR s$5[rsp], 1
  00519	74 11		 je	 SHORT $LN38@stbi__jpeg
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36369
  00522	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00527	e9 1e 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN38@stbi__jpeg:

; 2349 :                     // sign bit
; 2350 :                     if (stbi__jpeg_get_bit(j))

  0052c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00534	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  00539	85 c0		 test	 eax, eax
  0053b	74 0b		 je	 SHORT $LN39@stbi__jpeg

; 2351 :                         s = bit;

  0053d	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00542	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax
  00546	eb 0b		 jmp	 SHORT $LN40@stbi__jpeg
$LN39@stbi__jpeg:

; 2352 :                     else
; 2353 :                         s = -bit;

  00548	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  0054d	f7 d8		 neg	 eax
  0054f	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax
$LN40@stbi__jpeg:
$LN34@stbi__jpeg:
$LN11@stbi__jpeg:

; 2354 :                 }
; 2355 :                 
; 2356 :                 // advance by r
; 2357 :                 while (k <= j->spec_end) {

  00553	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0055b	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  00561	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00565	0f 8f c2 00 00
	00		 jg	 $LN12@stbi__jpeg

; 2358 :                     short *p = &data[stbi__jpeg_dezigzag[k++]];

  0056b	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00570	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  00577	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0057b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00583	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00587	48 89 44 24 38	 mov	 QWORD PTR p$6[rsp], rax
  0058c	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00590	ff c0		 inc	 eax
  00592	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2359 :                     if (*p != 0) {

  00596	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  0059b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0059e	85 c0		 test	 eax, eax
  005a0	74 66		 je	 SHORT $LN41@stbi__jpeg

; 2360 :                         if (stbi__jpeg_get_bit(j))

  005a2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  005aa	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  005af	85 c0		 test	 eax, eax
  005b1	74 53		 je	 SHORT $LN43@stbi__jpeg

; 2361 :                             if ((*p & bit)==0) {

  005b3	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  005b8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005bb	0f bf 4c 24 24	 movsx	 ecx, WORD PTR bit$1[rsp]
  005c0	23 c1		 and	 eax, ecx
  005c2	85 c0		 test	 eax, eax
  005c4	75 40		 jne	 SHORT $LN44@stbi__jpeg

; 2362 :                             if (*p > 0)

  005c6	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  005cb	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005ce	85 c0		 test	 eax, eax
  005d0	7e 1b		 jle	 SHORT $LN45@stbi__jpeg

; 2363 :                                 *p += bit;

  005d2	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  005d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  005dc	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  005df	03 c8		 add	 ecx, eax
  005e1	8b c1		 mov	 eax, ecx
  005e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  005e8	66 89 01	 mov	 WORD PTR [rcx], ax
  005eb	eb 19		 jmp	 SHORT $LN46@stbi__jpeg
$LN45@stbi__jpeg:

; 2364 :                             else
; 2365 :                                 *p -= bit;

  005ed	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  005f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  005f7	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  005fa	2b c8		 sub	 ecx, eax
  005fc	8b c1		 mov	 eax, ecx
  005fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  00603	66 89 01	 mov	 WORD PTR [rcx], ax
$LN46@stbi__jpeg:
$LN44@stbi__jpeg:
$LN43@stbi__jpeg:

; 2366 :                         }
; 2367 :                     } else {

  00606	eb 20		 jmp	 SHORT $LN42@stbi__jpeg
$LN41@stbi__jpeg:

; 2368 :                         if (r == 0) {

  00608	83 7c 24 2c 00	 cmp	 DWORD PTR r$3[rsp], 0
  0060d	75 0f		 jne	 SHORT $LN47@stbi__jpeg

; 2369 :                             *p = (short) s;

  0060f	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  00614	0f b7 4c 24 34	 movzx	 ecx, WORD PTR s$5[rsp]
  00619	66 89 08	 mov	 WORD PTR [rax], cx

; 2370 :                             break;

  0061c	eb 0f		 jmp	 SHORT $LN12@stbi__jpeg
$LN47@stbi__jpeg:

; 2371 :                         }
; 2372 :                         --r;

  0061e	8b 44 24 2c	 mov	 eax, DWORD PTR r$3[rsp]
  00622	ff c8		 dec	 eax
  00624	89 44 24 2c	 mov	 DWORD PTR r$3[rsp], eax
$LN42@stbi__jpeg:

; 2373 :                     }
; 2374 :                 }

  00628	e9 26 ff ff ff	 jmp	 $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 2375 :             } while (k <= j->spec_end);

  0062d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00635	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  0063b	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0063f	0f 8e 16 fe ff
	ff		 jle	 $LN10@stbi__jpeg
$LN26@stbi__jpeg:
$LN15@stbi__jpeg:

; 2376 :         }
; 2377 :     }
; 2378 :     return 1;

  00645	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2379 : }

  0064a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00651	c3		 ret	 0
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ENDP ; stbi__jpeg_decode_block_prog_ac
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
t$ = 32
tv88 = 36
dc$ = 40
diff$ = 44
tv179 = 48
j$ = 80
data$ = 88
hdc$ = 96
b$ = 104
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z PROC ; stbi__jpeg_decode_block_prog_dc

; 2235 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2236 :     int diff,dc;
; 2237 :     int t;
; 2238 :     if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0001e	83 b8 38 48 00
	00 00		 cmp	 DWORD PTR [rax+18488], 0
  00025	74 11		 je	 SHORT $LN2@stbi__jpeg
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36298
  0002e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00033	e9 55 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 2239 :     
; 2240 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0003d	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00044	7d 0a		 jge	 SHORT $LN3@stbi__jpeg
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN3@stbi__jpeg:

; 2241 :     
; 2242 :     if (j->succ_high == 0) {

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00055	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  0005c	0f 85 db 00 00
	00		 jne	 $LN4@stbi__jpeg

; 2243 :         // first scan for DC coefficient, must be first
; 2244 :         memset(data,0,64*sizeof(data[0])); // 0 all the ac values now

  00062	48 8b 7c 24 58	 mov	 rdi, QWORD PTR data$[rsp]
  00067	33 c0		 xor	 eax, eax
  00069	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0006e	f3 aa		 rep stosb

; 2245 :         t = stbi__jpeg_huff_decode(j, hdc);

  00070	48 8b 54 24 60	 mov	 rdx, QWORD PTR hdc$[rsp]
  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  0007f	89 44 24 20	 mov	 DWORD PTR t$[rsp], eax

; 2246 :         if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00083	83 7c 24 20 00	 cmp	 DWORD PTR t$[rsp], 0
  00088	7c 07		 jl	 SHORT $LN7@stbi__jpeg
  0008a	83 7c 24 20 0f	 cmp	 DWORD PTR t$[rsp], 15
  0008f	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36304
  00098	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0009d	e9 eb 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2247 :         diff = t ? stbi__extend_receive(j, t) : 0;

  000a2	83 7c 24 20 00	 cmp	 DWORD PTR t$[rsp], 0
  000a7	74 14		 je	 SHORT $LN10@stbi__jpeg
  000a9	8b 54 24 20	 mov	 edx, DWORD PTR t$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  000b2	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  000b7	89 44 24 24	 mov	 DWORD PTR tv88[rsp], eax
  000bb	eb 08		 jmp	 SHORT $LN11@stbi__jpeg
$LN10@stbi__jpeg:
  000bd	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN11@stbi__jpeg:
  000c5	8b 44 24 24	 mov	 eax, DWORD PTR tv88[rsp]
  000c9	89 44 24 2c	 mov	 DWORD PTR diff$[rsp], eax

; 2248 :         
; 2249 :         dc = j->img_comp[b].dc_pred + diff;

  000cd	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$[rsp]
  000d2	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  000db	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  000e2	03 44 24 2c	 add	 eax, DWORD PTR diff$[rsp]
  000e6	89 44 24 28	 mov	 DWORD PTR dc$[rsp], eax

; 2250 :         j->img_comp[b].dc_pred = dc;

  000ea	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$[rsp]
  000ef	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  000f8	8b 54 24 28	 mov	 edx, DWORD PTR dc$[rsp]
  000fc	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 2251 :         data[0] = (short) (dc * (1 << j->succ_low));

  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00108	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  0010e	b9 01 00 00 00	 mov	 ecx, 1
  00113	89 4c 24 30	 mov	 DWORD PTR tv179[rsp], ecx
  00117	0f b6 c8	 movzx	 ecx, al
  0011a	8b 44 24 30	 mov	 eax, DWORD PTR tv179[rsp]
  0011e	d3 e0		 shl	 eax, cl
  00120	8b 4c 24 28	 mov	 ecx, DWORD PTR dc$[rsp]
  00124	0f af c8	 imul	 ecx, eax
  00127	8b c1		 mov	 eax, ecx
  00129	b9 02 00 00 00	 mov	 ecx, 2
  0012e	48 6b c9 00	 imul	 rcx, rcx, 0
  00132	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  00137	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2252 :     } else {

  0013b	eb 4b		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 2253 :         // refinement scan for DC coefficient
; 2254 :         if (stbi__jpeg_get_bit(j))

  0013d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00142	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  00147	85 c0		 test	 eax, eax
  00149	74 3d		 je	 SHORT $LN8@stbi__jpeg

; 2255 :             data[0] += (short) (1 << j->succ_low);

  0014b	b8 02 00 00 00	 mov	 eax, 2
  00150	48 6b c0 00	 imul	 rax, rax, 0
  00154	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00159	8b 89 40 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18496]
  0015f	ba 01 00 00 00	 mov	 edx, 1
  00164	d3 e2		 shl	 edx, cl
  00166	8b ca		 mov	 ecx, edx
  00168	0f bf c9	 movsx	 ecx, cx
  0016b	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  00170	0f bf 04 02	 movsx	 eax, WORD PTR [rdx+rax]
  00174	03 c1		 add	 eax, ecx
  00176	b9 02 00 00 00	 mov	 ecx, 2
  0017b	48 6b c9 00	 imul	 rcx, rcx, 0
  0017f	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  00184	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN8@stbi__jpeg:
$LN5@stbi__jpeg:

; 2256 :     }
; 2257 :     return 1;

  00188	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2258 : }

  0018d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00191	5f		 pop	 rdi
  00192	c3		 ret	 0
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ENDP ; stbi__jpeg_decode_block_prog_dc
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
r$1 = 36
s$2 = 40
zig$3 = 44
t$ = 48
rs$4 = 52
tv82 = 56
dc$ = 60
diff$ = 64
c$5 = 68
tv240 = 72
j$ = 96
data$ = 104
hdc$ = 112
hac$ = 120
fac$ = 128
b$ = 136
dequant$ = 144
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z PROC ; stbi__jpeg_decode_block

; 2183 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2184 :     int diff,dc,k;
; 2185 :     int t;
; 2186 :     
; 2187 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0001e	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00025	7d 0a		 jge	 SHORT $LN5@stbi__jpeg
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 2188 :     t = stbi__jpeg_huff_decode(j, hdc);

  00031	48 8b 54 24 70	 mov	 rdx, QWORD PTR hdc$[rsp]
  00036	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  00040	89 44 24 30	 mov	 DWORD PTR t$[rsp], eax

; 2189 :     if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

  00044	83 7c 24 30 00	 cmp	 DWORD PTR t$[rsp], 0
  00049	7c 07		 jl	 SHORT $LN7@stbi__jpeg
  0004b	83 7c 24 30 0f	 cmp	 DWORD PTR t$[rsp], 15
  00050	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36277
  00059	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005e	e9 79 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2190 :     
; 2191 :     // 0 all the ac values now so we can do it 32-bits at a time
; 2192 :     memset(data,0,64*sizeof(data[0]));

  00063	48 8b 7c 24 68	 mov	 rdi, QWORD PTR data$[rsp]
  00068	33 c0		 xor	 eax, eax
  0006a	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0006f	f3 aa		 rep stosb

; 2193 :     
; 2194 :     diff = t ? stbi__extend_receive(j, t) : 0;

  00071	83 7c 24 30 00	 cmp	 DWORD PTR t$[rsp], 0
  00076	74 14		 je	 SHORT $LN16@stbi__jpeg
  00078	8b 54 24 30	 mov	 edx, DWORD PTR t$[rsp]
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00081	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  00086	89 44 24 38	 mov	 DWORD PTR tv82[rsp], eax
  0008a	eb 08		 jmp	 SHORT $LN17@stbi__jpeg
$LN16@stbi__jpeg:
  0008c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN17@stbi__jpeg:
  00094	8b 44 24 38	 mov	 eax, DWORD PTR tv82[rsp]
  00098	89 44 24 40	 mov	 DWORD PTR diff$[rsp], eax

; 2195 :     dc = j->img_comp[b].dc_pred + diff;

  0009c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  000a4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000ad	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  000b4	03 44 24 40	 add	 eax, DWORD PTR diff$[rsp]
  000b8	89 44 24 3c	 mov	 DWORD PTR dc$[rsp], eax

; 2196 :     j->img_comp[b].dc_pred = dc;

  000bc	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  000c4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000cd	8b 54 24 3c	 mov	 edx, DWORD PTR dc$[rsp]
  000d1	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 2197 :     data[0] = (short) (dc * dequant[0]);

  000d8	b8 02 00 00 00	 mov	 eax, 2
  000dd	48 6b c0 00	 imul	 rax, rax, 0
  000e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dequant$[rsp]
  000e9	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  000ed	8b 4c 24 3c	 mov	 ecx, DWORD PTR dc$[rsp]
  000f1	0f af c8	 imul	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	b9 02 00 00 00	 mov	 ecx, 2
  000fb	48 6b c9 00	 imul	 rcx, rcx, 0
  000ff	48 8b 54 24 68	 mov	 rdx, QWORD PTR data$[rsp]
  00104	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2198 :     
; 2199 :     // decode AC components, see JPEG spec
; 2200 :     k = 1;

  00108	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR k$[rsp], 1
$LN4@stbi__jpeg:

; 2201 :     do {
; 2202 :         unsigned int zig;
; 2203 :         int c,r,s;
; 2204 :         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00110	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00115	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0011c	7d 0a		 jge	 SHORT $LN8@stbi__jpeg
  0011e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00123	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN8@stbi__jpeg:

; 2205 :         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00128	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0012d	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00133	c1 e8 17	 shr	 eax, 23
  00136	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0013b	89 44 24 44	 mov	 DWORD PTR c$5[rsp], eax

; 2206 :         r = fac[c];

  0013f	48 63 44 24 44	 movsxd	 rax, DWORD PTR c$5[rsp]
  00144	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR fac$[rsp]
  0014c	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  00150	89 44 24 24	 mov	 DWORD PTR r$1[rsp], eax

; 2207 :         if (r) { // fast-AC path

  00154	83 7c 24 24 00	 cmp	 DWORD PTR r$1[rsp], 0
  00159	0f 84 b0 00 00
	00		 je	 $LN9@stbi__jpeg

; 2208 :             k += (r >> 4) & 15; // run

  0015f	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  00163	c1 f8 04	 sar	 eax, 4
  00166	83 e0 0f	 and	 eax, 15
  00169	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0016d	03 c8		 add	 ecx, eax
  0016f	8b c1		 mov	 eax, ecx
  00171	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2209 :             s = r & 15; // combined length

  00175	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  00179	83 e0 0f	 and	 eax, 15
  0017c	89 44 24 28	 mov	 DWORD PTR s$2[rsp], eax

; 2210 :             j->code_buffer <<= s;

  00180	8b 44 24 28	 mov	 eax, DWORD PTR s$2[rsp]
  00184	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00189	48 89 4c 24 48	 mov	 QWORD PTR tv240[rsp], rcx
  0018e	0f b6 c8	 movzx	 ecx, al
  00191	48 8b 44 24 48	 mov	 rax, QWORD PTR tv240[rsp]
  00196	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0019c	d3 e0		 shl	 eax, cl
  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  001a3	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2211 :             j->code_bits -= s;

  001a9	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  001ae	8b 4c 24 28	 mov	 ecx, DWORD PTR s$2[rsp]
  001b2	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001b8	2b c1		 sub	 eax, ecx
  001ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  001bf	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2212 :             // decode into unzigzag'd location
; 2213 :             zig = stbi__jpeg_dezigzag[k++];

  001c5	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  001d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d5	89 44 24 2c	 mov	 DWORD PTR zig$3[rsp], eax
  001d9	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  001dd	ff c0		 inc	 eax
  001df	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2214 :             data[zig] = (short) ((r >> 8) * dequant[zig]);

  001e3	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  001e7	c1 f8 08	 sar	 eax, 8
  001ea	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  001ee	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dequant$[rsp]
  001f6	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  001fa	0f af c1	 imul	 eax, ecx
  001fd	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  00201	48 8b 54 24 68	 mov	 rdx, QWORD PTR data$[rsp]
  00206	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 2215 :         } else {

  0020a	e9 bd 00 00 00	 jmp	 $LN10@stbi__jpeg
$LN9@stbi__jpeg:

; 2216 :             int rs = stbi__jpeg_huff_decode(j, hac);

  0020f	48 8b 54 24 78	 mov	 rdx, QWORD PTR hac$[rsp]
  00214	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00219	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  0021e	89 44 24 34	 mov	 DWORD PTR rs$4[rsp], eax

; 2217 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  00222	83 7c 24 34 00	 cmp	 DWORD PTR rs$4[rsp], 0
  00227	7d 11		 jge	 SHORT $LN11@stbi__jpeg
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36282
  00230	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00235	e9 a2 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN11@stbi__jpeg:

; 2218 :             s = rs & 15;

  0023a	8b 44 24 34	 mov	 eax, DWORD PTR rs$4[rsp]
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 28	 mov	 DWORD PTR s$2[rsp], eax

; 2219 :             r = rs >> 4;

  00245	8b 44 24 34	 mov	 eax, DWORD PTR rs$4[rsp]
  00249	c1 f8 04	 sar	 eax, 4
  0024c	89 44 24 24	 mov	 DWORD PTR r$1[rsp], eax

; 2220 :             if (s == 0) {

  00250	83 7c 24 28 00	 cmp	 DWORD PTR s$2[rsp], 0
  00255	75 19		 jne	 SHORT $LN12@stbi__jpeg

; 2221 :                 if (rs != 0xf0) break; // end block

  00257	81 7c 24 34 f0
	00 00 00	 cmp	 DWORD PTR rs$4[rsp], 240 ; 000000f0H
  0025f	74 02		 je	 SHORT $LN14@stbi__jpeg
  00261	eb 74		 jmp	 SHORT $LN3@stbi__jpeg
$LN14@stbi__jpeg:

; 2222 :                 k += 16;

  00263	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00267	83 c0 10	 add	 eax, 16
  0026a	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2223 :             } else {

  0026e	eb 5c		 jmp	 SHORT $LN13@stbi__jpeg
$LN12@stbi__jpeg:

; 2224 :                 k += r;

  00270	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  00274	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00278	03 c8		 add	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2225 :                 // decode into unzigzag'd location
; 2226 :                 zig = stbi__jpeg_dezigzag[k++];

  00280	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  0028c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00290	89 44 24 2c	 mov	 DWORD PTR zig$3[rsp], eax
  00294	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00298	ff c0		 inc	 eax
  0029a	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2227 :                 data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);

  0029e	8b 54 24 28	 mov	 edx, DWORD PTR s$2[rsp]
  002a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  002a7	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  002ac	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  002b0	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dequant$[rsp]
  002b8	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  002bc	0f af c1	 imul	 eax, ecx
  002bf	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  002c3	48 8b 54 24 68	 mov	 rdx, QWORD PTR data$[rsp]
  002c8	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN13@stbi__jpeg:
$LN10@stbi__jpeg:

; 2228 :             }
; 2229 :         }
; 2230 :     } while (k < 64);

  002cc	83 7c 24 20 40	 cmp	 DWORD PTR k$[rsp], 64	; 00000040H
  002d1	0f 8c 39 fe ff
	ff		 jl	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2231 :     return 1;

  002d7	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2232 : }

  002dc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002e0	5f		 pop	 rdi
  002e1	c3		 ret	 0
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ENDP ; stbi__jpeg_decode_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
j$ = 64
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_get_bit

; 2155 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2156 :     unsigned int k;
; 2157 :     if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00015	7d 0a		 jge	 SHORT $LN2@stbi__jpeg
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 2158 :     k = j->code_buffer;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00026	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0002c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2159 :     j->code_buffer <<= 1;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00035	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0003b	d1 e0		 shl	 eax, 1
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00042	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2160 :     --j->code_bits;

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0004d	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00053	ff c8		 dec	 eax
  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0005a	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2161 :     return k & 0x80000000;

  00060	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00064	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H

; 2162 : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_get_bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
tv90 = 40
j$ = 64
n$ = 72
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__jpeg_get_bits

; 2144 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2145 :     unsigned int k;
; 2146 :     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00016	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  0001c	7d 0a		 jge	 SHORT $LN2@stbi__jpeg
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 2147 :     k = stbi_lrot(j->code_buffer, n);

  00028	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00031	48 89 4c 24 28	 mov	 QWORD PTR tv90[rsp], rcx
  00036	0f b6 c8	 movzx	 ecx, al
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR tv90[rsp]
  0003e	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00044	d3 c0		 rol	 eax, cl
  00046	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2148 :     j->code_buffer = k & ~stbi__bmask[n];

  0004a	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00056	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00059	f7 d0		 not	 eax
  0005b	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0005f	23 c8		 and	 ecx, eax
  00061	8b c1		 mov	 eax, ecx
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00068	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2149 :     k &= stbi__bmask[n];

  0006e	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  0007a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0007d	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00081	23 c8		 and	 ecx, eax
  00083	8b c1		 mov	 eax, ecx
  00085	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2150 :     j->code_bits -= n;

  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0008e	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00092	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00098	2b c1		 sub	 eax, ecx
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0009f	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2151 :     return k;

  000a5	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]

; 2152 : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__jpeg_get_bits
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
sgn$ = 36
tv133 = 40
j$ = 64
n$ = 72
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__extend_receive

; 2129 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2130 :     unsigned int k;
; 2131 :     int sgn;
; 2132 :     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00016	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  0001c	7d 0a		 jge	 SHORT $LN2@stbi__exte
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__exte:

; 2133 :     
; 2134 :     sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0002d	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00033	c1 e8 1f	 shr	 eax, 31
  00036	89 44 24 24	 mov	 DWORD PTR sgn$[rsp], eax

; 2135 :     k = stbi_lrot(j->code_buffer, n);

  0003a	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00043	48 89 4c 24 28	 mov	 QWORD PTR tv133[rsp], rcx
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv133[rsp]
  00050	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00056	d3 c0		 rol	 eax, cl
  00058	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2136 :     j->code_buffer = k & ~stbi__bmask[n];

  0005c	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00068	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0006b	f7 d0		 not	 eax
  0006d	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0007a	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2137 :     k &= stbi__bmask[n];

  00080	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  0008c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0008f	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00093	23 c8		 and	 ecx, eax
  00095	8b c1		 mov	 eax, ecx
  00097	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2138 :     j->code_bits -= n;

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000a0	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  000a4	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000aa	2b c1		 sub	 eax, ecx
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000b1	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2139 :     return k + (stbi__jbias[n] & (sgn - 1));

  000b7	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jbias@@3QBHB
  000c3	8b 54 24 24	 mov	 edx, DWORD PTR sgn$[rsp]
  000c7	ff ca		 dec	 edx
  000c9	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000cc	23 c2		 and	 eax, edx
  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  000d2	03 c8		 add	 ecx, eax
  000d4	8b c1		 mov	 eax, ecx

; 2140 : }

  000d6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000da	c3		 ret	 0
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__extend_receive
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
c$ = 36
s$1 = 40
temp$ = 44
tv206 = 48
tv227 = 56
tv236 = 64
tv246 = 72
j$ = 96
h$ = 104
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z PROC ; stbi__jpeg_huff_decode

; 2075 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2076 :     unsigned int temp;
; 2077 :     int c,k;
; 2078 :     
; 2079 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00013	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0001a	7d 0a		 jge	 SHORT $LN5@stbi__jpeg
  0001c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00021	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 2080 :     
; 2081 :     // look at the top FAST_BITS and determine what symbol ID it is,
; 2082 :     // if the code is <= FAST_BITS
; 2083 :     c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0002b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00031	c1 e8 17	 shr	 eax, 23
  00034	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00039	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 2084 :     k = h->fast[c];

  0003d	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  00042	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00047	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004b	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2085 :     if (k < 255) {

  0004f	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR k$[rsp], 255	; 000000ffH
  00057	0f 8d 8d 00 00
	00		 jge	 $LN6@stbi__jpeg

; 2086 :         int s = h->size[k];

  0005d	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00062	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00067	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0006f	89 44 24 28	 mov	 DWORD PTR s$1[rsp], eax

; 2087 :         if (s > j->code_bits)

  00073	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00078	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0007e	39 44 24 28	 cmp	 DWORD PTR s$1[rsp], eax
  00082	7e 0a		 jle	 SHORT $LN7@stbi__jpeg

; 2088 :             return -1;

  00084	b8 ff ff ff ff	 mov	 eax, -1
  00089	e9 f2 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN7@stbi__jpeg:

; 2089 :         j->code_buffer <<= s;

  0008e	8b 44 24 28	 mov	 eax, DWORD PTR s$1[rsp]
  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00097	48 89 4c 24 30	 mov	 QWORD PTR tv206[rsp], rcx
  0009c	0f b6 c8	 movzx	 ecx, al
  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR tv206[rsp]
  000a4	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000aa	d3 e0		 shl	 eax, cl
  000ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000b1	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2090 :         j->code_bits -= s;

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  000bc	8b 4c 24 28	 mov	 ecx, DWORD PTR s$1[rsp]
  000c0	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000c6	2b c1		 sub	 eax, ecx
  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000cd	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2091 :         return h->values[k];

  000d3	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  000dd	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  000e5	e9 96 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2092 :     }
; 2093 :     
; 2094 :     // naive test is to shift the code_buffer down so k bits are
; 2095 :     // valid, then test against maxcode. To speed this up, we've
; 2096 :     // preshifted maxcode left so that it has (16-k) 0s at the
; 2097 :     // end; in other words, regardless of the number of bits, it
; 2098 :     // wants to be compared against something shifted to have 16;
; 2099 :     // that way we don't need to shift inside the loop.
; 2100 :     temp = j->code_buffer >> 16;

  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  000ef	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000f5	c1 e8 10	 shr	 eax, 16
  000f8	89 44 24 2c	 mov	 DWORD PTR temp$[rsp], eax

; 2101 :     for (k=FAST_BITS+1 ; ; ++k)

  000fc	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR k$[rsp], 10
  00104	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00106	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0010a	ff c0		 inc	 eax
  0010c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 2102 :         if (temp < h->maxcode[k])

  00110	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00115	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  0011a	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  00121	39 44 24 2c	 cmp	 DWORD PTR temp$[rsp], eax
  00125	73 02		 jae	 SHORT $LN8@stbi__jpeg

; 2103 :         break;

  00127	eb 02		 jmp	 SHORT $LN3@stbi__jpeg
$LN8@stbi__jpeg:
  00129	eb db		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 2104 :     if (k == 17) {

  0012b	83 7c 24 20 11	 cmp	 DWORD PTR k$[rsp], 17
  00130	75 23		 jne	 SHORT $LN9@stbi__jpeg

; 2105 :         // error! code not found
; 2106 :         j->code_bits -= 16;

  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00137	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0013d	83 e8 10	 sub	 eax, 16
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00145	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2107 :         return -1;

  0014b	b8 ff ff ff ff	 mov	 eax, -1
  00150	e9 2b 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2108 :     }
; 2109 :     
; 2110 :     if (k > j->code_bits)

  00155	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0015a	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00160	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00164	7e 0a		 jle	 SHORT $LN10@stbi__jpeg

; 2111 :         return -1;

  00166	b8 ff ff ff ff	 mov	 eax, -1
  0016b	e9 10 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 2112 :     
; 2113 :     // convert the huffman code to the symbol id
; 2114 :     c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  00170	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00175	2b 44 24 20	 sub	 eax, DWORD PTR k$[rsp]
  00179	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0017e	48 89 4c 24 38	 mov	 QWORD PTR tv227[rsp], rcx
  00183	0f b6 c8	 movzx	 ecx, al
  00186	48 8b 44 24 38	 mov	 rax, QWORD PTR tv227[rsp]
  0018b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00191	d3 e8		 shr	 eax, cl
  00193	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__bmask@@3QBIB
  0019f	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  001a2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  001a7	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  001ac	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  001b3	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 2115 :     STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  001b7	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  001bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  001c1	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  001c9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001ce	2b c8		 sub	 ecx, eax
  001d0	8b c1		 mov	 eax, ecx
  001d2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  001d7	48 89 4c 24 40	 mov	 QWORD PTR tv236[rsp], rcx
  001dc	0f b6 c8	 movzx	 ecx, al
  001df	48 8b 44 24 40	 mov	 rax, QWORD PTR tv236[rsp]
  001e4	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  001ea	d3 e8		 shr	 eax, cl
  001ec	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR c$[rsp]
  001f1	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  001f6	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00205	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00208	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR c$[rsp]
  0020d	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  00212	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  0021a	3b c1		 cmp	 eax, ecx
  0021c	74 0b		 je	 SHORT $LN11@stbi__jpeg
  0021e	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN11@stbi__jpeg:

; 2116 :     
; 2117 :     // convert the id to a symbol
; 2118 :     j->code_bits -= k;

  00229	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0022e	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00232	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00238	2b c1		 sub	 eax, ecx
  0023a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0023f	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2119 :     j->code_buffer <<= k;

  00245	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00249	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0024e	48 89 4c 24 48	 mov	 QWORD PTR tv246[rsp], rcx
  00253	0f b6 c8	 movzx	 ecx, al
  00256	48 8b 44 24 48	 mov	 rax, QWORD PTR tv246[rsp]
  0025b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00261	d3 e0		 shl	 eax, cl
  00263	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00268	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2120 :     return h->values[c];

  0026e	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  00273	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00278	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
$LN1@stbi__jpeg:

; 2121 : }

  00280	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00284	c3		 ret	 0
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ENDP ; stbi__jpeg_huff_decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
c$1 = 32
tv70 = 36
b$2 = 40
j$ = 64
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z PROC	; stbi__grow_buffer_unsafe

; 2053 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@stbi__grow:

; 2054 :     do {
; 2055 :         unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	83 b8 2c 48 00
	00 00		 cmp	 DWORD PTR [rax+18476], 0
  00015	74 0a		 je	 SHORT $LN10@stbi__grow
  00017	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0001f	eb 14		 jmp	 SHORT $LN11@stbi__grow
$LN10@stbi__grow:
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00026	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00029	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
$LN11@stbi__grow:
  00035	8b 44 24 24	 mov	 eax, DWORD PTR tv70[rsp]
  00039	89 44 24 28	 mov	 DWORD PTR b$2[rsp], eax

; 2056 :         if (b == 0xff) {

  0003d	81 7c 24 28 ff
	00 00 00	 cmp	 DWORD PTR b$2[rsp], 255	; 000000ffH
  00045	75 5c		 jne	 SHORT $LN7@stbi__grow

; 2057 :             int c = stbi__get8(j->s);

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0004c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00054	0f b6 c0	 movzx	 eax, al
  00057	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax
$LN5@stbi__grow:

; 2058 :             while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

  0005b	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR c$1[rsp], 255	; 000000ffH
  00063	75 16		 jne	 SHORT $LN6@stbi__grow
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00072	0f b6 c0	 movzx	 eax, al
  00075	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax
  00079	eb e0		 jmp	 SHORT $LN5@stbi__grow
$LN6@stbi__grow:

; 2059 :             if (c != 0) {

  0007b	83 7c 24 20 00	 cmp	 DWORD PTR c$1[rsp], 0
  00080	74 21		 je	 SHORT $LN8@stbi__grow

; 2060 :                 j->marker = (unsigned char) c;

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00087	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$1[rsp]
  0008c	88 88 28 48 00
	00		 mov	 BYTE PTR [rax+18472], cl

; 2061 :                 j->nomore = 1;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00097	c7 80 2c 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18476], 1

; 2062 :                 return;

  000a1	eb 60		 jmp	 SHORT $LN1@stbi__grow
$LN8@stbi__grow:
$LN7@stbi__grow:

; 2063 :             }
; 2064 :         }
; 2065 :         j->code_buffer |= b << (24 - j->code_bits);

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000a8	b9 18 00 00 00	 mov	 ecx, 24
  000ad	2b 88 24 48 00
	00		 sub	 ecx, DWORD PTR [rax+18468]
  000b3	8b c1		 mov	 eax, ecx
  000b5	0f b6 c8	 movzx	 ecx, al
  000b8	8b 44 24 28	 mov	 eax, DWORD PTR b$2[rsp]
  000bc	d3 e0		 shl	 eax, cl
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000c3	8b 89 20 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18464]
  000c9	0b c8		 or	 ecx, eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000d2	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2066 :         j->code_bits += 8;

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000dd	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000e3	83 c0 08	 add	 eax, 8
  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000eb	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2067 :     } while (j->code_bits <= 24);

  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000f6	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  000fd	0f 8e 06 ff ff
	ff		 jle	 $LN4@stbi__grow
$LN1@stbi__grow:

; 2068 : }

  00103	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00107	c3		 ret	 0
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ENDP	; stbi__grow_buffer_unsafe
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
fast$1 = 0
i$ = 4
k$2 = 8
magbits$3 = 12
len$4 = 16
rs$5 = 20
tv173 = 24
m$6 = 28
tv177 = 32
run$7 = 36
fast_ac$ = 64
h$ = 72
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z PROC	; stbi__build_fast_ac

; 2028 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2029 :     int i;
; 2030 :     for (i=0; i < (1 << FAST_BITS); ++i) {

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  00018	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
  00022	81 7c 24 04 00
	02 00 00	 cmp	 DWORD PTR i$[rsp], 512	; 00000200H
  0002a	0f 8d 3a 01 00
	00		 jge	 $LN3@stbi__buil

; 2031 :         stbi_uc fast = h->fast[i];

  00030	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR h$[rsp]
  0003a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003e	88 04 24	 mov	 BYTE PTR fast$1[rsp], al

; 2032 :         fast_ac[i] = 0;

  00041	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00046	33 c9		 xor	 ecx, ecx
  00048	48 8b 54 24 40	 mov	 rdx, QWORD PTR fast_ac$[rsp]
  0004d	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 2033 :         if (fast < 255) {

  00051	0f b6 04 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00055	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0005a	0f 8d 05 01 00
	00		 jge	 $LN5@stbi__buil

; 2034 :             int rs = h->values[fast];

  00060	0f b6 04 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00064	48 8b 4c 24 48	 mov	 rcx, QWORD PTR h$[rsp]
  00069	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00071	89 44 24 14	 mov	 DWORD PTR rs$5[rsp], eax

; 2035 :             int run = (rs >> 4) & 15;

  00075	8b 44 24 14	 mov	 eax, DWORD PTR rs$5[rsp]
  00079	c1 f8 04	 sar	 eax, 4
  0007c	83 e0 0f	 and	 eax, 15
  0007f	89 44 24 24	 mov	 DWORD PTR run$7[rsp], eax

; 2036 :             int magbits = rs & 15;

  00083	8b 44 24 14	 mov	 eax, DWORD PTR rs$5[rsp]
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 0c	 mov	 DWORD PTR magbits$3[rsp], eax

; 2037 :             int len = h->size[fast];

  0008e	0f b6 04 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00092	48 8b 4c 24 48	 mov	 rcx, QWORD PTR h$[rsp]
  00097	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0009f	89 44 24 10	 mov	 DWORD PTR len$4[rsp], eax

; 2038 :             
; 2039 :             if (magbits && len + magbits <= FAST_BITS) {

  000a3	83 7c 24 0c 00	 cmp	 DWORD PTR magbits$3[rsp], 0
  000a8	0f 84 b7 00 00
	00		 je	 $LN6@stbi__buil
  000ae	8b 44 24 0c	 mov	 eax, DWORD PTR magbits$3[rsp]
  000b2	8b 4c 24 10	 mov	 ecx, DWORD PTR len$4[rsp]
  000b6	03 c8		 add	 ecx, eax
  000b8	8b c1		 mov	 eax, ecx
  000ba	83 f8 09	 cmp	 eax, 9
  000bd	0f 8f a2 00 00
	00		 jg	 $LN6@stbi__buil

; 2040 :                 // magnitude code followed by receive_extend code
; 2041 :                 int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

  000c3	8b 44 24 10	 mov	 eax, DWORD PTR len$4[rsp]
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  000ce	d3 e0		 shl	 eax, cl
  000d0	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000d5	b9 09 00 00 00	 mov	 ecx, 9
  000da	2b 4c 24 0c	 sub	 ecx, DWORD PTR magbits$3[rsp]
  000de	d3 f8		 sar	 eax, cl
  000e0	89 44 24 08	 mov	 DWORD PTR k$2[rsp], eax

; 2042 :                 int m = 1 << (magbits - 1);

  000e4	8b 44 24 0c	 mov	 eax, DWORD PTR magbits$3[rsp]
  000e8	ff c8		 dec	 eax
  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	89 4c 24 18	 mov	 DWORD PTR tv173[rsp], ecx
  000f3	0f b6 c8	 movzx	 ecx, al
  000f6	8b 44 24 18	 mov	 eax, DWORD PTR tv173[rsp]
  000fa	d3 e0		 shl	 eax, cl
  000fc	89 44 24 1c	 mov	 DWORD PTR m$6[rsp], eax

; 2043 :                 if (k < m) k += (~0U << magbits) + 1;

  00100	8b 44 24 1c	 mov	 eax, DWORD PTR m$6[rsp]
  00104	39 44 24 08	 cmp	 DWORD PTR k$2[rsp], eax
  00108	7d 22		 jge	 SHORT $LN7@stbi__buil
  0010a	8b 44 24 0c	 mov	 eax, DWORD PTR magbits$3[rsp]
  0010e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00113	89 4c 24 20	 mov	 DWORD PTR tv177[rsp], ecx
  00117	0f b6 c8	 movzx	 ecx, al
  0011a	8b 44 24 20	 mov	 eax, DWORD PTR tv177[rsp]
  0011e	d3 e0		 shl	 eax, cl
  00120	8b 4c 24 08	 mov	 ecx, DWORD PTR k$2[rsp]
  00124	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00128	89 44 24 08	 mov	 DWORD PTR k$2[rsp], eax
$LN7@stbi__buil:

; 2044 :                 // if the result is small enough, we can fit it in fast_ac table
; 2045 :                 if (k >= -128 && k <= 127)

  0012c	83 7c 24 08 80	 cmp	 DWORD PTR k$2[rsp], -128 ; ffffffffffffff80H
  00131	7c 32		 jl	 SHORT $LN8@stbi__buil
  00133	83 7c 24 08 7f	 cmp	 DWORD PTR k$2[rsp], 127	; 0000007fH
  00138	7f 2b		 jg	 SHORT $LN8@stbi__buil

; 2046 :                     fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));

  0013a	69 44 24 08 00
	01 00 00	 imul	 eax, DWORD PTR k$2[rsp], 256 ; 00000100H
  00142	6b 4c 24 24 10	 imul	 ecx, DWORD PTR run$7[rsp], 16
  00147	03 c1		 add	 eax, ecx
  00149	8b 4c 24 0c	 mov	 ecx, DWORD PTR magbits$3[rsp]
  0014d	8b 54 24 10	 mov	 edx, DWORD PTR len$4[rsp]
  00151	03 d1		 add	 edx, ecx
  00153	8b ca		 mov	 ecx, edx
  00155	03 c1		 add	 eax, ecx
  00157	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0015c	48 8b 54 24 40	 mov	 rdx, QWORD PTR fast_ac$[rsp]
  00161	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN8@stbi__buil:
$LN6@stbi__buil:
$LN5@stbi__buil:

; 2047 :             }
; 2048 :         }
; 2049 :     }

  00165	e9 ae fe ff ff	 jmp	 $LN2@stbi__buil
$LN3@stbi__buil:

; 2050 : }

  0016a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016e	c3		 ret	 0
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ENDP	; stbi__build_fast_ac
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
j$ = 32
k$ = 36
i$ = 40
code$ = 44
s$1 = 48
tv236 = 52
m$2 = 56
c$3 = 60
h$ = 80
count$ = 88
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z PROC	; stbi__build_huffman

; 1984 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1985 :     int i,j,k=0;

  0000f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 1986 :     unsigned int code;
; 1987 :     // build size list for each symbol (from JPEG spec)
; 1988 :     for (i=0; i < 16; ++i)

  00017	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 0a		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  00021	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
  0002b	83 7c 24 28 10	 cmp	 DWORD PTR i$[rsp], 16
  00030	7d 4c		 jge	 SHORT $LN3@stbi__buil

; 1989 :         for (j=0; j < count[i]; ++j)

  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0003a	eb 0a		 jmp	 SHORT $LN7@stbi__buil
$LN5@stbi__buil:
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__buil:
  00046	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0004b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR count$[rsp]
  00050	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00053	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  00057	7d 23		 jge	 SHORT $LN6@stbi__buil

; 1990 :         h->size[k++] = (stbi_uc) (i+1);

  00059	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00064	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  00069	88 84 0a 00 05
	00 00		 mov	 BYTE PTR [rdx+rcx+1280], al
  00070	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00074	ff c0		 inc	 eax
  00076	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  0007a	eb c0		 jmp	 SHORT $LN5@stbi__buil
$LN6@stbi__buil:
  0007c	eb a3		 jmp	 SHORT $LN2@stbi__buil
$LN3@stbi__buil:

; 1991 :     h->size[k] = 0;

  0007e	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00088	c6 84 01 00 05
	00 00 00	 mov	 BYTE PTR [rcx+rax+1280], 0

; 1992 :     
; 1993 :     // compute actual symbols (from jpeg spec)
; 1994 :     code = 0;

  00090	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 1995 :     k = 0;

  00098	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 1996 :     for(j=1; j <= 16; ++j) {

  000a0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
  000a8	eb 0a		 jmp	 SHORT $LN10@stbi__buil
$LN8@stbi__buil:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  000ae	ff c0		 inc	 eax
  000b0	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN10@stbi__buil:
  000b4	83 7c 24 20 10	 cmp	 DWORD PTR j$[rsp], 16
  000b9	0f 8f d4 00 00
	00		 jg	 $LN9@stbi__buil

; 1997 :         // compute delta to add to code to compute symbol id
; 1998 :         h->delta[j] = k - code;

  000bf	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  000c3	8b 4c 24 24	 mov	 ecx, DWORD PTR k$[rsp]
  000c7	2b c8		 sub	 ecx, eax
  000c9	8b c1		 mov	 eax, ecx
  000cb	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR j$[rsp]
  000d0	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  000d5	89 84 8a 4c 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1612], eax

; 1999 :         if (h->size[k] == j) {

  000dc	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  000e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  000e6	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  000ee	3b 44 24 20	 cmp	 eax, DWORD PTR j$[rsp]
  000f2	75 6d		 jne	 SHORT $LN19@stbi__buil
$LN11@stbi__buil:

; 2000 :             while (h->size[k] == j)

  000f4	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  000f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  000fe	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00106	3b 44 24 20	 cmp	 eax, DWORD PTR j$[rsp]
  0010a	75 2d		 jne	 SHORT $LN12@stbi__buil

; 2001 :                 h->code[k++] = (stbi__uint16) (code++);

  0010c	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00116	0f b7 54 24 2c	 movzx	 edx, WORD PTR code$[rsp]
  0011b	66 89 94 41 00
	02 00 00	 mov	 WORD PTR [rcx+rax*2+512], dx
  00123	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00127	ff c0		 inc	 eax
  00129	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  0012d	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00131	ff c0		 inc	 eax
  00133	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax
  00137	eb bb		 jmp	 SHORT $LN11@stbi__buil
$LN12@stbi__buil:

; 2002 :             if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");

  00139	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  0013d	ff c8		 dec	 eax
  0013f	8b 4c 24 20	 mov	 ecx, DWORD PTR j$[rsp]
  00143	ba 01 00 00 00	 mov	 edx, 1
  00148	d3 e2		 shl	 edx, cl
  0014a	8b ca		 mov	 ecx, edx
  0014c	3b c1		 cmp	 eax, ecx
  0014e	72 11		 jb	 SHORT $LN20@stbi__buil
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36175
  00157	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015c	e9 21 01 00 00	 jmp	 $LN1@stbi__buil
$LN20@stbi__buil:
$LN19@stbi__buil:

; 2003 :         }
; 2004 :         // compute largest code + 1 for this size, preshifted as needed later
; 2005 :         h->maxcode[j] = code << (16-j);

  00161	b8 10 00 00 00	 mov	 eax, 16
  00166	2b 44 24 20	 sub	 eax, DWORD PTR j$[rsp]
  0016a	0f b6 c8	 movzx	 ecx, al
  0016d	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00171	d3 e0		 shl	 eax, cl
  00173	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR j$[rsp]
  00178	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  0017d	89 84 8a 04 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1540], eax

; 2006 :         code <<= 1;

  00184	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00188	d1 e0		 shl	 eax, 1
  0018a	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax

; 2007 :     }

  0018e	e9 17 ff ff ff	 jmp	 $LN8@stbi__buil
$LN9@stbi__buil:

; 2008 :     h->maxcode[j] = 0xffffffff;

  00193	48 63 44 24 20	 movsxd	 rax, DWORD PTR j$[rsp]
  00198	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  0019d	c7 84 81 04 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+1540], -1 ; ffffffffH

; 2009 :     
; 2010 :     // build non-spec acceleration table; 255 is flag for not-accelerated
; 2011 :     memset(h->fast, 255, 1 << FAST_BITS);

  001a8	48 8b 44 24 50	 mov	 rax, QWORD PTR h$[rsp]
  001ad	48 8b 7c 24 50	 mov	 rdi, QWORD PTR h$[rsp]
  001b2	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001b7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001bc	f3 aa		 rep stosb

; 2012 :     for (i=0; i < k; ++i) {

  001be	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c6	eb 0a		 jmp	 SHORT $LN15@stbi__buil
$LN13@stbi__buil:
  001c8	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN15@stbi__buil:
  001d2	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  001d6	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  001da	0f 8d 9d 00 00
	00		 jge	 $LN14@stbi__buil

; 2013 :         int s = h->size[i];

  001e0	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  001ea	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  001f2	89 44 24 30	 mov	 DWORD PTR s$1[rsp], eax

; 2014 :         if (s <= FAST_BITS) {

  001f6	83 7c 24 30 09	 cmp	 DWORD PTR s$1[rsp], 9
  001fb	7f 7b		 jg	 SHORT $LN21@stbi__buil

; 2015 :             int c = h->code[i] << (FAST_BITS-s);

  001fd	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00202	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00207	0f b7 84 41 00
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+512]
  0020f	b9 09 00 00 00	 mov	 ecx, 9
  00214	2b 4c 24 30	 sub	 ecx, DWORD PTR s$1[rsp]
  00218	d3 e0		 shl	 eax, cl
  0021a	89 44 24 3c	 mov	 DWORD PTR c$3[rsp], eax

; 2016 :             int m = 1 << (FAST_BITS-s);

  0021e	b8 09 00 00 00	 mov	 eax, 9
  00223	2b 44 24 30	 sub	 eax, DWORD PTR s$1[rsp]
  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	89 4c 24 34	 mov	 DWORD PTR tv236[rsp], ecx
  00230	0f b6 c8	 movzx	 ecx, al
  00233	8b 44 24 34	 mov	 eax, DWORD PTR tv236[rsp]
  00237	d3 e0		 shl	 eax, cl
  00239	89 44 24 38	 mov	 DWORD PTR m$2[rsp], eax

; 2017 :             for (j=0; j < m; ++j) {

  0023d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00245	eb 0a		 jmp	 SHORT $LN18@stbi__buil
$LN16@stbi__buil:
  00247	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  0024b	ff c0		 inc	 eax
  0024d	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN18@stbi__buil:
  00251	8b 44 24 38	 mov	 eax, DWORD PTR m$2[rsp]
  00255	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  00259	7d 1d		 jge	 SHORT $LN17@stbi__buil

; 2018 :                 h->fast[c+j] = (stbi_uc) i;

  0025b	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  0025f	8b 4c 24 3c	 mov	 ecx, DWORD PTR c$3[rsp]
  00263	03 c8		 add	 ecx, eax
  00265	8b c1		 mov	 eax, ecx
  00267	48 98		 cdqe
  00269	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  0026e	0f b6 54 24 28	 movzx	 edx, BYTE PTR i$[rsp]
  00273	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 2019 :             }

  00276	eb cf		 jmp	 SHORT $LN16@stbi__buil
$LN17@stbi__buil:
$LN21@stbi__buil:

; 2020 :         }
; 2021 :     }

  00278	e9 4b ff ff ff	 jmp	 $LN13@stbi__buil
$LN14@stbi__buil:

; 2022 :     return 1;

  0027d	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__buil:

; 2023 : }

  00282	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00286	5f		 pop	 rdi
  00287	c3		 ret	 0
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ENDP	; stbi__build_huffman
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
dest$1 = 40
src$2 = 48
j$ = 56
tv95 = 60
tv79 = 64
tv351 = 68
good$ = 72
tv259 = 80
tv279 = 84
tv301 = 88
tv321 = 92
data$ = 112
img_n$ = 120
req_comp$ = 128
x$ = 136
y$ = 144
?stbi__convert_format16@@YAPEAGPEAGHHII@Z PROC		; stbi__convert_format16

; 1793 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1794 :     int i,j;
; 1795 :     stbi__uint16 *good;
; 1796 :     
; 1797 :     if (req_comp == img_n) return data;

  00017	8b 44 24 78	 mov	 eax, DWORD PTR img_n$[rsp]
  0001b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00022	75 0a		 jne	 SHORT $LN43@stbi__conv
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR data$[rsp]
  00029	e9 de 09 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1798 :     STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  0002e	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR req_comp$[rsp], 1
  00036	7c 0a		 jl	 SHORT $LN45@stbi__conv
  00038	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00040	7e 0b		 jle	 SHORT $LN44@stbi__conv
$LN45@stbi__conv:
  00042	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN44@stbi__conv:

; 1799 :     
; 1800 :     good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);

  0004d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00054	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  0005c	0f af 84 24 90
	00 00 00	 imul	 eax, DWORD PTR y$[rsp]
  00064	d1 e0		 shl	 eax, 1
  00066	8b c0		 mov	 eax, eax
  00068	8b c8		 mov	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0006f	48 89 44 24 48	 mov	 QWORD PTR good$[rsp], rax

; 1801 :     if (good == NULL) {

  00074	48 83 7c 24 48
	00		 cmp	 QWORD PTR good$[rsp], 0
  0007a	75 36		 jne	 SHORT $LN46@stbi__conv

; 1802 :         STBI_FREE(data);

  0007c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  00081	e8 00 00 00 00	 call	 free

; 1803 :         return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35955
  0008d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00092	85 c0		 test	 eax, eax
  00094	74 0a		 je	 SHORT $LN62@stbi__conv
  00096	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
  0009e	eb 08		 jmp	 SHORT $LN63@stbi__conv
$LN62@stbi__conv:
  000a0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN63@stbi__conv:
  000a8	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv79[rsp]
  000ad	e9 5a 09 00 00	 jmp	 $LN1@stbi__conv
$LN46@stbi__conv:

; 1804 :     }
; 1805 :     
; 1806 :     for (j=0; j < (int) y; ++j) {

  000b2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000ba	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000bc	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000c0	ff c0		 inc	 eax
  000c2	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
  000c6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  000cd	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  000d1	0f 8d 26 09 00
	00		 jge	 $LN3@stbi__conv

; 1807 :         stbi__uint16 *src  = data + j * x * img_n   ;

  000d7	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000db	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  000e3	0f af 44 24 78	 imul	 eax, DWORD PTR img_n$[rsp]
  000e8	8b c0		 mov	 eax, eax
  000ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  000ef	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  000f3	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax

; 1808 :         stbi__uint16 *dest = good + j * x * req_comp;

  000f8	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000fc	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00104	0f af 84 24 80
	00 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0010c	8b c0		 mov	 eax, eax
  0010e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  00113	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00117	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax

; 1809 :         
; 1810 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1811 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1812 :         // convert source image with img_n components to one with req_comp components;
; 1813 :         // avoid switch per pixel, so use switch per scanline and massive macros
; 1814 :         switch (STBI__COMBO(img_n, req_comp)) {

  0011c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00123	8b 4c 24 78	 mov	 ecx, DWORD PTR img_n$[rsp]
  00127	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0012a	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  0012e	8b 44 24 3c	 mov	 eax, DWORD PTR tv95[rsp]
  00132	83 e8 0a	 sub	 eax, 10
  00135	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  00139	83 7c 24 3c 19	 cmp	 DWORD PTR tv95[rsp], 25
  0013e	0f 87 65 08 00
	00		 ja	 $LN59@stbi__conv
  00144	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv95[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00150	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  00157	48 03 c1	 add	 rax, rcx
  0015a	ff e0		 jmp	 rax
$LN47@stbi__conv:

; 1815 :             STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;

  0015c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00163	ff c8		 dec	 eax
  00165	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00169	eb 26		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0016b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016f	ff c8		 dec	 eax
  00171	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0017a	48 83 c0 02	 add	 rax, 2
  0017e	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00183	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00188	48 83 c0 04	 add	 rax, 4
  0018c	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN9@stbi__conv:
  00191	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00196	7c 3e		 jl	 SHORT $LN8@stbi__conv
  00198	b8 02 00 00 00	 mov	 eax, 2
  0019d	48 6b c0 00	 imul	 rax, rax, 0
  001a1	b9 02 00 00 00	 mov	 ecx, 2
  001a6	48 6b c9 00	 imul	 rcx, rcx, 0
  001aa	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  001af	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  001b4	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  001b9	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  001bd	b8 02 00 00 00	 mov	 eax, 2
  001c2	48 6b c0 01	 imul	 rax, rax, 1
  001c6	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001cb	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  001d0	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  001d4	eb 95		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  001d6	e9 1d 08 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1816 :             STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

  001db	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  001e2	ff c8		 dec	 eax
  001e4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001e8	eb 26		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  001ea	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001ee	ff c8		 dec	 eax
  001f0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001f4	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  001f9	48 83 c0 02	 add	 rax, 2
  001fd	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00202	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00207	48 83 c0 06	 add	 rax, 6
  0020b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN12@stbi__conv:
  00210	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00215	7c 74		 jl	 SHORT $LN11@stbi__conv
  00217	b8 02 00 00 00	 mov	 eax, 2
  0021c	48 6b c0 00	 imul	 rax, rax, 0
  00220	b9 02 00 00 00	 mov	 ecx, 2
  00225	48 6b c9 02	 imul	 rcx, rcx, 2
  00229	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0022e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00233	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00238	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0023c	b8 02 00 00 00	 mov	 eax, 2
  00241	48 6b c0 02	 imul	 rax, rax, 2
  00245	b9 02 00 00 00	 mov	 ecx, 2
  0024a	48 6b c9 01	 imul	 rcx, rcx, 1
  0024e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00253	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00258	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0025d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00261	b8 02 00 00 00	 mov	 eax, 2
  00266	48 6b c0 01	 imul	 rax, rax, 1
  0026a	b9 02 00 00 00	 mov	 ecx, 2
  0026f	48 6b c9 00	 imul	 rcx, rcx, 0
  00273	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00278	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0027d	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00282	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00286	e9 5f ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  0028b	e9 68 07 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1817 :             STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;

  00290	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00297	ff c8		 dec	 eax
  00299	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0029d	eb 26		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  0029f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002a3	ff c8		 dec	 eax
  002a5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002a9	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  002ae	48 83 c0 02	 add	 rax, 2
  002b2	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  002b7	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  002bc	48 83 c0 08	 add	 rax, 8
  002c0	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN15@stbi__conv:
  002c5	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002ca	0f 8c 8b 00 00
	00		 jl	 $LN14@stbi__conv
  002d0	b8 02 00 00 00	 mov	 eax, 2
  002d5	48 6b c0 00	 imul	 rax, rax, 0
  002d9	b9 02 00 00 00	 mov	 ecx, 2
  002de	48 6b c9 02	 imul	 rcx, rcx, 2
  002e2	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  002e7	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  002ec	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  002f1	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  002f5	b8 02 00 00 00	 mov	 eax, 2
  002fa	48 6b c0 02	 imul	 rax, rax, 2
  002fe	b9 02 00 00 00	 mov	 ecx, 2
  00303	48 6b c9 01	 imul	 rcx, rcx, 1
  00307	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0030c	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00311	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00316	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0031a	b8 02 00 00 00	 mov	 eax, 2
  0031f	48 6b c0 01	 imul	 rax, rax, 1
  00323	b9 02 00 00 00	 mov	 ecx, 2
  00328	48 6b c9 00	 imul	 rcx, rcx, 0
  0032c	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00331	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00336	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0033b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0033f	b8 02 00 00 00	 mov	 eax, 2
  00344	48 6b c0 03	 imul	 rax, rax, 3
  00348	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0034d	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00352	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00356	e9 44 ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  0035b	e9 98 06 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1818 :             STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;

  00360	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00367	ff c8		 dec	 eax
  00369	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0036d	eb 26		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  0036f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00373	ff c8		 dec	 eax
  00375	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00379	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0037e	48 83 c0 04	 add	 rax, 4
  00382	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00387	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  0038c	48 83 c0 02	 add	 rax, 2
  00390	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN18@stbi__conv:
  00395	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0039a	7c 27		 jl	 SHORT $LN17@stbi__conv
  0039c	b8 02 00 00 00	 mov	 eax, 2
  003a1	48 6b c0 00	 imul	 rax, rax, 0
  003a5	b9 02 00 00 00	 mov	 ecx, 2
  003aa	48 6b c9 00	 imul	 rcx, rcx, 0
  003ae	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  003b3	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  003b8	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  003bd	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  003c1	eb ac		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003c3	e9 30 06 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1819 :             STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

  003c8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003cf	ff c8		 dec	 eax
  003d1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003d5	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  003d7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003db	ff c8		 dec	 eax
  003dd	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003e1	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  003e6	48 83 c0 04	 add	 rax, 4
  003ea	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  003ef	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  003f4	48 83 c0 06	 add	 rax, 6
  003f8	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN21@stbi__conv:
  003fd	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00402	7c 74		 jl	 SHORT $LN20@stbi__conv
  00404	b8 02 00 00 00	 mov	 eax, 2
  00409	48 6b c0 00	 imul	 rax, rax, 0
  0040d	b9 02 00 00 00	 mov	 ecx, 2
  00412	48 6b c9 02	 imul	 rcx, rcx, 2
  00416	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0041b	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00420	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00425	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00429	b8 02 00 00 00	 mov	 eax, 2
  0042e	48 6b c0 02	 imul	 rax, rax, 2
  00432	b9 02 00 00 00	 mov	 ecx, 2
  00437	48 6b c9 01	 imul	 rcx, rcx, 1
  0043b	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00440	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00445	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0044a	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0044e	b8 02 00 00 00	 mov	 eax, 2
  00453	48 6b c0 01	 imul	 rax, rax, 1
  00457	b9 02 00 00 00	 mov	 ecx, 2
  0045c	48 6b c9 00	 imul	 rcx, rcx, 0
  00460	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00465	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0046a	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0046f	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00473	e9 5f ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  00478	e9 7b 05 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1820 :             STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;

  0047d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00484	ff c8		 dec	 eax
  00486	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0048a	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  0048c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00490	ff c8		 dec	 eax
  00492	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00496	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0049b	48 83 c0 04	 add	 rax, 4
  0049f	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  004a4	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  004a9	48 83 c0 08	 add	 rax, 8
  004ad	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN24@stbi__conv:
  004b2	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  004b7	0f 8c 99 00 00
	00		 jl	 $LN23@stbi__conv
  004bd	b8 02 00 00 00	 mov	 eax, 2
  004c2	48 6b c0 00	 imul	 rax, rax, 0
  004c6	b9 02 00 00 00	 mov	 ecx, 2
  004cb	48 6b c9 02	 imul	 rcx, rcx, 2
  004cf	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004d4	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  004d9	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  004de	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  004e2	b8 02 00 00 00	 mov	 eax, 2
  004e7	48 6b c0 02	 imul	 rax, rax, 2
  004eb	b9 02 00 00 00	 mov	 ecx, 2
  004f0	48 6b c9 01	 imul	 rcx, rcx, 1
  004f4	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004f9	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  004fe	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00503	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00507	b8 02 00 00 00	 mov	 eax, 2
  0050c	48 6b c0 01	 imul	 rax, rax, 1
  00510	b9 02 00 00 00	 mov	 ecx, 2
  00515	48 6b c9 00	 imul	 rcx, rcx, 0
  00519	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0051e	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00523	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00528	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0052c	b8 02 00 00 00	 mov	 eax, 2
  00531	48 6b c0 01	 imul	 rax, rax, 1
  00535	b9 02 00 00 00	 mov	 ecx, 2
  0053a	48 6b c9 03	 imul	 rcx, rcx, 3
  0053e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00543	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00548	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0054d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00551	e9 36 ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  00556	e9 9d 04 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1821 :             STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;

  0055b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00562	ff c8		 dec	 eax
  00564	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00568	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  0056a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0056e	ff c8		 dec	 eax
  00570	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00574	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00579	48 83 c0 06	 add	 rax, 6
  0057d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00582	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00587	48 83 c0 08	 add	 rax, 8
  0058b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN27@stbi__conv:
  00590	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00595	0f 8c 8b 00 00
	00		 jl	 $LN26@stbi__conv
  0059b	b8 02 00 00 00	 mov	 eax, 2
  005a0	48 6b c0 00	 imul	 rax, rax, 0
  005a4	b9 02 00 00 00	 mov	 ecx, 2
  005a9	48 6b c9 00	 imul	 rcx, rcx, 0
  005ad	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005b2	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005b7	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  005bc	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  005c0	b8 02 00 00 00	 mov	 eax, 2
  005c5	48 6b c0 01	 imul	 rax, rax, 1
  005c9	b9 02 00 00 00	 mov	 ecx, 2
  005ce	48 6b c9 01	 imul	 rcx, rcx, 1
  005d2	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005d7	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005dc	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  005e1	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  005e5	b8 02 00 00 00	 mov	 eax, 2
  005ea	48 6b c0 02	 imul	 rax, rax, 2
  005ee	b9 02 00 00 00	 mov	 ecx, 2
  005f3	48 6b c9 02	 imul	 rcx, rcx, 2
  005f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005fc	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00601	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00606	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0060a	b8 02 00 00 00	 mov	 eax, 2
  0060f	48 6b c0 03	 imul	 rax, rax, 3
  00613	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00618	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0061d	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00621	e9 44 ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00626	e9 cd 03 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1822 :             STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

  0062b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00632	ff c8		 dec	 eax
  00634	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00638	eb 26		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  0063a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0063e	ff c8		 dec	 eax
  00640	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00644	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00649	48 83 c0 06	 add	 rax, 6
  0064d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00652	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00657	48 83 c0 02	 add	 rax, 2
  0065b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN30@stbi__conv:
  00660	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00665	7c 62		 jl	 SHORT $LN29@stbi__conv
  00667	b8 02 00 00 00	 mov	 eax, 2
  0066c	48 6b c0 02	 imul	 rax, rax, 2
  00670	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00675	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00679	b9 02 00 00 00	 mov	 ecx, 2
  0067e	48 6b c9 01	 imul	 rcx, rcx, 1
  00682	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  00687	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0068b	ba 02 00 00 00	 mov	 edx, 2
  00690	48 6b d2 00	 imul	 rdx, rdx, 0
  00694	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00699	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  0069e	89 54 24 50	 mov	 DWORD PTR tv259[rsp], edx
  006a2	44 8b c0	 mov	 r8d, eax
  006a5	8b d1		 mov	 edx, ecx
  006a7	8b 44 24 50	 mov	 eax, DWORD PTR tv259[rsp]
  006ab	8b c8		 mov	 ecx, eax
  006ad	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  006b2	b9 02 00 00 00	 mov	 ecx, 2
  006b7	48 6b c9 00	 imul	 rcx, rcx, 0
  006bb	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  006c0	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  006c4	e9 71 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006c9	e9 2a 03 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1823 :             STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

  006ce	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  006d5	ff c8		 dec	 eax
  006d7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006db	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  006dd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006e1	ff c8		 dec	 eax
  006e3	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006e7	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  006ec	48 83 c0 06	 add	 rax, 6
  006f0	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  006f5	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  006fa	48 83 c0 04	 add	 rax, 4
  006fe	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN33@stbi__conv:
  00703	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00708	7c 79		 jl	 SHORT $LN32@stbi__conv
  0070a	b8 02 00 00 00	 mov	 eax, 2
  0070f	48 6b c0 02	 imul	 rax, rax, 2
  00713	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00718	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0071c	b9 02 00 00 00	 mov	 ecx, 2
  00721	48 6b c9 01	 imul	 rcx, rcx, 1
  00725	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  0072a	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0072e	ba 02 00 00 00	 mov	 edx, 2
  00733	48 6b d2 00	 imul	 rdx, rdx, 0
  00737	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0073c	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  00741	89 54 24 54	 mov	 DWORD PTR tv279[rsp], edx
  00745	44 8b c0	 mov	 r8d, eax
  00748	8b d1		 mov	 edx, ecx
  0074a	8b 44 24 54	 mov	 eax, DWORD PTR tv279[rsp]
  0074e	8b c8		 mov	 ecx, eax
  00750	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  00755	b9 02 00 00 00	 mov	 ecx, 2
  0075a	48 6b c9 00	 imul	 rcx, rcx, 0
  0075e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00763	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00767	b8 02 00 00 00	 mov	 eax, 2
  0076c	48 6b c0 01	 imul	 rax, rax, 1
  00770	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00775	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0077a	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  0077e	e9 5a ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  00783	e9 70 02 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1824 :             STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

  00788	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0078f	ff c8		 dec	 eax
  00791	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00795	eb 26		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  00797	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0079b	ff c8		 dec	 eax
  0079d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007a1	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  007a6	48 83 c0 08	 add	 rax, 8
  007aa	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  007af	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  007b4	48 83 c0 02	 add	 rax, 2
  007b8	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN36@stbi__conv:
  007bd	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  007c2	7c 62		 jl	 SHORT $LN35@stbi__conv
  007c4	b8 02 00 00 00	 mov	 eax, 2
  007c9	48 6b c0 02	 imul	 rax, rax, 2
  007cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  007d2	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  007d6	b9 02 00 00 00	 mov	 ecx, 2
  007db	48 6b c9 01	 imul	 rcx, rcx, 1
  007df	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  007e4	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  007e8	ba 02 00 00 00	 mov	 edx, 2
  007ed	48 6b d2 00	 imul	 rdx, rdx, 0
  007f1	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  007f6	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  007fb	89 54 24 58	 mov	 DWORD PTR tv301[rsp], edx
  007ff	44 8b c0	 mov	 r8d, eax
  00802	8b d1		 mov	 edx, ecx
  00804	8b 44 24 58	 mov	 eax, DWORD PTR tv301[rsp]
  00808	8b c8		 mov	 ecx, eax
  0080a	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  0080f	b9 02 00 00 00	 mov	 ecx, 2
  00814	48 6b c9 00	 imul	 rcx, rcx, 0
  00818	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0081d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00821	e9 71 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  00826	e9 cd 01 00 00	 jmp	 $LN5@stbi__conv
$LN57@stbi__conv:

; 1825 :             STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

  0082b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00832	ff c8		 dec	 eax
  00834	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00838	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  0083a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0083e	ff c8		 dec	 eax
  00840	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00844	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00849	48 83 c0 08	 add	 rax, 8
  0084d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00852	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00857	48 83 c0 04	 add	 rax, 4
  0085b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN39@stbi__conv:
  00860	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00865	0f 8c 87 00 00
	00		 jl	 $LN38@stbi__conv
  0086b	b8 02 00 00 00	 mov	 eax, 2
  00870	48 6b c0 02	 imul	 rax, rax, 2
  00874	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00879	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0087d	b9 02 00 00 00	 mov	 ecx, 2
  00882	48 6b c9 01	 imul	 rcx, rcx, 1
  00886	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  0088b	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0088f	ba 02 00 00 00	 mov	 edx, 2
  00894	48 6b d2 00	 imul	 rdx, rdx, 0
  00898	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0089d	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  008a2	89 54 24 5c	 mov	 DWORD PTR tv321[rsp], edx
  008a6	44 8b c0	 mov	 r8d, eax
  008a9	8b d1		 mov	 edx, ecx
  008ab	8b 44 24 5c	 mov	 eax, DWORD PTR tv321[rsp]
  008af	8b c8		 mov	 ecx, eax
  008b1	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  008b6	b9 02 00 00 00	 mov	 ecx, 2
  008bb	48 6b c9 00	 imul	 rcx, rcx, 0
  008bf	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008c4	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  008c8	b8 02 00 00 00	 mov	 eax, 2
  008cd	48 6b c0 03	 imul	 rax, rax, 3
  008d1	b9 02 00 00 00	 mov	 ecx, 2
  008d6	48 6b c9 01	 imul	 rcx, rcx, 1
  008da	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008df	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  008e4	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  008e9	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  008ed	e9 48 ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  008f2	e9 01 01 00 00	 jmp	 $LN5@stbi__conv
$LN58@stbi__conv:

; 1826 :             STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;

  008f7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  008fe	ff c8		 dec	 eax
  00900	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00904	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  00906	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0090a	ff c8		 dec	 eax
  0090c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00910	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00915	48 83 c0 08	 add	 rax, 8
  00919	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0091e	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00923	48 83 c0 06	 add	 rax, 6
  00927	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN42@stbi__conv:
  0092c	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00931	7c 74		 jl	 SHORT $LN41@stbi__conv
  00933	b8 02 00 00 00	 mov	 eax, 2
  00938	48 6b c0 00	 imul	 rax, rax, 0
  0093c	b9 02 00 00 00	 mov	 ecx, 2
  00941	48 6b c9 00	 imul	 rcx, rcx, 0
  00945	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0094a	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0094f	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00954	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00958	b8 02 00 00 00	 mov	 eax, 2
  0095d	48 6b c0 01	 imul	 rax, rax, 1
  00961	b9 02 00 00 00	 mov	 ecx, 2
  00966	48 6b c9 01	 imul	 rcx, rcx, 1
  0096a	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0096f	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00974	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00979	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0097d	b8 02 00 00 00	 mov	 eax, 2
  00982	48 6b c0 02	 imul	 rax, rax, 2
  00986	b9 02 00 00 00	 mov	 ecx, 2
  0098b	48 6b c9 02	 imul	 rcx, rcx, 2
  0098f	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00994	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00999	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0099e	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009a2	e9 5f ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  009a7	eb 4f		 jmp	 SHORT $LN5@stbi__conv
$LN59@stbi__conv:

; 1827 :             default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");

  009a9	33 c0		 xor	 eax, eax
  009ab	83 f8 01	 cmp	 eax, 1
  009ae	74 0b		 je	 SHORT $LN60@stbi__conv
  009b0	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN60@stbi__conv:
  009bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  009c0	e8 00 00 00 00	 call	 free
  009c5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  009ca	e8 00 00 00 00	 call	 free
  009cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35970
  009d6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  009db	85 c0		 test	 eax, eax
  009dd	74 0a		 je	 SHORT $LN64@stbi__conv
  009df	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv351[rsp], 0
  009e7	eb 08		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  009e9	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv351[rsp], 0
$LN65@stbi__conv:
  009f1	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv351[rsp]
  009f6	eb 14		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1828 :         }
; 1829 : #undef STBI__CASE
; 1830 :     }

  009f8	e9 bf f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1831 :     
; 1832 :     STBI_FREE(data);

  009fd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  00a02	e8 00 00 00 00	 call	 free

; 1833 :     return good;

  00a07	48 8b 44 24 48	 mov	 rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1834 : }

  00a0c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00a10	c3		 ret	 0
  00a11	0f 1f 00	 npad	 3
$LN66@stbi__conv:
  00a14	00 00 00 00	 DD	 $LN47@stbi__conv
  00a18	00 00 00 00	 DD	 $LN48@stbi__conv
  00a1c	00 00 00 00	 DD	 $LN49@stbi__conv
  00a20	00 00 00 00	 DD	 $LN59@stbi__conv
  00a24	00 00 00 00	 DD	 $LN59@stbi__conv
  00a28	00 00 00 00	 DD	 $LN59@stbi__conv
  00a2c	00 00 00 00	 DD	 $LN59@stbi__conv
  00a30	00 00 00 00	 DD	 $LN50@stbi__conv
  00a34	00 00 00 00	 DD	 $LN59@stbi__conv
  00a38	00 00 00 00	 DD	 $LN51@stbi__conv
  00a3c	00 00 00 00	 DD	 $LN52@stbi__conv
  00a40	00 00 00 00	 DD	 $LN59@stbi__conv
  00a44	00 00 00 00	 DD	 $LN59@stbi__conv
  00a48	00 00 00 00	 DD	 $LN59@stbi__conv
  00a4c	00 00 00 00	 DD	 $LN59@stbi__conv
  00a50	00 00 00 00	 DD	 $LN54@stbi__conv
  00a54	00 00 00 00	 DD	 $LN55@stbi__conv
  00a58	00 00 00 00	 DD	 $LN59@stbi__conv
  00a5c	00 00 00 00	 DD	 $LN53@stbi__conv
  00a60	00 00 00 00	 DD	 $LN59@stbi__conv
  00a64	00 00 00 00	 DD	 $LN59@stbi__conv
  00a68	00 00 00 00	 DD	 $LN59@stbi__conv
  00a6c	00 00 00 00	 DD	 $LN59@stbi__conv
  00a70	00 00 00 00	 DD	 $LN56@stbi__conv
  00a74	00 00 00 00	 DD	 $LN57@stbi__conv
  00a78	00 00 00 00	 DD	 $LN58@stbi__conv
?stbi__convert_format16@@YAPEAGPEAGHHII@Z ENDP		; stbi__convert_format16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y_16@@YAGHHH@Z PROC			; stbi__compute_y_16

; 1784 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1785 :     return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

  0000d	6b 44 24 08 4d	 imul	 eax, DWORD PTR r$[rsp], 77 ; 0000004dH
  00012	69 4c 24 10 96
	00 00 00	 imul	 ecx, DWORD PTR g$[rsp], 150 ; 00000096H
  0001a	03 c1		 add	 eax, ecx
  0001c	6b 4c 24 18 1d	 imul	 ecx, DWORD PTR b$[rsp], 29
  00021	03 c1		 add	 eax, ecx
  00023	c1 f8 08	 sar	 eax, 8

; 1786 : }

  00026	c3		 ret	 0
?stbi__compute_y_16@@YAGHHH@Z ENDP			; stbi__compute_y_16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
dest$1 = 40
src$2 = 48
j$ = 56
tv92 = 60
tv78 = 64
tv348 = 68
good$ = 72
tv256 = 80
tv276 = 84
tv298 = 88
tv318 = 92
data$ = 112
img_n$ = 120
req_comp$ = 128
x$ = 136
y$ = 144
?stbi__convert_format@@YAPEAEPEAEHHII@Z PROC		; stbi__convert_format

; 1736 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1737 :     int i,j;
; 1738 :     unsigned char *good;
; 1739 :     
; 1740 :     if (req_comp == img_n) return data;

  00017	8b 44 24 78	 mov	 eax, DWORD PTR img_n$[rsp]
  0001b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00022	75 0a		 jne	 SHORT $LN43@stbi__conv
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR data$[rsp]
  00029	e9 aa 09 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1741 :     STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  0002e	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR req_comp$[rsp], 1
  00036	7c 0a		 jl	 SHORT $LN45@stbi__conv
  00038	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00040	7e 0b		 jle	 SHORT $LN44@stbi__conv
$LN45@stbi__conv:
  00042	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN44@stbi__conv:

; 1742 :     
; 1743 :     good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);

  0004d	45 33 c9	 xor	 r9d, r9d
  00050	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR y$[rsp]
  00058	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR x$[rsp]
  0005f	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  00066	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0006b	48 89 44 24 48	 mov	 QWORD PTR good$[rsp], rax

; 1744 :     if (good == NULL) {

  00070	48 83 7c 24 48
	00		 cmp	 QWORD PTR good$[rsp], 0
  00076	75 36		 jne	 SHORT $LN46@stbi__conv

; 1745 :         STBI_FREE(data);

  00078	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  0007d	e8 00 00 00 00	 call	 free

; 1746 :         return stbi__errpuc("outofmem", "Out of memory");

  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35866
  00089	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0008e	85 c0		 test	 eax, eax
  00090	74 0a		 je	 SHORT $LN62@stbi__conv
  00092	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  0009a	eb 08		 jmp	 SHORT $LN63@stbi__conv
$LN62@stbi__conv:
  0009c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN63@stbi__conv:
  000a4	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv78[rsp]
  000a9	e9 2a 09 00 00	 jmp	 $LN1@stbi__conv
$LN46@stbi__conv:

; 1747 :     }
; 1748 :     
; 1749 :     for (j=0; j < (int) y; ++j) {

  000ae	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000b6	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000b8	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000bc	ff c0		 inc	 eax
  000be	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  000c9	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  000cd	0f 8d f6 08 00
	00		 jge	 $LN3@stbi__conv

; 1750 :         unsigned char *src  = data + j * x * img_n   ;

  000d3	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000d7	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  000df	0f af 44 24 78	 imul	 eax, DWORD PTR img_n$[rsp]
  000e4	8b c0		 mov	 eax, eax
  000e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  000eb	48 03 c8	 add	 rcx, rax
  000ee	48 8b c1	 mov	 rax, rcx
  000f1	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax

; 1751 :         unsigned char *dest = good + j * x * req_comp;

  000f6	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000fa	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00102	0f af 84 24 80
	00 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0010a	8b c0		 mov	 eax, eax
  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  00111	48 03 c8	 add	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax

; 1752 :         
; 1753 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1754 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1755 :         // convert source image with img_n components to one with req_comp components;
; 1756 :         // avoid switch per pixel, so use switch per scanline and massive macros
; 1757 :         switch (STBI__COMBO(img_n, req_comp)) {

  0011c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00123	8b 4c 24 78	 mov	 ecx, DWORD PTR img_n$[rsp]
  00127	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0012a	89 44 24 3c	 mov	 DWORD PTR tv92[rsp], eax
  0012e	8b 44 24 3c	 mov	 eax, DWORD PTR tv92[rsp]
  00132	83 e8 0a	 sub	 eax, 10
  00135	89 44 24 3c	 mov	 DWORD PTR tv92[rsp], eax
  00139	83 7c 24 3c 19	 cmp	 DWORD PTR tv92[rsp], 25
  0013e	0f 87 31 08 00
	00		 ja	 $LN59@stbi__conv
  00144	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv92[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00150	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  00157	48 03 c1	 add	 rax, rcx
  0015a	ff e0		 jmp	 rax
$LN47@stbi__conv:

; 1758 :             STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;

  0015c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00163	ff c8		 dec	 eax
  00165	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00169	eb 25		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0016b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016f	ff c8		 dec	 eax
  00171	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0017a	48 ff c0	 inc	 rax
  0017d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00182	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00187	48 83 c0 02	 add	 rax, 2
  0018b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN9@stbi__conv:
  00190	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00195	7c 38		 jl	 SHORT $LN8@stbi__conv
  00197	b8 01 00 00 00	 mov	 eax, 1
  0019c	48 6b c0 00	 imul	 rax, rax, 0
  001a0	b9 01 00 00 00	 mov	 ecx, 1
  001a5	48 6b c9 00	 imul	 rcx, rcx, 0
  001a9	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  001ae	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  001b3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001b8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001bb	b8 01 00 00 00	 mov	 eax, 1
  001c0	48 6b c0 01	 imul	 rax, rax, 1
  001c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  001c9	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  001cd	eb 9c		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  001cf	e9 f0 07 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1759 :             STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

  001d4	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  001db	ff c8		 dec	 eax
  001dd	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001e1	eb 25		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  001e3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e7	ff c8		 dec	 eax
  001e9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001ed	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  001f2	48 ff c0	 inc	 rax
  001f5	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  001fa	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  001ff	48 83 c0 03	 add	 rax, 3
  00203	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN12@stbi__conv:
  00208	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0020d	7c 71		 jl	 SHORT $LN11@stbi__conv
  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	48 6b c0 00	 imul	 rax, rax, 0
  00218	b9 01 00 00 00	 mov	 ecx, 1
  0021d	48 6b c9 02	 imul	 rcx, rcx, 2
  00221	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00226	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0022b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00230	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00233	b8 01 00 00 00	 mov	 eax, 1
  00238	48 6b c0 02	 imul	 rax, rax, 2
  0023c	b9 01 00 00 00	 mov	 ecx, 1
  00241	48 6b c9 01	 imul	 rcx, rcx, 1
  00245	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0024a	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0024f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00254	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00257	b8 01 00 00 00	 mov	 eax, 1
  0025c	48 6b c0 01	 imul	 rax, rax, 1
  00260	b9 01 00 00 00	 mov	 ecx, 1
  00265	48 6b c9 00	 imul	 rcx, rcx, 0
  00269	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0026e	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00273	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00278	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0027b	e9 63 ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  00280	e9 3f 07 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1760 :             STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;

  00285	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0028c	ff c8		 dec	 eax
  0028e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00292	eb 25		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  00294	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00298	ff c8		 dec	 eax
  0029a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0029e	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  002a3	48 ff c0	 inc	 rax
  002a6	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  002ab	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  002b0	48 83 c0 04	 add	 rax, 4
  002b4	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN15@stbi__conv:
  002b9	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002be	0f 8c 83 00 00
	00		 jl	 $LN14@stbi__conv
  002c4	b8 01 00 00 00	 mov	 eax, 1
  002c9	48 6b c0 00	 imul	 rax, rax, 0
  002cd	b9 01 00 00 00	 mov	 ecx, 1
  002d2	48 6b c9 02	 imul	 rcx, rcx, 2
  002d6	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  002db	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  002e0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002e5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002e8	b8 01 00 00 00	 mov	 eax, 1
  002ed	48 6b c0 02	 imul	 rax, rax, 2
  002f1	b9 01 00 00 00	 mov	 ecx, 1
  002f6	48 6b c9 01	 imul	 rcx, rcx, 1
  002fa	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  002ff	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00304	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00309	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0030c	b8 01 00 00 00	 mov	 eax, 1
  00311	48 6b c0 01	 imul	 rax, rax, 1
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	48 6b c9 00	 imul	 rcx, rcx, 0
  0031e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00323	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00328	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0032d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00330	b8 01 00 00 00	 mov	 eax, 1
  00335	48 6b c0 03	 imul	 rax, rax, 3
  00339	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  0033e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00342	e9 4d ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  00347	e9 78 06 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1761 :             STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;

  0034c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00353	ff c8		 dec	 eax
  00355	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00359	eb 25		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  0035b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0035f	ff c8		 dec	 eax
  00361	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00365	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0036a	48 83 c0 02	 add	 rax, 2
  0036e	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00373	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00378	48 ff c0	 inc	 rax
  0037b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN18@stbi__conv:
  00380	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00385	7c 26		 jl	 SHORT $LN17@stbi__conv
  00387	b8 01 00 00 00	 mov	 eax, 1
  0038c	48 6b c0 00	 imul	 rax, rax, 0
  00390	b9 01 00 00 00	 mov	 ecx, 1
  00395	48 6b c9 00	 imul	 rcx, rcx, 0
  00399	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0039e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  003a3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  003a8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003ab	eb ae		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003ad	e9 12 06 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1762 :             STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

  003b2	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003b9	ff c8		 dec	 eax
  003bb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003bf	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  003c1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003c5	ff c8		 dec	 eax
  003c7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003cb	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  003d0	48 83 c0 02	 add	 rax, 2
  003d4	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  003d9	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  003de	48 83 c0 03	 add	 rax, 3
  003e2	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN21@stbi__conv:
  003e7	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  003ec	7c 71		 jl	 SHORT $LN20@stbi__conv
  003ee	b8 01 00 00 00	 mov	 eax, 1
  003f3	48 6b c0 00	 imul	 rax, rax, 0
  003f7	b9 01 00 00 00	 mov	 ecx, 1
  003fc	48 6b c9 02	 imul	 rcx, rcx, 2
  00400	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00405	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0040a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0040f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00412	b8 01 00 00 00	 mov	 eax, 1
  00417	48 6b c0 02	 imul	 rax, rax, 2
  0041b	b9 01 00 00 00	 mov	 ecx, 1
  00420	48 6b c9 01	 imul	 rcx, rcx, 1
  00424	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00429	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0042e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00433	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00436	b8 01 00 00 00	 mov	 eax, 1
  0043b	48 6b c0 01	 imul	 rax, rax, 1
  0043f	b9 01 00 00 00	 mov	 ecx, 1
  00444	48 6b c9 00	 imul	 rcx, rcx, 0
  00448	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0044d	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00452	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00457	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0045a	e9 62 ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  0045f	e9 60 05 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1763 :             STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;

  00464	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0046b	ff c8		 dec	 eax
  0046d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00471	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  00473	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00477	ff c8		 dec	 eax
  00479	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0047d	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00482	48 83 c0 02	 add	 rax, 2
  00486	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0048b	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00490	48 83 c0 04	 add	 rax, 4
  00494	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN24@stbi__conv:
  00499	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0049e	0f 8c 95 00 00
	00		 jl	 $LN23@stbi__conv
  004a4	b8 01 00 00 00	 mov	 eax, 1
  004a9	48 6b c0 00	 imul	 rax, rax, 0
  004ad	b9 01 00 00 00	 mov	 ecx, 1
  004b2	48 6b c9 02	 imul	 rcx, rcx, 2
  004b6	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004bb	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  004c0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  004c5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004c8	b8 01 00 00 00	 mov	 eax, 1
  004cd	48 6b c0 02	 imul	 rax, rax, 2
  004d1	b9 01 00 00 00	 mov	 ecx, 1
  004d6	48 6b c9 01	 imul	 rcx, rcx, 1
  004da	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004df	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  004e4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  004e9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004ec	b8 01 00 00 00	 mov	 eax, 1
  004f1	48 6b c0 01	 imul	 rax, rax, 1
  004f5	b9 01 00 00 00	 mov	 ecx, 1
  004fa	48 6b c9 00	 imul	 rcx, rcx, 0
  004fe	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00503	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00508	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0050d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00510	b8 01 00 00 00	 mov	 eax, 1
  00515	48 6b c0 01	 imul	 rax, rax, 1
  00519	b9 01 00 00 00	 mov	 ecx, 1
  0051e	48 6b c9 03	 imul	 rcx, rcx, 3
  00522	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00527	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0052c	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00531	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00534	e9 3a ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  00539	e9 86 04 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1764 :             STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;

  0053e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00545	ff c8		 dec	 eax
  00547	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0054b	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  0054d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00551	ff c8		 dec	 eax
  00553	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00557	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0055c	48 83 c0 03	 add	 rax, 3
  00560	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00565	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  0056a	48 83 c0 04	 add	 rax, 4
  0056e	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN27@stbi__conv:
  00573	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00578	0f 8c 83 00 00
	00		 jl	 $LN26@stbi__conv
  0057e	b8 01 00 00 00	 mov	 eax, 1
  00583	48 6b c0 00	 imul	 rax, rax, 0
  00587	b9 01 00 00 00	 mov	 ecx, 1
  0058c	48 6b c9 00	 imul	 rcx, rcx, 0
  00590	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00595	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0059a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0059f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005a2	b8 01 00 00 00	 mov	 eax, 1
  005a7	48 6b c0 01	 imul	 rax, rax, 1
  005ab	b9 01 00 00 00	 mov	 ecx, 1
  005b0	48 6b c9 01	 imul	 rcx, rcx, 1
  005b4	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005b9	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005be	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005c3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005c6	b8 01 00 00 00	 mov	 eax, 1
  005cb	48 6b c0 02	 imul	 rax, rax, 2
  005cf	b9 01 00 00 00	 mov	 ecx, 1
  005d4	48 6b c9 02	 imul	 rcx, rcx, 2
  005d8	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005dd	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005e2	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005e7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005ea	b8 01 00 00 00	 mov	 eax, 1
  005ef	48 6b c0 03	 imul	 rax, rax, 3
  005f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  005f8	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  005fc	e9 4c ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00601	e9 be 03 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1765 :             STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

  00606	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0060d	ff c8		 dec	 eax
  0060f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00613	eb 25		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  00615	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00619	ff c8		 dec	 eax
  0061b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0061f	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00624	48 83 c0 03	 add	 rax, 3
  00628	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0062d	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00632	48 ff c0	 inc	 rax
  00635	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN30@stbi__conv:
  0063a	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0063f	7c 61		 jl	 SHORT $LN29@stbi__conv
  00641	b8 01 00 00 00	 mov	 eax, 1
  00646	48 6b c0 02	 imul	 rax, rax, 2
  0064a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  0064f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00653	b9 01 00 00 00	 mov	 ecx, 1
  00658	48 6b c9 01	 imul	 rcx, rcx, 1
  0065c	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  00661	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00665	ba 01 00 00 00	 mov	 edx, 1
  0066a	48 6b d2 00	 imul	 rdx, rdx, 0
  0066e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00673	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00678	89 54 24 50	 mov	 DWORD PTR tv256[rsp], edx
  0067c	44 8b c0	 mov	 r8d, eax
  0067f	8b d1		 mov	 edx, ecx
  00681	8b 44 24 50	 mov	 eax, DWORD PTR tv256[rsp]
  00685	8b c8		 mov	 ecx, eax
  00687	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  0068c	b9 01 00 00 00	 mov	 ecx, 1
  00691	48 6b c9 00	 imul	 rcx, rcx, 0
  00695	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0069a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0069d	e9 73 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006a2	e9 1d 03 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1766 :             STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

  006a7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  006ae	ff c8		 dec	 eax
  006b0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006b4	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  006b6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006ba	ff c8		 dec	 eax
  006bc	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006c0	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  006c5	48 83 c0 03	 add	 rax, 3
  006c9	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  006ce	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  006d3	48 83 c0 02	 add	 rax, 2
  006d7	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN33@stbi__conv:
  006dc	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  006e1	7c 73		 jl	 SHORT $LN32@stbi__conv
  006e3	b8 01 00 00 00	 mov	 eax, 1
  006e8	48 6b c0 02	 imul	 rax, rax, 2
  006ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  006f1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006f5	b9 01 00 00 00	 mov	 ecx, 1
  006fa	48 6b c9 01	 imul	 rcx, rcx, 1
  006fe	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  00703	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00707	ba 01 00 00 00	 mov	 edx, 1
  0070c	48 6b d2 00	 imul	 rdx, rdx, 0
  00710	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00715	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0071a	89 54 24 54	 mov	 DWORD PTR tv276[rsp], edx
  0071e	44 8b c0	 mov	 r8d, eax
  00721	8b d1		 mov	 edx, ecx
  00723	8b 44 24 54	 mov	 eax, DWORD PTR tv276[rsp]
  00727	8b c8		 mov	 ecx, eax
  00729	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  0072e	b9 01 00 00 00	 mov	 ecx, 1
  00733	48 6b c9 00	 imul	 rcx, rcx, 0
  00737	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0073c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0073f	b8 01 00 00 00	 mov	 eax, 1
  00744	48 6b c0 01	 imul	 rax, rax, 1
  00748	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  0074d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00751	e9 60 ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  00756	e9 69 02 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1767 :             STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

  0075b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00762	ff c8		 dec	 eax
  00764	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00768	eb 25		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  0076a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0076e	ff c8		 dec	 eax
  00770	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00774	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00779	48 83 c0 04	 add	 rax, 4
  0077d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00782	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00787	48 ff c0	 inc	 rax
  0078a	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN36@stbi__conv:
  0078f	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00794	7c 61		 jl	 SHORT $LN35@stbi__conv
  00796	b8 01 00 00 00	 mov	 eax, 1
  0079b	48 6b c0 02	 imul	 rax, rax, 2
  0079f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  007a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007a8	b9 01 00 00 00	 mov	 ecx, 1
  007ad	48 6b c9 01	 imul	 rcx, rcx, 1
  007b1	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  007b6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  007ba	ba 01 00 00 00	 mov	 edx, 1
  007bf	48 6b d2 00	 imul	 rdx, rdx, 0
  007c3	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  007c8	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  007cd	89 54 24 58	 mov	 DWORD PTR tv298[rsp], edx
  007d1	44 8b c0	 mov	 r8d, eax
  007d4	8b d1		 mov	 edx, ecx
  007d6	8b 44 24 58	 mov	 eax, DWORD PTR tv298[rsp]
  007da	8b c8		 mov	 ecx, eax
  007dc	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  007e1	b9 01 00 00 00	 mov	 ecx, 1
  007e6	48 6b c9 00	 imul	 rcx, rcx, 0
  007ea	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  007ef	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007f2	e9 73 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  007f7	e9 c8 01 00 00	 jmp	 $LN5@stbi__conv
$LN57@stbi__conv:

; 1768 :             STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

  007fc	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00803	ff c8		 dec	 eax
  00805	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00809	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  0080b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0080f	ff c8		 dec	 eax
  00811	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00815	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0081a	48 83 c0 04	 add	 rax, 4
  0081e	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00823	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00828	48 83 c0 02	 add	 rax, 2
  0082c	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN39@stbi__conv:
  00831	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00836	0f 8c 85 00 00
	00		 jl	 $LN38@stbi__conv
  0083c	b8 01 00 00 00	 mov	 eax, 1
  00841	48 6b c0 02	 imul	 rax, rax, 2
  00845	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  0084a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0084e	b9 01 00 00 00	 mov	 ecx, 1
  00853	48 6b c9 01	 imul	 rcx, rcx, 1
  00857	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  0085c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00860	ba 01 00 00 00	 mov	 edx, 1
  00865	48 6b d2 00	 imul	 rdx, rdx, 0
  00869	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0086e	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00873	89 54 24 5c	 mov	 DWORD PTR tv318[rsp], edx
  00877	44 8b c0	 mov	 r8d, eax
  0087a	8b d1		 mov	 edx, ecx
  0087c	8b 44 24 5c	 mov	 eax, DWORD PTR tv318[rsp]
  00880	8b c8		 mov	 ecx, eax
  00882	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00887	b9 01 00 00 00	 mov	 ecx, 1
  0088c	48 6b c9 00	 imul	 rcx, rcx, 0
  00890	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00895	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00898	b8 01 00 00 00	 mov	 eax, 1
  0089d	48 6b c0 03	 imul	 rax, rax, 3
  008a1	b9 01 00 00 00	 mov	 ecx, 1
  008a6	48 6b c9 01	 imul	 rcx, rcx, 1
  008aa	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008af	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  008b4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  008b9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008bc	e9 4a ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  008c1	e9 fe 00 00 00	 jmp	 $LN5@stbi__conv
$LN58@stbi__conv:

; 1769 :             STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;

  008c6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  008cd	ff c8		 dec	 eax
  008cf	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  008d3	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  008d5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  008d9	ff c8		 dec	 eax
  008db	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  008df	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  008e4	48 83 c0 04	 add	 rax, 4
  008e8	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  008ed	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  008f2	48 83 c0 03	 add	 rax, 3
  008f6	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN42@stbi__conv:
  008fb	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00900	7c 71		 jl	 SHORT $LN41@stbi__conv
  00902	b8 01 00 00 00	 mov	 eax, 1
  00907	48 6b c0 00	 imul	 rax, rax, 0
  0090b	b9 01 00 00 00	 mov	 ecx, 1
  00910	48 6b c9 00	 imul	 rcx, rcx, 0
  00914	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00919	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0091e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00923	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00926	b8 01 00 00 00	 mov	 eax, 1
  0092b	48 6b c0 01	 imul	 rax, rax, 1
  0092f	b9 01 00 00 00	 mov	 ecx, 1
  00934	48 6b c9 01	 imul	 rcx, rcx, 1
  00938	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0093d	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00942	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00947	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0094a	b8 01 00 00 00	 mov	 eax, 1
  0094f	48 6b c0 02	 imul	 rax, rax, 2
  00953	b9 01 00 00 00	 mov	 ecx, 1
  00958	48 6b c9 02	 imul	 rcx, rcx, 2
  0095c	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00961	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00966	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0096b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0096e	e9 62 ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  00973	eb 4f		 jmp	 SHORT $LN5@stbi__conv
$LN59@stbi__conv:

; 1770 :             default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");

  00975	33 c0		 xor	 eax, eax
  00977	83 f8 01	 cmp	 eax, 1
  0097a	74 0b		 je	 SHORT $LN60@stbi__conv
  0097c	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN60@stbi__conv:
  00987	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  0098c	e8 00 00 00 00	 call	 free
  00991	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  00996	e8 00 00 00 00	 call	 free
  0099b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35881
  009a2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  009a7	85 c0		 test	 eax, eax
  009a9	74 0a		 je	 SHORT $LN64@stbi__conv
  009ab	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv348[rsp], 0
  009b3	eb 08		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  009b5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv348[rsp], 0
$LN65@stbi__conv:
  009bd	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv348[rsp]
  009c2	eb 14		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1771 :         }
; 1772 : #undef STBI__CASE
; 1773 :     }

  009c4	e9 ef f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1774 :     
; 1775 :     STBI_FREE(data);

  009c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  009ce	e8 00 00 00 00	 call	 free

; 1776 :     return good;

  009d3	48 8b 44 24 48	 mov	 rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1777 : }

  009d8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  009dc	c3		 ret	 0
  009dd	0f 1f 00	 npad	 3
$LN66@stbi__conv:
  009e0	00 00 00 00	 DD	 $LN47@stbi__conv
  009e4	00 00 00 00	 DD	 $LN48@stbi__conv
  009e8	00 00 00 00	 DD	 $LN49@stbi__conv
  009ec	00 00 00 00	 DD	 $LN59@stbi__conv
  009f0	00 00 00 00	 DD	 $LN59@stbi__conv
  009f4	00 00 00 00	 DD	 $LN59@stbi__conv
  009f8	00 00 00 00	 DD	 $LN59@stbi__conv
  009fc	00 00 00 00	 DD	 $LN50@stbi__conv
  00a00	00 00 00 00	 DD	 $LN59@stbi__conv
  00a04	00 00 00 00	 DD	 $LN51@stbi__conv
  00a08	00 00 00 00	 DD	 $LN52@stbi__conv
  00a0c	00 00 00 00	 DD	 $LN59@stbi__conv
  00a10	00 00 00 00	 DD	 $LN59@stbi__conv
  00a14	00 00 00 00	 DD	 $LN59@stbi__conv
  00a18	00 00 00 00	 DD	 $LN59@stbi__conv
  00a1c	00 00 00 00	 DD	 $LN54@stbi__conv
  00a20	00 00 00 00	 DD	 $LN55@stbi__conv
  00a24	00 00 00 00	 DD	 $LN59@stbi__conv
  00a28	00 00 00 00	 DD	 $LN53@stbi__conv
  00a2c	00 00 00 00	 DD	 $LN59@stbi__conv
  00a30	00 00 00 00	 DD	 $LN59@stbi__conv
  00a34	00 00 00 00	 DD	 $LN59@stbi__conv
  00a38	00 00 00 00	 DD	 $LN59@stbi__conv
  00a3c	00 00 00 00	 DD	 $LN56@stbi__conv
  00a40	00 00 00 00	 DD	 $LN57@stbi__conv
  00a44	00 00 00 00	 DD	 $LN58@stbi__conv
?stbi__convert_format@@YAPEAEPEAEHHII@Z ENDP		; stbi__convert_format
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y@@YAEHHH@Z PROC				; stbi__compute_y

; 1727 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1728 :     return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

  0000d	6b 44 24 08 4d	 imul	 eax, DWORD PTR r$[rsp], 77 ; 0000004dH
  00012	69 4c 24 10 96
	00 00 00	 imul	 ecx, DWORD PTR g$[rsp], 150 ; 00000096H
  0001a	03 c1		 add	 eax, ecx
  0001c	6b 4c 24 18 1d	 imul	 ecx, DWORD PTR b$[rsp], 29
  00021	03 c1		 add	 eax, ecx
  00023	c1 f8 08	 sar	 eax, 8

; 1729 : }

  00026	c3		 ret	 0
?stbi__compute_y@@YAEHHH@Z ENDP				; stbi__compute_y
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
?stbi__get32le@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32le

; 1703 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1704 :     stbi__uint32 z = stbi__get16le(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00013	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1705 :     z += (stbi__uint32)stbi__get16le(s) << 16;

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00021	c1 e0 10	 shl	 eax, 16
  00024	8b 4c 24 20	 mov	 ecx, DWORD PTR z$[rsp]
  00028	03 c8		 add	 ecx, eax
  0002a	8b c1		 mov	 eax, ecx
  0002c	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1706 :     return z;

  00030	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]

; 1707 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?stbi__get32le@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32le
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
?stbi__get16le@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16le

; 1695 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1696 :     int z = stbi__get8(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1697 :     return z + (stbi__get8(s) << 8);

  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00024	0f b6 c0	 movzx	 eax, al
  00027	c1 e0 08	 shl	 eax, 8
  0002a	8b 4c 24 20	 mov	 ecx, DWORD PTR z$[rsp]
  0002e	03 c8		 add	 ecx, eax
  00030	8b c1		 mov	 eax, ecx

; 1698 : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
?stbi__get16le@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16le
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv66 = 36
s$ = 64
?stbi__get32be@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32be

; 1685 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1686 :     stbi__uint32 z = stbi__get16be(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00013	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1687 :     return (z << 16) + stbi__get16be(s);

  00017	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  0001b	c1 e0 10	 shl	 eax, 16
  0001e	89 44 24 24	 mov	 DWORD PTR tv66[rsp], eax
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00027	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0002c	8b 4c 24 24	 mov	 ecx, DWORD PTR tv66[rsp]
  00030	03 c8		 add	 ecx, eax
  00032	8b c1		 mov	 eax, ecx

; 1688 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?stbi__get32be@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32be
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv67 = 36
s$ = 64
?stbi__get16be@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16be

; 1675 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1676 :     int z = stbi__get8(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1677 :     return (z << 8) + stbi__get8(s);

  0001a	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  0001e	c1 e0 08	 shl	 eax, 8
  00021	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002f	0f b6 c0	 movzx	 eax, al
  00032	8b 4c 24 24	 mov	 ecx, DWORD PTR tv67[rsp]
  00036	03 c8		 add	 ecx, eax
  00038	8b c1		 mov	 eax, ecx

; 1678 : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
?stbi__get16be@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16be
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
tv91 = 36
count$2 = 40
res$3 = 44
s$ = 80
buffer$ = 88
n$ = 96
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z PROC		; stbi__getn

; 1647 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1648 :     if (s->io.read) {

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0001f	0f 84 c9 00 00
	00		 je	 $LN2@stbi__getn

; 1649 :         int blen = (int) (s->img_buffer_end - s->img_buffer);

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00036	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0003d	48 2b c1	 sub	 rax, rcx
  00040	89 44 24 20	 mov	 DWORD PTR blen$1[rsp], eax

; 1650 :         if (blen < n) {

  00044	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  00048	39 44 24 20	 cmp	 DWORD PTR blen$1[rsp], eax
  0004c	0f 8d 9c 00 00
	00		 jge	 $LN3@stbi__getn

; 1651 :             int res, count;
; 1652 :             
; 1653 :             memcpy(buffer, s->img_buffer, blen);

  00052	48 63 44 24 20	 movsxd	 rax, DWORD PTR blen$1[rsp]
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0005c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR buffer$[rsp]
  00061	48 8b b1 c0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+192]
  00068	48 8b c8	 mov	 rcx, rax
  0006b	f3 a4		 rep movsb

; 1654 :             
; 1655 :             count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  00071	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  00075	2b c8		 sub	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR blen$1[rsp]
  0007e	48 8b 54 24 58	 mov	 rdx, QWORD PTR buffer$[rsp]
  00083	48 03 d1	 add	 rdx, rcx
  00086	48 8b ca	 mov	 rcx, rdx
  00089	44 8b c0	 mov	 r8d, eax
  0008c	48 8b d1	 mov	 rdx, rcx
  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00094	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009d	ff 50 10	 call	 QWORD PTR [rax+16]
  000a0	89 44 24 28	 mov	 DWORD PTR count$2[rsp], eax

; 1656 :             res = (count == (n-blen));

  000a4	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  000a8	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000ac	2b c8		 sub	 ecx, eax
  000ae	8b c1		 mov	 eax, ecx
  000b0	39 44 24 28	 cmp	 DWORD PTR count$2[rsp], eax
  000b4	75 0a		 jne	 SHORT $LN7@stbi__getn
  000b6	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000be	eb 08		 jmp	 SHORT $LN8@stbi__getn
$LN7@stbi__getn:
  000c0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN8@stbi__getn:
  000c8	8b 44 24 24	 mov	 eax, DWORD PTR tv91[rsp]
  000cc	89 44 24 2c	 mov	 DWORD PTR res$3[rsp], eax

; 1657 :             s->img_buffer = s->img_buffer_end;

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000da	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000e1	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1658 :             return res;

  000e8	8b 44 24 2c	 mov	 eax, DWORD PTR res$3[rsp]
  000ec	eb 62		 jmp	 SHORT $LN1@stbi__getn
$LN3@stbi__getn:
$LN2@stbi__getn:

; 1659 :         }
; 1660 :     }
; 1661 :     
; 1662 :     if (s->img_buffer+n <= s->img_buffer_end) {

  000ee	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$[rsp]
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000f8	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00104	48 3b 81 c8 00
	00 00		 cmp	 rax, QWORD PTR [rcx+200]
  0010b	77 41		 ja	 SHORT $LN4@stbi__getn

; 1663 :         memcpy(buffer, s->img_buffer, n);

  0010d	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$[rsp]
  00112	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00117	48 8b 7c 24 58	 mov	 rdi, QWORD PTR buffer$[rsp]
  0011c	48 8b b1 c0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+192]
  00123	48 8b c8	 mov	 rcx, rax
  00126	f3 a4		 rep movsb

; 1664 :         s->img_buffer += n;

  00128	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$[rsp]
  0012d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00132	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  00139	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1665 :         return 1;

  00145	b8 01 00 00 00	 mov	 eax, 1
  0014a	eb 04		 jmp	 SHORT $LN1@stbi__getn

; 1666 :     } else

  0014c	eb 02		 jmp	 SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1667 :         return 0;

  0014e	33 c0		 xor	 eax, eax
$LN5@stbi__getn:
$LN1@stbi__getn:

; 1668 : }

  00150	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00154	5f		 pop	 rdi
  00155	5e		 pop	 rsi
  00156	c3		 ret	 0
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ENDP		; stbi__getn
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
s$ = 64
n$ = 72
?stbi__skip@@YAXPEAUstbi__context@@H@Z PROC		; stbi__skip

; 1625 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1626 :     if (n == 0) return;  // already there!

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR n$[rsp], 0
  00012	75 05		 jne	 SHORT $LN2@stbi__skip
  00014	e9 af 00 00 00	 jmp	 $LN1@stbi__skip
$LN2@stbi__skip:

; 1627 :     if (n < 0) {

  00019	83 7c 24 48 00	 cmp	 DWORD PTR n$[rsp], 0
  0001e	7d 1d		 jge	 SHORT $LN3@stbi__skip

; 1628 :         s->img_buffer = s->img_buffer_end;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00031	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1629 :         return;

  00038	e9 8b 00 00 00	 jmp	 $LN1@stbi__skip
$LN3@stbi__skip:

; 1630 :     }
; 1631 :     if (s->io.read) {

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00042	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00047	74 62		 je	 SHORT $LN4@stbi__skip

; 1632 :         int blen = (int) (s->img_buffer_end - s->img_buffer);

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  0005a	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00061	48 2b c1	 sub	 rax, rcx
  00064	89 44 24 20	 mov	 DWORD PTR blen$1[rsp], eax

; 1633 :         if (blen < n) {

  00068	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  0006c	39 44 24 20	 cmp	 DWORD PTR blen$1[rsp], eax
  00070	7d 39		 jge	 SHORT $LN5@stbi__skip

; 1634 :             s->img_buffer = s->img_buffer_end;

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0007c	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00083	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1635 :             (s->io.skip)(s->io_user_data, n - blen);

  0008a	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  0008e	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00092	2b c8		 sub	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	8b d0		 mov	 edx, eax
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0009d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a6	ff 50 18	 call	 QWORD PTR [rax+24]

; 1636 :             return;

  000a9	eb 1d		 jmp	 SHORT $LN1@stbi__skip
$LN5@stbi__skip:
$LN4@stbi__skip:

; 1637 :         }
; 1638 :     }
; 1639 :     s->img_buffer += n;

  000ab	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN1@stbi__skip:

; 1640 : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
?stbi__skip@@YAXPEAUstbi__context@@H@Z ENDP		; stbi__skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv78 = 32
s$ = 64
?stbi__at_eof@@YAHPEAUstbi__context@@@Z PROC		; stbi__at_eof

; 1609 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1610 :     if (s->io.read) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00013	74 2b		 je	 SHORT $LN2@stbi__at_e

; 1611 :         if (!(s->io.eof)(s->io_user_data)) return 0;

  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001a	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00023	ff 50 20	 call	 QWORD PTR [rax+32]
  00026	85 c0		 test	 eax, eax
  00028	75 04		 jne	 SHORT $LN3@stbi__at_e
  0002a	33 c0		 xor	 eax, eax
  0002c	eb 42		 jmp	 SHORT $LN1@stbi__at_e
$LN3@stbi__at_e:

; 1612 :         // if feof() is true, check if buffer = end
; 1613 :         // special case: we've only got the special 0 character at the end
; 1614 :         if (s->read_from_callbacks == 0) return 1;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00033	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00037	75 07		 jne	 SHORT $LN4@stbi__at_e
  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	eb 30		 jmp	 SHORT $LN1@stbi__at_e
$LN4@stbi__at_e:
$LN2@stbi__at_e:

; 1615 :     }
; 1616 :     
; 1617 :     return s->img_buffer >= s->img_buffer_end;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00051	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00058	72 0a		 jb	 SHORT $LN6@stbi__at_e
  0005a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00062	eb 08		 jmp	 SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
  00064	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN7@stbi__at_e:
  0006c	8b 44 24 20	 mov	 eax, DWORD PTR tv78[rsp]
$LN1@stbi__at_e:

; 1618 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
?stbi__at_eof@@YAHPEAUstbi__context@@@Z ENDP		; stbi__at_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv72 = 32
tv81 = 33
s$ = 64
?stbi__get8@@YAEPEAUstbi__context@@@Z PROC		; stbi__get8

; 1595 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1596 :     if (s->img_buffer < s->img_buffer_end)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00013	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0001a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00021	73 35		 jae	 SHORT $LN2@stbi__get8

; 1597 :         return *s->img_buffer++;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	88 44 24 20	 mov	 BYTE PTR tv72[rsp], al
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0003b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00042	48 ff c0	 inc	 rax
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00051	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv72[rsp]
  00056	eb 4c		 jmp	 SHORT $LN1@stbi__get8
$LN2@stbi__get8:

; 1598 :     if (s->read_from_callbacks) {

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00061	74 3f		 je	 SHORT $LN3@stbi__get8

; 1599 :         stbi__refill_buffer(s);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1600 :         return *s->img_buffer++;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00072	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00079	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007c	88 44 24 21	 mov	 BYTE PTR tv81[rsp], al
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00085	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008c	48 ff c0	 inc	 rax
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00094	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0009b	0f b6 44 24 21	 movzx	 eax, BYTE PTR tv81[rsp]
  000a0	eb 02		 jmp	 SHORT $LN1@stbi__get8
$LN3@stbi__get8:

; 1601 :     }
; 1602 :     return 0;

  000a2	32 c0		 xor	 al, al
$LN1@stbi__get8:

; 1603 : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
?stbi__get8@@YAEPEAUstbi__context@@@Z ENDP		; stbi__get8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv89 = 48
tv129 = 52
hdr_data$1 = 56
data$ = 64
ri$2 = 72
__$ArrayPad$ = 88
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
req_comp$ = 144
?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z PROC ; stbi__loadf_main

; 1441 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1442 :     unsigned char *data;
; 1443 : #ifndef STBI_NO_HDR
; 1444 :     if (stbi__hdr_test(s)) {

  00027	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  00031	85 c0		 test	 eax, eax
  00033	74 75		 je	 SHORT $LN2@stbi__load

; 1445 :         stbi__result_info ri;
; 1446 :         float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);

  00035	48 8d 44 24 48	 lea	 rax, QWORD PTR ri$2[rsp]
  0003a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__hdr_load
  00069	48 89 44 24 38	 mov	 QWORD PTR hdr_data$1[rsp], rax

; 1447 :         if (hdr_data)

  0006e	48 83 7c 24 38
	00		 cmp	 QWORD PTR hdr_data$1[rsp], 0
  00074	74 2a		 je	 SHORT $LN3@stbi__load

; 1448 :             stbi__float_postprocess(hdr_data,x,y,comp,req_comp);

  00076	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0007d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00081	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00089	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00091	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00096	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hdr_data$1[rsp]
  0009b	e8 00 00 00 00	 call	 ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z ; stbi__float_postprocess
$LN3@stbi__load:

; 1449 :         return hdr_data;

  000a0	48 8b 44 24 38	 mov	 rax, QWORD PTR hdr_data$1[rsp]
  000a5	e9 a6 00 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1450 :     }
; 1451 : #endif
; 1452 :     data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);

  000aa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000b1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  000bd	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  000c5	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  000ca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
  000d4	48 89 44 24 40	 mov	 QWORD PTR data$[rsp], rax

; 1453 :     if (data)

  000d9	48 83 7c 24 40
	00		 cmp	 QWORD PTR data$[rsp], 0
  000df	74 48		 je	 SHORT $LN4@stbi__load

; 1454 :         return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

  000e1	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000e9	74 0d		 je	 SHORT $LN6@stbi__load
  000eb	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000f2	89 44 24 30	 mov	 DWORD PTR tv89[rsp], eax
  000f6	eb 0e		 jmp	 SHORT $LN7@stbi__load
$LN6@stbi__load:
  000f8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00100	8b 00		 mov	 eax, DWORD PTR [rax]
  00102	89 44 24 30	 mov	 DWORD PTR tv89[rsp], eax
$LN7@stbi__load:
  00106	44 8b 4c 24 30	 mov	 r9d, DWORD PTR tv89[rsp]
  0010b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00113	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR x$[rsp]
  0011b	8b 10		 mov	 edx, DWORD PTR [rax]
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00122	e8 00 00 00 00	 call	 ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z ; stbi__ldr_to_hdr
  00127	eb 27		 jmp	 SHORT $LN1@stbi__load
$LN4@stbi__load:

; 1455 :     return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35649
  00130	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00135	85 c0		 test	 eax, eax
  00137	74 0a		 je	 SHORT $LN8@stbi__load
  00139	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  00141	eb 08		 jmp	 SHORT $LN9@stbi__load
$LN8@stbi__load:
  00143	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@stbi__load:
  0014b	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv129[rsp]
$LN1@stbi__load:

; 1456 : }

  00150	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00155	48 33 cc	 xor	 rcx, rsp
  00158	e8 00 00 00 00	 call	 __security_check_cookie
  0015d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00161	c3		 ret	 0
?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__loadf_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
f$ = 32
filename$ = 64
mode$ = 72
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z PROC		; stbi__fopen

; 1318 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1319 :     FILE *f;
; 1320 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1321 :     wchar_t wMode[64];
; 1322 :     wchar_t wFilename[1024];
; 1323 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1324 :         return 0;
; 1325 :     
; 1326 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1327 :         return 0;
; 1328 :     
; 1329 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1330 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1331 : 		f = 0;
; 1332 : #else
; 1333 :     f = _wfopen(wFilename, wMode);
; 1334 : #endif
; 1335 :     
; 1336 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1337 :     if (0 != fopen_s(&f, filename, mode))

  0000e	4c 8b 44 24 48	 mov	 r8, QWORD PTR mode$[rsp]
  00013	48 8b 54 24 40	 mov	 rdx, QWORD PTR filename$[rsp]
  00018	48 8d 4c 24 20	 lea	 rcx, QWORD PTR f$[rsp]
  0001d	e8 00 00 00 00	 call	 fopen_s
  00022	85 c0		 test	 eax, eax
  00024	74 09		 je	 SHORT $LN2@stbi__fope

; 1338 :         f=0;

  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR f$[rsp], 0
$LN2@stbi__fope:

; 1339 : #else
; 1340 :     f = fopen(filename, mode);
; 1341 : #endif
; 1342 :     return f;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR f$[rsp]

; 1343 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ENDP		; stbi__fopen
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv77 = 32
tv81 = 36
channels$1 = 40
result$ = 64
x$ = 72
y$ = 80
comp$ = 88
req_comp$ = 96
?stbi__float_postprocess@@YAXPEAMPEAH11H@Z PROC		; stbi__float_postprocess

; 1295 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1296 :     if (stbi__vertically_flip_on_load && result != NULL) {

  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  0001d	8b c0		 mov	 eax, eax
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00025	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0002e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00032	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00036	74 23		 je	 SHORT $LN4@stbi__floa
  00038	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  0003d	8b c0		 mov	 eax, eax
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00045	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0004e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00052	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00055	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  00059	eb 0a		 jmp	 SHORT $LN5@stbi__floa
$LN4@stbi__floa:
  0005b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  00061	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
$LN5@stbi__floa:
  00065	83 7c 24 20 00	 cmp	 DWORD PTR tv77[rsp], 0
  0006a	74 51		 je	 SHORT $LN2@stbi__floa
  0006c	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  00072	74 49		 je	 SHORT $LN2@stbi__floa

; 1297 :         int channels = req_comp ? req_comp : *comp;

  00074	83 7c 24 60 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00079	74 0a		 je	 SHORT $LN6@stbi__floa
  0007b	8b 44 24 60	 mov	 eax, DWORD PTR req_comp$[rsp]
  0007f	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
  00083	eb 0b		 jmp	 SHORT $LN7@stbi__floa
$LN6@stbi__floa:
  00085	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  0008a	8b 00		 mov	 eax, DWORD PTR [rax]
  0008c	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
$LN7@stbi__floa:
  00090	8b 44 24 24	 mov	 eax, DWORD PTR tv81[rsp]
  00094	89 44 24 28	 mov	 DWORD PTR channels$1[rsp], eax

; 1298 :         stbi__vertical_flip(result, *x, *y, channels * sizeof(float));

  00098	48 63 44 24 28	 movsxd	 rax, DWORD PTR channels$1[rsp]
  0009d	48 c1 e0 02	 shl	 rax, 2
  000a1	44 8b c8	 mov	 r9d, eax
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  000a9	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  000b1	8b 10		 mov	 edx, DWORD PTR [rax]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  000b8	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip
$LN2@stbi__floa:

; 1299 :     }
; 1300 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
?stbi__float_postprocess@@YAXPEAMPEAH11H@Z ENDP		; stbi__float_postprocess
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv79 = 64
tv129 = 68
tv132 = 72
result$ = 80
channels$1 = 88
ri$ = 96
__$ArrayPad$ = 112
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$ = 176
?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_and_postprocess_16bit

; 1267 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1268 :     stbi__result_info ri;
; 1269 :     void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

  0002a	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  00032	48 8d 44 24 60	 lea	 rax, QWORD PTR ri$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00043	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00047	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00057	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__load_main
  0006c	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1270 :     
; 1271 :     if (result == NULL)

  00071	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	75 07		 jne	 SHORT $LN2@stbi__load

; 1272 :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 26 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1273 :     
; 1274 :     // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1275 :     STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  00080	83 7c 24 60 08	 cmp	 DWORD PTR ri$[rsp], 8
  00085	74 12		 je	 SHORT $LN3@stbi__load
  00087	83 7c 24 60 10	 cmp	 DWORD PTR ri$[rsp], 16
  0008c	74 0b		 je	 SHORT $LN3@stbi__load
  0008e	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN3@stbi__load:

; 1276 :     
; 1277 :     if (ri.bits_per_channel != 16) {

  00099	83 7c 24 60 10	 cmp	 DWORD PTR ri$[rsp], 16
  0009e	74 56		 je	 SHORT $LN4@stbi__load

; 1278 :         result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000a0	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000a8	75 10		 jne	 SHORT $LN7@stbi__load
  000aa	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000b2	8b 00		 mov	 eax, DWORD PTR [rax]
  000b4	89 44 24 40	 mov	 DWORD PTR tv79[rsp], eax
  000b8	eb 0b		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000ba	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000c1	89 44 24 40	 mov	 DWORD PTR tv79[rsp], eax
$LN8@stbi__load:
  000c5	44 8b 4c 24 40	 mov	 r9d, DWORD PTR tv79[rsp]
  000ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000d2	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000dd	8b 10		 mov	 edx, DWORD PTR [rax]
  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z ; stbi__convert_8_to_16
  000e9	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1279 :         ri.bits_per_channel = 16;

  000ee	c7 44 24 60 10
	00 00 00	 mov	 DWORD PTR ri$[rsp], 16
$LN4@stbi__load:

; 1280 :     }
; 1281 :     
; 1282 :     // @TODO: move stbi__convert_format16 to here
; 1283 :     // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1284 :     
; 1285 :     if (stbi__vertically_flip_on_load) {

  000f6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  000fb	8b c0		 mov	 eax, eax
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00103	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00110	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00114	74 23		 je	 SHORT $LN9@stbi__load
  00116	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  0011b	8b c0		 mov	 eax, eax
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0012c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00130	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00133	89 44 24 44	 mov	 DWORD PTR tv129[rsp], eax
  00137	eb 0a		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  00139	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  0013f	89 44 24 44	 mov	 DWORD PTR tv129[rsp], eax
$LN10@stbi__load:
  00143	83 7c 24 44 00	 cmp	 DWORD PTR tv129[rsp], 0
  00148	74 57		 je	 SHORT $LN5@stbi__load

; 1286 :         int channels = req_comp ? req_comp : *comp;

  0014a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00152	74 0d		 je	 SHORT $LN11@stbi__load
  00154	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0015b	89 44 24 48	 mov	 DWORD PTR tv132[rsp], eax
  0015f	eb 0e		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  00161	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00169	8b 00		 mov	 eax, DWORD PTR [rax]
  0016b	89 44 24 48	 mov	 DWORD PTR tv132[rsp], eax
$LN12@stbi__load:
  0016f	8b 44 24 48	 mov	 eax, DWORD PTR tv132[rsp]
  00173	89 44 24 58	 mov	 DWORD PTR channels$1[rsp], eax

; 1287 :         stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));

  00177	48 63 44 24 58	 movsxd	 rax, DWORD PTR channels$1[rsp]
  0017c	48 d1 e0	 shl	 rax, 1
  0017f	44 8b c8	 mov	 r9d, eax
  00182	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  0018a	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0018d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00195	8b 10		 mov	 edx, DWORD PTR [rax]
  00197	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  0019c	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip
$LN5@stbi__load:

; 1288 :     }
; 1289 :     
; 1290 :     return (stbi__uint16 *) result;

  001a1	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__load:

; 1291 : }

  001a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ab	48 33 cc	 xor	 rcx, rsp
  001ae	e8 00 00 00 00	 call	 __security_check_cookie
  001b3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001ba	c3		 ret	 0
?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_and_postprocess_16bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv79 = 64
tv129 = 68
tv132 = 72
result$ = 80
channels$1 = 88
ri$ = 96
__$ArrayPad$ = 112
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$ = 176
?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_and_postprocess_8bit

; 1241 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1242 :     stbi__result_info ri;
; 1243 :     void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

  0002a	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR [rsp+48], 8
  00032	48 8d 44 24 60	 lea	 rax, QWORD PTR ri$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00043	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00047	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00057	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__load_main
  0006c	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1244 :     
; 1245 :     if (result == NULL)

  00071	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	75 07		 jne	 SHORT $LN2@stbi__load

; 1246 :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 20 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1247 :     
; 1248 :     // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1249 :     STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  00080	83 7c 24 60 08	 cmp	 DWORD PTR ri$[rsp], 8
  00085	74 12		 je	 SHORT $LN3@stbi__load
  00087	83 7c 24 60 10	 cmp	 DWORD PTR ri$[rsp], 16
  0008c	74 0b		 je	 SHORT $LN3@stbi__load
  0008e	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN3@stbi__load:

; 1250 :     
; 1251 :     if (ri.bits_per_channel != 8) {

  00099	83 7c 24 60 08	 cmp	 DWORD PTR ri$[rsp], 8
  0009e	74 56		 je	 SHORT $LN4@stbi__load

; 1252 :         result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000a0	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000a8	75 10		 jne	 SHORT $LN7@stbi__load
  000aa	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000b2	8b 00		 mov	 eax, DWORD PTR [rax]
  000b4	89 44 24 40	 mov	 DWORD PTR tv79[rsp], eax
  000b8	eb 0b		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000ba	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000c1	89 44 24 40	 mov	 DWORD PTR tv79[rsp], eax
$LN8@stbi__load:
  000c5	44 8b 4c 24 40	 mov	 r9d, DWORD PTR tv79[rsp]
  000ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000d2	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000dd	8b 10		 mov	 edx, DWORD PTR [rax]
  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z ; stbi__convert_16_to_8
  000e9	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1253 :         ri.bits_per_channel = 8;

  000ee	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR ri$[rsp], 8
$LN4@stbi__load:

; 1254 :     }
; 1255 :     
; 1256 :     // @TODO: move stbi__convert_format to here
; 1257 :     
; 1258 :     if (stbi__vertically_flip_on_load) {

  000f6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  000fb	8b c0		 mov	 eax, eax
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00103	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00110	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00114	74 23		 je	 SHORT $LN9@stbi__load
  00116	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  0011b	8b c0		 mov	 eax, eax
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00123	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0012c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00130	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00133	89 44 24 44	 mov	 DWORD PTR tv129[rsp], eax
  00137	eb 0a		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  00139	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  0013f	89 44 24 44	 mov	 DWORD PTR tv129[rsp], eax
$LN10@stbi__load:
  00143	83 7c 24 44 00	 cmp	 DWORD PTR tv129[rsp], 0
  00148	74 51		 je	 SHORT $LN5@stbi__load

; 1259 :         int channels = req_comp ? req_comp : *comp;

  0014a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00152	74 0d		 je	 SHORT $LN11@stbi__load
  00154	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0015b	89 44 24 48	 mov	 DWORD PTR tv132[rsp], eax
  0015f	eb 0e		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  00161	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00169	8b 00		 mov	 eax, DWORD PTR [rax]
  0016b	89 44 24 48	 mov	 DWORD PTR tv132[rsp], eax
$LN12@stbi__load:
  0016f	8b 44 24 48	 mov	 eax, DWORD PTR tv132[rsp]
  00173	89 44 24 58	 mov	 DWORD PTR channels$1[rsp], eax

; 1260 :         stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

  00177	44 8b 4c 24 58	 mov	 r9d, DWORD PTR channels$1[rsp]
  0017c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00184	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00187	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0018f	8b 10		 mov	 edx, DWORD PTR [rax]
  00191	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  00196	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip
$LN5@stbi__load:

; 1261 :     }
; 1262 :     
; 1263 :     return (unsigned char *) result;

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__load:

; 1264 : }

  001a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a5	48 33 cc	 xor	 rcx, rsp
  001a8	e8 00 00 00 00	 call	 __security_check_cookie
  001ad	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001b4	c3		 ret	 0
?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_and_postprocess_8bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
slice$ = 32
slice_size$ = 36
bytes$ = 40
image$ = 64
w$ = 72
h$ = 80
z$ = 88
bytes_per_pixel$ = 96
?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z PROC		; stbi__vertical_flip_slices

; 1228 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1229 :     int slice;
; 1230 :     int slice_size = w * h * bytes_per_pixel;

  00017	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  0001b	0f af 44 24 50	 imul	 eax, DWORD PTR h$[rsp]
  00020	0f af 44 24 60	 imul	 eax, DWORD PTR bytes_per_pixel$[rsp]
  00025	89 44 24 24	 mov	 DWORD PTR slice_size$[rsp], eax

; 1231 :     
; 1232 :     stbi_uc *bytes = (stbi_uc *)image;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR image$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 1233 :     for (slice = 0; slice < z; ++slice) {

  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR slice$[rsp], 0
  0003b	eb 0a		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  0003d	8b 44 24 20	 mov	 eax, DWORD PTR slice$[rsp]
  00041	ff c0		 inc	 eax
  00043	89 44 24 20	 mov	 DWORD PTR slice$[rsp], eax
$LN4@stbi__vert:
  00047	8b 44 24 58	 mov	 eax, DWORD PTR z$[rsp]
  0004b	39 44 24 20	 cmp	 DWORD PTR slice$[rsp], eax
  0004f	7d 2f		 jge	 SHORT $LN3@stbi__vert

; 1234 :         stbi__vertical_flip(bytes, w, h, bytes_per_pixel);

  00051	44 8b 4c 24 60	 mov	 r9d, DWORD PTR bytes_per_pixel$[rsp]
  00056	44 8b 44 24 50	 mov	 r8d, DWORD PTR h$[rsp]
  0005b	8b 54 24 48	 mov	 edx, DWORD PTR w$[rsp]
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip

; 1235 :         bytes += slice_size;

  00069	48 63 44 24 24	 movsxd	 rax, DWORD PTR slice_size$[rsp]
  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 1236 :     }

  0007e	eb bd		 jmp	 SHORT $LN2@stbi__vert
$LN3@stbi__vert:

; 1237 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z ENDP		; stbi__vertical_flip_slices
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
row$ = 0
bytes_copy$1 = 8
bytes_left$2 = 16
row0$3 = 24
row1$4 = 32
bytes_per_row$ = 40
bytes$ = 48
tv80 = 56
temp$ = 64
__$ArrayPad$ = 2112
image$ = 2160
w$ = 2168
h$ = 2176
bytes_per_pixel$ = 2184
?stbi__vertical_flip@@YAXPEAXHHH@Z PROC			; stbi__vertical_flip

; 1203 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 58 08
	00 00		 sub	 rsp, 2136		; 00000858H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 40
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1204 :     int row;
; 1205 :     size_t bytes_per_row = (size_t)w * bytes_per_pixel;

  0002e	48 63 84 24 78
	08 00 00	 movsxd	 rax, DWORD PTR w$[rsp]
  00036	48 63 8c 24 88
	08 00 00	 movsxd	 rcx, DWORD PTR bytes_per_pixel$[rsp]
  0003e	48 0f af c1	 imul	 rax, rcx
  00042	48 89 44 24 28	 mov	 QWORD PTR bytes_per_row$[rsp], rax

; 1206 :     stbi_uc temp[2048];
; 1207 :     stbi_uc *bytes = (stbi_uc *)image;

  00047	48 8b 84 24 70
	08 00 00	 mov	 rax, QWORD PTR image$[rsp]
  0004f	48 89 44 24 30	 mov	 QWORD PTR bytes$[rsp], rax

; 1208 :     
; 1209 :     for (row = 0; row < (h>>1); row++) {

  00054	c7 04 24 00 00
	00 00		 mov	 DWORD PTR row$[rsp], 0
  0005b	eb 08		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  0005d	8b 04 24	 mov	 eax, DWORD PTR row$[rsp]
  00060	ff c0		 inc	 eax
  00062	89 04 24	 mov	 DWORD PTR row$[rsp], eax
$LN4@stbi__vert:
  00065	8b 84 24 80 08
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  0006c	d1 f8		 sar	 eax, 1
  0006e	39 04 24	 cmp	 DWORD PTR row$[rsp], eax
  00071	0f 8d 04 01 00
	00		 jge	 $LN3@stbi__vert

; 1210 :         stbi_uc *row0 = bytes + row*bytes_per_row;

  00077	48 63 04 24	 movsxd	 rax, DWORD PTR row$[rsp]
  0007b	48 0f af 44 24
	28		 imul	 rax, QWORD PTR bytes_per_row$[rsp]
  00081	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  00086	48 03 c8	 add	 rcx, rax
  00089	48 8b c1	 mov	 rax, rcx
  0008c	48 89 44 24 18	 mov	 QWORD PTR row0$3[rsp], rax

; 1211 :         stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;

  00091	8b 04 24	 mov	 eax, DWORD PTR row$[rsp]
  00094	8b 8c 24 80 08
	00 00		 mov	 ecx, DWORD PTR h$[rsp]
  0009b	2b c8		 sub	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	ff c8		 dec	 eax
  000a1	48 98		 cdqe
  000a3	48 0f af 44 24
	28		 imul	 rax, QWORD PTR bytes_per_row$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes$[rsp]
  000ae	48 03 c8	 add	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	48 89 44 24 20	 mov	 QWORD PTR row1$4[rsp], rax

; 1212 :         // swap row0 with row1
; 1213 :         size_t bytes_left = bytes_per_row;

  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes_per_row$[rsp]
  000be	48 89 44 24 10	 mov	 QWORD PTR bytes_left$2[rsp], rax
$LN5@stbi__vert:

; 1214 :         while (bytes_left) {

  000c3	48 83 7c 24 10
	00		 cmp	 QWORD PTR bytes_left$2[rsp], 0
  000c9	0f 84 a7 00 00
	00		 je	 $LN6@stbi__vert

; 1215 :             size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

  000cf	48 81 7c 24 10
	00 08 00 00	 cmp	 QWORD PTR bytes_left$2[rsp], 2048 ; 00000800H
  000d8	73 0c		 jae	 SHORT $LN8@stbi__vert
  000da	48 8b 44 24 10	 mov	 rax, QWORD PTR bytes_left$2[rsp]
  000df	48 89 44 24 38	 mov	 QWORD PTR tv80[rsp], rax
  000e4	eb 09		 jmp	 SHORT $LN9@stbi__vert
$LN8@stbi__vert:
  000e6	48 c7 44 24 38
	00 08 00 00	 mov	 QWORD PTR tv80[rsp], 2048 ; 00000800H
$LN9@stbi__vert:
  000ef	48 8b 44 24 38	 mov	 rax, QWORD PTR tv80[rsp]
  000f4	48 89 44 24 08	 mov	 QWORD PTR bytes_copy$1[rsp], rax

; 1216 :             memcpy(temp, row0, bytes_copy);

  000f9	48 8d 44 24 40	 lea	 rax, QWORD PTR temp$[rsp]
  000fe	48 8b f8	 mov	 rdi, rax
  00101	48 8b 74 24 18	 mov	 rsi, QWORD PTR row0$3[rsp]
  00106	48 8b 4c 24 08	 mov	 rcx, QWORD PTR bytes_copy$1[rsp]
  0010b	f3 a4		 rep movsb

; 1217 :             memcpy(row0, row1, bytes_copy);

  0010d	48 8b 7c 24 18	 mov	 rdi, QWORD PTR row0$3[rsp]
  00112	48 8b 74 24 20	 mov	 rsi, QWORD PTR row1$4[rsp]
  00117	48 8b 4c 24 08	 mov	 rcx, QWORD PTR bytes_copy$1[rsp]
  0011c	f3 a4		 rep movsb

; 1218 :             memcpy(row1, temp, bytes_copy);

  0011e	48 8d 44 24 40	 lea	 rax, QWORD PTR temp$[rsp]
  00123	48 8b 7c 24 20	 mov	 rdi, QWORD PTR row1$4[rsp]
  00128	48 8b f0	 mov	 rsi, rax
  0012b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR bytes_copy$1[rsp]
  00130	f3 a4		 rep movsb

; 1219 :             row0 += bytes_copy;

  00132	48 8b 44 24 08	 mov	 rax, QWORD PTR bytes_copy$1[rsp]
  00137	48 8b 4c 24 18	 mov	 rcx, QWORD PTR row0$3[rsp]
  0013c	48 03 c8	 add	 rcx, rax
  0013f	48 8b c1	 mov	 rax, rcx
  00142	48 89 44 24 18	 mov	 QWORD PTR row0$3[rsp], rax

; 1220 :             row1 += bytes_copy;

  00147	48 8b 44 24 08	 mov	 rax, QWORD PTR bytes_copy$1[rsp]
  0014c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR row1$4[rsp]
  00151	48 03 c8	 add	 rcx, rax
  00154	48 8b c1	 mov	 rax, rcx
  00157	48 89 44 24 20	 mov	 QWORD PTR row1$4[rsp], rax

; 1221 :             bytes_left -= bytes_copy;

  0015c	48 8b 44 24 08	 mov	 rax, QWORD PTR bytes_copy$1[rsp]
  00161	48 8b 4c 24 10	 mov	 rcx, QWORD PTR bytes_left$2[rsp]
  00166	48 2b c8	 sub	 rcx, rax
  00169	48 8b c1	 mov	 rax, rcx
  0016c	48 89 44 24 10	 mov	 QWORD PTR bytes_left$2[rsp], rax

; 1222 :         }

  00171	e9 4d ff ff ff	 jmp	 $LN5@stbi__vert
$LN6@stbi__vert:

; 1223 :     }

  00176	e9 e2 fe ff ff	 jmp	 $LN2@stbi__vert
$LN3@stbi__vert:

; 1224 : }

  0017b	48 8b 8c 24 40
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00183	48 33 cc	 xor	 rcx, rsp
  00186	e8 00 00 00 00	 call	 __security_check_cookie
  0018b	48 81 c4 58 08
	00 00		 add	 rsp, 2136		; 00000858H
  00192	5f		 pop	 rdi
  00193	5e		 pop	 rsi
  00194	c3		 ret	 0
?stbi__vertical_flip@@YAXPEAXHHH@Z ENDP			; stbi__vertical_flip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv74 = 36
img_len$ = 40
enlarged$ = 48
orig$ = 80
w$ = 88
h$ = 96
channels$ = 104
?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z PROC		; stbi__convert_8_to_16

; 1187 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1188 :     int i;
; 1189 :     int img_len = w * h * channels;

  00017	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  0001b	0f af 44 24 60	 imul	 eax, DWORD PTR h$[rsp]
  00020	0f af 44 24 68	 imul	 eax, DWORD PTR channels$[rsp]
  00025	89 44 24 28	 mov	 DWORD PTR img_len$[rsp], eax

; 1190 :     stbi__uint16 *enlarged;
; 1191 :     
; 1192 :     enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);

  00029	8b 44 24 28	 mov	 eax, DWORD PTR img_len$[rsp]
  0002d	d1 e0		 shl	 eax, 1
  0002f	48 98		 cdqe
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00039	48 89 44 24 30	 mov	 QWORD PTR enlarged$[rsp], rax

; 1193 :     if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

  0003e	48 83 7c 24 30
	00		 cmp	 QWORD PTR enlarged$[rsp], 0
  00044	75 29		 jne	 SHORT $LN5@stbi__conv
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35443
  0004d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00052	85 c0		 test	 eax, eax
  00054	74 0a		 je	 SHORT $LN7@stbi__conv
  00056	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
  0005e	eb 08		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  00060	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@stbi__conv:
  00068	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  0006d	eb 5e		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1194 :     
; 1195 :     for (i = 0; i < img_len; ++i)

  0006f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00077	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00079	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007d	ff c0		 inc	 eax
  0007f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__conv:
  00083	8b 44 24 28	 mov	 eax, DWORD PTR img_len$[rsp]
  00087	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0008b	7d 31		 jge	 SHORT $LN3@stbi__conv

; 1196 :         enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

  0008d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  00097	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009b	c1 e0 08	 shl	 eax, 8
  0009e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a3	48 8b 54 24 50	 mov	 rdx, QWORD PTR orig$[rsp]
  000a8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ac	03 c1		 add	 eax, ecx
  000ae	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b3	48 8b 54 24 30	 mov	 rdx, QWORD PTR enlarged$[rsp]
  000b8	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  000bc	eb bb		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1197 :     
; 1198 :     STBI_FREE(orig);

  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000c3	e8 00 00 00 00	 call	 free

; 1199 :     return enlarged;

  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR enlarged$[rsp]
$LN1@stbi__conv:

; 1200 : }

  000cd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d1	c3		 ret	 0
?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z ENDP		; stbi__convert_8_to_16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv73 = 36
img_len$ = 40
reduced$ = 48
orig$ = 80
w$ = 88
h$ = 96
channels$ = 104
?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z PROC		; stbi__convert_16_to_8

; 1171 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1172 :     int i;
; 1173 :     int img_len = w * h * channels;

  00017	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  0001b	0f af 44 24 60	 imul	 eax, DWORD PTR h$[rsp]
  00020	0f af 44 24 68	 imul	 eax, DWORD PTR channels$[rsp]
  00025	89 44 24 28	 mov	 DWORD PTR img_len$[rsp], eax

; 1174 :     stbi_uc *reduced;
; 1175 :     
; 1176 :     reduced = (stbi_uc *) stbi__malloc(img_len);

  00029	48 63 44 24 28	 movsxd	 rax, DWORD PTR img_len$[rsp]
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00036	48 89 44 24 30	 mov	 QWORD PTR reduced$[rsp], rax

; 1177 :     if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

  0003b	48 83 7c 24 30
	00		 cmp	 QWORD PTR reduced$[rsp], 0
  00041	75 29		 jne	 SHORT $LN5@stbi__conv
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35424
  0004a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN7@stbi__conv
  00053	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0005b	eb 08		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  0005d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN8@stbi__conv:
  00065	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv73[rsp]
  0006a	eb 52		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1178 :     
; 1179 :     for (i = 0; i < img_len; ++i)

  0006c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00074	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00076	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007a	ff c0		 inc	 eax
  0007c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__conv:
  00080	8b 44 24 28	 mov	 eax, DWORD PTR img_len$[rsp]
  00084	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00088	7d 25		 jge	 SHORT $LN3@stbi__conv

; 1180 :         reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

  0008a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  00094	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00098	c1 f8 08	 sar	 eax, 8
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a5	48 8b 54 24 30	 mov	 rdx, QWORD PTR reduced$[rsp]
  000aa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ad	eb c7		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1181 :     
; 1182 :     STBI_FREE(orig);

  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000b4	e8 00 00 00 00	 call	 free

; 1183 :     return reduced;

  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR reduced$[rsp]
$LN1@stbi__conv:

; 1184 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z ENDP		; stbi__convert_16_to_8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv186 = 64
tv204 = 68
hdr$1 = 72
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
bpc$ = 144
?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z PROC ; stbi__load_main

; 1118 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1119 :     memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields

  00019	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR ri$[rsp]
  00021	33 c0		 xor	 eax, eax
  00023	b9 0c 00 00 00	 mov	 ecx, 12
  00028	f3 aa		 rep stosb

; 1120 :     ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

  0002a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00032	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1121 :     ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

  00038	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00040	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1122 :     ri->num_channels = 0;

  00047	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0004f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1123 :     
; 1124 :     // test the formats with a very explicit header first (at least a FOURCC
; 1125 :     // or distinctive magic number first)
; 1126 : #ifndef STBI_NO_PNG
; 1127 :     if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

  00056	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	e8 00 00 00 00	 call	 ?stbi__png_test@@YAHPEAUstbi__context@@@Z ; stbi__png_test
  00060	85 c0		 test	 eax, eax
  00062	74 36		 je	 SHORT $LN2@stbi__load
  00064	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00078	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00081	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00086	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  0008b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__png_load
  00095	e9 91 02 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1128 : #endif
; 1129 : #ifndef STBI_NO_BMP
; 1130 :     if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);

  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	e8 00 00 00 00	 call	 ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ; stbi__bmp_test
  000a4	85 c0		 test	 eax, eax
  000a6	74 36		 je	 SHORT $LN3@stbi__load
  000a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  000b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000bc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c0	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  000c5	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  000ca	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  000cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000d4	e8 00 00 00 00	 call	 ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__bmp_load
  000d9	e9 4d 02 00 00	 jmp	 $LN1@stbi__load
$LN3@stbi__load:

; 1131 : #endif
; 1132 : #ifndef STBI_NO_GIF
; 1133 :     if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);

  000de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e3	e8 00 00 00 00	 call	 ?stbi__gif_test@@YAHPEAUstbi__context@@@Z ; stbi__gif_test
  000e8	85 c0		 test	 eax, eax
  000ea	74 36		 je	 SHORT $LN4@stbi__load
  000ec	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  000f4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00100	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00104	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00109	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  0010e	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00118	e8 00 00 00 00	 call	 ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__gif_load
  0011d	e9 09 02 00 00	 jmp	 $LN1@stbi__load
$LN4@stbi__load:

; 1134 : #endif
; 1135 : #ifndef STBI_NO_PSD
; 1136 :     if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);

  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00127	e8 00 00 00 00	 call	 ?stbi__psd_test@@YAHPEAUstbi__context@@@Z ; stbi__psd_test
  0012c	85 c0		 test	 eax, eax
  0012e	74 41		 je	 SHORT $LN5@stbi__load
  00130	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR bpc$[rsp]
  00137	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0014f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00153	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00158	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  0015d	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00167	e8 00 00 00 00	 call	 ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__psd_load
  0016c	e9 ba 01 00 00	 jmp	 $LN1@stbi__load
$LN5@stbi__load:

; 1137 : #else
; 1138 :     STBI_NOTUSED(bpc);
; 1139 : #endif
; 1140 : #ifndef STBI_NO_PIC
; 1141 :     if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);

  00171	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00176	e8 00 00 00 00	 call	 ?stbi__pic_test@@YAHPEAUstbi__context@@@Z ; stbi__pic_test
  0017b	85 c0		 test	 eax, eax
  0017d	74 36		 je	 SHORT $LN6@stbi__load
  0017f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00187	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00193	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00197	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0019c	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  001a1	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  001a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ab	e8 00 00 00 00	 call	 ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__pic_load
  001b0	e9 76 01 00 00	 jmp	 $LN1@stbi__load
$LN6@stbi__load:

; 1142 : #endif
; 1143 :     
; 1144 :     // then the formats that can end up attempting to load with just 1 or 2
; 1145 :     // bytes matching expectations; these are prone to false positives, so
; 1146 :     // try them later
; 1147 : #ifndef STBI_NO_JPEG
; 1148 :     if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);

  001b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ba	e8 00 00 00 00	 call	 ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ; stbi__jpeg_test
  001bf	85 c0		 test	 eax, eax
  001c1	74 36		 je	 SHORT $LN7@stbi__load
  001c3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  001cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  001d7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001db	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  001e0	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  001e5	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  001ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ef	e8 00 00 00 00	 call	 ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__jpeg_load
  001f4	e9 32 01 00 00	 jmp	 $LN1@stbi__load
$LN7@stbi__load:

; 1149 : #endif
; 1150 : #ifndef STBI_NO_PNM
; 1151 :     if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);

  001f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001fe	e8 00 00 00 00	 call	 ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ; stbi__pnm_test
  00203	85 c0		 test	 eax, eax
  00205	74 36		 je	 SHORT $LN8@stbi__load
  00207	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0020f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00214	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0021b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0021f	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00224	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00229	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  0022e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00233	e8 00 00 00 00	 call	 ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__pnm_load
  00238	e9 ee 00 00 00	 jmp	 $LN1@stbi__load
$LN8@stbi__load:

; 1152 : #endif
; 1153 :     
; 1154 : #ifndef STBI_NO_HDR
; 1155 :     if (stbi__hdr_test(s)) {

  0023d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00242	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  00247	85 c0		 test	 eax, eax
  00249	74 78		 je	 SHORT $LN9@stbi__load

; 1156 :         float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);

  0024b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00253	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00258	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0025f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00263	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00268	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  0026d	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00272	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00277	e8 00 00 00 00	 call	 ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__hdr_load
  0027c	48 89 44 24 48	 mov	 QWORD PTR hdr$1[rsp], rax

; 1157 :         return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

  00281	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00289	74 0d		 je	 SHORT $LN12@stbi__load
  0028b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00292	89 44 24 40	 mov	 DWORD PTR tv186[rsp], eax
  00296	eb 0b		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:
  00298	48 8b 44 24 78	 mov	 rax, QWORD PTR comp$[rsp]
  0029d	8b 00		 mov	 eax, DWORD PTR [rax]
  0029f	89 44 24 40	 mov	 DWORD PTR tv186[rsp], eax
$LN13@stbi__load:
  002a3	44 8b 4c 24 40	 mov	 r9d, DWORD PTR tv186[rsp]
  002a8	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  002ad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  002b0	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  002b5	8b 10		 mov	 edx, DWORD PTR [rax]
  002b7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hdr$1[rsp]
  002bc	e8 00 00 00 00	 call	 ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z ; stbi__hdr_to_ldr
  002c1	eb 68		 jmp	 SHORT $LN1@stbi__load
$LN9@stbi__load:

; 1158 :     }
; 1159 : #endif
; 1160 :     
; 1161 : #ifndef STBI_NO_TGA
; 1162 :     // test tga last because it's a crappy test!
; 1163 :     if (stbi__tga_test(s))

  002c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002c8	e8 00 00 00 00	 call	 ?stbi__tga_test@@YAHPEAUstbi__context@@@Z ; stbi__tga_test
  002cd	85 c0		 test	 eax, eax
  002cf	74 33		 je	 SHORT $LN10@stbi__load

; 1164 :         return stbi__tga_load(s,x,y,comp,req_comp, ri);

  002d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  002d9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002de	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  002e5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002e9	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  002ee	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  002f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  002f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002fd	e8 00 00 00 00	 call	 ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__tga_load
  00302	eb 27		 jmp	 SHORT $LN1@stbi__load
$LN10@stbi__load:

; 1165 : #endif
; 1166 :     
; 1167 :     return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35406
  0030b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00310	85 c0		 test	 eax, eax
  00312	74 0a		 je	 SHORT $LN14@stbi__load
  00314	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
  0031c	eb 08		 jmp	 SHORT $LN15@stbi__load
$LN14@stbi__load:
  0031e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN15@stbi__load:
  00326	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv204[rsp]
$LN1@stbi__load:

; 1168 : }

  0032b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0032f	5f		 pop	 rdi
  00330	c3		 ret	 0
?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ENDP ; stbi__load_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
k$ = 32
i$ = 36
z$1 = 40
z$2 = 44
tv75 = 48
n$ = 52
output$ = 56
data$ = 80
x$ = 88
y$ = 96
comp$ = 104
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z PROC			; stbi__hdr_to_ldr

; 1865 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1866 :     int i,k,n;
; 1867 :     stbi_uc *output;
; 1868 :     if (!data) return NULL;

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR data$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN8@stbi__hdr_
  0001f	33 c0		 xor	 eax, eax
  00021	e9 fa 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN8@stbi__hdr_:

; 1869 :     output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);

  00026	45 33 c9	 xor	 r9d, r9d
  00029	44 8b 44 24 68	 mov	 r8d, DWORD PTR comp$[rsp]
  0002e	8b 54 24 60	 mov	 edx, DWORD PTR y$[rsp]
  00032	8b 4c 24 58	 mov	 ecx, DWORD PTR x$[rsp]
  00036	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0003b	48 89 44 24 38	 mov	 QWORD PTR output$[rsp], rax

; 1870 :     if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

  00040	48 83 7c 24 38
	00		 cmp	 QWORD PTR output$[rsp], 0
  00046	75 36		 jne	 SHORT $LN9@stbi__hdr_
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  0004d	e8 00 00 00 00	 call	 free
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG36029
  00059	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005e	85 c0		 test	 eax, eax
  00060	74 0a		 je	 SHORT $LN18@stbi__hdr_
  00062	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0006a	eb 08		 jmp	 SHORT $LN19@stbi__hdr_
$LN18@stbi__hdr_:
  0006c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN19@stbi__hdr_:
  00074	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv75[rsp]
  00079	e9 a2 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN9@stbi__hdr_:

; 1871 :     // compute number of non-alpha components
; 1872 :     if (comp & 1) n = comp; else n = comp-1;

  0007e	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  00082	83 e0 01	 and	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	74 0a		 je	 SHORT $LN10@stbi__hdr_
  00089	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  0008d	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
  00091	eb 0a		 jmp	 SHORT $LN11@stbi__hdr_
$LN10@stbi__hdr_:
  00093	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  00097	ff c8		 dec	 eax
  00099	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN11@stbi__hdr_:

; 1873 :     for (i=0; i < x*y; ++i) {

  0009d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a5	eb 0a		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  000a7	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ab	ff c0		 inc	 eax
  000ad	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
  000b1	8b 44 24 58	 mov	 eax, DWORD PTR x$[rsp]
  000b5	0f af 44 24 60	 imul	 eax, DWORD PTR y$[rsp]
  000ba	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000be	0f 8d 4d 01 00
	00		 jge	 $LN3@stbi__hdr_

; 1874 :         for (k=0; k < n; ++k) {

  000c4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000cc	eb 0a		 jmp	 SHORT $LN7@stbi__hdr_
$LN5@stbi__hdr_:
  000ce	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__hdr_:
  000d8	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  000dc	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  000e0	0f 8d 9f 00 00
	00		 jge	 $LN6@stbi__hdr_

; 1875 :             float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

  000e6	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ea	0f af 44 24 68	 imul	 eax, DWORD PTR comp$[rsp]
  000ef	03 44 24 20	 add	 eax, DWORD PTR k$[rsp]
  000f3	48 98		 cdqe
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  000fa	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  000ff	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?stbi__h2l_scale_i@@3MA
  00107	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0010b	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR ?stbi__h2l_gamma_i@@3MA
  00113	e8 00 00 00 00	 call	 pow
  00118	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0011c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00124	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0012c	f3 0f 11 44 24
	28		 movss	 DWORD PTR z$1[rsp], xmm0

; 1876 :             if (z < 0) z = 0;

  00132	0f 57 c0	 xorps	 xmm0, xmm0
  00135	0f 2f 44 24 28	 comiss	 xmm0, DWORD PTR z$1[rsp]
  0013a	76 09		 jbe	 SHORT $LN12@stbi__hdr_
  0013c	0f 57 c0	 xorps	 xmm0, xmm0
  0013f	f3 0f 11 44 24
	28		 movss	 DWORD PTR z$1[rsp], xmm0
$LN12@stbi__hdr_:

; 1877 :             if (z > 255) z = 255;

  00145	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR z$1[rsp]
  0014b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00152	76 0e		 jbe	 SHORT $LN13@stbi__hdr_
  00154	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0015c	f3 0f 11 44 24
	28		 movss	 DWORD PTR z$1[rsp], xmm0
$LN13@stbi__hdr_:

; 1878 :             output[i*comp + k] = (stbi_uc) stbi__float2int(z);

  00162	f3 0f 2c 44 24
	28		 cvttss2si eax, DWORD PTR z$1[rsp]
  00168	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  0016c	0f af 4c 24 68	 imul	 ecx, DWORD PTR comp$[rsp]
  00171	03 4c 24 20	 add	 ecx, DWORD PTR k$[rsp]
  00175	48 63 c9	 movsxd	 rcx, ecx
  00178	48 8b 54 24 38	 mov	 rdx, QWORD PTR output$[rsp]
  0017d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1879 :         }

  00180	e9 49 ff ff ff	 jmp	 $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 1880 :         if (k < comp) {

  00185	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  00189	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0018d	7d 7d		 jge	 SHORT $LN14@stbi__hdr_

; 1881 :             float z = data[i*comp+k] * 255 + 0.5f;

  0018f	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00193	0f af 44 24 68	 imul	 eax, DWORD PTR comp$[rsp]
  00198	03 44 24 20	 add	 eax, DWORD PTR k$[rsp]
  0019c	48 98		 cdqe
  0019e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  001a3	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  001a8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001b0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001b8	f3 0f 11 44 24
	2c		 movss	 DWORD PTR z$2[rsp], xmm0

; 1882 :             if (z < 0) z = 0;

  001be	0f 57 c0	 xorps	 xmm0, xmm0
  001c1	0f 2f 44 24 2c	 comiss	 xmm0, DWORD PTR z$2[rsp]
  001c6	76 09		 jbe	 SHORT $LN15@stbi__hdr_
  001c8	0f 57 c0	 xorps	 xmm0, xmm0
  001cb	f3 0f 11 44 24
	2c		 movss	 DWORD PTR z$2[rsp], xmm0
$LN15@stbi__hdr_:

; 1883 :             if (z > 255) z = 255;

  001d1	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR z$2[rsp]
  001d7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  001de	76 0e		 jbe	 SHORT $LN16@stbi__hdr_
  001e0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  001e8	f3 0f 11 44 24
	2c		 movss	 DWORD PTR z$2[rsp], xmm0
$LN16@stbi__hdr_:

; 1884 :             output[i*comp + k] = (stbi_uc) stbi__float2int(z);

  001ee	f3 0f 2c 44 24
	2c		 cvttss2si eax, DWORD PTR z$2[rsp]
  001f4	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  001f8	0f af 4c 24 68	 imul	 ecx, DWORD PTR comp$[rsp]
  001fd	03 4c 24 20	 add	 ecx, DWORD PTR k$[rsp]
  00201	48 63 c9	 movsxd	 rcx, ecx
  00204	48 8b 54 24 38	 mov	 rdx, QWORD PTR output$[rsp]
  00209	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN14@stbi__hdr_:

; 1885 :         }
; 1886 :     }

  0020c	e9 96 fe ff ff	 jmp	 $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 1887 :     STBI_FREE(data);

  00211	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  00216	e8 00 00 00 00	 call	 free

; 1888 :     return output;

  0021b	48 8b 44 24 38	 mov	 rax, QWORD PTR output$[rsp]
$LN1@stbi__hdr_:

; 1889 : }

  00220	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00224	c3		 ret	 0
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z ENDP			; stbi__hdr_to_ldr
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 48
k$ = 52
n$ = 56
tv76 = 60
output$ = 64
data$ = 96
x$ = 104
y$ = 112
comp$ = 120
?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z PROC			; stbi__ldr_to_hdr

; 1839 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1840 :     int i,k,n;
; 1841 :     float *output;
; 1842 :     if (!data) return NULL;

  00017	48 83 7c 24 60
	00		 cmp	 QWORD PTR data$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN11@stbi__ldr_
  0001f	33 c0		 xor	 eax, eax
  00021	e9 a7 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN11@stbi__ldr_:

; 1843 :     output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0002e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00034	44 8b 44 24 78	 mov	 r8d, DWORD PTR comp$[rsp]
  00039	8b 54 24 70	 mov	 edx, DWORD PTR y$[rsp]
  0003d	8b 4c 24 68	 mov	 ecx, DWORD PTR x$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__malloc_mad4@@YAPEAXHHHHH@Z ; stbi__malloc_mad4
  00046	48 89 44 24 40	 mov	 QWORD PTR output$[rsp], rax

; 1844 :     if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

  0004b	48 83 7c 24 40
	00		 cmp	 QWORD PTR output$[rsp], 0
  00051	75 36		 jne	 SHORT $LN12@stbi__ldr_
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00058	e8 00 00 00 00	 call	 free
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35997
  00064	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00069	85 c0		 test	 eax, eax
  0006b	74 0a		 je	 SHORT $LN17@stbi__ldr_
  0006d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00075	eb 08		 jmp	 SHORT $LN18@stbi__ldr_
$LN17@stbi__ldr_:
  00077	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN18@stbi__ldr_:
  0007f	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv76[rsp]
  00084	e9 44 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN12@stbi__ldr_:

; 1845 :     // compute number of non-alpha components
; 1846 :     if (comp & 1) n = comp; else n = comp-1;

  00089	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  0008d	83 e0 01	 and	 eax, 1
  00090	85 c0		 test	 eax, eax
  00092	74 0a		 je	 SHORT $LN13@stbi__ldr_
  00094	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00098	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  0009c	eb 0a		 jmp	 SHORT $LN14@stbi__ldr_
$LN13@stbi__ldr_:
  0009e	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  000a2	ff c8		 dec	 eax
  000a4	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
$LN14@stbi__ldr_:

; 1847 :     for (i=0; i < x*y; ++i) {

  000a8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b0	eb 0a		 jmp	 SHORT $LN4@stbi__ldr_
$LN2@stbi__ldr_:
  000b2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000b6	ff c0		 inc	 eax
  000b8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__ldr_:
  000bc	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  000c0	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  000c5	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000c9	0f 8d 83 00 00
	00		 jge	 $LN3@stbi__ldr_

; 1848 :         for (k=0; k < n; ++k) {

  000cf	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000d7	eb 0a		 jmp	 SHORT $LN7@stbi__ldr_
$LN5@stbi__ldr_:
  000d9	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  000dd	ff c0		 inc	 eax
  000df	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__ldr_:
  000e3	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  000e7	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  000eb	7d 60		 jge	 SHORT $LN6@stbi__ldr_

; 1849 :             output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

  000ed	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000f1	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  000f6	03 44 24 34	 add	 eax, DWORD PTR k$[rsp]
  000fa	48 98		 cdqe
  000fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00101	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00105	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00109	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  00111	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00115	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR ?stbi__l2h_gamma@@3MA
  0011d	e8 00 00 00 00	 call	 pow
  00122	f3 0f 5a 0d 00
	00 00 00	 cvtss2sd xmm1, DWORD PTR ?stbi__l2h_scale@@3MA
  0012a	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0012e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00132	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00136	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  0013b	03 44 24 34	 add	 eax, DWORD PTR k$[rsp]
  0013f	48 98		 cdqe
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00146	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1850 :         }

  0014b	eb 8c		 jmp	 SHORT $LN5@stbi__ldr_
$LN6@stbi__ldr_:

; 1851 :     }

  0014d	e9 60 ff ff ff	 jmp	 $LN2@stbi__ldr_
$LN3@stbi__ldr_:

; 1852 :     if (n < comp) {

  00152	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00156	39 44 24 38	 cmp	 DWORD PTR n$[rsp], eax
  0015a	7d 62		 jge	 SHORT $LN15@stbi__ldr_

; 1853 :         for (i=0; i < x*y; ++i) {

  0015c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00164	eb 0a		 jmp	 SHORT $LN10@stbi__ldr_
$LN8@stbi__ldr_:
  00166	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0016a	ff c0		 inc	 eax
  0016c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__ldr_:
  00170	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  00174	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  00179	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0017d	7d 3f		 jge	 SHORT $LN9@stbi__ldr_

; 1854 :             output[i*comp + n] = data[i*comp + n]/255.0f;

  0017f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00183	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  00188	03 44 24 38	 add	 eax, DWORD PTR n$[rsp]
  0018c	48 98		 cdqe
  0018e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00193	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00197	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0019b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  001a3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001a7	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  001ac	03 44 24 38	 add	 eax, DWORD PTR n$[rsp]
  001b0	48 98		 cdqe
  001b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001b7	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1855 :         }

  001bc	eb a8		 jmp	 SHORT $LN8@stbi__ldr_
$LN9@stbi__ldr_:
$LN15@stbi__ldr_:

; 1856 :     }
; 1857 :     STBI_FREE(data);

  001be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  001c3	e8 00 00 00 00	 call	 free

; 1858 :     return output;

  001c8	48 8b 44 24 40	 mov	 rax, QWORD PTR output$[rsp]
$LN1@stbi__ldr_:

; 1859 : }

  001cd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d1	c3		 ret	 0
?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z ENDP			; stbi__ldr_to_hdr
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 64
b$ = 72
c$ = 80
d$ = 88
add$ = 96
?stbi__malloc_mad4@@YAPEAXHHHHH@Z PROC			; stbi__malloc_mad4

; 1060 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1061 :     if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

  00016	8b 44 24 60	 mov	 eax, DWORD PTR add$[rsp]
  0001a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0001e	44 8b 4c 24 58	 mov	 r9d, DWORD PTR d$[rsp]
  00023	44 8b 44 24 50	 mov	 r8d, DWORD PTR c$[rsp]
  00028	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  0002c	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  00030	e8 00 00 00 00	 call	 ?stbi__mad4sizes_valid@@YAHHHHHH@Z ; stbi__mad4sizes_valid
  00035	85 c0		 test	 eax, eax
  00037	75 04		 jne	 SHORT $LN2@stbi__mall
  00039	33 c0		 xor	 eax, eax
  0003b	eb 21		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1062 :     return stbi__malloc(a*b*c*d + add);

  0003d	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00041	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00046	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0004b	0f af 44 24 58	 imul	 eax, DWORD PTR d$[rsp]
  00050	03 44 24 60	 add	 eax, DWORD PTR add$[rsp]
  00054	48 98		 cdqe
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
$LN1@stbi__mall:

; 1063 : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
?stbi__malloc_mad4@@YAPEAXHHHHH@Z ENDP			; stbi__malloc_mad4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 48
b$ = 56
c$ = 64
add$ = 72
?stbi__malloc_mad3@@YAPEAXHHHH@Z PROC			; stbi__malloc_mad3

; 1053 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1054 :     if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

  00016	44 8b 4c 24 48	 mov	 r9d, DWORD PTR add$[rsp]
  0001b	44 8b 44 24 40	 mov	 r8d, DWORD PTR c$[rsp]
  00020	8b 54 24 38	 mov	 edx, DWORD PTR b$[rsp]
  00024	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  00028	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  0002d	85 c0		 test	 eax, eax
  0002f	75 04		 jne	 SHORT $LN2@stbi__mall
  00031	33 c0		 xor	 eax, eax
  00033	eb 1c		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1055 :     return stbi__malloc(a*b*c + add);

  00035	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00039	0f af 44 24 38	 imul	 eax, DWORD PTR b$[rsp]
  0003e	0f af 44 24 40	 imul	 eax, DWORD PTR c$[rsp]
  00043	03 44 24 48	 add	 eax, DWORD PTR add$[rsp]
  00047	48 98		 cdqe
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
$LN1@stbi__mall:

; 1056 : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
?stbi__malloc_mad3@@YAPEAXHHHH@Z ENDP			; stbi__malloc_mad3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 48
b$ = 56
add$ = 64
?stbi__malloc_mad2@@YAPEAXHHH@Z PROC			; stbi__malloc_mad2

; 1046 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1047 :     if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

  00011	44 8b 44 24 40	 mov	 r8d, DWORD PTR add$[rsp]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR b$[rsp]
  0001a	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__mad2sizes_valid@@YAHHHH@Z ; stbi__mad2sizes_valid
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@stbi__mall
  00027	33 c0		 xor	 eax, eax
  00029	eb 17		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1048 :     return stbi__malloc(a*b + add);

  0002b	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  0002f	0f af 44 24 38	 imul	 eax, DWORD PTR b$[rsp]
  00034	03 44 24 40	 add	 eax, DWORD PTR add$[rsp]
  00038	48 98		 cdqe
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
$LN1@stbi__mall:

; 1049 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
?stbi__malloc_mad2@@YAPEAXHHH@Z ENDP			; stbi__malloc_mad2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv86 = 32
a$ = 64
b$ = 72
c$ = 80
d$ = 88
add$ = 96
?stbi__mad4sizes_valid@@YAHHHHHH@Z PROC			; stbi__mad4sizes_valid

; 1037 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1038 :     return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

  00016	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  00023	85 c0		 test	 eax, eax
  00025	74 61		 je	 SHORT $LN3@stbi__mad4
  00027	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  0002b	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00030	8b 54 24 50	 mov	 edx, DWORD PTR c$[rsp]
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  0003b	85 c0		 test	 eax, eax
  0003d	74 49		 je	 SHORT $LN3@stbi__mad4
  0003f	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00043	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00048	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0004d	8b 54 24 58	 mov	 edx, DWORD PTR d$[rsp]
  00051	8b c8		 mov	 ecx, eax
  00053	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  00058	85 c0		 test	 eax, eax
  0005a	74 2c		 je	 SHORT $LN3@stbi__mad4
  0005c	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00060	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00065	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0006a	0f af 44 24 58	 imul	 eax, DWORD PTR d$[rsp]
  0006f	8b 54 24 60	 mov	 edx, DWORD PTR add$[rsp]
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 ?stbi__addsizes_valid@@YAHHH@Z ; stbi__addsizes_valid
  0007a	85 c0		 test	 eax, eax
  0007c	74 0a		 je	 SHORT $LN3@stbi__mad4
  0007e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00086	eb 08		 jmp	 SHORT $LN4@stbi__mad4
$LN3@stbi__mad4:
  00088	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN4@stbi__mad4:
  00090	8b 44 24 20	 mov	 eax, DWORD PTR tv86[rsp]

; 1039 :         stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
; 1040 : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
?stbi__mad4sizes_valid@@YAHHHHHH@Z ENDP			; stbi__mad4sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv79 = 32
a$ = 64
b$ = 72
c$ = 80
add$ = 88
?stbi__mad3sizes_valid@@YAHHHHH@Z PROC			; stbi__mad3sizes_valid

; 1029 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1030 :     return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

  00016	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  00023	85 c0		 test	 eax, eax
  00025	74 3f		 je	 SHORT $LN3@stbi__mad3
  00027	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  0002b	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00030	8b 54 24 50	 mov	 edx, DWORD PTR c$[rsp]
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  0003b	85 c0		 test	 eax, eax
  0003d	74 27		 je	 SHORT $LN3@stbi__mad3
  0003f	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00043	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00048	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0004d	8b 54 24 58	 mov	 edx, DWORD PTR add$[rsp]
  00051	8b c8		 mov	 ecx, eax
  00053	e8 00 00 00 00	 call	 ?stbi__addsizes_valid@@YAHHH@Z ; stbi__addsizes_valid
  00058	85 c0		 test	 eax, eax
  0005a	74 0a		 je	 SHORT $LN3@stbi__mad3
  0005c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN4@stbi__mad3
$LN3@stbi__mad3:
  00066	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN4@stbi__mad3:
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR tv79[rsp]

; 1031 :         stbi__addsizes_valid(a*b*c, add);
; 1032 : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
?stbi__mad3sizes_valid@@YAHHHHH@Z ENDP			; stbi__mad3sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv73 = 32
a$ = 64
b$ = 72
add$ = 80
?stbi__mad2sizes_valid@@YAHHHH@Z PROC			; stbi__mad2sizes_valid

; 1022 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1023 :     return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

  00011	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  00015	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  00019	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  0001e	85 c0		 test	 eax, eax
  00020	74 22		 je	 SHORT $LN3@stbi__mad2
  00022	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00026	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  0002b	8b 54 24 50	 mov	 edx, DWORD PTR add$[rsp]
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ?stbi__addsizes_valid@@YAHHH@Z ; stbi__addsizes_valid
  00036	85 c0		 test	 eax, eax
  00038	74 0a		 je	 SHORT $LN3@stbi__mad2
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN4@stbi__mad2
$LN3@stbi__mad2:
  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN4@stbi__mad2:
  0004c	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]

; 1024 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
?stbi__mad2sizes_valid@@YAHHHH@Z ENDP			; stbi__mad2sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv69 = 0
a$ = 32
b$ = 40
?stbi__mul2sizes_valid@@YAHHH@Z PROC			; stbi__mul2sizes_valid

; 1012 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1013 :     if (a < 0 || b < 0) return 0;

  0000c	83 7c 24 20 00	 cmp	 DWORD PTR a$[rsp], 0
  00011	7c 07		 jl	 SHORT $LN3@stbi__mul2
  00013	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00018	7d 04		 jge	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 31		 jmp	 SHORT $LN1@stbi__mul2
$LN2@stbi__mul2:

; 1014 :     if (b == 0) return 1; // mul-by-0 is always safe

  0001e	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00023	75 07		 jne	 SHORT $LN4@stbi__mul2
  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	eb 23		 jmp	 SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 1015 :     // portable way to check for no overflows in a*b
; 1016 :     return a <= INT_MAX/b;

  0002c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00031	99		 cdq
  00032	f7 7c 24 28	 idiv	 DWORD PTR b$[rsp]
  00036	39 44 24 20	 cmp	 DWORD PTR a$[rsp], eax
  0003a	7f 09		 jg	 SHORT $LN6@stbi__mul2
  0003c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  00043	eb 07		 jmp	 SHORT $LN7@stbi__mul2
$LN6@stbi__mul2:
  00045	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN7@stbi__mul2:
  0004c	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
$LN1@stbi__mul2:

; 1017 : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
?stbi__mul2sizes_valid@@YAHHH@Z ENDP			; stbi__mul2sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv67 = 0
a$ = 32
b$ = 40
?stbi__addsizes_valid@@YAHHH@Z PROC			; stbi__addsizes_valid

; 1000 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1001 :     if (b < 0) return 0;

  0000c	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00011	7d 04		 jge	 SHORT $LN2@stbi__adds
  00013	33 c0		 xor	 eax, eax
  00015	eb 22		 jmp	 SHORT $LN1@stbi__adds
$LN2@stbi__adds:

; 1002 :     // now 0 <= b <= INT_MAX, hence also
; 1003 :     // 0 <= INT_MAX - b <= INTMAX.
; 1004 :     // And "a + b <= INT_MAX" (which might overflow) is the
; 1005 :     // same as a <= INT_MAX - b (no overflow)
; 1006 :     return a <= INT_MAX - b;

  00017	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0001c	2b 44 24 28	 sub	 eax, DWORD PTR b$[rsp]
  00020	39 44 24 20	 cmp	 DWORD PTR a$[rsp], eax
  00024	7f 09		 jg	 SHORT $LN4@stbi__adds
  00026	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  0002d	eb 07		 jmp	 SHORT $LN5@stbi__adds
$LN4@stbi__adds:
  0002f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN5@stbi__adds:
  00036	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]
$LN1@stbi__adds:

; 1007 : }

  00039	48 83 c4 18	 add	 rsp, 24
  0003d	c3		 ret	 0
?stbi__addsizes_valid@@YAHHH@Z ENDP			; stbi__addsizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
size$ = 48
?stbi__malloc@@YAPEAX_K@Z PROC				; stbi__malloc

; 983  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 984  :     return STBI_MALLOC(size);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0000e	e8 00 00 00 00	 call	 malloc

; 985  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?stbi__malloc@@YAPEAX_K@Z ENDP				; stbi__malloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
str$ = 8
?stbi__err@@YAHPEBD@Z PROC				; stbi__err

; 976  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 977  :     stbi__g_failure_reason = str;

  00005	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
  0000a	8b c0		 mov	 eax, eax
  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00012	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001f	48 8b 54 24 08	 mov	 rdx, QWORD PTR str$[rsp]
  00024	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 978  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 979  : }

  0002a	c3		 ret	 0
?stbi__err@@YAHPEBD@Z ENDP				; stbi__err
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z PROC		; stbi__pnm_is16

; 7534 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7535 :     if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00016	e8 00 00 00 00	 call	 ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
  0001b	83 f8 10	 cmp	 eax, 16
  0001e	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7536 :         return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	eb 02		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7537 :     return 0;

  00027	33 c0		 xor	 eax, eax
$LN1@stbi__pnm_:

; 7538 : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pnm_is16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
c$ = 32
t$ = 33
p$ = 34
dummy$ = 36
tv81 = 40
maxv$ = 44
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pnm_info

; 7495 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7496 :     int maxv, dummy;
; 7497 :     char c, p, t;
; 7498 :     
; 7499 :     if (!x) x = &dummy;

  00018	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  0001e	75 0a		 jne	 SHORT $LN2@stbi__pnm_
  00020	48 8d 44 24 24	 lea	 rax, QWORD PTR dummy$[rsp]
  00025	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax
$LN2@stbi__pnm_:

; 7500 :     if (!y) y = &dummy;

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN3@stbi__pnm_
  00032	48 8d 44 24 24	 lea	 rax, QWORD PTR dummy$[rsp]
  00037	48 89 44 24 50	 mov	 QWORD PTR y$[rsp], rax
$LN3@stbi__pnm_:

; 7501 :     if (!comp) comp = &dummy;

  0003c	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00042	75 0a		 jne	 SHORT $LN4@stbi__pnm_
  00044	48 8d 44 24 24	 lea	 rax, QWORD PTR dummy$[rsp]
  00049	48 89 44 24 58	 mov	 QWORD PTR comp$[rsp], rax
$LN4@stbi__pnm_:

; 7502 :     
; 7503 :     stbi__rewind(s);

  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7504 :     
; 7505 :     // Get identifier
; 7506 :     p = (char) stbi__get8(s);

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00062	88 44 24 22	 mov	 BYTE PTR p$[rsp], al

; 7507 :     t = (char) stbi__get8(s);

  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00070	88 44 24 21	 mov	 BYTE PTR t$[rsp], al

; 7508 :     if (p != 'P' || (t != '5' && t != '6')) {

  00074	0f be 44 24 22	 movsx	 eax, BYTE PTR p$[rsp]
  00079	83 f8 50	 cmp	 eax, 80			; 00000050H
  0007c	75 14		 jne	 SHORT $LN6@stbi__pnm_
  0007e	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  00083	83 f8 35	 cmp	 eax, 53			; 00000035H
  00086	74 1b		 je	 SHORT $LN5@stbi__pnm_
  00088	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  0008d	83 f8 36	 cmp	 eax, 54			; 00000036H
  00090	74 11		 je	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7509 :         stbi__rewind(s);

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00097	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7510 :         return 0;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 d3 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN5@stbi__pnm_:

; 7511 :     }
; 7512 :     
; 7513 :     *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

  000a3	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  000a8	83 f8 36	 cmp	 eax, 54			; 00000036H
  000ab	75 0a		 jne	 SHORT $LN12@stbi__pnm_
  000ad	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv81[rsp], 3
  000b5	eb 08		 jmp	 SHORT $LN13@stbi__pnm_
$LN12@stbi__pnm_:
  000b7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
$LN13@stbi__pnm_:
  000bf	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  000c4	8b 4c 24 28	 mov	 ecx, DWORD PTR tv81[rsp]
  000c8	89 08		 mov	 DWORD PTR [rax], ecx

; 7514 :     
; 7515 :     c = (char) stbi__get8(s);

  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000d4	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 7516 :     stbi__pnm_skip_whitespace(s, &c);

  000d8	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000e2	e8 00 00 00 00	 call	 ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7517 :     
; 7518 :     *x = stbi__pnm_getinteger(s, &c); // read width

  000e7	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
  000f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  000fb	89 01		 mov	 DWORD PTR [rcx], eax

; 7519 :     stbi__pnm_skip_whitespace(s, &c);

  000fd	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00107	e8 00 00 00 00	 call	 ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7520 :     
; 7521 :     *y = stbi__pnm_getinteger(s, &c); // read height

  0010c	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  00111	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00116	e8 00 00 00 00	 call	 ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  00120	89 01		 mov	 DWORD PTR [rcx], eax

; 7522 :     stbi__pnm_skip_whitespace(s, &c);

  00122	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  00127	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	e8 00 00 00 00	 call	 ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7523 :     
; 7524 :     maxv = stbi__pnm_getinteger(s, &c);  // read max value

  00131	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0013b	e8 00 00 00 00	 call	 ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
  00140	89 44 24 2c	 mov	 DWORD PTR maxv$[rsp], eax

; 7525 :     if (maxv > 65535)

  00144	81 7c 24 2c ff
	ff 00 00	 cmp	 DWORD PTR maxv$[rsp], 65535 ; 0000ffffH
  0014c	7e 10		 jle	 SHORT $LN7@stbi__pnm_

; 7526 :         return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");

  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41127
  00155	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015a	eb 1a		 jmp	 SHORT $LN1@stbi__pnm_
  0015c	eb 18		 jmp	 SHORT $LN8@stbi__pnm_
$LN7@stbi__pnm_:

; 7527 :     else if (maxv > 255)

  0015e	81 7c 24 2c ff
	00 00 00	 cmp	 DWORD PTR maxv$[rsp], 255 ; 000000ffH
  00166	7e 09		 jle	 SHORT $LN9@stbi__pnm_

; 7528 :         return 16;

  00168	b8 10 00 00 00	 mov	 eax, 16
  0016d	eb 07		 jmp	 SHORT $LN1@stbi__pnm_
  0016f	eb 05		 jmp	 SHORT $LN10@stbi__pnm_
$LN9@stbi__pnm_:

; 7529 :     else
; 7530 :         return 8;

  00171	b8 08 00 00 00	 mov	 eax, 8
$LN10@stbi__pnm_:
$LN8@stbi__pnm_:
$LN1@stbi__pnm_:

; 7531 : }

  00176	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0017a	c3		 ret	 0
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pnm_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv80 = 48
tv87 = 52
tv140 = 56
tv157 = 60
tv164 = 64
out$ = 72
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__pnm_load

; 7429 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 7430 :     stbi_uc *out;
; 7431 :     STBI_NOTUSED(ri);
; 7432 :     
; 7433 :     ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00026	48 83 c1 04	 add	 rcx, 4
  0002a	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0002f	4c 8b c8	 mov	 r9, rax
  00032	4c 8b c1	 mov	 r8, rcx
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
  0003f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  00047	89 01		 mov	 DWORD PTR [rcx], eax

; 7434 :     if (ri->bits_per_channel == 0)

  00049	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00051	83 38 00	 cmp	 DWORD PTR [rax], 0
  00054	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7435 :         return 0;

  00056	33 c0		 xor	 eax, eax
  00058	e9 33 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7436 :     
; 7437 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00062	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00069	76 2c		 jbe	 SHORT $LN3@stbi__pnm_
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41067
  00072	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00077	85 c0		 test	 eax, eax
  00079	74 0a		 je	 SHORT $LN11@stbi__pnm_
  0007b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00083	eb 08		 jmp	 SHORT $LN12@stbi__pnm_
$LN11@stbi__pnm_:
  00085	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN12@stbi__pnm_:
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv80[rsp]
  00092	e9 f9 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN3@stbi__pnm_:

; 7438 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0009c	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  000a2	76 2c		 jbe	 SHORT $LN4@stbi__pnm_
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41069
  000ab	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN13@stbi__pnm_
  000b4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  000bc	eb 08		 jmp	 SHORT $LN14@stbi__pnm_
$LN13@stbi__pnm_:
  000be	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN14@stbi__pnm_:
  000c6	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv87[rsp]
  000cb	e9 c0 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7439 :     
; 7440 :     *x = s->img_x;

  000d0	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000da	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000dc	89 08		 mov	 DWORD PTR [rax], ecx

; 7441 :     *y = s->img_y;

  000de	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  000e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e8	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000eb	89 08		 mov	 DWORD PTR [rax], ecx

; 7442 :     if (comp) *comp = s->img_n;

  000ed	48 83 7c 24 78
	00		 cmp	 QWORD PTR comp$[rsp], 0
  000f3	74 0f		 je	 SHORT $LN5@stbi__pnm_
  000f5	48 8b 44 24 78	 mov	 rax, QWORD PTR comp$[rsp]
  000fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ff	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00102	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__pnm_:

; 7443 :     
; 7444 :     if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))

  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0010c	8b 00		 mov	 eax, DWORD PTR [rax]
  0010e	99		 cdq
  0010f	83 e2 07	 and	 edx, 7
  00112	03 c2		 add	 eax, edx
  00114	c1 f8 03	 sar	 eax, 3
  00117	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0011f	44 8b c8	 mov	 r9d, eax
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00127	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00130	8b 10		 mov	 edx, DWORD PTR [rax]
  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00137	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0013a	e8 00 00 00 00	 call	 ?stbi__mad4sizes_valid@@YAHHHHHH@Z ; stbi__mad4sizes_valid
  0013f	85 c0		 test	 eax, eax
  00141	75 2c		 jne	 SHORT $LN6@stbi__pnm_

; 7445 :         return stbi__errpuc("too large", "PNM too large");

  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41072
  0014a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014f	85 c0		 test	 eax, eax
  00151	74 0a		 je	 SHORT $LN15@stbi__pnm_
  00153	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
  0015b	eb 08		 jmp	 SHORT $LN16@stbi__pnm_
$LN15@stbi__pnm_:
  0015d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN16@stbi__pnm_:
  00165	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv140[rsp]
  0016a	e9 21 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN6@stbi__pnm_:

; 7446 :     
; 7447 :     out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);

  0016f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00177	8b 00		 mov	 eax, DWORD PTR [rax]
  00179	99		 cdq
  0017a	83 e2 07	 and	 edx, 7
  0017d	03 c2		 add	 eax, edx
  0017f	c1 f8 03	 sar	 eax, 3
  00182	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0018a	44 8b c8	 mov	 r9d, eax
  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00192	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0019b	8b 10		 mov	 edx, DWORD PTR [rax]
  0019d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001a2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001a5	e8 00 00 00 00	 call	 ?stbi__malloc_mad4@@YAPEAXHHHHH@Z ; stbi__malloc_mad4
  001aa	48 89 44 24 48	 mov	 QWORD PTR out$[rsp], rax

; 7448 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  001af	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  001b5	75 2c		 jne	 SHORT $LN7@stbi__pnm_
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41074
  001be	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c3	85 c0		 test	 eax, eax
  001c5	74 0a		 je	 SHORT $LN17@stbi__pnm_
  001c7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
  001cf	eb 08		 jmp	 SHORT $LN18@stbi__pnm_
$LN17@stbi__pnm_:
  001d1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN18@stbi__pnm_:
  001d9	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv157[rsp]
  001de	e9 ad 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7449 :     stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));

  001e3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ed	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001f0	0f af 01	 imul	 eax, DWORD PTR [rcx]
  001f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f8	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  001fc	89 44 24 40	 mov	 DWORD PTR tv164[rsp], eax
  00200	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  00208	8b 01		 mov	 eax, DWORD PTR [rcx]
  0020a	99		 cdq
  0020b	83 e2 07	 and	 edx, 7
  0020e	03 c2		 add	 eax, edx
  00210	c1 f8 03	 sar	 eax, 3
  00213	8b 4c 24 40	 mov	 ecx, DWORD PTR tv164[rsp]
  00217	0f af c8	 imul	 ecx, eax
  0021a	8b c1		 mov	 eax, ecx
  0021c	44 8b c0	 mov	 r8d, eax
  0021f	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  00224	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00229	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 7450 :     
; 7451 :     if (req_comp && req_comp != s->img_n) {

  0022e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00236	74 53		 je	 SHORT $LN8@stbi__pnm_
  00238	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0023d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00240	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00247	74 42		 je	 SHORT $LN8@stbi__pnm_

; 7452 :         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

  00249	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0024e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00251	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00255	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0025a	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0025d	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00265	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0026a	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  0026d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  00272	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00277	48 89 44 24 48	 mov	 QWORD PTR out$[rsp], rax

; 7453 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  0027c	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  00282	75 07		 jne	 SHORT $LN9@stbi__pnm_
  00284	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
  00289	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN9@stbi__pnm_:
$LN8@stbi__pnm_:

; 7454 :     }
; 7455 :     return out;

  0028b	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__pnm_:

; 7456 : }

  00290	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00294	c3		 ret	 0
?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__pnm_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
t$ = 32
p$ = 33
s$ = 64
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pnm_test

; 7417 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7418 :     char p, t;
; 7419 :     p = (char) stbi__get8(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	88 44 24 21	 mov	 BYTE PTR p$[rsp], al

; 7420 :     t = (char) stbi__get8(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00021	88 44 24 20	 mov	 BYTE PTR t$[rsp], al

; 7421 :     if (p != 'P' || (t != '5' && t != '6')) {

  00025	0f be 44 24 21	 movsx	 eax, BYTE PTR p$[rsp]
  0002a	83 f8 50	 cmp	 eax, 80			; 00000050H
  0002d	75 14		 jne	 SHORT $LN3@stbi__pnm_
  0002f	0f be 44 24 20	 movsx	 eax, BYTE PTR t$[rsp]
  00034	83 f8 35	 cmp	 eax, 53			; 00000035H
  00037	74 18		 je	 SHORT $LN2@stbi__pnm_
  00039	0f be 44 24 20	 movsx	 eax, BYTE PTR t$[rsp]
  0003e	83 f8 36	 cmp	 eax, 54			; 00000036H
  00041	74 0e		 je	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7422 :         stbi__rewind( s );

  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7423 :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7424 :     }
; 7425 :     return 1;

  00051	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pnm_:

; 7426 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pnm_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__gif_info

; 7000 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7001 :     return stbi__gif_info_raw(s,x,y,comp);

  00018	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__gif_info_raw

; 7002 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__gif_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
layers$1 = 48
stride$2 = 52
out$3 = 56
u$4 = 64
out_size$5 = 72
delays_size$6 = 76
tv205 = 80
tmp$7 = 88
new_delays$8 = 96
two_back$9 = 104
g$10 = 112
__$ArrayPad$ = 35040
s$ = 35088
delays$ = 35096
x$ = 35104
y$ = 35112
z$ = 35120
comp$ = 35128
req_comp$ = 35136
?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z PROC ; stbi__load_gif_main

; 6886 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	b8 f8 88 00 00	 mov	 eax, 35064		; 000088f8H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 e0
	88 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6887 :     if (stbi__gif_test(s)) {

  00035	48 8b 8c 24 10
	89 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	e8 00 00 00 00	 call	 ?stbi__gif_test@@YAHPEAUstbi__context@@@Z ; stbi__gif_test
  00042	85 c0		 test	 eax, eax
  00044	0f 84 65 03 00
	00		 je	 $LN5@stbi__load

; 6888 :         int layers = 0;

  0004a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR layers$1[rsp], 0

; 6889 :         stbi_uc *u = 0;

  00052	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR u$4[rsp], 0

; 6890 :         stbi_uc *out = 0;

  0005b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR out$3[rsp], 0

; 6891 :         stbi_uc *two_back = 0;

  00064	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR two_back$9[rsp], 0

; 6892 :         stbi__gif g;
; 6893 :         int stride;
; 6894 :         int out_size = 0;

  0006d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR out_size$5[rsp], 0

; 6895 :         int delays_size = 0;

  00075	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR delays_size$6[rsp], 0

; 6896 :         
; 6897 :         STBI_NOTUSED(out_size);
; 6898 :         STBI_NOTUSED(delays_size);
; 6899 :         
; 6900 :         memset(&g, 0, sizeof(g));

  0007d	48 8d 44 24 70	 lea	 rax, QWORD PTR g$10[rsp]
  00082	48 8b f8	 mov	 rdi, rax
  00085	33 c0		 xor	 eax, eax
  00087	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  0008c	f3 aa		 rep stosb

; 6901 :         if (delays) {

  0008e	48 83 bc 24 18
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  00097	74 0f		 je	 SHORT $LN7@stbi__load

; 6902 :             *delays = 0;

  00099	48 8b 84 24 18
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  000a1	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN7@stbi__load:
$LN4@stbi__load:

; 6903 :         }
; 6904 :         
; 6905 :         do {
; 6906 :             u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);

  000a8	48 8b 44 24 68	 mov	 rax, QWORD PTR two_back$9[rsp]
  000ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b2	44 8b 8c 24 40
	89 00 00	 mov	 r9d, DWORD PTR req_comp$[rsp]
  000ba	4c 8b 84 24 38
	89 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  000c2	48 8d 54 24 70	 lea	 rdx, QWORD PTR g$10[rsp]
  000c7	48 8b 8c 24 10
	89 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	e8 00 00 00 00	 call	 ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ; stbi__gif_load_next
  000d4	48 89 44 24 40	 mov	 QWORD PTR u$4[rsp], rax

; 6907 :             if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

  000d9	48 8b 84 24 10
	89 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e1	48 39 44 24 40	 cmp	 QWORD PTR u$4[rsp], rax
  000e6	75 09		 jne	 SHORT $LN8@stbi__load
  000e8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR u$4[rsp], 0
$LN8@stbi__load:

; 6908 :             
; 6909 :             if (u) {

  000f1	48 83 7c 24 40
	00		 cmp	 QWORD PTR u$4[rsp], 0
  000f7	0f 84 27 02 00
	00		 je	 $LN9@stbi__load

; 6910 :                 *x = g.w;

  000fd	48 8b 84 24 20
	89 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00105	8b 4c 24 70	 mov	 ecx, DWORD PTR g$10[rsp]
  00109	89 08		 mov	 DWORD PTR [rax], ecx

; 6911 :                 *y = g.h;

  0010b	48 8b 84 24 28
	89 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00113	8b 4c 24 74	 mov	 ecx, DWORD PTR g$10[rsp+4]
  00117	89 08		 mov	 DWORD PTR [rax], ecx

; 6912 :                 ++layers;

  00119	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0011d	ff c0		 inc	 eax
  0011f	89 44 24 30	 mov	 DWORD PTR layers$1[rsp], eax

; 6913 :                 stride = g.w * g.h * 4;

  00123	8b 44 24 70	 mov	 eax, DWORD PTR g$10[rsp]
  00127	0f af 44 24 74	 imul	 eax, DWORD PTR g$10[rsp+4]
  0012c	c1 e0 02	 shl	 eax, 2
  0012f	89 44 24 34	 mov	 DWORD PTR stride$2[rsp], eax

; 6914 :                 
; 6915 :                 if (out) {

  00133	48 83 7c 24 38
	00		 cmp	 QWORD PTR out$3[rsp], 0
  00139	0f 84 cc 00 00
	00		 je	 $LN10@stbi__load

; 6916 :                     void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );

  0013f	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  00143	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00148	48 98		 cdqe
  0014a	48 8b d0	 mov	 rdx, rax
  0014d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$3[rsp]
  00152	e8 00 00 00 00	 call	 realloc
  00157	48 89 44 24 58	 mov	 QWORD PTR tmp$7[rsp], rax

; 6917 :                     if (!tmp)

  0015c	48 83 7c 24 58
	00		 cmp	 QWORD PTR tmp$7[rsp], 0
  00162	75 1e		 jne	 SHORT $LN12@stbi__load

; 6918 :                         return stbi__load_gif_main_outofmem(&g, out, delays);

  00164	4c 8b 84 24 18
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  0016c	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  00171	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  00176	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  0017b	e9 56 02 00 00	 jmp	 $LN1@stbi__load
  00180	eb 17		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:

; 6919 :                     else {
; 6920 :                         out = (stbi_uc*) tmp;

  00182	48 8b 44 24 58	 mov	 rax, QWORD PTR tmp$7[rsp]
  00187	48 89 44 24 38	 mov	 QWORD PTR out$3[rsp], rax

; 6921 :                         out_size = layers * stride;

  0018c	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  00190	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00195	89 44 24 48	 mov	 DWORD PTR out_size$5[rsp], eax
$LN13@stbi__load:

; 6922 :                     }
; 6923 :                     
; 6924 :                     if (delays) {

  00199	48 83 bc 24 18
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  001a2	74 62		 je	 SHORT $LN14@stbi__load

; 6925 :                         int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  001a9	48 c1 e0 02	 shl	 rax, 2
  001ad	48 8b d0	 mov	 rdx, rax
  001b0	48 8b 84 24 18
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  001b8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001bb	e8 00 00 00 00	 call	 realloc
  001c0	48 89 44 24 60	 mov	 QWORD PTR new_delays$8[rsp], rax

; 6926 :                         if (!new_delays)

  001c5	48 83 7c 24 60
	00		 cmp	 QWORD PTR new_delays$8[rsp], 0
  001cb	75 1c		 jne	 SHORT $LN15@stbi__load

; 6927 :                             return stbi__load_gif_main_outofmem(&g, out, delays);

  001cd	4c 8b 84 24 18
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  001d5	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  001da	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  001df	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  001e4	e9 ed 01 00 00	 jmp	 $LN1@stbi__load
$LN15@stbi__load:

; 6928 :                         *delays = new_delays;

  001e9	48 8b 84 24 18
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  001f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR new_delays$8[rsp]
  001f6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6929 :                         delays_size = layers * sizeof(int);

  001f9	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  001fe	48 c1 e0 02	 shl	 rax, 2
  00202	89 44 24 4c	 mov	 DWORD PTR delays_size$6[rsp], eax
$LN14@stbi__load:

; 6930 :                     }
; 6931 :                 } else {

  00206	e9 a7 00 00 00	 jmp	 $LN11@stbi__load
$LN10@stbi__load:

; 6932 :                     out = (stbi_uc*)stbi__malloc( layers * stride );

  0020b	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0020f	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00214	48 98		 cdqe
  00216	48 8b c8	 mov	 rcx, rax
  00219	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0021e	48 89 44 24 38	 mov	 QWORD PTR out$3[rsp], rax

; 6933 :                     if (!out)

  00223	48 83 7c 24 38
	00		 cmp	 QWORD PTR out$3[rsp], 0
  00229	75 1c		 jne	 SHORT $LN16@stbi__load

; 6934 :                         return stbi__load_gif_main_outofmem(&g, out, delays);

  0022b	4c 8b 84 24 18
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  00233	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  00238	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  0023d	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  00242	e9 8f 01 00 00	 jmp	 $LN1@stbi__load
$LN16@stbi__load:

; 6935 :                     out_size = layers * stride;

  00247	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0024b	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00250	89 44 24 48	 mov	 DWORD PTR out_size$5[rsp], eax

; 6936 :                     if (delays) {

  00254	48 83 bc 24 18
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  0025d	74 53		 je	 SHORT $LN17@stbi__load

; 6937 :                         *delays = (int*) stbi__malloc( layers * sizeof(int) );

  0025f	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  00264	48 c1 e0 02	 shl	 rax, 2
  00268	48 8b c8	 mov	 rcx, rax
  0026b	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00270	48 8b 8c 24 18
	89 00 00	 mov	 rcx, QWORD PTR delays$[rsp]
  00278	48 89 01	 mov	 QWORD PTR [rcx], rax

; 6938 :                         if (!*delays)

  0027b	48 8b 84 24 18
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  00283	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00287	75 1c		 jne	 SHORT $LN18@stbi__load

; 6939 :                             return stbi__load_gif_main_outofmem(&g, out, delays);

  00289	4c 8b 84 24 18
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  00291	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  00296	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  0029b	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  002a0	e9 31 01 00 00	 jmp	 $LN1@stbi__load
$LN18@stbi__load:

; 6940 :                         delays_size = layers * sizeof(int);

  002a5	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  002aa	48 c1 e0 02	 shl	 rax, 2
  002ae	89 44 24 4c	 mov	 DWORD PTR delays_size$6[rsp], eax
$LN17@stbi__load:
$LN11@stbi__load:

; 6941 :                     }
; 6942 :                 }
; 6943 :                 memcpy( out + ((layers - 1) * stride), u, stride );

  002b2	48 63 44 24 34	 movsxd	 rax, DWORD PTR stride$2[rsp]
  002b7	8b 4c 24 30	 mov	 ecx, DWORD PTR layers$1[rsp]
  002bb	ff c9		 dec	 ecx
  002bd	0f af 4c 24 34	 imul	 ecx, DWORD PTR stride$2[rsp]
  002c2	48 63 c9	 movsxd	 rcx, ecx
  002c5	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  002ca	48 03 d1	 add	 rdx, rcx
  002cd	48 8b ca	 mov	 rcx, rdx
  002d0	48 8b f9	 mov	 rdi, rcx
  002d3	48 8b 74 24 40	 mov	 rsi, QWORD PTR u$4[rsp]
  002d8	48 8b c8	 mov	 rcx, rax
  002db	f3 a4		 rep movsb

; 6944 :                 if (layers >= 2) {

  002dd	83 7c 24 30 02	 cmp	 DWORD PTR layers$1[rsp], 2
  002e2	7c 18		 jl	 SHORT $LN19@stbi__load

; 6945 :                     two_back = out - 2 * stride;

  002e4	8b 44 24 34	 mov	 eax, DWORD PTR stride$2[rsp]
  002e8	d1 e0		 shl	 eax, 1
  002ea	48 98		 cdqe
  002ec	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$3[rsp]
  002f1	48 2b c8	 sub	 rcx, rax
  002f4	48 8b c1	 mov	 rax, rcx
  002f7	48 89 44 24 68	 mov	 QWORD PTR two_back$9[rsp], rax
$LN19@stbi__load:

; 6946 :                 }
; 6947 :                 
; 6948 :                 if (delays) {

  002fc	48 83 bc 24 18
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  00305	74 1d		 je	 SHORT $LN20@stbi__load

; 6949 :                     (*delays)[layers - 1U] = g.delay;

  00307	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0030b	ff c8		 dec	 eax
  0030d	8b c0		 mov	 eax, eax
  0030f	48 8b 8c 24 18
	89 00 00	 mov	 rcx, QWORD PTR delays$[rsp]
  00317	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0031a	8b 94 24 d8 88
	00 00		 mov	 edx, DWORD PTR g$10[rsp+34920]
  00321	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN20@stbi__load:
$LN9@stbi__load:

; 6950 :                 }
; 6951 :             }
; 6952 :         } while (u != 0);

  00324	48 83 7c 24 40
	00		 cmp	 QWORD PTR u$4[rsp], 0
  0032a	0f 85 78 fd ff
	ff		 jne	 $LN4@stbi__load

; 6953 :         
; 6954 :         // free temp buffer;
; 6955 :         STBI_FREE(g.out);

  00330	48 8b 4c 24 78	 mov	 rcx, QWORD PTR g$10[rsp+8]
  00335	e8 00 00 00 00	 call	 free

; 6956 :         STBI_FREE(g.history);

  0033a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR g$10[rsp+24]
  00342	e8 00 00 00 00	 call	 free

; 6957 :         STBI_FREE(g.background);

  00347	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR g$10[rsp+16]
  0034f	e8 00 00 00 00	 call	 free

; 6958 :         
; 6959 :         // do the final conversion after loading everything;
; 6960 :         if (req_comp && req_comp != 4)

  00354	83 bc 24 40 89
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0035c	74 3a		 je	 SHORT $LN21@stbi__load
  0035e	83 bc 24 40 89
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00366	74 30		 je	 SHORT $LN21@stbi__load

; 6961 :             out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

  00368	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0036c	0f af 44 24 70	 imul	 eax, DWORD PTR g$10[rsp]
  00371	8b 4c 24 74	 mov	 ecx, DWORD PTR g$10[rsp+4]
  00375	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00379	44 8b c8	 mov	 r9d, eax
  0037c	44 8b 84 24 40
	89 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00384	ba 04 00 00 00	 mov	 edx, 4
  00389	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$3[rsp]
  0038e	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00393	48 89 44 24 38	 mov	 QWORD PTR out$3[rsp], rax
$LN21@stbi__load:

; 6962 :         
; 6963 :         *z = layers;

  00398	48 8b 84 24 30
	89 00 00	 mov	 rax, QWORD PTR z$[rsp]
  003a0	8b 4c 24 30	 mov	 ecx, DWORD PTR layers$1[rsp]
  003a4	89 08		 mov	 DWORD PTR [rax], ecx

; 6964 :         return out;

  003a6	48 8b 44 24 38	 mov	 rax, QWORD PTR out$3[rsp]
  003ab	eb 29		 jmp	 SHORT $LN1@stbi__load

; 6965 :     } else {

  003ad	eb 27		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:

; 6966 :         return stbi__errpuc("not GIF", "Image was not as a gif type.");

  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40729
  003b6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003bb	85 c0		 test	 eax, eax
  003bd	74 0a		 je	 SHORT $LN23@stbi__load
  003bf	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
  003c7	eb 08		 jmp	 SHORT $LN24@stbi__load
$LN23@stbi__load:
  003c9	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
$LN24@stbi__load:
  003d1	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv205[rsp]
$LN6@stbi__load:
$LN1@stbi__load:

; 6967 :     }
; 6968 : }

  003d6	48 8b 8c 24 e0
	88 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003de	48 33 cc	 xor	 rcx, rsp
  003e1	e8 00 00 00 00	 call	 __security_check_cookie
  003e6	48 81 c4 f8 88
	00 00		 add	 rsp, 35064		; 000088f8H
  003ed	5f		 pop	 rdi
  003ee	5e		 pop	 rsi
  003ef	c3		 ret	 0
?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z ENDP ; stbi__load_gif_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
u$ = 48
g$ = 64
__$ArrayPad$ = 34992
s$ = 35024
x$ = 35032
y$ = 35040
comp$ = 35048
req_comp$ = 35056
ri$ = 35064
?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__gif_load

; 6971 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 c0 88 00 00	 mov	 eax, 35008		; 000088c0H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 b0
	88 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6972 :     stbi_uc *u = 0;

  00034	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0

; 6973 :     stbi__gif g;
; 6974 :     memset(&g, 0, sizeof(g));

  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR g$[rsp]
  00042	48 8b f8	 mov	 rdi, rax
  00045	33 c0		 xor	 eax, eax
  00047	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  0004c	f3 aa		 rep stosb

; 6975 :     STBI_NOTUSED(ri);
; 6976 :     
; 6977 :     u = stbi__gif_load_next(s, &g, comp, req_comp, 0);

  0004e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00057	44 8b 8c 24 f0
	88 00 00	 mov	 r9d, DWORD PTR req_comp$[rsp]
  0005f	4c 8b 84 24 e8
	88 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  00067	48 8d 54 24 40	 lea	 rdx, QWORD PTR g$[rsp]
  0006c	48 8b 8c 24 d0
	88 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00074	e8 00 00 00 00	 call	 ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ; stbi__gif_load_next
  00079	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 6978 :     if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

  0007e	48 8b 84 24 d0
	88 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00086	48 39 44 24 30	 cmp	 QWORD PTR u$[rsp], rax
  0008b	75 09		 jne	 SHORT $LN2@stbi__gif_
  0008d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0
$LN2@stbi__gif_:

; 6979 :     if (u) {

  00096	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  0009c	74 5b		 je	 SHORT $LN3@stbi__gif_

; 6980 :         *x = g.w;

  0009e	48 8b 84 24 d8
	88 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000a6	8b 4c 24 40	 mov	 ecx, DWORD PTR g$[rsp]
  000aa	89 08		 mov	 DWORD PTR [rax], ecx

; 6981 :         *y = g.h;

  000ac	48 8b 84 24 e0
	88 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000b4	8b 4c 24 44	 mov	 ecx, DWORD PTR g$[rsp+4]
  000b8	89 08		 mov	 DWORD PTR [rax], ecx

; 6982 :         
; 6983 :         // moved conversion to after successful load so that the same
; 6984 :         // can be done for multiple frames.
; 6985 :         if (req_comp && req_comp != 4)

  000ba	83 bc 24 f0 88
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000c2	74 33		 je	 SHORT $LN5@stbi__gif_
  000c4	83 bc 24 f0 88
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  000cc	74 29		 je	 SHORT $LN5@stbi__gif_

; 6986 :             u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

  000ce	8b 44 24 44	 mov	 eax, DWORD PTR g$[rsp+4]
  000d2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d6	44 8b 4c 24 40	 mov	 r9d, DWORD PTR g$[rsp]
  000db	44 8b 84 24 f0
	88 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  000e3	ba 04 00 00 00	 mov	 edx, 4
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  000ed	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  000f2	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax
$LN5@stbi__gif_:
  000f7	eb 12		 jmp	 SHORT $LN4@stbi__gif_
$LN3@stbi__gif_:

; 6987 :     } else if (g.out) {

  000f9	48 83 7c 24 48
	00		 cmp	 QWORD PTR g$[rsp+8], 0
  000ff	74 0a		 je	 SHORT $LN6@stbi__gif_

; 6988 :         // if there was an error and we allocated an image buffer, free it!
; 6989 :         STBI_FREE(g.out);

  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp+8]
  00106	e8 00 00 00 00	 call	 free
$LN6@stbi__gif_:
$LN4@stbi__gif_:

; 6990 :     }
; 6991 :     
; 6992 :     // free buffers needed for multiple frame loading;
; 6993 :     STBI_FREE(g.history);

  0010b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp+24]
  00110	e8 00 00 00 00	 call	 free

; 6994 :     STBI_FREE(g.background);

  00115	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp+16]
  0011a	e8 00 00 00 00	 call	 free

; 6995 :     
; 6996 :     return u;

  0011f	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]

; 6997 : }

  00124	48 8b 8c 24 b0
	88 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012c	48 33 cc	 xor	 rcx, rsp
  0012f	e8 00 00 00 00	 call	 __security_check_cookie
  00134	48 81 c4 c0 88
	00 00		 add	 rsp, 35008		; 000088c0H
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__gif_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__gif_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__gif_test

; 6513 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6514 :     int r = stbi__gif_test_raw(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__gif_test_raw
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6515 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6516 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6517 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__gif_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__gif_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
num_packets$ = 32
act_comp$ = 36
dummy$ = 40
tv152 = 44
packet$1 = 48
chained$ = 56
packets$ = 64
__$ArrayPad$ = 96
s$ = 128
x$ = 136
y$ = 144
comp$ = 152
?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pic_info

; 7346 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7347 :     int act_comp=0,num_packets=0,chained,dummy;

  00027	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR act_comp$[rsp], 0
  0002f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR num_packets$[rsp], 0

; 7348 :     stbi__pic_packet packets[10];
; 7349 :     
; 7350 :     if (!x) x = &dummy;

  00037	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  00040	75 0d		 jne	 SHORT $LN5@stbi__pic_
  00042	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00047	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN5@stbi__pic_:

; 7351 :     if (!y) y = &dummy;

  0004f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00058	75 0d		 jne	 SHORT $LN6@stbi__pic_
  0005a	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  0005f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN6@stbi__pic_:

; 7352 :     if (!comp) comp = &dummy;

  00067	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00070	75 0d		 jne	 SHORT $LN7@stbi__pic_
  00072	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00077	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN7@stbi__pic_:

; 7353 :     
; 7354 :     if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {

  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41028
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0008e	e8 00 00 00 00	 call	 ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
  00093	85 c0		 test	 eax, eax
  00095	75 14		 jne	 SHORT $LN8@stbi__pic_

; 7355 :         stbi__rewind(s);

  00097	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7356 :         return 0;

  000a4	33 c0		 xor	 eax, eax
  000a6	e9 c5 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 7357 :     }
; 7358 :     
; 7359 :     stbi__skip(s, 88);

  000ab	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  000b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b8	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 7360 :     
; 7361 :     *x = stbi__get16be(s);

  000bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000ca	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  000d2	89 01		 mov	 DWORD PTR [rcx], eax

; 7362 :     *y = stbi__get16be(s);

  000d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000dc	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  000e9	89 01		 mov	 DWORD PTR [rcx], eax

; 7363 :     if (stbi__at_eof(s)) {

  000eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f3	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000f8	85 c0		 test	 eax, eax
  000fa	74 14		 je	 SHORT $LN9@stbi__pic_

; 7364 :         stbi__rewind( s);

  000fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00104	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7365 :         return 0;

  00109	33 c0		 xor	 eax, eax
  0010b	e9 60 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 7366 :     }
; 7367 :     if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {

  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00118	83 38 00	 cmp	 DWORD PTR [rax], 0
  0011b	74 30		 je	 SHORT $LN10@stbi__pic_
  0011d	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  00122	99		 cdq
  00123	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  0012b	f7 39		 idiv	 DWORD PTR [rcx]
  0012d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  00135	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00137	7d 14		 jge	 SHORT $LN10@stbi__pic_

; 7368 :         stbi__rewind( s );

  00139	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00141	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7369 :         return 0;

  00146	33 c0		 xor	 eax, eax
  00148	e9 23 01 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 7370 :     }
; 7371 :     
; 7372 :     stbi__skip(s, 8);

  0014d	ba 08 00 00 00	 mov	 edx, 8
  00152	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN4@stbi__pic_:

; 7373 :     
; 7374 :     do {
; 7375 :         stbi__pic_packet *packet;
; 7376 :         
; 7377 :         if (num_packets==sizeof(packets)/sizeof(packets[0]))

  0015f	48 63 44 24 20	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00164	48 83 f8 0a	 cmp	 rax, 10
  00168	75 07		 jne	 SHORT $LN11@stbi__pic_

; 7378 :             return 0;

  0016a	33 c0		 xor	 eax, eax
  0016c	e9 ff 00 00 00	 jmp	 $LN1@stbi__pic_
$LN11@stbi__pic_:

; 7379 :         
; 7380 :         packet = &packets[num_packets++];

  00171	48 63 44 24 20	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00176	48 6b c0 03	 imul	 rax, rax, 3
  0017a	48 8d 44 04 40	 lea	 rax, QWORD PTR packets$[rsp+rax]
  0017f	48 89 44 24 30	 mov	 QWORD PTR packet$1[rsp], rax
  00184	8b 44 24 20	 mov	 eax, DWORD PTR num_packets$[rsp]
  00188	ff c0		 inc	 eax
  0018a	89 44 24 20	 mov	 DWORD PTR num_packets$[rsp], eax

; 7381 :         chained = stbi__get8(s);

  0018e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00196	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0019b	0f b6 c0	 movzx	 eax, al
  0019e	89 44 24 38	 mov	 DWORD PTR chained$[rsp], eax

; 7382 :         packet->size    = stbi__get8(s);

  001a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001aa	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR packet$1[rsp]
  001b4	88 01		 mov	 BYTE PTR [rcx], al

; 7383 :         packet->type    = stbi__get8(s);

  001b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001be	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR packet$1[rsp]
  001c8	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 7384 :         packet->channel = stbi__get8(s);

  001cb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001d3	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR packet$1[rsp]
  001dd	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 7385 :         act_comp |= packet->channel;

  001e0	48 8b 44 24 30	 mov	 rax, QWORD PTR packet$1[rsp]
  001e5	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001e9	8b 4c 24 24	 mov	 ecx, DWORD PTR act_comp$[rsp]
  001ed	0b c8		 or	 ecx, eax
  001ef	8b c1		 mov	 eax, ecx
  001f1	89 44 24 24	 mov	 DWORD PTR act_comp$[rsp], eax

; 7386 :         
; 7387 :         if (stbi__at_eof(s)) {

  001f5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00202	85 c0		 test	 eax, eax
  00204	74 11		 je	 SHORT $LN12@stbi__pic_

; 7388 :             stbi__rewind( s );

  00206	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0020e	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7389 :             return 0;

  00213	33 c0		 xor	 eax, eax
  00215	eb 59		 jmp	 SHORT $LN1@stbi__pic_
$LN12@stbi__pic_:

; 7390 :         }
; 7391 :         if (packet->size != 8) {

  00217	48 8b 44 24 30	 mov	 rax, QWORD PTR packet$1[rsp]
  0021c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0021f	83 f8 08	 cmp	 eax, 8
  00222	74 11		 je	 SHORT $LN13@stbi__pic_

; 7392 :             stbi__rewind( s );

  00224	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0022c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7393 :             return 0;

  00231	33 c0		 xor	 eax, eax
  00233	eb 3b		 jmp	 SHORT $LN1@stbi__pic_
$LN13@stbi__pic_:

; 7394 :         }
; 7395 :     } while (chained);

  00235	83 7c 24 38 00	 cmp	 DWORD PTR chained$[rsp], 0
  0023a	0f 85 1f ff ff
	ff		 jne	 $LN4@stbi__pic_

; 7396 :     
; 7397 :     *comp = (act_comp & 0x10 ? 4 : 3);

  00240	8b 44 24 24	 mov	 eax, DWORD PTR act_comp$[rsp]
  00244	83 e0 10	 and	 eax, 16
  00247	85 c0		 test	 eax, eax
  00249	74 0a		 je	 SHORT $LN15@stbi__pic_
  0024b	c7 44 24 2c 04
	00 00 00	 mov	 DWORD PTR tv152[rsp], 4
  00253	eb 08		 jmp	 SHORT $LN16@stbi__pic_
$LN15@stbi__pic_:
  00255	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR tv152[rsp], 3
$LN16@stbi__pic_:
  0025d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00265	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv152[rsp]
  00269	89 08		 mov	 DWORD PTR [rax], ecx

; 7398 :     
; 7399 :     return 1;

  0026b	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 7400 : }

  00270	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00275	48 33 cc	 xor	 rcx, rsp
  00278	e8 00 00 00 00	 call	 __security_check_cookie
  0027d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00281	c3		 ret	 0
?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pic_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
y$ = 48
x$ = 52
result$ = 56
i$ = 64
tv76 = 68
tv82 = 72
tv90 = 76
tv133 = 80
tv147 = 84
internal_comp$ = 88
tv153 = 96
s$ = 128
px$ = 136
py$ = 144
comp$ = 152
req_comp$ = 160
ri$ = 168
?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__pic_load

; 6423 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 6424 :     stbi_uc *result;
; 6425 :     int i, x,y, internal_comp;
; 6426 :     STBI_NOTUSED(ri);
; 6427 :     
; 6428 :     if (!comp) comp = &internal_comp;

  00019	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00022	75 0d		 jne	 SHORT $LN5@stbi__pic_
  00024	48 8d 44 24 58	 lea	 rax, QWORD PTR internal_comp$[rsp]
  00029	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN5@stbi__pic_:

; 6429 :     
; 6430 :     for (i=0; i<92; ++i)

  00031	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00039	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  0003b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0003f	ff c0		 inc	 eax
  00041	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00045	83 7c 24 40 5c	 cmp	 DWORD PTR i$[rsp], 92	; 0000005cH
  0004a	7d 0f		 jge	 SHORT $LN3@stbi__pic_

; 6431 :         stbi__get8(s);

  0004c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00054	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00059	eb e0		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6432 :     
; 6433 :     x = stbi__get16be(s);

  0005b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00068	89 44 24 34	 mov	 DWORD PTR x$[rsp], eax

; 6434 :     y = stbi__get16be(s);

  0006c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00074	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00079	89 44 24 30	 mov	 DWORD PTR y$[rsp], eax

; 6435 :     
; 6436 :     if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  0007d	81 7c 24 30 00
	00 00 01	 cmp	 DWORD PTR y$[rsp], 16777216 ; 01000000H
  00085	7e 2c		 jle	 SHORT $LN6@stbi__pic_
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40376
  0008e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00093	85 c0		 test	 eax, eax
  00095	74 0a		 je	 SHORT $LN14@stbi__pic_
  00097	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  0009f	eb 08		 jmp	 SHORT $LN15@stbi__pic_
$LN14@stbi__pic_:
  000a1	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN15@stbi__pic_:
  000a9	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv76[rsp]
  000ae	e9 f8 01 00 00	 jmp	 $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6437 :     if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  000b3	81 7c 24 34 00
	00 00 01	 cmp	 DWORD PTR x$[rsp], 16777216 ; 01000000H
  000bb	7e 2c		 jle	 SHORT $LN7@stbi__pic_
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40378
  000c4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000c9	85 c0		 test	 eax, eax
  000cb	74 0a		 je	 SHORT $LN16@stbi__pic_
  000cd	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  000d5	eb 08		 jmp	 SHORT $LN17@stbi__pic_
$LN16@stbi__pic_:
  000d7	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN17@stbi__pic_:
  000df	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv82[rsp]
  000e4	e9 c2 01 00 00	 jmp	 $LN1@stbi__pic_
$LN7@stbi__pic_:

; 6438 :     
; 6439 :     if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");

  000e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000f6	85 c0		 test	 eax, eax
  000f8	74 2c		 je	 SHORT $LN8@stbi__pic_
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40380
  00101	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00106	85 c0		 test	 eax, eax
  00108	74 0a		 je	 SHORT $LN18@stbi__pic_
  0010a	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
  00112	eb 08		 jmp	 SHORT $LN19@stbi__pic_
$LN18@stbi__pic_:
  00114	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN19@stbi__pic_:
  0011c	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv90[rsp]
  00121	e9 85 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 6440 :     if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

  00126	45 33 c9	 xor	 r9d, r9d
  00129	41 b8 04 00 00
	00		 mov	 r8d, 4
  0012f	8b 54 24 30	 mov	 edx, DWORD PTR y$[rsp]
  00133	8b 4c 24 34	 mov	 ecx, DWORD PTR x$[rsp]
  00137	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  0013c	85 c0		 test	 eax, eax
  0013e	75 2c		 jne	 SHORT $LN9@stbi__pic_
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40382
  00147	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014c	85 c0		 test	 eax, eax
  0014e	74 0a		 je	 SHORT $LN20@stbi__pic_
  00150	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
  00158	eb 08		 jmp	 SHORT $LN21@stbi__pic_
$LN20@stbi__pic_:
  0015a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN21@stbi__pic_:
  00162	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv133[rsp]
  00167	e9 3f 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 6441 :     
; 6442 :     stbi__get32be(s); //skip `ratio'

  0016c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00174	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 6443 :     stbi__get16be(s); //skip `fields'

  00179	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00181	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 6444 :     stbi__get16be(s); //skip `pad'

  00186	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0018e	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 6445 :     
; 6446 :     // intermediate buffer is RGBA
; 6447 :     result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);

  00193	45 33 c9	 xor	 r9d, r9d
  00196	41 b8 04 00 00
	00		 mov	 r8d, 4
  0019c	8b 54 24 30	 mov	 edx, DWORD PTR y$[rsp]
  001a0	8b 4c 24 34	 mov	 ecx, DWORD PTR x$[rsp]
  001a4	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  001a9	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 6448 :     if (!result) return stbi__errpuc("outofmem", "Out of memory");

  001ae	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  001b4	75 2c		 jne	 SHORT $LN10@stbi__pic_
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40384
  001bd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c2	85 c0		 test	 eax, eax
  001c4	74 0a		 je	 SHORT $LN22@stbi__pic_
  001c6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
  001ce	eb 08		 jmp	 SHORT $LN23@stbi__pic_
$LN22@stbi__pic_:
  001d0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN23@stbi__pic_:
  001d8	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv147[rsp]
  001dd	e9 c9 00 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 6449 :     memset(result, 0xff, x*y*4);

  001e2	8b 44 24 34	 mov	 eax, DWORD PTR x$[rsp]
  001e6	0f af 44 24 30	 imul	 eax, DWORD PTR y$[rsp]
  001eb	c1 e0 02	 shl	 eax, 2
  001ee	48 98		 cdqe
  001f0	48 89 44 24 60	 mov	 QWORD PTR tv153[rsp], rax
  001f5	48 8b 7c 24 38	 mov	 rdi, QWORD PTR result$[rsp]
  001fa	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv153[rsp]
  00204	f3 aa		 rep stosb

; 6450 :     
; 6451 :     if (!stbi__pic_load_core(s,x,y,comp, result)) {

  00206	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  0020b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00210	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00218	44 8b 44 24 30	 mov	 r8d, DWORD PTR y$[rsp]
  0021d	8b 54 24 34	 mov	 edx, DWORD PTR x$[rsp]
  00221	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00229	e8 00 00 00 00	 call	 ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ; stbi__pic_load_core
  0022e	48 85 c0	 test	 rax, rax
  00231	75 13		 jne	 SHORT $LN11@stbi__pic_

; 6452 :         STBI_FREE(result);

  00233	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00238	e8 00 00 00 00	 call	 free

; 6453 :         result=0;

  0023d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN11@stbi__pic_:

; 6454 :     }
; 6455 :     *px = x;

  00246	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR px$[rsp]
  0024e	8b 4c 24 34	 mov	 ecx, DWORD PTR x$[rsp]
  00252	89 08		 mov	 DWORD PTR [rax], ecx

; 6456 :     *py = y;

  00254	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR py$[rsp]
  0025c	8b 4c 24 30	 mov	 ecx, DWORD PTR y$[rsp]
  00260	89 08		 mov	 DWORD PTR [rax], ecx

; 6457 :     if (req_comp == 0) req_comp = *comp;

  00262	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0026a	75 11		 jne	 SHORT $LN12@stbi__pic_
  0026c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00274	8b 00		 mov	 eax, DWORD PTR [rax]
  00276	89 84 24 a0 00
	00 00		 mov	 DWORD PTR req_comp$[rsp], eax
$LN12@stbi__pic_:

; 6458 :     result=stbi__convert_format(result,4,req_comp,x,y);

  0027d	8b 44 24 30	 mov	 eax, DWORD PTR y$[rsp]
  00281	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00285	44 8b 4c 24 34	 mov	 r9d, DWORD PTR x$[rsp]
  0028a	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00292	ba 04 00 00 00	 mov	 edx, 4
  00297	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0029c	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  002a1	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 6459 :     
; 6460 :     return result;

  002a6	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 6461 : }

  002ab	48 83 c4 70	 add	 rsp, 112		; 00000070H
  002af	5f		 pop	 rdi
  002b0	c3		 ret	 0
?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__pic_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__pic_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pic_test

; 6464 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6465 :     int r = stbi__pic_test_core(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ; stbi__pic_test_core
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6466 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6467 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6468 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__pic_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pic_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
token$ = 32
dummy$ = 40
valid$ = 44
buffer$ = 48
__$ArrayPad$ = 1072
s$ = 1104
x$ = 1112
y$ = 1120
comp$ = 1128
?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__hdr_info

; 7212 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 48 04
	00 00		 sub	 rsp, 1096		; 00000448H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 30
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7213 :     char buffer[STBI__HDR_BUFLEN];
; 7214 :     char *token;
; 7215 :     int valid = 0;

  0002d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR valid$[rsp], 0

; 7216 :     int dummy;
; 7217 :     
; 7218 :     if (!x) x = &dummy;

  00035	48 83 bc 24 58
	04 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  0003e	75 0d		 jne	 SHORT $LN7@stbi__hdr_
  00040	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00045	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN7@stbi__hdr_:

; 7219 :     if (!y) y = &dummy;

  0004d	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00056	75 0d		 jne	 SHORT $LN8@stbi__hdr_
  00058	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  0005d	48 89 84 24 60
	04 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN8@stbi__hdr_:

; 7220 :     if (!comp) comp = &dummy;

  00065	48 83 bc 24 68
	04 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0006e	75 0d		 jne	 SHORT $LN9@stbi__hdr_
  00070	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00075	48 89 84 24 68
	04 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN9@stbi__hdr_:

; 7221 :     
; 7222 :     if (stbi__hdr_test(s) == 0) {

  0007d	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00085	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  0008a	85 c0		 test	 eax, eax
  0008c	75 14		 jne	 SHORT $LN10@stbi__hdr_

; 7223 :         stbi__rewind( s );

  0008e	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00096	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7224 :         return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 77 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN10@stbi__hdr_:
$LN2@stbi__hdr_:

; 7225 :     }
; 7226 :     
; 7227 :     for(;;) {
; 7228 :         token = stbi__hdr_gettoken(s,buffer);

  000a2	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000a7	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000af	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  000b4	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7229 :         if (token[0] == 0) break;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	48 6b c0 00	 imul	 rax, rax, 0
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000c7	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000cb	85 c0		 test	 eax, eax
  000cd	75 02		 jne	 SHORT $LN11@stbi__hdr_
  000cf	eb 35		 jmp	 SHORT $LN3@stbi__hdr_
$LN11@stbi__hdr_:

; 7230 :         if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40959
  000dd	48 2b c8	 sub	 rcx, rax
$LL17@stbi__hdr_:
  000e0	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000e3	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  000e6	75 0b		 jne	 SHORT $LN19@stbi__hdr_
  000e8	48 ff c0	 inc	 rax
  000eb	84 d2		 test	 dl, dl
  000ed	75 f1		 jne	 SHORT $LL17@stbi__hdr_
  000ef	33 c0		 xor	 eax, eax
  000f1	eb 05		 jmp	 SHORT $LN18@stbi__hdr_
$LN19@stbi__hdr_:
  000f3	1b c0		 sbb	 eax, eax
  000f5	83 c8 01	 or	 eax, 1
$LN18@stbi__hdr_:
  000f8	85 c0		 test	 eax, eax
  000fa	75 08		 jne	 SHORT $LN12@stbi__hdr_
  000fc	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR valid$[rsp], 1
$LN12@stbi__hdr_:

; 7231 :     }

  00104	eb 9c		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7232 :     
; 7233 :     if (!valid) {

  00106	83 7c 24 2c 00	 cmp	 DWORD PTR valid$[rsp], 0
  0010b	75 14		 jne	 SHORT $LN13@stbi__hdr_

; 7234 :         stbi__rewind( s );

  0010d	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00115	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7235 :         return 0;

  0011a	33 c0		 xor	 eax, eax
  0011c	e9 f8 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN13@stbi__hdr_:

; 7236 :     }
; 7237 :     token = stbi__hdr_gettoken(s,buffer);

  00121	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00126	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012e	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  00133	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7238 :     if (strncmp(token, "-Y ", 3)) {

  00138	41 b8 03 00 00
	00		 mov	 r8d, 3
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40962
  00145	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0014a	e8 00 00 00 00	 call	 strncmp
  0014f	85 c0		 test	 eax, eax
  00151	74 14		 je	 SHORT $LN14@stbi__hdr_

; 7239 :         stbi__rewind( s );

  00153	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015b	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7240 :         return 0;

  00160	33 c0		 xor	 eax, eax
  00162	e9 b2 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN14@stbi__hdr_:

; 7241 :     }
; 7242 :     token += 3;

  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0016c	48 83 c0 03	 add	 rax, 3
  00170	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7243 :     *y = (int) strtol(token, &token, 10);

  00175	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0017b	48 8d 54 24 20	 lea	 rdx, QWORD PTR token$[rsp]
  00180	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00185	e8 00 00 00 00	 call	 strtol
  0018a	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  00192	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__hdr_:

; 7244 :     while (*token == ' ') ++token;

  00194	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00199	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0019f	75 0f		 jne	 SHORT $LN6@stbi__hdr_
  001a1	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  001a6	48 ff c0	 inc	 rax
  001a9	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax
  001ae	eb e4		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7245 :     if (strncmp(token, "+X ", 3)) {

  001b0	41 b8 03 00 00
	00		 mov	 r8d, 3
  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40964
  001bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001c2	e8 00 00 00 00	 call	 strncmp
  001c7	85 c0		 test	 eax, eax
  001c9	74 11		 je	 SHORT $LN15@stbi__hdr_

; 7246 :         stbi__rewind( s );

  001cb	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001d3	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7247 :         return 0;

  001d8	33 c0		 xor	 eax, eax
  001da	eb 3d		 jmp	 SHORT $LN1@stbi__hdr_
$LN15@stbi__hdr_:

; 7248 :     }
; 7249 :     token += 3;

  001dc	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  001e1	48 83 c0 03	 add	 rax, 3
  001e5	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7250 :     *x = (int) strtol(token, NULL, 10);

  001ea	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001f0	33 d2		 xor	 edx, edx
  001f2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001f7	e8 00 00 00 00	 call	 strtol
  001fc	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  00204	89 01		 mov	 DWORD PTR [rcx], eax

; 7251 :     *comp = 3;

  00206	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0020e	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 7252 :     return 1;

  00214	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 7253 : }

  00219	48 8b 8c 24 30
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00221	48 33 cc	 xor	 rcx, rsp
  00224	e8 00 00 00 00	 call	 __security_check_cookie
  00229	48 81 c4 48 04
	00 00		 add	 rsp, 1096		; 00000448H
  00230	c3		 ret	 0
?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__hdr_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
count$ = 48
i$ = 52
width$ = 56
j$ = 60
value$ = 64
len$ = 68
z$ = 72
token$ = 80
height$ = 88
scanline$ = 96
k$ = 104
rgbe$1 = 108
hdr_data$ = 112
nleft$2 = 120
tv78 = 124
valid$ = 128
tv95 = 132
tv140 = 136
tv158 = 140
tv169 = 144
tv175 = 148
tv189 = 152
tv201 = 156
c1$ = 160
c2$ = 164
tv264 = 168
tv276 = 172
tv298 = 176
tv316 = 180
rgbe$3 = 184
headerToken$ = 192
buffer$ = 208
__$ArrayPad$ = 1232
s$ = 1264
x$ = 1272
y$ = 1280
comp$ = 1288
req_comp$ = 1296
ri$ = 1304
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__hdr_load

; 7081 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 04
	00 00		 sub	 rsp, 1256		; 000004e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7082 :     char buffer[STBI__HDR_BUFLEN];
; 7083 :     char *token;
; 7084 :     int valid = 0;

  0002d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR valid$[rsp], 0

; 7085 :     int width, height;
; 7086 :     stbi_uc *scanline;
; 7087 :     float *hdr_data;
; 7088 :     int len;
; 7089 :     unsigned char count, value;
; 7090 :     int i, j, k, c1,c2, z;
; 7091 :     const char *headerToken;
; 7092 :     STBI_NOTUSED(ri);
; 7093 :     
; 7094 :     // Check identifier
; 7095 :     headerToken = stbi__hdr_gettoken(s,buffer);

  00038	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$[rsp]
  00040	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  0004d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR headerToken$[rsp], rax

; 7096 :     if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)

  00055	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR headerToken$[rsp]
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40895
  00064	48 2b c8	 sub	 rcx, rax
$LL86@stbi__hdr_:
  00067	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0006a	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  0006d	75 0b		 jne	 SHORT $LN88@stbi__hdr_
  0006f	48 ff c0	 inc	 rax
  00072	84 d2		 test	 dl, dl
  00074	75 f1		 jne	 SHORT $LL86@stbi__hdr_
  00076	33 c0		 xor	 eax, eax
  00078	eb 05		 jmp	 SHORT $LN87@stbi__hdr_
$LN88@stbi__hdr_:
  0007a	1b c0		 sbb	 eax, eax
  0007c	83 c8 01	 or	 eax, 1
$LN87@stbi__hdr_:
  0007f	85 c0		 test	 eax, eax
  00081	74 5a		 je	 SHORT $LN30@stbi__hdr_
  00083	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR headerToken$[rsp]
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40896
  00092	48 2b c8	 sub	 rcx, rax
$LL83@stbi__hdr_:
  00095	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00098	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  0009b	75 0b		 jne	 SHORT $LN85@stbi__hdr_
  0009d	48 ff c0	 inc	 rax
  000a0	84 d2		 test	 dl, dl
  000a2	75 f1		 jne	 SHORT $LL83@stbi__hdr_
  000a4	33 c0		 xor	 eax, eax
  000a6	eb 05		 jmp	 SHORT $LN84@stbi__hdr_
$LN85@stbi__hdr_:
  000a8	1b c0		 sbb	 eax, eax
  000aa	83 c8 01	 or	 eax, 1
$LN84@stbi__hdr_:
  000ad	85 c0		 test	 eax, eax
  000af	74 2c		 je	 SHORT $LN30@stbi__hdr_

; 7097 :         return stbi__errpf("not HDR", "Corrupt HDR image");

  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40897
  000b8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000bd	85 c0		 test	 eax, eax
  000bf	74 0a		 je	 SHORT $LN56@stbi__hdr_
  000c1	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  000c9	eb 08		 jmp	 SHORT $LN57@stbi__hdr_
$LN56@stbi__hdr_:
  000cb	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN57@stbi__hdr_:
  000d3	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv78[rsp]
  000d8	e9 60 08 00 00	 jmp	 $LN1@stbi__hdr_
$LN30@stbi__hdr_:
$LN2@stbi__hdr_:

; 7098 :     
; 7099 :     // Parse header
; 7100 :     for(;;) {
; 7101 :         token = stbi__hdr_gettoken(s,buffer);

  000dd	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$[rsp]
  000e5	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ed	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  000f2	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7102 :         if (token[0] == 0) break;

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	48 6b c0 00	 imul	 rax, rax, 0
  00100	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00105	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00109	85 c0		 test	 eax, eax
  0010b	75 02		 jne	 SHORT $LN31@stbi__hdr_
  0010d	eb 38		 jmp	 SHORT $LN3@stbi__hdr_
$LN31@stbi__hdr_:

; 7103 :         if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  0010f	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40900
  0011b	48 2b c8	 sub	 rcx, rax
$LL80@stbi__hdr_:
  0011e	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00121	3a 14 08	 cmp	 dl, BYTE PTR [rax+rcx]
  00124	75 0b		 jne	 SHORT $LN82@stbi__hdr_
  00126	48 ff c0	 inc	 rax
  00129	84 d2		 test	 dl, dl
  0012b	75 f1		 jne	 SHORT $LL80@stbi__hdr_
  0012d	33 c0		 xor	 eax, eax
  0012f	eb 05		 jmp	 SHORT $LN81@stbi__hdr_
$LN82@stbi__hdr_:
  00131	1b c0		 sbb	 eax, eax
  00133	83 c8 01	 or	 eax, 1
$LN81@stbi__hdr_:
  00136	85 c0		 test	 eax, eax
  00138	75 0b		 jne	 SHORT $LN32@stbi__hdr_
  0013a	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR valid$[rsp], 1
$LN32@stbi__hdr_:

; 7104 :     }

  00145	eb 96		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7105 :     
; 7106 :     if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

  00147	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR valid$[rsp], 0
  0014f	75 35		 jne	 SHORT $LN33@stbi__hdr_
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40902
  00158	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015d	85 c0		 test	 eax, eax
  0015f	74 0d		 je	 SHORT $LN58@stbi__hdr_
  00161	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
  0016c	eb 0b		 jmp	 SHORT $LN59@stbi__hdr_
$LN58@stbi__hdr_:
  0016e	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
$LN59@stbi__hdr_:
  00179	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv95[rsp]
  00181	e9 b7 07 00 00	 jmp	 $LN1@stbi__hdr_
$LN33@stbi__hdr_:

; 7107 :     
; 7108 :     // Parse width and height
; 7109 :     // can't use sscanf() if we're not using stdio!
; 7110 :     token = stbi__hdr_gettoken(s,buffer);

  00186	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$[rsp]
  0018e	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00196	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  0019b	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7111 :     if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  001a0	41 b8 03 00 00
	00		 mov	 r8d, 3
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40904
  001ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  001b2	e8 00 00 00 00	 call	 strncmp
  001b7	85 c0		 test	 eax, eax
  001b9	74 35		 je	 SHORT $LN34@stbi__hdr_
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40905
  001c2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c7	85 c0		 test	 eax, eax
  001c9	74 0d		 je	 SHORT $LN60@stbi__hdr_
  001cb	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
  001d6	eb 0b		 jmp	 SHORT $LN61@stbi__hdr_
$LN60@stbi__hdr_:
  001d8	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
$LN61@stbi__hdr_:
  001e3	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv140[rsp]
  001eb	e9 4d 07 00 00	 jmp	 $LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 7112 :     token += 3;

  001f0	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  001f5	48 83 c0 03	 add	 rax, 3
  001f9	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7113 :     height = (int) strtol(token, &token, 10);

  001fe	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00204	48 8d 54 24 50	 lea	 rdx, QWORD PTR token$[rsp]
  00209	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  0020e	e8 00 00 00 00	 call	 strtol
  00213	89 44 24 58	 mov	 DWORD PTR height$[rsp], eax
$LN5@stbi__hdr_:

; 7114 :     while (*token == ' ') ++token;

  00217	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0021c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0021f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00222	75 0f		 jne	 SHORT $LN6@stbi__hdr_
  00224	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00229	48 ff c0	 inc	 rax
  0022c	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax
  00231	eb e4		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7115 :     if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  00233	41 b8 03 00 00
	00		 mov	 r8d, 3
  00239	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40907
  00240	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00245	e8 00 00 00 00	 call	 strncmp
  0024a	85 c0		 test	 eax, eax
  0024c	74 35		 je	 SHORT $LN35@stbi__hdr_
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40908
  00255	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0025a	85 c0		 test	 eax, eax
  0025c	74 0d		 je	 SHORT $LN62@stbi__hdr_
  0025e	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv158[rsp], 0
  00269	eb 0b		 jmp	 SHORT $LN63@stbi__hdr_
$LN62@stbi__hdr_:
  0026b	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv158[rsp], 0
$LN63@stbi__hdr_:
  00276	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR tv158[rsp]
  0027e	e9 ba 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN35@stbi__hdr_:

; 7116 :     token += 3;

  00283	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00288	48 83 c0 03	 add	 rax, 3
  0028c	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7117 :     width = (int) strtol(token, NULL, 10);

  00291	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00297	33 d2		 xor	 edx, edx
  00299	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  0029e	e8 00 00 00 00	 call	 strtol
  002a3	89 44 24 38	 mov	 DWORD PTR width$[rsp], eax

; 7118 :     
; 7119 :     if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

  002a7	81 7c 24 58 00
	00 00 01	 cmp	 DWORD PTR height$[rsp], 16777216 ; 01000000H
  002af	7e 35		 jle	 SHORT $LN36@stbi__hdr_
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40910
  002b8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002bd	85 c0		 test	 eax, eax
  002bf	74 0d		 je	 SHORT $LN64@stbi__hdr_
  002c1	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv169[rsp], 0
  002cc	eb 0b		 jmp	 SHORT $LN65@stbi__hdr_
$LN64@stbi__hdr_:
  002ce	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv169[rsp], 0
$LN65@stbi__hdr_:
  002d9	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv169[rsp]
  002e1	e9 57 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN36@stbi__hdr_:

; 7120 :     if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

  002e6	81 7c 24 38 00
	00 00 01	 cmp	 DWORD PTR width$[rsp], 16777216 ; 01000000H
  002ee	7e 35		 jle	 SHORT $LN37@stbi__hdr_
  002f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40912
  002f7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002fc	85 c0		 test	 eax, eax
  002fe	74 0d		 je	 SHORT $LN66@stbi__hdr_
  00300	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
  0030b	eb 0b		 jmp	 SHORT $LN67@stbi__hdr_
$LN66@stbi__hdr_:
  0030d	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
$LN67@stbi__hdr_:
  00318	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR tv175[rsp]
  00320	e9 18 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN37@stbi__hdr_:

; 7121 :     
; 7122 :     *x = width;

  00325	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0032d	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  00331	89 08		 mov	 DWORD PTR [rax], ecx

; 7123 :     *y = height;

  00333	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR y$[rsp]
  0033b	8b 4c 24 58	 mov	 ecx, DWORD PTR height$[rsp]
  0033f	89 08		 mov	 DWORD PTR [rax], ecx

; 7124 :     
; 7125 :     if (comp) *comp = 3;

  00341	48 83 bc 24 08
	05 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0034a	74 0e		 je	 SHORT $LN38@stbi__hdr_
  0034c	48 8b 84 24 08
	05 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00354	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN38@stbi__hdr_:

; 7126 :     if (req_comp == 0) req_comp = 3;

  0035a	83 bc 24 10 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00362	75 0b		 jne	 SHORT $LN39@stbi__hdr_
  00364	c7 84 24 10 05
	00 00 03 00 00
	00		 mov	 DWORD PTR req_comp$[rsp], 3
$LN39@stbi__hdr_:

; 7127 :     
; 7128 :     if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))

  0036f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00377	41 b9 04 00 00
	00		 mov	 r9d, 4
  0037d	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00385	8b 54 24 58	 mov	 edx, DWORD PTR height$[rsp]
  00389	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  0038d	e8 00 00 00 00	 call	 ?stbi__mad4sizes_valid@@YAHHHHHH@Z ; stbi__mad4sizes_valid
  00392	85 c0		 test	 eax, eax
  00394	75 35		 jne	 SHORT $LN40@stbi__hdr_

; 7129 :         return stbi__errpf("too large", "HDR image is too large");

  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40916
  0039d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003a2	85 c0		 test	 eax, eax
  003a4	74 0d		 je	 SHORT $LN68@stbi__hdr_
  003a6	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
  003b1	eb 0b		 jmp	 SHORT $LN69@stbi__hdr_
$LN68@stbi__hdr_:
  003b3	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
$LN69@stbi__hdr_:
  003be	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv189[rsp]
  003c6	e9 72 05 00 00	 jmp	 $LN1@stbi__hdr_
$LN40@stbi__hdr_:

; 7130 :     
; 7131 :     // Read data
; 7132 :     hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);

  003cb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  003d3	41 b9 04 00 00
	00		 mov	 r9d, 4
  003d9	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  003e1	8b 54 24 58	 mov	 edx, DWORD PTR height$[rsp]
  003e5	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  003e9	e8 00 00 00 00	 call	 ?stbi__malloc_mad4@@YAPEAXHHHHH@Z ; stbi__malloc_mad4
  003ee	48 89 44 24 70	 mov	 QWORD PTR hdr_data$[rsp], rax

; 7133 :     if (!hdr_data)

  003f3	48 83 7c 24 70
	00		 cmp	 QWORD PTR hdr_data$[rsp], 0
  003f9	75 35		 jne	 SHORT $LN41@stbi__hdr_

; 7134 :         return stbi__errpf("outofmem", "Out of memory");

  003fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40918
  00402	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00407	85 c0		 test	 eax, eax
  00409	74 0d		 je	 SHORT $LN70@stbi__hdr_
  0040b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
  00416	eb 0b		 jmp	 SHORT $LN71@stbi__hdr_
$LN70@stbi__hdr_:
  00418	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
$LN71@stbi__hdr_:
  00423	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv201[rsp]
  0042b	e9 0d 05 00 00	 jmp	 $LN1@stbi__hdr_
$LN41@stbi__hdr_:

; 7135 :     
; 7136 :     // Load image data
; 7137 :     // image data is stored as some number of sca
; 7138 :     if ( width < 8 || width >= 32768) {

  00430	83 7c 24 38 08	 cmp	 DWORD PTR width$[rsp], 8
  00435	7c 0e		 jl	 SHORT $LN44@stbi__hdr_
  00437	81 7c 24 38 00
	80 00 00	 cmp	 DWORD PTR width$[rsp], 32768 ; 00008000H
  0043f	0f 8c ae 00 00
	00		 jl	 $LN42@stbi__hdr_
$LN44@stbi__hdr_:

; 7139 :         // Read flat data
; 7140 :         for (j=0; j < height; ++j) {

  00445	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0044d	eb 0a		 jmp	 SHORT $LN9@stbi__hdr_
$LN7@stbi__hdr_:
  0044f	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00453	ff c0		 inc	 eax
  00455	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN9@stbi__hdr_:
  00459	8b 44 24 58	 mov	 eax, DWORD PTR height$[rsp]
  0045d	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  00461	0f 8d 87 00 00
	00		 jge	 $LN8@stbi__hdr_

; 7141 :             for (i=0; i < width; ++i) {

  00467	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0046f	eb 0a		 jmp	 SHORT $LN12@stbi__hdr_
$LN10@stbi__hdr_:
  00471	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00475	ff c0		 inc	 eax
  00477	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN12@stbi__hdr_:
  0047b	8b 44 24 38	 mov	 eax, DWORD PTR width$[rsp]
  0047f	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00483	7d 64		 jge	 SHORT $LN11@stbi__hdr_
$main_decode_loop$89:

; 7142 :                 stbi_uc rgbe[4];
; 7143 :                 main_decode_loop:
; 7144 :                 stbi__getn(s, rgbe, 4);

  00485	41 b8 04 00 00
	00		 mov	 r8d, 4
  0048b	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR rgbe$3[rsp]
  00493	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0049b	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 7145 :                 stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

  004a0	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  004a4	0f af 44 24 38	 imul	 eax, DWORD PTR width$[rsp]
  004a9	0f af 84 24 10
	05 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  004b1	48 98		 cdqe
  004b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  004b8	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  004bc	8b 4c 24 34	 mov	 ecx, DWORD PTR i$[rsp]
  004c0	0f af 8c 24 10
	05 00 00	 imul	 ecx, DWORD PTR req_comp$[rsp]
  004c8	48 63 c9	 movsxd	 rcx, ecx
  004cb	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  004cf	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  004d7	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR rgbe$3[rsp]
  004df	48 8b c8	 mov	 rcx, rax
  004e2	e8 00 00 00 00	 call	 ?stbi__hdr_convert@@YAXPEAMPEAEH@Z ; stbi__hdr_convert

; 7146 :             }

  004e7	eb 88		 jmp	 SHORT $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 7147 :         }

  004e9	e9 61 ff ff ff	 jmp	 $LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 7148 :     } else {

  004ee	e9 45 04 00 00	 jmp	 $LN43@stbi__hdr_
$LN42@stbi__hdr_:

; 7149 :         // Read RLE-encoded data
; 7150 :         scanline = NULL;

  004f3	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR scanline$[rsp], 0

; 7151 :         
; 7152 :         for (j = 0; j < height; ++j) {

  004fc	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00504	eb 0a		 jmp	 SHORT $LN15@stbi__hdr_
$LN13@stbi__hdr_:
  00506	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  0050a	ff c0		 inc	 eax
  0050c	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN15@stbi__hdr_:
  00510	8b 44 24 58	 mov	 eax, DWORD PTR height$[rsp]
  00514	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  00518	0f 8d 08 04 00
	00		 jge	 $LN14@stbi__hdr_

; 7153 :             c1 = stbi__get8(s);

  0051e	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00526	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0052b	0f b6 c0	 movzx	 eax, al
  0052e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR c1$[rsp], eax

; 7154 :             c2 = stbi__get8(s);

  00535	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0053d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00542	0f b6 c0	 movzx	 eax, al
  00545	89 84 24 a4 00
	00 00		 mov	 DWORD PTR c2$[rsp], eax

; 7155 :             len = stbi__get8(s);

  0054c	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00554	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00559	0f b6 c0	 movzx	 eax, al
  0055c	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 7156 :             if (c1 != 2 || c2 != 2 || (len & 0x80)) {

  00560	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR c1$[rsp], 2
  00568	75 1b		 jne	 SHORT $LN46@stbi__hdr_
  0056a	83 bc 24 a4 00
	00 00 02	 cmp	 DWORD PTR c2$[rsp], 2
  00572	75 11		 jne	 SHORT $LN46@stbi__hdr_
  00574	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00578	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0057d	85 c0		 test	 eax, eax
  0057f	0f 84 8c 00 00
	00		 je	 $LN45@stbi__hdr_
$LN46@stbi__hdr_:

; 7157 :                 // not run-length encoded, so we have to actually use THIS data as a decoded
; 7158 :                 // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 7159 :                 stbi_uc rgbe[4];
; 7160 :                 rgbe[0] = (stbi_uc) c1;

  00585	b8 01 00 00 00	 mov	 eax, 1
  0058a	48 6b c0 00	 imul	 rax, rax, 0
  0058e	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR c1$[rsp]
  00596	88 4c 04 6c	 mov	 BYTE PTR rgbe$1[rsp+rax], cl

; 7161 :                 rgbe[1] = (stbi_uc) c2;

  0059a	b8 01 00 00 00	 mov	 eax, 1
  0059f	48 6b c0 01	 imul	 rax, rax, 1
  005a3	0f b6 8c 24 a4
	00 00 00	 movzx	 ecx, BYTE PTR c2$[rsp]
  005ab	88 4c 04 6c	 mov	 BYTE PTR rgbe$1[rsp+rax], cl

; 7162 :                 rgbe[2] = (stbi_uc) len;

  005af	b8 01 00 00 00	 mov	 eax, 1
  005b4	48 6b c0 02	 imul	 rax, rax, 2
  005b8	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR len$[rsp]
  005bd	88 4c 04 6c	 mov	 BYTE PTR rgbe$1[rsp+rax], cl

; 7163 :                 rgbe[3] = (stbi_uc) stbi__get8(s);

  005c1	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005c9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  005ce	b9 01 00 00 00	 mov	 ecx, 1
  005d3	48 6b c9 03	 imul	 rcx, rcx, 3
  005d7	88 44 0c 6c	 mov	 BYTE PTR rgbe$1[rsp+rcx], al

; 7164 :                 stbi__hdr_convert(hdr_data, rgbe, req_comp);

  005db	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  005e3	48 8d 54 24 6c	 lea	 rdx, QWORD PTR rgbe$1[rsp]
  005e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  005ed	e8 00 00 00 00	 call	 ?stbi__hdr_convert@@YAXPEAMPEAEH@Z ; stbi__hdr_convert

; 7165 :                 i = 1;

  005f2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1

; 7166 :                 j = 0;

  005fa	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 7167 :                 STBI_FREE(scanline);

  00602	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  00607	e8 00 00 00 00	 call	 free

; 7168 :                 goto main_decode_loop; // yes, this makes no sense

  0060c	e9 74 fe ff ff	 jmp	 $main_decode_loop$89
$LN45@stbi__hdr_:

; 7169 :             }
; 7170 :             len <<= 8;

  00611	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00615	c1 e0 08	 shl	 eax, 8
  00618	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 7171 :             len |= stbi__get8(s);

  0061c	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00624	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00629	0f b6 c0	 movzx	 eax, al
  0062c	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00630	0b c8		 or	 ecx, eax
  00632	8b c1		 mov	 eax, ecx
  00634	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 7172 :             if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

  00638	8b 44 24 38	 mov	 eax, DWORD PTR width$[rsp]
  0063c	39 44 24 44	 cmp	 DWORD PTR len$[rsp], eax
  00640	74 49		 je	 SHORT $LN47@stbi__hdr_
  00642	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00647	e8 00 00 00 00	 call	 free
  0064c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  00651	e8 00 00 00 00	 call	 free
  00656	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40925
  0065d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00662	85 c0		 test	 eax, eax
  00664	74 0d		 je	 SHORT $LN72@stbi__hdr_
  00666	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
  00671	eb 0b		 jmp	 SHORT $LN73@stbi__hdr_
$LN72@stbi__hdr_:
  00673	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
$LN73@stbi__hdr_:
  0067e	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv264[rsp]
  00686	e9 b2 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN47@stbi__hdr_:

; 7173 :             if (scanline == NULL) {

  0068b	48 83 7c 24 60
	00		 cmp	 QWORD PTR scanline$[rsp], 0
  00691	75 5d		 jne	 SHORT $LN48@stbi__hdr_

; 7174 :                 scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);

  00693	45 33 c0	 xor	 r8d, r8d
  00696	ba 04 00 00 00	 mov	 edx, 4
  0069b	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  0069f	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  006a4	48 89 44 24 60	 mov	 QWORD PTR scanline$[rsp], rax

; 7175 :                 if (!scanline) {

  006a9	48 83 7c 24 60
	00		 cmp	 QWORD PTR scanline$[rsp], 0
  006af	75 3f		 jne	 SHORT $LN49@stbi__hdr_

; 7176 :                     STBI_FREE(hdr_data);

  006b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  006b6	e8 00 00 00 00	 call	 free

; 7177 :                     return stbi__errpf("outofmem", "Out of memory");

  006bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40928
  006c2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  006c7	85 c0		 test	 eax, eax
  006c9	74 0d		 je	 SHORT $LN74@stbi__hdr_
  006cb	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv276[rsp], 0
  006d6	eb 0b		 jmp	 SHORT $LN75@stbi__hdr_
$LN74@stbi__hdr_:
  006d8	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv276[rsp], 0
$LN75@stbi__hdr_:
  006e3	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR tv276[rsp]
  006eb	e9 4d 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN49@stbi__hdr_:
$LN48@stbi__hdr_:

; 7178 :                 }
; 7179 :             }
; 7180 :             
; 7181 :             for (k = 0; k < 4; ++k) {

  006f0	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  006f8	eb 0a		 jmp	 SHORT $LN18@stbi__hdr_
$LN16@stbi__hdr_:
  006fa	8b 44 24 68	 mov	 eax, DWORD PTR k$[rsp]
  006fe	ff c0		 inc	 eax
  00700	89 44 24 68	 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__hdr_:
  00704	83 7c 24 68 04	 cmp	 DWORD PTR k$[rsp], 4
  00709	0f 8d ad 01 00
	00		 jge	 $LN17@stbi__hdr_

; 7182 :                 int nleft;
; 7183 :                 i = 0;

  0070f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN19@stbi__hdr_:

; 7184 :                 while ((nleft = width - i) > 0) {

  00717	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0071b	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  0071f	2b c8		 sub	 ecx, eax
  00721	8b c1		 mov	 eax, ecx
  00723	89 44 24 78	 mov	 DWORD PTR nleft$2[rsp], eax
  00727	83 7c 24 78 00	 cmp	 DWORD PTR nleft$2[rsp], 0
  0072c	0f 8e 85 01 00
	00		 jle	 $LN20@stbi__hdr_

; 7185 :                     count = stbi__get8(s);

  00732	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0073a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0073f	88 44 24 30	 mov	 BYTE PTR count$[rsp], al

; 7186 :                     if (count > 128) {

  00743	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00748	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0074d	0f 8e bd 00 00
	00		 jle	 $LN50@stbi__hdr_

; 7187 :                         // Run
; 7188 :                         value = stbi__get8(s);

  00753	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0075b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00760	88 44 24 40	 mov	 BYTE PTR value$[rsp], al

; 7189 :                         count -= 128;

  00764	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00769	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0076e	88 44 24 30	 mov	 BYTE PTR count$[rsp], al

; 7190 :                         if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  00772	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00777	3b 44 24 78	 cmp	 eax, DWORD PTR nleft$2[rsp]
  0077b	7e 49		 jle	 SHORT $LN52@stbi__hdr_
  0077d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00782	e8 00 00 00 00	 call	 free
  00787	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  0078c	e8 00 00 00 00	 call	 free
  00791	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40932
  00798	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0079d	85 c0		 test	 eax, eax
  0079f	74 0d		 je	 SHORT $LN76@stbi__hdr_
  007a1	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv298[rsp], 0
  007ac	eb 0b		 jmp	 SHORT $LN77@stbi__hdr_
$LN76@stbi__hdr_:
  007ae	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv298[rsp], 0
$LN77@stbi__hdr_:
  007b9	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv298[rsp]
  007c1	e9 77 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN52@stbi__hdr_:

; 7191 :                         for (z = 0; z < count; ++z)

  007c6	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR z$[rsp], 0
  007ce	eb 0a		 jmp	 SHORT $LN23@stbi__hdr_
$LN21@stbi__hdr_:
  007d0	8b 44 24 48	 mov	 eax, DWORD PTR z$[rsp]
  007d4	ff c0		 inc	 eax
  007d6	89 44 24 48	 mov	 DWORD PTR z$[rsp], eax
$LN23@stbi__hdr_:
  007da	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  007df	39 44 24 48	 cmp	 DWORD PTR z$[rsp], eax
  007e3	7d 26		 jge	 SHORT $LN22@stbi__hdr_

; 7192 :                             scanline[i++ * 4 + k] = value;

  007e5	8b 44 24 68	 mov	 eax, DWORD PTR k$[rsp]
  007e9	8b 4c 24 34	 mov	 ecx, DWORD PTR i$[rsp]
  007ed	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  007f0	48 98		 cdqe
  007f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  007f7	0f b6 54 24 40	 movzx	 edx, BYTE PTR value$[rsp]
  007fc	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  007ff	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00803	ff c0		 inc	 eax
  00805	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
  00809	eb c5		 jmp	 SHORT $LN21@stbi__hdr_
$LN22@stbi__hdr_:

; 7193 :                     } else {

  0080b	e9 a2 00 00 00	 jmp	 $LN51@stbi__hdr_
$LN50@stbi__hdr_:

; 7194 :                         // Dump
; 7195 :                         if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  00810	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00815	3b 44 24 78	 cmp	 eax, DWORD PTR nleft$2[rsp]
  00819	7e 49		 jle	 SHORT $LN53@stbi__hdr_
  0081b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00820	e8 00 00 00 00	 call	 free
  00825	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  0082a	e8 00 00 00 00	 call	 free
  0082f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40934
  00836	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0083b	85 c0		 test	 eax, eax
  0083d	74 0d		 je	 SHORT $LN78@stbi__hdr_
  0083f	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv316[rsp], 0
  0084a	eb 0b		 jmp	 SHORT $LN79@stbi__hdr_
$LN78@stbi__hdr_:
  0084c	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv316[rsp], 0
$LN79@stbi__hdr_:
  00857	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv316[rsp]
  0085f	e9 d9 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN53@stbi__hdr_:

; 7196 :                         for (z = 0; z < count; ++z)

  00864	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR z$[rsp], 0
  0086c	eb 0a		 jmp	 SHORT $LN26@stbi__hdr_
$LN24@stbi__hdr_:
  0086e	8b 44 24 48	 mov	 eax, DWORD PTR z$[rsp]
  00872	ff c0		 inc	 eax
  00874	89 44 24 48	 mov	 DWORD PTR z$[rsp], eax
$LN26@stbi__hdr_:
  00878	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  0087d	39 44 24 48	 cmp	 DWORD PTR z$[rsp], eax
  00881	7d 2f		 jge	 SHORT $LN25@stbi__hdr_

; 7197 :                             scanline[i++ * 4 + k] = stbi__get8(s);

  00883	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0088b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00890	8b 4c 24 68	 mov	 ecx, DWORD PTR k$[rsp]
  00894	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00898	8d 0c 91	 lea	 ecx, DWORD PTR [rcx+rdx*4]
  0089b	48 63 c9	 movsxd	 rcx, ecx
  0089e	48 8b 54 24 60	 mov	 rdx, QWORD PTR scanline$[rsp]
  008a3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008a6	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  008aa	ff c0		 inc	 eax
  008ac	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
  008b0	eb bc		 jmp	 SHORT $LN24@stbi__hdr_
$LN25@stbi__hdr_:
$LN51@stbi__hdr_:

; 7198 :                     }
; 7199 :                 }

  008b2	e9 60 fe ff ff	 jmp	 $LN19@stbi__hdr_
$LN20@stbi__hdr_:

; 7200 :             }

  008b7	e9 3e fe ff ff	 jmp	 $LN16@stbi__hdr_
$LN17@stbi__hdr_:

; 7201 :             for (i=0; i < width; ++i)

  008bc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  008c4	eb 0a		 jmp	 SHORT $LN29@stbi__hdr_
$LN27@stbi__hdr_:
  008c6	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  008ca	ff c0		 inc	 eax
  008cc	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN29@stbi__hdr_:
  008d0	8b 44 24 38	 mov	 eax, DWORD PTR width$[rsp]
  008d4	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  008d8	7d 47		 jge	 SHORT $LN28@stbi__hdr_

; 7202 :                 stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);

  008da	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  008de	c1 e0 02	 shl	 eax, 2
  008e1	48 98		 cdqe
  008e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  008e8	48 03 c8	 add	 rcx, rax
  008eb	48 8b c1	 mov	 rax, rcx
  008ee	8b 4c 24 3c	 mov	 ecx, DWORD PTR j$[rsp]
  008f2	0f af 4c 24 38	 imul	 ecx, DWORD PTR width$[rsp]
  008f7	03 4c 24 34	 add	 ecx, DWORD PTR i$[rsp]
  008fb	0f af 8c 24 10
	05 00 00	 imul	 ecx, DWORD PTR req_comp$[rsp]
  00903	48 63 c9	 movsxd	 rcx, ecx
  00906	48 8b 54 24 70	 mov	 rdx, QWORD PTR hdr_data$[rsp]
  0090b	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  0090f	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00917	48 8b d0	 mov	 rdx, rax
  0091a	e8 00 00 00 00	 call	 ?stbi__hdr_convert@@YAXPEAMPEAEH@Z ; stbi__hdr_convert
  0091f	eb a5		 jmp	 SHORT $LN27@stbi__hdr_
$LN28@stbi__hdr_:

; 7203 :         }

  00921	e9 e0 fb ff ff	 jmp	 $LN13@stbi__hdr_
$LN14@stbi__hdr_:

; 7204 :         if (scanline)

  00926	48 83 7c 24 60
	00		 cmp	 QWORD PTR scanline$[rsp], 0
  0092c	74 0a		 je	 SHORT $LN54@stbi__hdr_

; 7205 :             STBI_FREE(scanline);

  0092e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  00933	e8 00 00 00 00	 call	 free
$LN54@stbi__hdr_:
$LN43@stbi__hdr_:

; 7206 :     }
; 7207 :     
; 7208 :     return hdr_data;

  00938	48 8b 44 24 70	 mov	 rax, QWORD PTR hdr_data$[rsp]
$LN1@stbi__hdr_:

; 7209 : }

  0093d	48 8b 8c 24 d0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00945	48 33 cc	 xor	 rcx, rsp
  00948	e8 00 00 00 00	 call	 __security_check_cookie
  0094d	48 81 c4 e8 04
	00 00		 add	 rsp, 1256		; 000004e8H
  00954	c3		 ret	 0
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__hdr_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__hdr_test

; 7020 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7021 :     int r = stbi__hdr_test_core(s, "#?RADIANCE\n");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40766
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ; stbi__hdr_test_core
  0001a	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7022 :     stbi__rewind(s);

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7023 :     if(!r) {

  00028	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  0002d	75 1f		 jne	 SHORT $LN2@stbi__hdr_

; 7024 :         r = stbi__hdr_test_core(s, "#?RGBE\n");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG40768
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ; stbi__hdr_test_core
  00040	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7025 :         stbi__rewind(s);

  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00049	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind
$LN2@stbi__hdr_:

; 7026 :     }
; 7027 :     return r;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 7028 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__hdr_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
channelCount$ = 32
depth$ = 36
s$ = 64
?stbi__psd_is16@@YAHPEAUstbi__context@@@Z PROC		; stbi__psd_is16

; 7317 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7318 :     int channelCount, depth;
; 7319 :     if (stbi__get32be(s) != 0x38425053) {

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00013	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00018	74 11		 je	 SHORT $LN2@stbi__psd_

; 7320 :         stbi__rewind( s );

  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7321 :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	e9 92 00 00 00	 jmp	 $LN1@stbi__psd_
$LN2@stbi__psd_:

; 7322 :     }
; 7323 :     if (stbi__get16be(s) != 1) {

  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00030	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00035	83 f8 01	 cmp	 eax, 1
  00038	74 0e		 je	 SHORT $LN3@stbi__psd_

; 7324 :         stbi__rewind( s );

  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7325 :         return 0;

  00044	33 c0		 xor	 eax, eax
  00046	eb 75		 jmp	 SHORT $LN1@stbi__psd_
$LN3@stbi__psd_:

; 7326 :     }
; 7327 :     stbi__skip(s, 6);

  00048	ba 06 00 00 00	 mov	 edx, 6
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00052	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 7328 :     channelCount = stbi__get16be(s);

  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005c	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00061	89 44 24 20	 mov	 DWORD PTR channelCount$[rsp], eax

; 7329 :     if (channelCount < 0 || channelCount > 16) {

  00065	83 7c 24 20 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  0006a	7c 07		 jl	 SHORT $LN5@stbi__psd_
  0006c	83 7c 24 20 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  00071	7e 0e		 jle	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 7330 :         stbi__rewind( s );

  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00078	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7331 :         return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 3c		 jmp	 SHORT $LN1@stbi__psd_
$LN4@stbi__psd_:

; 7332 :     }
; 7333 :     STBI_NOTUSED(stbi__get32be(s));

  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00086	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 7334 :     STBI_NOTUSED(stbi__get32be(s));

  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 7335 :     depth = stbi__get16be(s);

  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0009f	89 44 24 24	 mov	 DWORD PTR depth$[rsp], eax

; 7336 :     if (depth != 16) {

  000a3	83 7c 24 24 10	 cmp	 DWORD PTR depth$[rsp], 16
  000a8	74 0e		 je	 SHORT $LN6@stbi__psd_

; 7337 :         stbi__rewind( s );

  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000af	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7338 :         return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 05		 jmp	 SHORT $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7339 :     }
; 7340 :     return 1;

  000b8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 7341 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
?stbi__psd_is16@@YAHPEAUstbi__context@@@Z ENDP		; stbi__psd_is16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
dummy$ = 32
channelCount$ = 36
depth$ = 40
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__psd_info

; 7282 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7283 :     int channelCount, dummy, depth;
; 7284 :     if (!x) x = &dummy;

  00018	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  0001e	75 0a		 jne	 SHORT $LN2@stbi__psd_
  00020	48 8d 44 24 20	 lea	 rax, QWORD PTR dummy$[rsp]
  00025	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax
$LN2@stbi__psd_:

; 7285 :     if (!y) y = &dummy;

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN3@stbi__psd_
  00032	48 8d 44 24 20	 lea	 rax, QWORD PTR dummy$[rsp]
  00037	48 89 44 24 50	 mov	 QWORD PTR y$[rsp], rax
$LN3@stbi__psd_:

; 7286 :     if (!comp) comp = &dummy;

  0003c	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00042	75 0a		 jne	 SHORT $LN4@stbi__psd_
  00044	48 8d 44 24 20	 lea	 rax, QWORD PTR dummy$[rsp]
  00049	48 89 44 24 58	 mov	 QWORD PTR comp$[rsp], rax
$LN4@stbi__psd_:

; 7287 :     if (stbi__get32be(s) != 0x38425053) {

  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00058	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0005d	74 11		 je	 SHORT $LN5@stbi__psd_

; 7288 :         stbi__rewind( s );

  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7289 :         return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 d2 00 00 00	 jmp	 $LN1@stbi__psd_
$LN5@stbi__psd_:

; 7290 :     }
; 7291 :     if (stbi__get16be(s) != 1) {

  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00075	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0007a	83 f8 01	 cmp	 eax, 1
  0007d	74 11		 je	 SHORT $LN6@stbi__psd_

; 7292 :         stbi__rewind( s );

  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00084	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7293 :         return 0;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 b2 00 00 00	 jmp	 $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7294 :     }
; 7295 :     stbi__skip(s, 6);

  00090	ba 06 00 00 00	 mov	 edx, 6
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 7296 :     channelCount = stbi__get16be(s);

  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a4	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000a9	89 44 24 24	 mov	 DWORD PTR channelCount$[rsp], eax

; 7297 :     if (channelCount < 0 || channelCount > 16) {

  000ad	83 7c 24 24 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  000b2	7c 07		 jl	 SHORT $LN8@stbi__psd_
  000b4	83 7c 24 24 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  000b9	7e 0e		 jle	 SHORT $LN7@stbi__psd_
$LN8@stbi__psd_:

; 7298 :         stbi__rewind( s );

  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c0	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7299 :         return 0;

  000c5	33 c0		 xor	 eax, eax
  000c7	eb 79		 jmp	 SHORT $LN1@stbi__psd_
$LN7@stbi__psd_:

; 7300 :     }
; 7301 :     *y = stbi__get32be(s);

  000c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ce	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  000d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  000d8	89 01		 mov	 DWORD PTR [rcx], eax

; 7302 :     *x = stbi__get32be(s);

  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000df	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  000e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  000e9	89 01		 mov	 DWORD PTR [rcx], eax

; 7303 :     depth = stbi__get16be(s);

  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f0	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000f5	89 44 24 28	 mov	 DWORD PTR depth$[rsp], eax

; 7304 :     if (depth != 8 && depth != 16) {

  000f9	83 7c 24 28 08	 cmp	 DWORD PTR depth$[rsp], 8
  000fe	74 15		 je	 SHORT $LN9@stbi__psd_
  00100	83 7c 24 28 10	 cmp	 DWORD PTR depth$[rsp], 16
  00105	74 0e		 je	 SHORT $LN9@stbi__psd_

; 7305 :         stbi__rewind( s );

  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0010c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7306 :         return 0;

  00111	33 c0		 xor	 eax, eax
  00113	eb 2d		 jmp	 SHORT $LN1@stbi__psd_
$LN9@stbi__psd_:

; 7307 :     }
; 7308 :     if (stbi__get16be(s) != 3) {

  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0011a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0011f	83 f8 03	 cmp	 eax, 3
  00122	74 0e		 je	 SHORT $LN10@stbi__psd_

; 7309 :         stbi__rewind( s );

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00129	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7310 :         return 0;

  0012e	33 c0		 xor	 eax, eax
  00130	eb 10		 jmp	 SHORT $LN1@stbi__psd_
$LN10@stbi__psd_:

; 7311 :     }
; 7312 :     *comp = 4;

  00132	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  00137	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 7313 :     return 1;

  0013d	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 7314 : }

  00142	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00146	c3		 ret	 0
?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__psd_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 48
channel$ = 52
h$ = 56
w$ = 60
out$ = 64
val$1 = 72
pixelCount$ = 76
channelCount$ = 80
bitdepth$ = 84
ra$2 = 88
ra$3 = 92
pixel$4 = 96
pixel$5 = 104
val$6 = 112
compression$ = 116
inv_a$7 = 120
inv_a$8 = 124
p$9 = 128
tv137 = 136
tv146 = 140
tv154 = 144
tv174 = 148
tv185 = 152
tv205 = 156
tv222 = 160
tv233 = 164
tv244 = 168
tv252 = 172
tv70 = 176
tv78 = 180
tv89 = 184
tv131 = 188
p$10 = 192
a$11 = 200
a$12 = 204
q$13 = 208
p$14 = 216
q$15 = 224
s$ = 256
x$ = 264
y$ = 272
comp$ = 280
req_comp$ = 288
ri$ = 296
bpc$ = 304
?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z PROC ; stbi__psd_load

; 6049 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 6050 :     int pixelCount;
; 6051 :     int channelCount, compression;
; 6052 :     int channel, i;
; 6053 :     int bitdepth;
; 6054 :     int w,h;
; 6055 :     stbi_uc *out;
; 6056 :     STBI_NOTUSED(ri);
; 6057 :     
; 6058 :     // Check identifier
; 6059 :     if (stbi__get32be(s) != 0x38425053)   // "8BPS"

  0001b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00028	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0002d	74 35		 je	 SHORT $LN32@stbi__psd_

; 6060 :         return stbi__errpuc("not PSD", "Corrupt PSD image");

  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40141
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	85 c0		 test	 eax, eax
  0003d	74 0d		 je	 SHORT $LN69@stbi__psd_
  0003f	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
  0004a	eb 0b		 jmp	 SHORT $LN70@stbi__psd_
$LN69@stbi__psd_:
  0004c	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
$LN70@stbi__psd_:
  00057	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv70[rsp]
  0005f	e9 27 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN32@stbi__psd_:

; 6061 :     
; 6062 :     // Check file type version.
; 6063 :     if (stbi__get16be(s) != 1)

  00064	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006c	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00071	83 f8 01	 cmp	 eax, 1
  00074	74 35		 je	 SHORT $LN33@stbi__psd_

; 6064 :         return stbi__errpuc("wrong version", "Unsupported version of PSD image");

  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40143
  0007d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00082	85 c0		 test	 eax, eax
  00084	74 0d		 je	 SHORT $LN71@stbi__psd_
  00086	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv78[rsp], 0
  00091	eb 0b		 jmp	 SHORT $LN72@stbi__psd_
$LN71@stbi__psd_:
  00093	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv78[rsp], 0
$LN72@stbi__psd_:
  0009e	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv78[rsp]
  000a6	e9 e0 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN33@stbi__psd_:

; 6065 :     
; 6066 :     // Skip 6 reserved bytes.
; 6067 :     stbi__skip(s, 6 );

  000ab	ba 06 00 00 00	 mov	 edx, 6
  000b0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b8	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6068 :     
; 6069 :     // Read the number of channels (R, G, B, A, etc).
; 6070 :     channelCount = stbi__get16be(s);

  000bd	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000ca	89 44 24 50	 mov	 DWORD PTR channelCount$[rsp], eax

; 6071 :     if (channelCount < 0 || channelCount > 16)

  000ce	83 7c 24 50 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  000d3	7c 07		 jl	 SHORT $LN35@stbi__psd_
  000d5	83 7c 24 50 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  000da	7e 35		 jle	 SHORT $LN34@stbi__psd_
$LN35@stbi__psd_:

; 6072 :         return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40146
  000e3	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000e8	85 c0		 test	 eax, eax
  000ea	74 0d		 je	 SHORT $LN73@stbi__psd_
  000ec	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
  000f7	eb 0b		 jmp	 SHORT $LN74@stbi__psd_
$LN73@stbi__psd_:
  000f9	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
$LN74@stbi__psd_:
  00104	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv89[rsp]
  0010c	e9 7a 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN34@stbi__psd_:

; 6073 :     
; 6074 :     // Read the rows and columns of the image.
; 6075 :     h = stbi__get32be(s);

  00111	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00119	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  0011e	89 44 24 38	 mov	 DWORD PTR h$[rsp], eax

; 6076 :     w = stbi__get32be(s);

  00122	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  0012f	89 44 24 3c	 mov	 DWORD PTR w$[rsp], eax

; 6077 :     
; 6078 :     if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00133	81 7c 24 38 00
	00 00 01	 cmp	 DWORD PTR h$[rsp], 16777216 ; 01000000H
  0013b	7e 35		 jle	 SHORT $LN36@stbi__psd_
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40148
  00144	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00149	85 c0		 test	 eax, eax
  0014b	74 0d		 je	 SHORT $LN75@stbi__psd_
  0014d	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv131[rsp], 0
  00158	eb 0b		 jmp	 SHORT $LN76@stbi__psd_
$LN75@stbi__psd_:
  0015a	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv131[rsp], 0
$LN76@stbi__psd_:
  00165	48 63 84 24 bc
	00 00 00	 movsxd	 rax, DWORD PTR tv131[rsp]
  0016d	e9 19 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN36@stbi__psd_:

; 6079 :     if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00172	81 7c 24 3c 00
	00 00 01	 cmp	 DWORD PTR w$[rsp], 16777216 ; 01000000H
  0017a	7e 35		 jle	 SHORT $LN37@stbi__psd_
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40150
  00183	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00188	85 c0		 test	 eax, eax
  0018a	74 0d		 je	 SHORT $LN77@stbi__psd_
  0018c	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv137[rsp], 0
  00197	eb 0b		 jmp	 SHORT $LN78@stbi__psd_
$LN77@stbi__psd_:
  00199	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv137[rsp], 0
$LN78@stbi__psd_:
  001a4	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv137[rsp]
  001ac	e9 da 09 00 00	 jmp	 $LN1@stbi__psd_
$LN37@stbi__psd_:

; 6080 :     
; 6081 :     // Make sure the depth is 8 bits.
; 6082 :     bitdepth = stbi__get16be(s);

  001b1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001b9	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  001be	89 44 24 54	 mov	 DWORD PTR bitdepth$[rsp], eax

; 6083 :     if (bitdepth != 8 && bitdepth != 16)

  001c2	83 7c 24 54 08	 cmp	 DWORD PTR bitdepth$[rsp], 8
  001c7	74 3c		 je	 SHORT $LN38@stbi__psd_
  001c9	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  001ce	74 35		 je	 SHORT $LN38@stbi__psd_

; 6084 :         return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40152
  001d7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001dc	85 c0		 test	 eax, eax
  001de	74 0d		 je	 SHORT $LN79@stbi__psd_
  001e0	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
  001eb	eb 0b		 jmp	 SHORT $LN80@stbi__psd_
$LN79@stbi__psd_:
  001ed	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
$LN80@stbi__psd_:
  001f8	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR tv146[rsp]
  00200	e9 86 09 00 00	 jmp	 $LN1@stbi__psd_
$LN38@stbi__psd_:

; 6085 :     
; 6086 :     // Make sure the color mode is RGB.
; 6087 :     // Valid options are:
; 6088 :     //   0: Bitmap
; 6089 :     //   1: Grayscale
; 6090 :     //   2: Indexed color
; 6091 :     //   3: RGB color
; 6092 :     //   4: CMYK color
; 6093 :     //   7: Multichannel
; 6094 :     //   8: Duotone
; 6095 :     //   9: Lab color
; 6096 :     if (stbi__get16be(s) != 3)

  00205	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0020d	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00212	83 f8 03	 cmp	 eax, 3
  00215	74 35		 je	 SHORT $LN39@stbi__psd_

; 6097 :         return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40154
  0021e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00223	85 c0		 test	 eax, eax
  00225	74 0d		 je	 SHORT $LN81@stbi__psd_
  00227	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
  00232	eb 0b		 jmp	 SHORT $LN82@stbi__psd_
$LN81@stbi__psd_:
  00234	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
$LN82@stbi__psd_:
  0023f	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv154[rsp]
  00247	e9 3f 09 00 00	 jmp	 $LN1@stbi__psd_
$LN39@stbi__psd_:

; 6098 :     
; 6099 :     // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6100 :     stbi__skip(s,stbi__get32be(s) );

  0024c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00254	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00259	8b d0		 mov	 edx, eax
  0025b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00263	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6101 :     
; 6102 :     // Skip the image resources.  (resolution, pen tool paths, etc)
; 6103 :     stbi__skip(s, stbi__get32be(s) );

  00268	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00270	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00275	8b d0		 mov	 edx, eax
  00277	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0027f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6104 :     
; 6105 :     // Skip the reserved data.
; 6106 :     stbi__skip(s, stbi__get32be(s) );

  00284	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0028c	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00291	8b d0		 mov	 edx, eax
  00293	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0029b	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6107 :     
; 6108 :     // Find out if the data is compressed.
; 6109 :     // Known values:
; 6110 :     //   0: no compression
; 6111 :     //   1: RLE compressed
; 6112 :     compression = stbi__get16be(s);

  002a0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a8	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  002ad	89 44 24 74	 mov	 DWORD PTR compression$[rsp], eax

; 6113 :     if (compression > 1)

  002b1	83 7c 24 74 01	 cmp	 DWORD PTR compression$[rsp], 1
  002b6	7e 35		 jle	 SHORT $LN40@stbi__psd_

; 6114 :         return stbi__errpuc("bad compression", "PSD has an unknown compression format");

  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40156
  002bf	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002c4	85 c0		 test	 eax, eax
  002c6	74 0d		 je	 SHORT $LN83@stbi__psd_
  002c8	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
  002d3	eb 0b		 jmp	 SHORT $LN84@stbi__psd_
$LN83@stbi__psd_:
  002d5	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN84@stbi__psd_:
  002e0	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  002e8	e9 9e 08 00 00	 jmp	 $LN1@stbi__psd_
$LN40@stbi__psd_:

; 6115 :     
; 6116 :     // Check size
; 6117 :     if (!stbi__mad3sizes_valid(4, w, h, 0))

  002ed	45 33 c9	 xor	 r9d, r9d
  002f0	44 8b 44 24 38	 mov	 r8d, DWORD PTR h$[rsp]
  002f5	8b 54 24 3c	 mov	 edx, DWORD PTR w$[rsp]
  002f9	b9 04 00 00 00	 mov	 ecx, 4
  002fe	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  00303	85 c0		 test	 eax, eax
  00305	75 35		 jne	 SHORT $LN41@stbi__psd_

; 6118 :         return stbi__errpuc("too large", "Corrupt PSD");

  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40158
  0030e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00313	85 c0		 test	 eax, eax
  00315	74 0d		 je	 SHORT $LN85@stbi__psd_
  00317	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
  00322	eb 0b		 jmp	 SHORT $LN86@stbi__psd_
$LN85@stbi__psd_:
  00324	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN86@stbi__psd_:
  0032f	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv185[rsp]
  00337	e9 4f 08 00 00	 jmp	 $LN1@stbi__psd_
$LN41@stbi__psd_:

; 6119 :     
; 6120 :     // Create the destination image.
; 6121 :     
; 6122 :     if (!compression && bitdepth == 16 && bpc == 16) {

  0033c	83 7c 24 74 00	 cmp	 DWORD PTR compression$[rsp], 0
  00341	75 3c		 jne	 SHORT $LN42@stbi__psd_
  00343	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  00348	75 35		 jne	 SHORT $LN42@stbi__psd_
  0034a	83 bc 24 30 01
	00 00 10	 cmp	 DWORD PTR bpc$[rsp], 16
  00352	75 2b		 jne	 SHORT $LN42@stbi__psd_

; 6123 :         out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);

  00354	45 33 c9	 xor	 r9d, r9d
  00357	44 8b 44 24 38	 mov	 r8d, DWORD PTR h$[rsp]
  0035c	8b 54 24 3c	 mov	 edx, DWORD PTR w$[rsp]
  00360	b9 08 00 00 00	 mov	 ecx, 8
  00365	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0036a	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax

; 6124 :         ri->bits_per_channel = 16;

  0036f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00377	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 6125 :     } else

  0037d	eb 1b		 jmp	 SHORT $LN43@stbi__psd_
$LN42@stbi__psd_:

; 6126 :         out = (stbi_uc *) stbi__malloc(4 * w*h);

  0037f	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  00383	c1 e0 02	 shl	 eax, 2
  00386	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  0038b	48 98		 cdqe
  0038d	48 8b c8	 mov	 rcx, rax
  00390	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00395	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax
$LN43@stbi__psd_:

; 6127 :     
; 6128 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  0039a	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  003a0	75 35		 jne	 SHORT $LN44@stbi__psd_
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40162
  003a9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003ae	85 c0		 test	 eax, eax
  003b0	74 0d		 je	 SHORT $LN87@stbi__psd_
  003b2	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv205[rsp], 0
  003bd	eb 0b		 jmp	 SHORT $LN88@stbi__psd_
$LN87@stbi__psd_:
  003bf	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv205[rsp], 0
$LN88@stbi__psd_:
  003ca	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv205[rsp]
  003d2	e9 b4 07 00 00	 jmp	 $LN1@stbi__psd_
$LN44@stbi__psd_:

; 6129 :     pixelCount = w*h;

  003d7	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  003db	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  003e0	89 44 24 4c	 mov	 DWORD PTR pixelCount$[rsp], eax

; 6130 :     
; 6131 :     // Initialize the data to zero.
; 6132 :     //memset( out, 0, pixelCount * 4 );
; 6133 :     
; 6134 :     // Finally, the image data.
; 6135 :     if (compression) {

  003e4	83 7c 24 74 00	 cmp	 DWORD PTR compression$[rsp], 0
  003e9	0f 84 29 01 00
	00		 je	 $LN45@stbi__psd_

; 6136 :         // RLE as used by .PSD and .TIFF
; 6137 :         // Loop until you get the number of unpacked bytes you are expecting:
; 6138 :         //     Read the next source byte into n.
; 6139 :         //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6140 :         //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6141 :         //     Else if n is 128, noop.
; 6142 :         // Endloop
; 6143 :         
; 6144 :         // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6145 :         // which we're going to just skip.
; 6146 :         stbi__skip(s, h * channelCount * 2 );

  003ef	8b 44 24 38	 mov	 eax, DWORD PTR h$[rsp]
  003f3	0f af 44 24 50	 imul	 eax, DWORD PTR channelCount$[rsp]
  003f8	d1 e0		 shl	 eax, 1
  003fa	8b d0		 mov	 edx, eax
  003fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00404	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6147 :         
; 6148 :         // Read the RLE data by channel.
; 6149 :         for (channel = 0; channel < 4; channel++) {

  00409	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR channel$[rsp], 0
  00411	eb 0a		 jmp	 SHORT $LN4@stbi__psd_
$LN2@stbi__psd_:
  00413	8b 44 24 34	 mov	 eax, DWORD PTR channel$[rsp]
  00417	ff c0		 inc	 eax
  00419	89 44 24 34	 mov	 DWORD PTR channel$[rsp], eax
$LN4@stbi__psd_:
  0041d	83 7c 24 34 04	 cmp	 DWORD PTR channel$[rsp], 4
  00422	0f 8d eb 00 00
	00		 jge	 $LN3@stbi__psd_

; 6150 :             stbi_uc *p;
; 6151 :             
; 6152 :             p = out+channel;

  00428	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  0042d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00432	48 03 c8	 add	 rcx, rax
  00435	48 8b c1	 mov	 rax, rcx
  00438	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$10[rsp], rax

; 6153 :             if (channel >= channelCount) {

  00440	8b 44 24 50	 mov	 eax, DWORD PTR channelCount$[rsp]
  00444	39 44 24 34	 cmp	 DWORD PTR channel$[rsp], eax
  00448	7c 67		 jl	 SHORT $LN47@stbi__psd_

; 6154 :                 // Fill this channel with default data.
; 6155 :                 for (i = 0; i < pixelCount; i++, p += 4)

  0044a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00452	eb 1e		 jmp	 SHORT $LN7@stbi__psd_
$LN5@stbi__psd_:
  00454	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00458	ff c0		 inc	 eax
  0045a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0045e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$10[rsp]
  00466	48 83 c0 04	 add	 rax, 4
  0046a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$10[rsp], rax
$LN7@stbi__psd_:
  00472	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00476	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0047a	7d 33		 jge	 SHORT $LN6@stbi__psd_

; 6156 :                     *p = (channel == 3 ? 255 : 0);

  0047c	83 7c 24 34 03	 cmp	 DWORD PTR channel$[rsp], 3
  00481	75 0d		 jne	 SHORT $LN89@stbi__psd_
  00483	c7 84 24 a0 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv222[rsp], 255 ; 000000ffH
  0048e	eb 0b		 jmp	 SHORT $LN90@stbi__psd_
$LN89@stbi__psd_:
  00490	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv222[rsp], 0
$LN90@stbi__psd_:
  0049b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$10[rsp]
  004a3	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR tv222[rsp]
  004ab	88 08		 mov	 BYTE PTR [rax], cl
  004ad	eb a5		 jmp	 SHORT $LN5@stbi__psd_
$LN6@stbi__psd_:

; 6157 :             } else {

  004af	eb 5d		 jmp	 SHORT $LN48@stbi__psd_
$LN47@stbi__psd_:

; 6158 :                 // Read the RLE data.
; 6159 :                 if (!stbi__psd_decode_rle(s, p, pixelCount)) {

  004b1	44 8b 44 24 4c	 mov	 r8d, DWORD PTR pixelCount$[rsp]
  004b6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR p$10[rsp]
  004be	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004c6	e8 00 00 00 00	 call	 ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__psd_decode_rle
  004cb	85 c0		 test	 eax, eax
  004cd	75 3f		 jne	 SHORT $LN49@stbi__psd_

; 6160 :                     STBI_FREE(out);

  004cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  004d4	e8 00 00 00 00	 call	 free

; 6161 :                     return stbi__errpuc("corrupt", "bad RLE data");

  004d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG40168
  004e0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004e5	85 c0		 test	 eax, eax
  004e7	74 0d		 je	 SHORT $LN91@stbi__psd_
  004e9	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv233[rsp], 0
  004f4	eb 0b		 jmp	 SHORT $LN92@stbi__psd_
$LN91@stbi__psd_:
  004f6	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv233[rsp], 0
$LN92@stbi__psd_:
  00501	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR tv233[rsp]
  00509	e9 7d 06 00 00	 jmp	 $LN1@stbi__psd_
$LN49@stbi__psd_:
$LN48@stbi__psd_:

; 6162 :                 }
; 6163 :             }
; 6164 :         }

  0050e	e9 00 ff ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 6165 :         
; 6166 :     } else {

  00513	e9 8f 02 00 00	 jmp	 $LN46@stbi__psd_
$LN45@stbi__psd_:

; 6167 :         // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6168 :         // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6169 :         
; 6170 :         // Read the data by channel.
; 6171 :         for (channel = 0; channel < 4; channel++) {

  00518	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR channel$[rsp], 0
  00520	eb 0a		 jmp	 SHORT $LN10@stbi__psd_
$LN8@stbi__psd_:
  00522	8b 44 24 34	 mov	 eax, DWORD PTR channel$[rsp]
  00526	ff c0		 inc	 eax
  00528	89 44 24 34	 mov	 DWORD PTR channel$[rsp], eax
$LN10@stbi__psd_:
  0052c	83 7c 24 34 04	 cmp	 DWORD PTR channel$[rsp], 4
  00531	0f 8d 70 02 00
	00		 jge	 $LN9@stbi__psd_

; 6172 :             if (channel >= channelCount) {

  00537	8b 44 24 50	 mov	 eax, DWORD PTR channelCount$[rsp]
  0053b	39 44 24 34	 cmp	 DWORD PTR channel$[rsp], eax
  0053f	0f 8c 2f 01 00
	00		 jl	 $LN50@stbi__psd_

; 6173 :                 // Fill this channel with default data.
; 6174 :                 if (bitdepth == 16 && bpc == 16) {

  00545	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  0054a	0f 85 99 00 00
	00		 jne	 $LN52@stbi__psd_
  00550	83 bc 24 30 01
	00 00 10	 cmp	 DWORD PTR bpc$[rsp], 16
  00558	0f 85 8b 00 00
	00		 jne	 $LN52@stbi__psd_

; 6175 :                     stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

  0055e	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  00563	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00568	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0056c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR q$13[rsp], rax

; 6176 :                     stbi__uint16 val = channel == 3 ? 65535 : 0;

  00574	83 7c 24 34 03	 cmp	 DWORD PTR channel$[rsp], 3
  00579	75 0d		 jne	 SHORT $LN93@stbi__psd_
  0057b	c7 84 24 a8 00
	00 00 ff ff 00
	00		 mov	 DWORD PTR tv244[rsp], 65535 ; 0000ffffH
  00586	eb 0b		 jmp	 SHORT $LN94@stbi__psd_
$LN93@stbi__psd_:
  00588	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv244[rsp], 0
$LN94@stbi__psd_:
  00593	0f b7 84 24 a8
	00 00 00	 movzx	 eax, WORD PTR tv244[rsp]
  0059b	66 89 44 24 70	 mov	 WORD PTR val$6[rsp], ax

; 6177 :                     for (i = 0; i < pixelCount; i++, q += 4)

  005a0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a8	eb 1e		 jmp	 SHORT $LN13@stbi__psd_
$LN11@stbi__psd_:
  005aa	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005ae	ff c0		 inc	 eax
  005b0	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  005b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR q$13[rsp]
  005bc	48 83 c0 08	 add	 rax, 8
  005c0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR q$13[rsp], rax
$LN13@stbi__psd_:
  005c8	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  005cc	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  005d0	7d 12		 jge	 SHORT $LN12@stbi__psd_

; 6178 :                         *q = val;

  005d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR q$13[rsp]
  005da	0f b7 4c 24 70	 movzx	 ecx, WORD PTR val$6[rsp]
  005df	66 89 08	 mov	 WORD PTR [rax], cx
  005e2	eb c6		 jmp	 SHORT $LN11@stbi__psd_
$LN12@stbi__psd_:

; 6179 :                 } else {

  005e4	e9 86 00 00 00	 jmp	 $LN53@stbi__psd_
$LN52@stbi__psd_:

; 6180 :                     stbi_uc *p = out+channel;

  005e9	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  005ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  005f3	48 03 c8	 add	 rcx, rax
  005f6	48 8b c1	 mov	 rax, rcx
  005f9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR p$14[rsp], rax

; 6181 :                     stbi_uc val = channel == 3 ? 255 : 0;

  00601	83 7c 24 34 03	 cmp	 DWORD PTR channel$[rsp], 3
  00606	75 0d		 jne	 SHORT $LN95@stbi__psd_
  00608	c7 84 24 ac 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv252[rsp], 255 ; 000000ffH
  00613	eb 0b		 jmp	 SHORT $LN96@stbi__psd_
$LN95@stbi__psd_:
  00615	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv252[rsp], 0
$LN96@stbi__psd_:
  00620	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR tv252[rsp]
  00628	88 44 24 48	 mov	 BYTE PTR val$1[rsp], al

; 6182 :                     for (i = 0; i < pixelCount; i++, p += 4)

  0062c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00634	eb 1e		 jmp	 SHORT $LN16@stbi__psd_
$LN14@stbi__psd_:
  00636	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0063a	ff c0		 inc	 eax
  0063c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00640	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR p$14[rsp]
  00648	48 83 c0 04	 add	 rax, 4
  0064c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR p$14[rsp], rax
$LN16@stbi__psd_:
  00654	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00658	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0065c	7d 11		 jge	 SHORT $LN15@stbi__psd_

; 6183 :                         *p = val;

  0065e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR p$14[rsp]
  00666	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR val$1[rsp]
  0066b	88 08		 mov	 BYTE PTR [rax], cl
  0066d	eb c7		 jmp	 SHORT $LN14@stbi__psd_
$LN15@stbi__psd_:
$LN53@stbi__psd_:

; 6184 :                 }
; 6185 :             } else {

  0066f	e9 2e 01 00 00	 jmp	 $LN51@stbi__psd_
$LN50@stbi__psd_:

; 6186 :                 if (ri->bits_per_channel == 16) {    // output bpc

  00674	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0067c	83 38 10	 cmp	 DWORD PTR [rax], 16
  0067f	75 67		 jne	 SHORT $LN54@stbi__psd_

; 6187 :                     stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

  00681	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  00686	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0068b	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0068f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR q$15[rsp], rax

; 6188 :                     for (i = 0; i < pixelCount; i++, q += 4)

  00697	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0069f	eb 1e		 jmp	 SHORT $LN19@stbi__psd_
$LN17@stbi__psd_:
  006a1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006a5	ff c0		 inc	 eax
  006a7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  006ab	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR q$15[rsp]
  006b3	48 83 c0 08	 add	 rax, 8
  006b7	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR q$15[rsp], rax
$LN19@stbi__psd_:
  006bf	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  006c3	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  006c7	7d 1a		 jge	 SHORT $LN18@stbi__psd_

; 6189 :                         *q = (stbi__uint16) stbi__get16be(s);

  006c9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006d1	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  006d6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR q$15[rsp]
  006de	66 89 01	 mov	 WORD PTR [rcx], ax
  006e1	eb be		 jmp	 SHORT $LN17@stbi__psd_
$LN18@stbi__psd_:

; 6190 :                 } else {

  006e3	e9 ba 00 00 00	 jmp	 $LN55@stbi__psd_
$LN54@stbi__psd_:

; 6191 :                     stbi_uc *p = out+channel;

  006e8	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  006ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  006f2	48 03 c8	 add	 rcx, rax
  006f5	48 8b c1	 mov	 rax, rcx
  006f8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$9[rsp], rax

; 6192 :                     if (bitdepth == 16) {  // input bpc

  00700	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  00705	75 50		 jne	 SHORT $LN56@stbi__psd_

; 6193 :                         for (i = 0; i < pixelCount; i++, p += 4)

  00707	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0070f	eb 1e		 jmp	 SHORT $LN22@stbi__psd_
$LN20@stbi__psd_:
  00711	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00715	ff c0		 inc	 eax
  00717	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0071b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$9[rsp]
  00723	48 83 c0 04	 add	 rax, 4
  00727	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$9[rsp], rax
$LN22@stbi__psd_:
  0072f	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00733	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00737	7d 1c		 jge	 SHORT $LN21@stbi__psd_

; 6194 :                             *p = (stbi_uc) (stbi__get16be(s) >> 8);

  00739	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00741	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00746	c1 f8 08	 sar	 eax, 8
  00749	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$9[rsp]
  00751	88 01		 mov	 BYTE PTR [rcx], al
  00753	eb bc		 jmp	 SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 6195 :                     } else {

  00755	eb 4b		 jmp	 SHORT $LN57@stbi__psd_
$LN56@stbi__psd_:

; 6196 :                         for (i = 0; i < pixelCount; i++, p += 4)

  00757	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0075f	eb 1e		 jmp	 SHORT $LN25@stbi__psd_
$LN23@stbi__psd_:
  00761	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00765	ff c0		 inc	 eax
  00767	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0076b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$9[rsp]
  00773	48 83 c0 04	 add	 rax, 4
  00777	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$9[rsp], rax
$LN25@stbi__psd_:
  0077f	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00783	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00787	7d 19		 jge	 SHORT $LN24@stbi__psd_

; 6197 :                             *p = stbi__get8(s);

  00789	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00791	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00796	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$9[rsp]
  0079e	88 01		 mov	 BYTE PTR [rcx], al
  007a0	eb bf		 jmp	 SHORT $LN23@stbi__psd_
$LN24@stbi__psd_:
$LN57@stbi__psd_:
$LN55@stbi__psd_:
$LN51@stbi__psd_:

; 6198 :                     }
; 6199 :                 }
; 6200 :             }
; 6201 :         }

  007a2	e9 7b fd ff ff	 jmp	 $LN8@stbi__psd_
$LN9@stbi__psd_:
$LN46@stbi__psd_:

; 6202 :     }
; 6203 :     
; 6204 :     // remove weird white matte from PSD
; 6205 :     if (channelCount >= 4) {

  007a7	83 7c 24 50 04	 cmp	 DWORD PTR channelCount$[rsp], 4
  007ac	0f 8c 1b 03 00
	00		 jl	 $LN58@stbi__psd_

; 6206 :         if (ri->bits_per_channel == 16) {

  007b2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  007ba	83 38 10	 cmp	 DWORD PTR [rax], 16
  007bd	0f 85 88 01 00
	00		 jne	 $LN59@stbi__psd_

; 6207 :             for (i=0; i < w*h; ++i) {

  007c3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007cb	eb 0a		 jmp	 SHORT $LN28@stbi__psd_
$LN26@stbi__psd_:
  007cd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007d1	ff c0		 inc	 eax
  007d3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__psd_:
  007d7	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  007db	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  007e0	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  007e4	0f 8d 5c 01 00
	00		 jge	 $LN27@stbi__psd_

; 6208 :                 stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;

  007ea	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007ee	c1 e0 02	 shl	 eax, 2
  007f1	48 98		 cdqe
  007f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  007f8	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  007fc	48 89 44 24 60	 mov	 QWORD PTR pixel$4[rsp], rax

; 6209 :                 if (pixel[3] != 0 && pixel[3] != 65535) {

  00801	b8 02 00 00 00	 mov	 eax, 2
  00806	48 6b c0 03	 imul	 rax, rax, 3
  0080a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  0080f	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00813	85 c0		 test	 eax, eax
  00815	0f 84 26 01 00
	00		 je	 $LN61@stbi__psd_
  0081b	b8 02 00 00 00	 mov	 eax, 2
  00820	48 6b c0 03	 imul	 rax, rax, 3
  00824	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  00829	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0082d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00832	0f 84 09 01 00
	00		 je	 $LN61@stbi__psd_

; 6210 :                     float a = pixel[3] / 65535.0f;

  00838	b8 02 00 00 00	 mov	 eax, 2
  0083d	48 6b c0 03	 imul	 rax, rax, 3
  00841	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  00846	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0084a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0084e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@477fff00
  00856	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR a$11[rsp], xmm0

; 6211 :                     float ra = 1.0f / a;

  0085f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00867	f3 0f 5e 84 24
	c8 00 00 00	 divss	 xmm0, DWORD PTR a$11[rsp]
  00870	f3 0f 11 44 24
	58		 movss	 DWORD PTR ra$2[rsp], xmm0

; 6212 :                     float inv_a = 65535.0f * (1 - ra);

  00876	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0087e	f3 0f 5c 44 24
	58		 subss	 xmm0, DWORD PTR ra$2[rsp]
  00884	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@477fff00
  0088c	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00890	0f 28 c1	 movaps	 xmm0, xmm1
  00893	f3 0f 11 44 24
	78		 movss	 DWORD PTR inv_a$7[rsp], xmm0

; 6213 :                     pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

  00899	b8 02 00 00 00	 mov	 eax, 2
  0089e	48 6b c0 00	 imul	 rax, rax, 0
  008a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  008a7	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008ab	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008af	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR ra$2[rsp]
  008b5	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR inv_a$7[rsp]
  008bb	f3 0f 2c c0	 cvttss2si eax, xmm0
  008bf	b9 02 00 00 00	 mov	 ecx, 2
  008c4	48 6b c9 00	 imul	 rcx, rcx, 0
  008c8	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixel$4[rsp]
  008cd	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 6214 :                     pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

  008d1	b8 02 00 00 00	 mov	 eax, 2
  008d6	48 6b c0 01	 imul	 rax, rax, 1
  008da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  008df	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008e7	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR ra$2[rsp]
  008ed	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR inv_a$7[rsp]
  008f3	f3 0f 2c c0	 cvttss2si eax, xmm0
  008f7	b9 02 00 00 00	 mov	 ecx, 2
  008fc	48 6b c9 01	 imul	 rcx, rcx, 1
  00900	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixel$4[rsp]
  00905	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 6215 :                     pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

  00909	b8 02 00 00 00	 mov	 eax, 2
  0090e	48 6b c0 02	 imul	 rax, rax, 2
  00912	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  00917	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0091b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0091f	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR ra$2[rsp]
  00925	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR inv_a$7[rsp]
  0092b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0092f	b9 02 00 00 00	 mov	 ecx, 2
  00934	48 6b c9 02	 imul	 rcx, rcx, 2
  00938	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixel$4[rsp]
  0093d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN61@stbi__psd_:

; 6216 :                 }
; 6217 :             }

  00941	e9 87 fe ff ff	 jmp	 $LN26@stbi__psd_
$LN27@stbi__psd_:

; 6218 :         } else {

  00946	e9 82 01 00 00	 jmp	 $LN60@stbi__psd_
$LN59@stbi__psd_:

; 6219 :             for (i=0; i < w*h; ++i) {

  0094b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00953	eb 0a		 jmp	 SHORT $LN31@stbi__psd_
$LN29@stbi__psd_:
  00955	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00959	ff c0		 inc	 eax
  0095b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN31@stbi__psd_:
  0095f	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  00963	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  00968	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0096c	0f 8d 5b 01 00
	00		 jge	 $LN30@stbi__psd_

; 6220 :                 unsigned char *pixel = out + 4*i;

  00972	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00976	c1 e0 02	 shl	 eax, 2
  00979	48 98		 cdqe
  0097b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00980	48 03 c8	 add	 rcx, rax
  00983	48 8b c1	 mov	 rax, rcx
  00986	48 89 44 24 68	 mov	 QWORD PTR pixel$5[rsp], rax

; 6221 :                 if (pixel[3] != 0 && pixel[3] != 255) {

  0098b	b8 01 00 00 00	 mov	 eax, 1
  00990	48 6b c0 03	 imul	 rax, rax, 3
  00994	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00999	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0099d	85 c0		 test	 eax, eax
  0099f	0f 84 23 01 00
	00		 je	 $LN62@stbi__psd_
  009a5	b8 01 00 00 00	 mov	 eax, 1
  009aa	48 6b c0 03	 imul	 rax, rax, 3
  009ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  009b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009b7	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  009bc	0f 84 06 01 00
	00		 je	 $LN62@stbi__psd_

; 6222 :                     float a = pixel[3] / 255.0f;

  009c2	b8 01 00 00 00	 mov	 eax, 1
  009c7	48 6b c0 03	 imul	 rax, rax, 3
  009cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  009d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009d4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  009d8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  009e0	f3 0f 11 84 24
	cc 00 00 00	 movss	 DWORD PTR a$12[rsp], xmm0

; 6223 :                     float ra = 1.0f / a;

  009e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009f1	f3 0f 5e 84 24
	cc 00 00 00	 divss	 xmm0, DWORD PTR a$12[rsp]
  009fa	f3 0f 11 44 24
	5c		 movss	 DWORD PTR ra$3[rsp], xmm0

; 6224 :                     float inv_a = 255.0f * (1 - ra);

  00a00	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a08	f3 0f 5c 44 24
	5c		 subss	 xmm0, DWORD PTR ra$3[rsp]
  00a0e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@437f0000
  00a16	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00a1a	0f 28 c1	 movaps	 xmm0, xmm1
  00a1d	f3 0f 11 44 24
	7c		 movss	 DWORD PTR inv_a$8[rsp], xmm0

; 6225 :                     pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

  00a23	b8 01 00 00 00	 mov	 eax, 1
  00a28	48 6b c0 00	 imul	 rax, rax, 0
  00a2c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00a31	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a35	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a39	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR ra$3[rsp]
  00a3f	f3 0f 58 44 24
	7c		 addss	 xmm0, DWORD PTR inv_a$8[rsp]
  00a45	f3 0f 2c c0	 cvttss2si eax, xmm0
  00a49	b9 01 00 00 00	 mov	 ecx, 1
  00a4e	48 6b c9 00	 imul	 rcx, rcx, 0
  00a52	48 8b 54 24 68	 mov	 rdx, QWORD PTR pixel$5[rsp]
  00a57	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6226 :                     pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

  00a5a	b8 01 00 00 00	 mov	 eax, 1
  00a5f	48 6b c0 01	 imul	 rax, rax, 1
  00a63	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00a68	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a6c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a70	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR ra$3[rsp]
  00a76	f3 0f 58 44 24
	7c		 addss	 xmm0, DWORD PTR inv_a$8[rsp]
  00a7c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00a80	b9 01 00 00 00	 mov	 ecx, 1
  00a85	48 6b c9 01	 imul	 rcx, rcx, 1
  00a89	48 8b 54 24 68	 mov	 rdx, QWORD PTR pixel$5[rsp]
  00a8e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6227 :                     pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

  00a91	b8 01 00 00 00	 mov	 eax, 1
  00a96	48 6b c0 02	 imul	 rax, rax, 2
  00a9a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00a9f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00aa3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00aa7	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR ra$3[rsp]
  00aad	f3 0f 58 44 24
	7c		 addss	 xmm0, DWORD PTR inv_a$8[rsp]
  00ab3	f3 0f 2c c0	 cvttss2si eax, xmm0
  00ab7	b9 01 00 00 00	 mov	 ecx, 1
  00abc	48 6b c9 02	 imul	 rcx, rcx, 2
  00ac0	48 8b 54 24 68	 mov	 rdx, QWORD PTR pixel$5[rsp]
  00ac5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN62@stbi__psd_:

; 6228 :                 }
; 6229 :             }

  00ac8	e9 88 fe ff ff	 jmp	 $LN29@stbi__psd_
$LN30@stbi__psd_:
$LN60@stbi__psd_:
$LN58@stbi__psd_:

; 6230 :         }
; 6231 :     }
; 6232 :     
; 6233 :     // convert to desired output format
; 6234 :     if (req_comp && req_comp != 4) {

  00acd	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00ad5	74 7a		 je	 SHORT $LN63@stbi__psd_
  00ad7	83 bc 24 20 01
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00adf	74 70		 je	 SHORT $LN63@stbi__psd_

; 6235 :         if (ri->bits_per_channel == 16)

  00ae1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00ae9	83 38 10	 cmp	 DWORD PTR [rax], 16
  00aec	75 2b		 jne	 SHORT $LN64@stbi__psd_

; 6236 :             out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);

  00aee	8b 44 24 38	 mov	 eax, DWORD PTR h$[rsp]
  00af2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00af6	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR w$[rsp]
  00afb	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00b03	ba 04 00 00 00	 mov	 edx, 4
  00b08	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00b0d	e8 00 00 00 00	 call	 ?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
  00b12	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax
  00b17	eb 29		 jmp	 SHORT $LN65@stbi__psd_
$LN64@stbi__psd_:

; 6237 :         else
; 6238 :             out = stbi__convert_format(out, 4, req_comp, w, h);

  00b19	8b 44 24 38	 mov	 eax, DWORD PTR h$[rsp]
  00b1d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b21	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR w$[rsp]
  00b26	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00b2e	ba 04 00 00 00	 mov	 edx, 4
  00b33	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00b38	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00b3d	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax
$LN65@stbi__psd_:

; 6239 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  00b42	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  00b48	75 07		 jne	 SHORT $LN66@stbi__psd_
  00b4a	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
  00b4f	eb 3a		 jmp	 SHORT $LN1@stbi__psd_
$LN66@stbi__psd_:
$LN63@stbi__psd_:

; 6240 :     }
; 6241 :     
; 6242 :     if (comp) *comp = 4;

  00b51	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00b5a	74 0e		 je	 SHORT $LN67@stbi__psd_
  00b5c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00b64	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN67@stbi__psd_:

; 6243 :     *y = h;

  00b6a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00b72	8b 4c 24 38	 mov	 ecx, DWORD PTR h$[rsp]
  00b76	89 08		 mov	 DWORD PTR [rax], ecx

; 6244 :     *x = w;

  00b78	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00b80	8b 4c 24 3c	 mov	 ecx, DWORD PTR w$[rsp]
  00b84	89 08		 mov	 DWORD PTR [rax], ecx

; 6245 :     
; 6246 :     return out;

  00b86	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__psd_:

; 6247 : }

  00b8b	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00b92	c3		 ret	 0
?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ENDP ; stbi__psd_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv67 = 32
r$ = 36
s$ = 64
?stbi__psd_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__psd_test

; 6004 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6005 :     int r = (stbi__get32be(s) == 0x38425053);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00013	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00018	75 0a		 jne	 SHORT $LN3@stbi__psd_
  0001a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00022	eb 08		 jmp	 SHORT $LN4@stbi__psd_
$LN3@stbi__psd_:
  00024	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@stbi__psd_:
  0002c	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]
  00030	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 6006 :     stbi__rewind(s);

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6007 :     return r;

  0003e	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]

; 6008 : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
?stbi__psd_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__psd_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tga_image_type$ = 32
sz$ = 36
tga_colormap_bpp$ = 40
tga_bits_per_pixel$ = 44
tga_comp$ = 48
tga_colormap_type$ = 52
tv153 = 56
tga_w$ = 60
tga_h$ = 64
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__tga_info

; 5678 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5679 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5680 :     int sz, tga_colormap_type;
; 5681 :     stbi__get8(s);                   // discard Offset

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 5682 :     tga_colormap_type = stbi__get8(s); // colormap type

  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00027	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	89 44 24 34	 mov	 DWORD PTR tga_colormap_type$[rsp], eax

; 5683 :     if( tga_colormap_type > 1 ) {

  00033	83 7c 24 34 01	 cmp	 DWORD PTR tga_colormap_type$[rsp], 1
  00038	7e 11		 jle	 SHORT $LN2@stbi__tga_

; 5684 :         stbi__rewind(s);

  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5685 :         return 0;      // only RGB or indexed allowed

  00044	33 c0		 xor	 eax, eax
  00046	e9 14 02 00 00	 jmp	 $LN1@stbi__tga_
$LN2@stbi__tga_:

; 5686 :     }
; 5687 :     tga_image_type = stbi__get8(s); // image type

  0004b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00055	0f b6 c0	 movzx	 eax, al
  00058	89 44 24 20	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5688 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image

  0005c	83 7c 24 34 01	 cmp	 DWORD PTR tga_colormap_type$[rsp], 1
  00061	0f 85 8c 00 00
	00		 jne	 $LN3@stbi__tga_

; 5689 :         if (tga_image_type != 1 && tga_image_type != 9) {

  00067	83 7c 24 20 01	 cmp	 DWORD PTR tga_image_type$[rsp], 1
  0006c	74 18		 je	 SHORT $LN5@stbi__tga_
  0006e	83 7c 24 20 09	 cmp	 DWORD PTR tga_image_type$[rsp], 9
  00073	74 11		 je	 SHORT $LN5@stbi__tga_

; 5690 :             stbi__rewind(s);

  00075	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5691 :             return 0;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 d9 01 00 00	 jmp	 $LN1@stbi__tga_
$LN5@stbi__tga_:

; 5692 :         }
; 5693 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries

  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5694 :         sz = stbi__get8(s);    //   check bits per palette color entry

  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0009f	0f b6 c0	 movzx	 eax, al
  000a2	89 44 24 24	 mov	 DWORD PTR sz$[rsp], eax

; 5695 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {

  000a6	83 7c 24 24 08	 cmp	 DWORD PTR sz$[rsp], 8
  000ab	74 2d		 je	 SHORT $LN6@stbi__tga_
  000ad	83 7c 24 24 0f	 cmp	 DWORD PTR sz$[rsp], 15
  000b2	74 26		 je	 SHORT $LN6@stbi__tga_
  000b4	83 7c 24 24 10	 cmp	 DWORD PTR sz$[rsp], 16
  000b9	74 1f		 je	 SHORT $LN6@stbi__tga_
  000bb	83 7c 24 24 18	 cmp	 DWORD PTR sz$[rsp], 24
  000c0	74 18		 je	 SHORT $LN6@stbi__tga_
  000c2	83 7c 24 24 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  000c7	74 11		 je	 SHORT $LN6@stbi__tga_

; 5696 :             stbi__rewind(s);

  000c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ce	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5697 :             return 0;

  000d3	33 c0		 xor	 eax, eax
  000d5	e9 85 01 00 00	 jmp	 $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5698 :         }
; 5699 :         stbi__skip(s,4);       // skip image x and y origin

  000da	ba 04 00 00 00	 mov	 edx, 4
  000df	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5700 :         tga_colormap_bpp = sz;

  000e9	8b 44 24 24	 mov	 eax, DWORD PTR sz$[rsp]
  000ed	89 44 24 28	 mov	 DWORD PTR tga_colormap_bpp$[rsp], eax

; 5701 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE

  000f1	eb 44		 jmp	 SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5702 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {

  000f3	83 7c 24 20 02	 cmp	 DWORD PTR tga_image_type$[rsp], 2
  000f8	74 26		 je	 SHORT $LN7@stbi__tga_
  000fa	83 7c 24 20 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  000ff	74 1f		 je	 SHORT $LN7@stbi__tga_
  00101	83 7c 24 20 0a	 cmp	 DWORD PTR tga_image_type$[rsp], 10
  00106	74 18		 je	 SHORT $LN7@stbi__tga_
  00108	83 7c 24 20 0b	 cmp	 DWORD PTR tga_image_type$[rsp], 11
  0010d	74 11		 je	 SHORT $LN7@stbi__tga_

; 5703 :             stbi__rewind(s);

  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5704 :             return 0; // only RGB or grey allowed, +/- RLE

  00119	33 c0		 xor	 eax, eax
  0011b	e9 3f 01 00 00	 jmp	 $LN1@stbi__tga_
$LN7@stbi__tga_:

; 5705 :         }
; 5706 :         stbi__skip(s,9); // skip colormap specification and image x/y origin

  00120	ba 09 00 00 00	 mov	 edx, 9
  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5707 :         tga_colormap_bpp = 0;

  0012f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tga_colormap_bpp$[rsp], 0
$LN4@stbi__tga_:

; 5708 :     }
; 5709 :     tga_w = stbi__get16le(s);

  00137	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0013c	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00141	89 44 24 3c	 mov	 DWORD PTR tga_w$[rsp], eax

; 5710 :     if( tga_w < 1 ) {

  00145	83 7c 24 3c 01	 cmp	 DWORD PTR tga_w$[rsp], 1
  0014a	7d 11		 jge	 SHORT $LN8@stbi__tga_

; 5711 :         stbi__rewind(s);

  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00151	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5712 :         return 0;   // test width

  00156	33 c0		 xor	 eax, eax
  00158	e9 02 01 00 00	 jmp	 $LN1@stbi__tga_
$LN8@stbi__tga_:

; 5713 :     }
; 5714 :     tga_h = stbi__get16le(s);

  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00162	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00167	89 44 24 40	 mov	 DWORD PTR tga_h$[rsp], eax

; 5715 :     if( tga_h < 1 ) {

  0016b	83 7c 24 40 01	 cmp	 DWORD PTR tga_h$[rsp], 1
  00170	7d 11		 jge	 SHORT $LN9@stbi__tga_

; 5716 :         stbi__rewind(s);

  00172	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00177	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5717 :         return 0;   // test height

  0017c	33 c0		 xor	 eax, eax
  0017e	e9 dc 00 00 00	 jmp	 $LN1@stbi__tga_
$LN9@stbi__tga_:

; 5718 :     }
; 5719 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel

  00183	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00188	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0018d	0f b6 c0	 movzx	 eax, al
  00190	89 44 24 2c	 mov	 DWORD PTR tga_bits_per_pixel$[rsp], eax

; 5720 :     stbi__get8(s); // ignore alpha bits

  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00199	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 5721 :     if (tga_colormap_bpp != 0) {

  0019e	83 7c 24 28 00	 cmp	 DWORD PTR tga_colormap_bpp$[rsp], 0
  001a3	74 33		 je	 SHORT $LN10@stbi__tga_

; 5722 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {

  001a5	83 7c 24 2c 08	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 8
  001aa	74 18		 je	 SHORT $LN12@stbi__tga_
  001ac	83 7c 24 2c 10	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 16
  001b1	74 11		 je	 SHORT $LN12@stbi__tga_

; 5723 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5724 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5725 :             stbi__rewind(s);

  001b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001b8	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5726 :             return 0;

  001bd	33 c0		 xor	 eax, eax
  001bf	e9 9b 00 00 00	 jmp	 $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5727 :         }
; 5728 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);

  001c4	45 33 c0	 xor	 r8d, r8d
  001c7	33 d2		 xor	 edx, edx
  001c9	8b 4c 24 28	 mov	 ecx, DWORD PTR tga_colormap_bpp$[rsp]
  001cd	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  001d2	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax

; 5729 :     } else {

  001d6	eb 34		 jmp	 SHORT $LN11@stbi__tga_
$LN10@stbi__tga_:

; 5730 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);

  001d8	83 7c 24 20 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  001dd	74 11		 je	 SHORT $LN18@stbi__tga_
  001df	83 7c 24 20 0b	 cmp	 DWORD PTR tga_image_type$[rsp], 11
  001e4	74 0a		 je	 SHORT $LN18@stbi__tga_
  001e6	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
  001ee	eb 08		 jmp	 SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
  001f0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
$LN19@stbi__tga_:
  001f8	45 33 c0	 xor	 r8d, r8d
  001fb	8b 54 24 38	 mov	 edx, DWORD PTR tv153[rsp]
  001ff	8b 4c 24 2c	 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rsp]
  00203	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  00208	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax
$LN11@stbi__tga_:

; 5731 :     }
; 5732 :     if(!tga_comp) {

  0020c	83 7c 24 30 00	 cmp	 DWORD PTR tga_comp$[rsp], 0
  00211	75 0e		 jne	 SHORT $LN13@stbi__tga_

; 5733 :         stbi__rewind(s);

  00213	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00218	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5734 :         return 0;

  0021d	33 c0		 xor	 eax, eax
  0021f	eb 3e		 jmp	 SHORT $LN1@stbi__tga_
$LN13@stbi__tga_:

; 5735 :     }
; 5736 :     if (x) *x = tga_w;

  00221	48 83 7c 24 68
	00		 cmp	 QWORD PTR x$[rsp], 0
  00227	74 0b		 je	 SHORT $LN14@stbi__tga_
  00229	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  0022e	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_w$[rsp]
  00232	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@stbi__tga_:

; 5737 :     if (y) *y = tga_h;

  00234	48 83 7c 24 70
	00		 cmp	 QWORD PTR y$[rsp], 0
  0023a	74 0b		 je	 SHORT $LN15@stbi__tga_
  0023c	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00241	8b 4c 24 40	 mov	 ecx, DWORD PTR tga_h$[rsp]
  00245	89 08		 mov	 DWORD PTR [rax], ecx
$LN15@stbi__tga_:

; 5738 :     if (comp) *comp = tga_comp;

  00247	48 83 7c 24 78
	00		 cmp	 QWORD PTR comp$[rsp], 0
  0024d	74 0b		 je	 SHORT $LN16@stbi__tga_
  0024f	48 8b 44 24 78	 mov	 rax, QWORD PTR comp$[rsp]
  00254	8b 4c 24 30	 mov	 ecx, DWORD PTR tga_comp$[rsp]
  00258	89 08		 mov	 DWORD PTR [rax], ecx
$LN16@stbi__tga_:

; 5739 :     return 1;                   // seems to have passed everything

  0025a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__tga_:

; 5740 : }

  0025f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00263	c3		 ret	 0
?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__tga_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tga_comp$ = 48
j$ = 52
i$ = 56
tga_width$ = 60
tga_height$ = 64
temp$1 = 68
temp$2 = 69
tga_palette_len$ = 72
tga_data$ = 80
tga_rgb16$ = 88
pal_idx$3 = 92
read_next_pixel$ = 96
tga_image_type$ = 100
tga_indexed$ = 104
raw_data$ = 108
RLE_count$ = 112
tga_inverted$ = 116
index1$4 = 120
index2$5 = 124
tga_palette$ = 128
tga_is_RLE$ = 136
tga_palette_bits$ = 140
tga_pixel$6 = 144
tv162 = 152
tv174 = 156
tv185 = 160
tv197 = 164
tv212 = 168
tv225 = 172
tv247 = 176
RLE_cmd$7 = 180
RLE_repeating$ = 184
tga_bits_per_pixel$ = 188
tv301 = 192
tga_y_origin$ = 196
tga_x_origin$ = 200
tga_palette_start$ = 204
tv134 = 208
tv140 = 212
tv155 = 216
row$8 = 220
tga_offset$ = 224
pal_entry$9 = 232
tga_row$10 = 240
s$ = 272
x$ = 280
y$ = 288
comp$ = 296
req_comp$ = 304
ri$ = 312
?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__tga_load

; 5794 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H

; 5795 :     //   read in the TGA header stuff
; 5796 :     int tga_offset = stbi__get8(s);

  0001c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00029	0f b6 c0	 movzx	 eax, al
  0002c	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tga_offset$[rsp], eax

; 5797 :     int tga_indexed = stbi__get8(s);

  00033	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00040	0f b6 c0	 movzx	 eax, al
  00043	89 44 24 68	 mov	 DWORD PTR tga_indexed$[rsp], eax

; 5798 :     int tga_image_type = stbi__get8(s);

  00047	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00054	0f b6 c0	 movzx	 eax, al
  00057	89 44 24 64	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5799 :     int tga_is_RLE = 0;

  0005b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tga_is_RLE$[rsp], 0

; 5800 :     int tga_palette_start = stbi__get16le(s);

  00066	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00073	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tga_palette_start$[rsp], eax

; 5801 :     int tga_palette_len = stbi__get16le(s);

  0007a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00082	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00087	89 44 24 48	 mov	 DWORD PTR tga_palette_len$[rsp], eax

; 5802 :     int tga_palette_bits = stbi__get8(s);

  0008b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00093	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00098	0f b6 c0	 movzx	 eax, al
  0009b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tga_palette_bits$[rsp], eax

; 5803 :     int tga_x_origin = stbi__get16le(s);

  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000aa	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000af	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tga_x_origin$[rsp], eax

; 5804 :     int tga_y_origin = stbi__get16le(s);

  000b6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000be	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000c3	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tga_y_origin$[rsp], eax

; 5805 :     int tga_width = stbi__get16le(s);

  000ca	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000d2	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000d7	89 44 24 3c	 mov	 DWORD PTR tga_width$[rsp], eax

; 5806 :     int tga_height = stbi__get16le(s);

  000db	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e3	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000e8	89 44 24 40	 mov	 DWORD PTR tga_height$[rsp], eax

; 5807 :     int tga_bits_per_pixel = stbi__get8(s);

  000ec	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000f9	0f b6 c0	 movzx	 eax, al
  000fc	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tga_bits_per_pixel$[rsp], eax

; 5808 :     int tga_comp, tga_rgb16=0;

  00103	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tga_rgb16$[rsp], 0

; 5809 :     int tga_inverted = stbi__get8(s);

  0010b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00113	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00118	0f b6 c0	 movzx	 eax, al
  0011b	89 44 24 74	 mov	 DWORD PTR tga_inverted$[rsp], eax

; 5810 :     // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5811 :     //   image data
; 5812 :     unsigned char *tga_data;
; 5813 :     unsigned char *tga_palette = NULL;

  0011f	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tga_palette$[rsp], 0

; 5814 :     int i, j;
; 5815 :     unsigned char raw_data[4] = {0};

  0012b	48 8d 44 24 6c	 lea	 rax, QWORD PTR raw_data$[rsp]
  00130	48 8b f8	 mov	 rdi, rax
  00133	33 c0		 xor	 eax, eax
  00135	b9 04 00 00 00	 mov	 ecx, 4
  0013a	f3 aa		 rep stosb

; 5816 :     int RLE_count = 0;

  0013c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR RLE_count$[rsp], 0

; 5817 :     int RLE_repeating = 0;

  00144	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR RLE_repeating$[rsp], 0

; 5818 :     int read_next_pixel = 1;

  0014f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1

; 5819 :     STBI_NOTUSED(ri);
; 5820 :     STBI_NOTUSED(tga_x_origin); // @TODO
; 5821 :     STBI_NOTUSED(tga_y_origin); // @TODO
; 5822 :     
; 5823 :     if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00157	81 7c 24 40 00
	00 00 01	 cmp	 DWORD PTR tga_height$[rsp], 16777216 ; 01000000H
  0015f	7e 35		 jle	 SHORT $LN29@stbi__tga_
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39972
  00168	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0016d	85 c0		 test	 eax, eax
  0016f	74 0d		 je	 SHORT $LN64@stbi__tga_
  00171	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv134[rsp], 0
  0017c	eb 0b		 jmp	 SHORT $LN65@stbi__tga_
$LN64@stbi__tga_:
  0017e	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv134[rsp], 0
$LN65@stbi__tga_:
  00189	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR tv134[rsp]
  00191	e9 b4 08 00 00	 jmp	 $LN1@stbi__tga_
$LN29@stbi__tga_:

; 5824 :     if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00196	81 7c 24 3c 00
	00 00 01	 cmp	 DWORD PTR tga_width$[rsp], 16777216 ; 01000000H
  0019e	7e 35		 jle	 SHORT $LN30@stbi__tga_
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39974
  001a7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001ac	85 c0		 test	 eax, eax
  001ae	74 0d		 je	 SHORT $LN66@stbi__tga_
  001b0	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
  001bb	eb 0b		 jmp	 SHORT $LN67@stbi__tga_
$LN66@stbi__tga_:
  001bd	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
$LN67@stbi__tga_:
  001c8	48 63 84 24 d4
	00 00 00	 movsxd	 rax, DWORD PTR tv140[rsp]
  001d0	e9 75 08 00 00	 jmp	 $LN1@stbi__tga_
$LN30@stbi__tga_:

; 5825 :     
; 5826 :     //   do a tiny bit of precessing
; 5827 :     if ( tga_image_type >= 8 )

  001d5	83 7c 24 64 08	 cmp	 DWORD PTR tga_image_type$[rsp], 8
  001da	7c 16		 jl	 SHORT $LN31@stbi__tga_

; 5828 :     {
; 5829 :         tga_image_type -= 8;

  001dc	8b 44 24 64	 mov	 eax, DWORD PTR tga_image_type$[rsp]
  001e0	83 e8 08	 sub	 eax, 8
  001e3	89 44 24 64	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5830 :         tga_is_RLE = 1;

  001e7	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tga_is_RLE$[rsp], 1
$LN31@stbi__tga_:

; 5831 :     }
; 5832 :     tga_inverted = 1 - ((tga_inverted >> 5) & 1);

  001f2	8b 44 24 74	 mov	 eax, DWORD PTR tga_inverted$[rsp]
  001f6	c1 f8 05	 sar	 eax, 5
  001f9	83 e0 01	 and	 eax, 1
  001fc	b9 01 00 00 00	 mov	 ecx, 1
  00201	2b c8		 sub	 ecx, eax
  00203	8b c1		 mov	 eax, ecx
  00205	89 44 24 74	 mov	 DWORD PTR tga_inverted$[rsp], eax

; 5833 :     
; 5834 :     //   If I'm paletted, then I'll use the number of bits from the palette
; 5835 :     if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

  00209	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  0020e	74 19		 je	 SHORT $LN32@stbi__tga_
  00210	4c 8d 44 24 58	 lea	 r8, QWORD PTR tga_rgb16$[rsp]
  00215	33 d2		 xor	 edx, edx
  00217	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tga_palette_bits$[rsp]
  0021e	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  00223	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax
  00227	eb 3b		 jmp	 SHORT $LN33@stbi__tga_
$LN32@stbi__tga_:

; 5836 :     else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

  00229	83 7c 24 64 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  0022e	75 0d		 jne	 SHORT $LN68@stbi__tga_
  00230	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv155[rsp], 1
  0023b	eb 0b		 jmp	 SHORT $LN69@stbi__tga_
$LN68@stbi__tga_:
  0023d	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN69@stbi__tga_:
  00248	4c 8d 44 24 58	 lea	 r8, QWORD PTR tga_rgb16$[rsp]
  0024d	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR tv155[rsp]
  00254	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rsp]
  0025b	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  00260	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax
$LN33@stbi__tga_:

; 5837 :     
; 5838 :     if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

  00264	83 7c 24 30 00	 cmp	 DWORD PTR tga_comp$[rsp], 0
  00269	75 35		 jne	 SHORT $LN34@stbi__tga_

; 5839 :         return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

  0026b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39979
  00272	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00277	85 c0		 test	 eax, eax
  00279	74 0d		 je	 SHORT $LN70@stbi__tga_
  0027b	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
  00286	eb 0b		 jmp	 SHORT $LN71@stbi__tga_
$LN70@stbi__tga_:
  00288	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN71@stbi__tga_:
  00293	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv162[rsp]
  0029b	e9 aa 07 00 00	 jmp	 $LN1@stbi__tga_
$LN34@stbi__tga_:

; 5840 :     
; 5841 :     //   tga info
; 5842 :     *x = tga_width;

  002a0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  002a8	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_width$[rsp]
  002ac	89 08		 mov	 DWORD PTR [rax], ecx

; 5843 :     *y = tga_height;

  002ae	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  002b6	8b 4c 24 40	 mov	 ecx, DWORD PTR tga_height$[rsp]
  002ba	89 08		 mov	 DWORD PTR [rax], ecx

; 5844 :     if (comp) *comp = tga_comp;

  002bc	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  002c5	74 0e		 je	 SHORT $LN35@stbi__tga_
  002c7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  002cf	8b 4c 24 30	 mov	 ecx, DWORD PTR tga_comp$[rsp]
  002d3	89 08		 mov	 DWORD PTR [rax], ecx
$LN35@stbi__tga_:

; 5845 :     
; 5846 :     if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))

  002d5	45 33 c9	 xor	 r9d, r9d
  002d8	44 8b 44 24 30	 mov	 r8d, DWORD PTR tga_comp$[rsp]
  002dd	8b 54 24 40	 mov	 edx, DWORD PTR tga_height$[rsp]
  002e1	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_width$[rsp]
  002e5	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  002ea	85 c0		 test	 eax, eax
  002ec	75 35		 jne	 SHORT $LN36@stbi__tga_

; 5847 :         return stbi__errpuc("too large", "Corrupt TGA");

  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39982
  002f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002fa	85 c0		 test	 eax, eax
  002fc	74 0d		 je	 SHORT $LN72@stbi__tga_
  002fe	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
  00309	eb 0b		 jmp	 SHORT $LN73@stbi__tga_
$LN72@stbi__tga_:
  0030b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN73@stbi__tga_:
  00316	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  0031e	e9 27 07 00 00	 jmp	 $LN1@stbi__tga_
$LN36@stbi__tga_:

; 5848 :     
; 5849 :     tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);

  00323	45 33 c9	 xor	 r9d, r9d
  00326	44 8b 44 24 30	 mov	 r8d, DWORD PTR tga_comp$[rsp]
  0032b	8b 54 24 40	 mov	 edx, DWORD PTR tga_height$[rsp]
  0032f	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_width$[rsp]
  00333	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00338	48 89 44 24 50	 mov	 QWORD PTR tga_data$[rsp], rax

; 5850 :     if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

  0033d	48 83 7c 24 50
	00		 cmp	 QWORD PTR tga_data$[rsp], 0
  00343	75 35		 jne	 SHORT $LN37@stbi__tga_
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39984
  0034c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00351	85 c0		 test	 eax, eax
  00353	74 0d		 je	 SHORT $LN74@stbi__tga_
  00355	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
  00360	eb 0b		 jmp	 SHORT $LN75@stbi__tga_
$LN74@stbi__tga_:
  00362	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN75@stbi__tga_:
  0036d	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv185[rsp]
  00375	e9 d0 06 00 00	 jmp	 $LN1@stbi__tga_
$LN37@stbi__tga_:

; 5851 :     
; 5852 :     // skip to the data's starting position (offset usually = 0)
; 5853 :     stbi__skip(s, tga_offset );

  0037a	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR tga_offset$[rsp]
  00381	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00389	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5854 :     
; 5855 :     if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {

  0038e	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  00393	0f 85 c3 00 00
	00		 jne	 $LN38@stbi__tga_
  00399	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tga_is_RLE$[rsp], 0
  003a1	0f 85 b5 00 00
	00		 jne	 $LN38@stbi__tga_
  003a7	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  003ac	0f 85 aa 00 00
	00		 jne	 $LN38@stbi__tga_

; 5856 :         for (i=0; i < tga_height; ++i) {

  003b2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003ba	eb 0a		 jmp	 SHORT $LN4@stbi__tga_
$LN2@stbi__tga_:
  003bc	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003c0	ff c0		 inc	 eax
  003c2	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__tga_:
  003c6	8b 44 24 40	 mov	 eax, DWORD PTR tga_height$[rsp]
  003ca	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  003ce	0f 8d 83 00 00
	00		 jge	 $LN3@stbi__tga_

; 5857 :             int row = tga_inverted ? tga_height -i - 1 : i;

  003d4	83 7c 24 74 00	 cmp	 DWORD PTR tga_inverted$[rsp], 0
  003d9	74 17		 je	 SHORT $LN76@stbi__tga_
  003db	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003df	8b 4c 24 40	 mov	 ecx, DWORD PTR tga_height$[rsp]
  003e3	2b c8		 sub	 ecx, eax
  003e5	8b c1		 mov	 eax, ecx
  003e7	ff c8		 dec	 eax
  003e9	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
  003f0	eb 0b		 jmp	 SHORT $LN77@stbi__tga_
$LN76@stbi__tga_:
  003f2	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003f6	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
$LN77@stbi__tga_:
  003fd	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  00404	89 84 24 dc 00
	00 00		 mov	 DWORD PTR row$8[rsp], eax

; 5858 :             stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;

  0040b	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR row$8[rsp]
  00412	0f af 44 24 3c	 imul	 eax, DWORD PTR tga_width$[rsp]
  00417	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0041c	48 98		 cdqe
  0041e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00423	48 03 c8	 add	 rcx, rax
  00426	48 8b c1	 mov	 rax, rcx
  00429	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tga_row$10[rsp], rax

; 5859 :             stbi__getn(s, tga_row, tga_width * tga_comp);

  00431	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  00435	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0043a	44 8b c0	 mov	 r8d, eax
  0043d	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR tga_row$10[rsp]
  00445	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0044d	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 5860 :         }

  00452	e9 65 ff ff ff	 jmp	 $LN2@stbi__tga_
$LN3@stbi__tga_:

; 5861 :     } else  {

  00457	e9 ac 04 00 00	 jmp	 $LN39@stbi__tga_
$LN38@stbi__tga_:

; 5862 :         //   do I need to load a palette?
; 5863 :         if ( tga_indexed)

  0045c	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  00461	0f 84 a8 01 00
	00		 je	 $LN40@stbi__tga_

; 5864 :         {
; 5865 :             if (tga_palette_len == 0) {  /* you have to have at least one entry! */

  00467	83 7c 24 48 00	 cmp	 DWORD PTR tga_palette_len$[rsp], 0
  0046c	75 3f		 jne	 SHORT $LN41@stbi__tga_

; 5866 :                 STBI_FREE(tga_data);

  0046e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00473	e8 00 00 00 00	 call	 free

; 5867 :                 return stbi__errpuc("bad palette", "Corrupt TGA");

  00478	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39989
  0047f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00484	85 c0		 test	 eax, eax
  00486	74 0d		 je	 SHORT $LN78@stbi__tga_
  00488	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
  00493	eb 0b		 jmp	 SHORT $LN79@stbi__tga_
$LN78@stbi__tga_:
  00495	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN79@stbi__tga_:
  004a0	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv212[rsp]
  004a8	e9 9d 05 00 00	 jmp	 $LN1@stbi__tga_
$LN41@stbi__tga_:

; 5868 :             }
; 5869 :             
; 5870 :             //   any data to skip? (offset usually = 0)
; 5871 :             stbi__skip(s, tga_palette_start );

  004ad	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR tga_palette_start$[rsp]
  004b4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004bc	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5872 :             //   load the palette
; 5873 :             tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);

  004c1	45 33 c0	 xor	 r8d, r8d
  004c4	8b 54 24 30	 mov	 edx, DWORD PTR tga_comp$[rsp]
  004c8	8b 4c 24 48	 mov	 ecx, DWORD PTR tga_palette_len$[rsp]
  004cc	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  004d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tga_palette$[rsp], rax

; 5874 :             if (!tga_palette) {

  004d9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tga_palette$[rsp], 0
  004e2	75 3f		 jne	 SHORT $LN42@stbi__tga_

; 5875 :                 STBI_FREE(tga_data);

  004e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  004e9	e8 00 00 00 00	 call	 free

; 5876 :                 return stbi__errpuc("outofmem", "Out of memory");

  004ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39991
  004f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004fa	85 c0		 test	 eax, eax
  004fc	74 0d		 je	 SHORT $LN80@stbi__tga_
  004fe	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv225[rsp], 0
  00509	eb 0b		 jmp	 SHORT $LN81@stbi__tga_
$LN80@stbi__tga_:
  0050b	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv225[rsp], 0
$LN81@stbi__tga_:
  00516	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR tv225[rsp]
  0051e	e9 27 05 00 00	 jmp	 $LN1@stbi__tga_
$LN42@stbi__tga_:

; 5877 :             }
; 5878 :             if (tga_rgb16) {

  00523	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  00528	74 74		 je	 SHORT $LN43@stbi__tga_

; 5879 :                 stbi_uc *pal_entry = tga_palette;

  0052a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tga_palette$[rsp]
  00532	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pal_entry$9[rsp], rax

; 5880 :                 STBI_ASSERT(tga_comp == STBI_rgb);

  0053a	83 7c 24 30 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  0053f	74 0b		 je	 SHORT $LN45@stbi__tga_
  00541	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN45@stbi__tga_:

; 5881 :                 for (i=0; i < tga_palette_len; ++i) {

  0054c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00554	eb 0a		 jmp	 SHORT $LN7@stbi__tga_
$LN5@stbi__tga_:
  00556	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0055a	ff c0		 inc	 eax
  0055c	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__tga_:
  00560	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00564	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00568	7d 32		 jge	 SHORT $LN6@stbi__tga_

; 5882 :                     stbi__tga_read_rgb16(s, pal_entry);

  0056a	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pal_entry$9[rsp]
  00572	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0057a	e8 00 00 00 00	 call	 ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ; stbi__tga_read_rgb16

; 5883 :                     pal_entry += tga_comp;

  0057f	48 63 44 24 30	 movsxd	 rax, DWORD PTR tga_comp$[rsp]
  00584	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pal_entry$9[rsp]
  0058c	48 03 c8	 add	 rcx, rax
  0058f	48 8b c1	 mov	 rax, rcx
  00592	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pal_entry$9[rsp], rax

; 5884 :                 }

  0059a	eb ba		 jmp	 SHORT $LN5@stbi__tga_
$LN6@stbi__tga_:

; 5885 :             } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

  0059c	eb 71		 jmp	 SHORT $LN44@stbi__tga_
$LN43@stbi__tga_:
  0059e	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  005a2	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  005a7	44 8b c0	 mov	 r8d, eax
  005aa	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tga_palette$[rsp]
  005b2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ba	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
  005bf	85 c0		 test	 eax, eax
  005c1	75 4c		 jne	 SHORT $LN46@stbi__tga_

; 5886 :                 STBI_FREE(tga_data);

  005c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  005c8	e8 00 00 00 00	 call	 free

; 5887 :                 STBI_FREE(tga_palette);

  005cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tga_palette$[rsp]
  005d5	e8 00 00 00 00	 call	 free

; 5888 :                 return stbi__errpuc("bad palette", "Corrupt TGA");

  005da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39996
  005e1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005e6	85 c0		 test	 eax, eax
  005e8	74 0d		 je	 SHORT $LN82@stbi__tga_
  005ea	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv247[rsp], 0
  005f5	eb 0b		 jmp	 SHORT $LN83@stbi__tga_
$LN82@stbi__tga_:
  005f7	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv247[rsp], 0
$LN83@stbi__tga_:
  00602	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv247[rsp]
  0060a	e9 3b 04 00 00	 jmp	 $LN1@stbi__tga_
$LN46@stbi__tga_:
$LN44@stbi__tga_:
$LN40@stbi__tga_:

; 5889 :             }
; 5890 :         }
; 5891 :         //   load the data
; 5892 :         for (i=0; i < tga_width * tga_height; ++i)

  0060f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00617	eb 0a		 jmp	 SHORT $LN10@stbi__tga_
$LN8@stbi__tga_:
  00619	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0061d	ff c0		 inc	 eax
  0061f	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__tga_:
  00623	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  00627	0f af 44 24 40	 imul	 eax, DWORD PTR tga_height$[rsp]
  0062c	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00630	0f 8d e7 01 00
	00		 jge	 $LN9@stbi__tga_

; 5893 :         {
; 5894 :             //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5895 :             if ( tga_is_RLE )

  00636	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tga_is_RLE$[rsp], 0
  0063e	74 5d		 je	 SHORT $LN47@stbi__tga_

; 5896 :             {
; 5897 :                 if ( RLE_count == 0 )

  00640	83 7c 24 70 00	 cmp	 DWORD PTR RLE_count$[rsp], 0
  00645	75 42		 jne	 SHORT $LN49@stbi__tga_

; 5898 :                 {
; 5899 :                     //   yep, get the next byte as a RLE command
; 5900 :                     int RLE_cmd = stbi__get8(s);

  00647	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0064f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00654	0f b6 c0	 movzx	 eax, al
  00657	89 84 24 b4 00
	00 00		 mov	 DWORD PTR RLE_cmd$7[rsp], eax

; 5901 :                     RLE_count = 1 + (RLE_cmd & 127);

  0065e	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR RLE_cmd$7[rsp]
  00665	83 e0 7f	 and	 eax, 127		; 0000007fH
  00668	ff c0		 inc	 eax
  0066a	89 44 24 70	 mov	 DWORD PTR RLE_count$[rsp], eax

; 5902 :                     RLE_repeating = RLE_cmd >> 7;

  0066e	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR RLE_cmd$7[rsp]
  00675	c1 f8 07	 sar	 eax, 7
  00678	89 84 24 b8 00
	00 00		 mov	 DWORD PTR RLE_repeating$[rsp], eax

; 5903 :                     read_next_pixel = 1;

  0067f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1
  00687	eb 12		 jmp	 SHORT $LN50@stbi__tga_
$LN49@stbi__tga_:

; 5904 :                 } else if ( !RLE_repeating )

  00689	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR RLE_repeating$[rsp], 0
  00691	75 08		 jne	 SHORT $LN51@stbi__tga_

; 5905 :                 {
; 5906 :                     read_next_pixel = 1;

  00693	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1
$LN51@stbi__tga_:
$LN50@stbi__tga_:

; 5907 :                 }
; 5908 :             } else

  0069b	eb 08		 jmp	 SHORT $LN48@stbi__tga_
$LN47@stbi__tga_:

; 5909 :             {
; 5910 :                 read_next_pixel = 1;

  0069d	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1
$LN48@stbi__tga_:

; 5911 :             }
; 5912 :             //   OK, if I need to read a pixel, do it now
; 5913 :             if ( read_next_pixel )

  006a5	83 7c 24 60 00	 cmp	 DWORD PTR read_next_pixel$[rsp], 0
  006aa	0f 84 1c 01 00
	00		 je	 $LN52@stbi__tga_

; 5914 :             {
; 5915 :                 //   load however much data we did have
; 5916 :                 if ( tga_indexed )

  006b0	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  006b5	0f 84 a6 00 00
	00		 je	 $LN53@stbi__tga_

; 5917 :                 {
; 5918 :                     // read in index, then perform the lookup
; 5919 :                     int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

  006bb	83 bc 24 bc 00
	00 00 08	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 8
  006c3	75 19		 jne	 SHORT $LN84@stbi__tga_
  006c5	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006cd	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  006d2	0f b6 c0	 movzx	 eax, al
  006d5	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv301[rsp], eax
  006dc	eb 14		 jmp	 SHORT $LN85@stbi__tga_
$LN84@stbi__tga_:
  006de	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006e6	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  006eb	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv301[rsp], eax
$LN85@stbi__tga_:
  006f2	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv301[rsp]
  006f9	89 44 24 5c	 mov	 DWORD PTR pal_idx$3[rsp], eax

; 5920 :                     if ( pal_idx >= tga_palette_len ) {

  006fd	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00701	39 44 24 5c	 cmp	 DWORD PTR pal_idx$3[rsp], eax
  00705	7c 08		 jl	 SHORT $LN55@stbi__tga_

; 5921 :                         // invalid index
; 5922 :                         pal_idx = 0;

  00707	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR pal_idx$3[rsp], 0
$LN55@stbi__tga_:

; 5923 :                     }
; 5924 :                     pal_idx *= tga_comp;

  0070f	8b 44 24 5c	 mov	 eax, DWORD PTR pal_idx$3[rsp]
  00713	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  00718	89 44 24 5c	 mov	 DWORD PTR pal_idx$3[rsp], eax

; 5925 :                     for (j = 0; j < tga_comp; ++j) {

  0071c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00724	eb 0a		 jmp	 SHORT $LN13@stbi__tga_
$LN11@stbi__tga_:
  00726	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  0072a	ff c0		 inc	 eax
  0072c	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN13@stbi__tga_:
  00730	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  00734	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  00738	7d 25		 jge	 SHORT $LN12@stbi__tga_

; 5926 :                         raw_data[j] = tga_palette[pal_idx+j];

  0073a	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  0073e	8b 4c 24 5c	 mov	 ecx, DWORD PTR pal_idx$3[rsp]
  00742	03 c8		 add	 ecx, eax
  00744	8b c1		 mov	 eax, ecx
  00746	48 98		 cdqe
  00748	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  0074d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tga_palette$[rsp]
  00755	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00759	88 44 0c 6c	 mov	 BYTE PTR raw_data$[rsp+rcx], al

; 5927 :                     }

  0075d	eb c7		 jmp	 SHORT $LN11@stbi__tga_
$LN12@stbi__tga_:

; 5928 :                 } else if(tga_rgb16) {

  0075f	eb 63		 jmp	 SHORT $LN54@stbi__tga_
$LN53@stbi__tga_:
  00761	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  00766	74 26		 je	 SHORT $LN56@stbi__tga_

; 5929 :                     STBI_ASSERT(tga_comp == STBI_rgb);

  00768	83 7c 24 30 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  0076d	74 0b		 je	 SHORT $LN58@stbi__tga_
  0076f	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN58@stbi__tga_:

; 5930 :                     stbi__tga_read_rgb16(s, raw_data);

  0077a	48 8d 54 24 6c	 lea	 rdx, QWORD PTR raw_data$[rsp]
  0077f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00787	e8 00 00 00 00	 call	 ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ; stbi__tga_read_rgb16

; 5931 :                 } else {

  0078c	eb 36		 jmp	 SHORT $LN57@stbi__tga_
$LN56@stbi__tga_:

; 5932 :                     //   read in the data raw
; 5933 :                     for (j = 0; j < tga_comp; ++j) {

  0078e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00796	eb 0a		 jmp	 SHORT $LN16@stbi__tga_
$LN14@stbi__tga_:
  00798	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  0079c	ff c0		 inc	 eax
  0079e	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN16@stbi__tga_:
  007a2	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  007a6	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  007aa	7d 18		 jge	 SHORT $LN15@stbi__tga_

; 5934 :                         raw_data[j] = stbi__get8(s);

  007ac	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007b4	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  007b9	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  007be	88 44 0c 6c	 mov	 BYTE PTR raw_data$[rsp+rcx], al

; 5935 :                     }

  007c2	eb d4		 jmp	 SHORT $LN14@stbi__tga_
$LN15@stbi__tga_:
$LN57@stbi__tga_:
$LN54@stbi__tga_:

; 5936 :                 }
; 5937 :                 //   clear the reading flag for the next pixel
; 5938 :                 read_next_pixel = 0;

  007c4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 0
$LN52@stbi__tga_:

; 5939 :             } // end of reading a pixel
; 5940 :             
; 5941 :             // copy data
; 5942 :             for (j = 0; j < tga_comp; ++j)

  007cc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  007d4	eb 0a		 jmp	 SHORT $LN19@stbi__tga_
$LN17@stbi__tga_:
  007d6	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  007da	ff c0		 inc	 eax
  007dc	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN19@stbi__tga_:
  007e0	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  007e4	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  007e8	7d 24		 jge	 SHORT $LN18@stbi__tga_

; 5943 :                 tga_data[i*tga_comp+j] = raw_data[j];

  007ea	48 63 44 24 34	 movsxd	 rax, DWORD PTR j$[rsp]
  007ef	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  007f3	0f af 4c 24 30	 imul	 ecx, DWORD PTR tga_comp$[rsp]
  007f8	03 4c 24 34	 add	 ecx, DWORD PTR j$[rsp]
  007fc	48 63 c9	 movsxd	 rcx, ecx
  007ff	48 8b 54 24 50	 mov	 rdx, QWORD PTR tga_data$[rsp]
  00804	0f b6 44 04 6c	 movzx	 eax, BYTE PTR raw_data$[rsp+rax]
  00809	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0080c	eb c8		 jmp	 SHORT $LN17@stbi__tga_
$LN18@stbi__tga_:

; 5944 :             
; 5945 :             //   in case we're in RLE mode, keep counting down
; 5946 :             --RLE_count;

  0080e	8b 44 24 70	 mov	 eax, DWORD PTR RLE_count$[rsp]
  00812	ff c8		 dec	 eax
  00814	89 44 24 70	 mov	 DWORD PTR RLE_count$[rsp], eax

; 5947 :         }

  00818	e9 fc fd ff ff	 jmp	 $LN8@stbi__tga_
$LN9@stbi__tga_:

; 5948 :         //   do I need to invert the image?
; 5949 :         if ( tga_inverted )

  0081d	83 7c 24 74 00	 cmp	 DWORD PTR tga_inverted$[rsp], 0
  00822	0f 84 c8 00 00
	00		 je	 $LN59@stbi__tga_

; 5950 :         {
; 5951 :             for (j = 0; j*2 < tga_height; ++j)

  00828	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00830	eb 0a		 jmp	 SHORT $LN22@stbi__tga_
$LN20@stbi__tga_:
  00832	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00836	ff c0		 inc	 eax
  00838	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN22@stbi__tga_:
  0083c	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00840	d1 e0		 shl	 eax, 1
  00842	3b 44 24 40	 cmp	 eax, DWORD PTR tga_height$[rsp]
  00846	0f 8d a4 00 00
	00		 jge	 $LN21@stbi__tga_

; 5952 :             {
; 5953 :                 int index1 = j * tga_width * tga_comp;

  0084c	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00850	0f af 44 24 3c	 imul	 eax, DWORD PTR tga_width$[rsp]
  00855	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0085a	89 44 24 78	 mov	 DWORD PTR index1$4[rsp], eax

; 5954 :                 int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

  0085e	8b 44 24 40	 mov	 eax, DWORD PTR tga_height$[rsp]
  00862	ff c8		 dec	 eax
  00864	2b 44 24 34	 sub	 eax, DWORD PTR j$[rsp]
  00868	0f af 44 24 3c	 imul	 eax, DWORD PTR tga_width$[rsp]
  0086d	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  00872	89 44 24 7c	 mov	 DWORD PTR index2$5[rsp], eax

; 5955 :                 for (i = tga_width * tga_comp; i > 0; --i)

  00876	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  0087a	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0087f	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
  00883	eb 0a		 jmp	 SHORT $LN25@stbi__tga_
$LN23@stbi__tga_:
  00885	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00889	ff c8		 dec	 eax
  0088b	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN25@stbi__tga_:
  0088f	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  00894	7e 55		 jle	 SHORT $LN24@stbi__tga_

; 5956 :                 {
; 5957 :                     unsigned char temp = tga_data[index1];

  00896	48 63 44 24 78	 movsxd	 rax, DWORD PTR index1$4[rsp]
  0089b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  008a0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008a4	88 44 24 45	 mov	 BYTE PTR temp$2[rsp], al

; 5958 :                     tga_data[index1] = tga_data[index2];

  008a8	48 63 44 24 7c	 movsxd	 rax, DWORD PTR index2$5[rsp]
  008ad	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR index1$4[rsp]
  008b2	48 8b 54 24 50	 mov	 rdx, QWORD PTR tga_data$[rsp]
  008b7	48 8b 7c 24 50	 mov	 rdi, QWORD PTR tga_data$[rsp]
  008bc	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  008c0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5959 :                     tga_data[index2] = temp;

  008c3	48 63 44 24 7c	 movsxd	 rax, DWORD PTR index2$5[rsp]
  008c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  008cd	0f b6 54 24 45	 movzx	 edx, BYTE PTR temp$2[rsp]
  008d2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5960 :                     ++index1;

  008d5	8b 44 24 78	 mov	 eax, DWORD PTR index1$4[rsp]
  008d9	ff c0		 inc	 eax
  008db	89 44 24 78	 mov	 DWORD PTR index1$4[rsp], eax

; 5961 :                     ++index2;

  008df	8b 44 24 7c	 mov	 eax, DWORD PTR index2$5[rsp]
  008e3	ff c0		 inc	 eax
  008e5	89 44 24 7c	 mov	 DWORD PTR index2$5[rsp], eax

; 5962 :                 }

  008e9	eb 9a		 jmp	 SHORT $LN23@stbi__tga_
$LN24@stbi__tga_:

; 5963 :             }

  008eb	e9 42 ff ff ff	 jmp	 $LN20@stbi__tga_
$LN21@stbi__tga_:
$LN59@stbi__tga_:

; 5964 :         }
; 5965 :         //   clear my palette, if I had one
; 5966 :         if ( tga_palette != NULL )

  008f0	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tga_palette$[rsp], 0
  008f9	74 0d		 je	 SHORT $LN60@stbi__tga_

; 5967 :         {
; 5968 :             STBI_FREE( tga_palette );

  008fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tga_palette$[rsp]
  00903	e8 00 00 00 00	 call	 free
$LN60@stbi__tga_:
$LN39@stbi__tga_:

; 5969 :         }
; 5970 :     }
; 5971 :     
; 5972 :     // swap RGB - if the source data was RGB16, it already is in the right order
; 5973 :     if (tga_comp >= 3 && !tga_rgb16)

  00908	83 7c 24 30 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  0090d	0f 8c b6 00 00
	00		 jl	 $LN61@stbi__tga_
  00913	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  00918	0f 85 ab 00 00
	00		 jne	 $LN61@stbi__tga_

; 5974 :     {
; 5975 :         unsigned char* tga_pixel = tga_data;

  0091e	48 8b 44 24 50	 mov	 rax, QWORD PTR tga_data$[rsp]
  00923	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tga_pixel$6[rsp], rax

; 5976 :         for (i=0; i < tga_width * tga_height; ++i)

  0092b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00933	eb 0a		 jmp	 SHORT $LN28@stbi__tga_
$LN26@stbi__tga_:
  00935	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00939	ff c0		 inc	 eax
  0093b	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__tga_:
  0093f	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  00943	0f af 44 24 40	 imul	 eax, DWORD PTR tga_height$[rsp]
  00948	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0094c	7d 7b		 jge	 SHORT $LN27@stbi__tga_

; 5977 :         {
; 5978 :             unsigned char temp = tga_pixel[0];

  0094e	b8 01 00 00 00	 mov	 eax, 1
  00953	48 6b c0 00	 imul	 rax, rax, 0
  00957	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$6[rsp]
  0095f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00963	88 44 24 44	 mov	 BYTE PTR temp$1[rsp], al

; 5979 :             tga_pixel[0] = tga_pixel[2];

  00967	b8 01 00 00 00	 mov	 eax, 1
  0096c	48 6b c0 02	 imul	 rax, rax, 2
  00970	b9 01 00 00 00	 mov	 ecx, 1
  00975	48 6b c9 00	 imul	 rcx, rcx, 0
  00979	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tga_pixel$6[rsp]
  00981	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR tga_pixel$6[rsp]
  00989	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  0098d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5980 :             tga_pixel[2] = temp;

  00990	b8 01 00 00 00	 mov	 eax, 1
  00995	48 6b c0 02	 imul	 rax, rax, 2
  00999	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$6[rsp]
  009a1	0f b6 54 24 44	 movzx	 edx, BYTE PTR temp$1[rsp]
  009a6	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5981 :             tga_pixel += tga_comp;

  009a9	48 63 44 24 30	 movsxd	 rax, DWORD PTR tga_comp$[rsp]
  009ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$6[rsp]
  009b6	48 03 c8	 add	 rcx, rax
  009b9	48 8b c1	 mov	 rax, rcx
  009bc	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tga_pixel$6[rsp], rax

; 5982 :         }

  009c4	e9 6c ff ff ff	 jmp	 $LN26@stbi__tga_
$LN27@stbi__tga_:
$LN61@stbi__tga_:

; 5983 :     }
; 5984 :     
; 5985 :     // convert to target component count
; 5986 :     if (req_comp && req_comp != tga_comp)

  009c9	83 bc 24 30 01
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  009d1	74 35		 je	 SHORT $LN62@stbi__tga_
  009d3	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  009d7	39 84 24 30 01
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  009de	74 28		 je	 SHORT $LN62@stbi__tga_

; 5987 :         tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

  009e0	8b 44 24 40	 mov	 eax, DWORD PTR tga_height$[rsp]
  009e4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  009e8	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR tga_width$[rsp]
  009ed	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  009f5	8b 54 24 30	 mov	 edx, DWORD PTR tga_comp$[rsp]
  009f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  009fe	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00a03	48 89 44 24 50	 mov	 QWORD PTR tga_data$[rsp], rax
$LN62@stbi__tga_:

; 5988 :     
; 5989 :     //   the things I do to get rid of an error message, and yet keep
; 5990 :     //   Microsoft's C compilers happy... [8^(
; 5991 :     tga_palette_start = tga_palette_len = tga_palette_bits =

  00a08	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tga_y_origin$[rsp], 0
  00a13	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tga_y_origin$[rsp]
  00a1a	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tga_x_origin$[rsp], eax
  00a21	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tga_x_origin$[rsp]
  00a28	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tga_palette_bits$[rsp], eax
  00a2f	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tga_palette_bits$[rsp]
  00a36	89 44 24 48	 mov	 DWORD PTR tga_palette_len$[rsp], eax
  00a3a	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00a3e	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tga_palette_start$[rsp], eax

; 5992 :         tga_x_origin = tga_y_origin = 0;
; 5993 :     STBI_NOTUSED(tga_palette_start);
; 5994 :     //   OK, done
; 5995 :     return tga_data;

  00a45	48 8b 44 24 50	 mov	 rax, QWORD PTR tga_data$[rsp]
$LN1@stbi__tga_:

; 5996 : }

  00a4a	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00a51	5f		 pop	 rdi
  00a52	c3		 ret	 0
?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__tga_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
sz$ = 32
tga_color_type$ = 36
res$ = 40
s$ = 64
?stbi__tga_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__tga_test

; 5743 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5744 :     int res = 0;

  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 5745 :     int sz, tga_color_type;
; 5746 :     stbi__get8(s);      //   discard Offset

  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00016	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 5747 :     tga_color_type = stbi__get8(s);   //   color type

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00025	0f b6 c0	 movzx	 eax, al
  00028	89 44 24 24	 mov	 DWORD PTR tga_color_type$[rsp], eax

; 5748 :     if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed

  0002c	83 7c 24 24 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00031	7e 0a		 jle	 SHORT $LN2@stbi__tga_
  00033	e9 47 01 00 00	 jmp	 $LN3@stbi__tga_
  00038	e9 42 01 00 00	 jmp	 $errorEnd$21
$LN2@stbi__tga_:

; 5749 :     sz = stbi__get8(s);   //   image type

  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00047	0f b6 c0	 movzx	 eax, al
  0004a	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5750 :     if ( tga_color_type == 1 ) { // colormapped (paletted) image

  0004e	83 7c 24 24 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00053	75 76		 jne	 SHORT $LN4@stbi__tga_

; 5751 :         if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

  00055	83 7c 24 20 01	 cmp	 DWORD PTR sz$[rsp], 1
  0005a	74 11		 je	 SHORT $LN6@stbi__tga_
  0005c	83 7c 24 20 09	 cmp	 DWORD PTR sz$[rsp], 9
  00061	74 0a		 je	 SHORT $LN6@stbi__tga_
  00063	e9 17 01 00 00	 jmp	 $LN7@stbi__tga_
  00068	e9 12 01 00 00	 jmp	 $errorEnd$21
$LN6@stbi__tga_:

; 5752 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries

  0006d	ba 04 00 00 00	 mov	 edx, 4
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00077	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5753 :         sz = stbi__get8(s);    //   check bits per palette color entry

  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00081	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00086	0f b6 c0	 movzx	 eax, al
  00089	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5754 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

  0008d	83 7c 24 20 08	 cmp	 DWORD PTR sz$[rsp], 8
  00092	74 26		 je	 SHORT $LN8@stbi__tga_
  00094	83 7c 24 20 0f	 cmp	 DWORD PTR sz$[rsp], 15
  00099	74 1f		 je	 SHORT $LN8@stbi__tga_
  0009b	83 7c 24 20 10	 cmp	 DWORD PTR sz$[rsp], 16
  000a0	74 18		 je	 SHORT $LN8@stbi__tga_
  000a2	83 7c 24 20 18	 cmp	 DWORD PTR sz$[rsp], 24
  000a7	74 11		 je	 SHORT $LN8@stbi__tga_
  000a9	83 7c 24 20 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  000ae	74 0a		 je	 SHORT $LN8@stbi__tga_
  000b0	e9 ca 00 00 00	 jmp	 $LN9@stbi__tga_
  000b5	e9 c5 00 00 00	 jmp	 $errorEnd$21
$LN8@stbi__tga_:

; 5755 :         stbi__skip(s,4);       // skip image x and y origin

  000ba	ba 04 00 00 00	 mov	 edx, 4
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c4	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5756 :     } else { // "normal" image w/o colormap

  000c9	eb 35		 jmp	 SHORT $LN5@stbi__tga_
$LN4@stbi__tga_:

; 5757 :         if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE

  000cb	83 7c 24 20 02	 cmp	 DWORD PTR sz$[rsp], 2
  000d0	74 1f		 je	 SHORT $LN10@stbi__tga_
  000d2	83 7c 24 20 03	 cmp	 DWORD PTR sz$[rsp], 3
  000d7	74 18		 je	 SHORT $LN10@stbi__tga_
  000d9	83 7c 24 20 0a	 cmp	 DWORD PTR sz$[rsp], 10
  000de	74 11		 je	 SHORT $LN10@stbi__tga_
  000e0	83 7c 24 20 0b	 cmp	 DWORD PTR sz$[rsp], 11
  000e5	74 0a		 je	 SHORT $LN10@stbi__tga_
  000e7	e9 93 00 00 00	 jmp	 $LN11@stbi__tga_
  000ec	e9 8e 00 00 00	 jmp	 $errorEnd$21
$LN10@stbi__tga_:

; 5758 :         stbi__skip(s,9); // skip colormap specification and image x/y origin

  000f1	ba 09 00 00 00	 mov	 edx, 9
  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000fb	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN5@stbi__tga_:

; 5759 :     }
; 5760 :     if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width

  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00105	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0010a	83 f8 01	 cmp	 eax, 1
  0010d	7d 04		 jge	 SHORT $LN12@stbi__tga_
  0010f	eb 6e		 jmp	 SHORT $LN13@stbi__tga_
  00111	eb 6c		 jmp	 SHORT $errorEnd$21
$LN12@stbi__tga_:

; 5761 :     if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height

  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00118	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0011d	83 f8 01	 cmp	 eax, 1
  00120	7d 04		 jge	 SHORT $LN14@stbi__tga_
  00122	eb 5b		 jmp	 SHORT $LN15@stbi__tga_
  00124	eb 59		 jmp	 SHORT $errorEnd$21
$LN14@stbi__tga_:

; 5762 :     sz = stbi__get8(s);   //   bits per pixel

  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00130	0f b6 c0	 movzx	 eax, al
  00133	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5763 :     if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index

  00137	83 7c 24 24 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  0013c	75 12		 jne	 SHORT $LN16@stbi__tga_
  0013e	83 7c 24 20 08	 cmp	 DWORD PTR sz$[rsp], 8
  00143	74 0b		 je	 SHORT $LN16@stbi__tga_
  00145	83 7c 24 20 10	 cmp	 DWORD PTR sz$[rsp], 16
  0014a	74 04		 je	 SHORT $LN16@stbi__tga_
  0014c	eb 31		 jmp	 SHORT $LN17@stbi__tga_
  0014e	eb 2f		 jmp	 SHORT $errorEnd$21
$LN16@stbi__tga_:

; 5764 :     if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

  00150	83 7c 24 20 08	 cmp	 DWORD PTR sz$[rsp], 8
  00155	74 20		 je	 SHORT $LN18@stbi__tga_
  00157	83 7c 24 20 0f	 cmp	 DWORD PTR sz$[rsp], 15
  0015c	74 19		 je	 SHORT $LN18@stbi__tga_
  0015e	83 7c 24 20 10	 cmp	 DWORD PTR sz$[rsp], 16
  00163	74 12		 je	 SHORT $LN18@stbi__tga_
  00165	83 7c 24 20 18	 cmp	 DWORD PTR sz$[rsp], 24
  0016a	74 0b		 je	 SHORT $LN18@stbi__tga_
  0016c	83 7c 24 20 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  00171	74 04		 je	 SHORT $LN18@stbi__tga_
  00173	eb 0a		 jmp	 SHORT $LN19@stbi__tga_
  00175	eb 08		 jmp	 SHORT $errorEnd$21
$LN18@stbi__tga_:

; 5765 :     
; 5766 :     res = 1; // if we got this far, everything's good and we can return 1 instead of 0

  00177	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR res$[rsp], 1
$LN3@stbi__tga_:
$LN7@stbi__tga_:
$LN9@stbi__tga_:
$LN11@stbi__tga_:
$LN13@stbi__tga_:
$LN15@stbi__tga_:
$LN17@stbi__tga_:
$LN19@stbi__tga_:
$errorEnd$21:

; 5767 :     
; 5768 :     errorEnd:
; 5769 :     stbi__rewind(s);

  0017f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00184	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5770 :     return res;

  00189	8b 44 24 28	 mov	 eax, DWORD PTR res$[rsp]

; 5771 : }

  0018d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00191	c3		 ret	 0
?stbi__tga_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__tga_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv77 = 32
p$ = 40
info$ = 48
__$ArrayPad$ = 88
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__bmp_info

; 7258 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7259 :     void *p;
; 7260 :     stbi__bmp_data info;
; 7261 :     
; 7262 :     info.all_a = 255;

  00027	c7 44 24 4c ff
	00 00 00	 mov	 DWORD PTR info$[rsp+28], 255 ; 000000ffH

; 7263 :     p = stbi__bmp_parse_header(s, &info);

  0002f	48 8d 54 24 30	 lea	 rdx, QWORD PTR info$[rsp]
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
  0003e	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 7264 :     if (p == NULL) {

  00043	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  00049	75 11		 jne	 SHORT $LN2@stbi__bmp_

; 7265 :         stbi__rewind( s );

  0004b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7266 :         return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 8b 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 7267 :     }
; 7268 :     if (x) *x = s->img_x;

  0005c	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00062	74 0e		 je	 SHORT $LN3@stbi__bmp_
  00064	48 8b 44 24 78	 mov	 rax, QWORD PTR x$[rsp]
  00069	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00070	89 08		 mov	 DWORD PTR [rax], ecx
$LN3@stbi__bmp_:

; 7269 :     if (y) *y = s->img_y;

  00072	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  0007b	74 12		 je	 SHORT $LN4@stbi__bmp_
  0007d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00085	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0008a	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0008d	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__bmp_:

; 7270 :     if (comp) {

  0008f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00098	74 48		 je	 SHORT $LN5@stbi__bmp_

; 7271 :         if (info.bpp == 24 && info.ma == 0xff000000)

  0009a	83 7c 24 30 18	 cmp	 DWORD PTR info$[rsp], 24
  0009f	75 1a		 jne	 SHORT $LN6@stbi__bmp_
  000a1	81 7c 24 48 00
	00 00 ff	 cmp	 DWORD PTR info$[rsp+24], -16777216 ; ff000000H
  000a9	75 10		 jne	 SHORT $LN6@stbi__bmp_

; 7272 :             *comp = 3;

  000ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000b3	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
  000b9	eb 27		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 7273 :         else
; 7274 :             *comp = info.ma ? 4 : 3;

  000bb	83 7c 24 48 00	 cmp	 DWORD PTR info$[rsp+24], 0
  000c0	74 0a		 je	 SHORT $LN9@stbi__bmp_
  000c2	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv77[rsp], 4
  000ca	eb 08		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:
  000cc	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR tv77[rsp], 3
$LN10@stbi__bmp_:
  000d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000dc	8b 4c 24 20	 mov	 ecx, DWORD PTR tv77[rsp]
  000e0	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 7275 :     }
; 7276 :     return 1;

  000e2	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 7277 : }

  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ec	48 33 cc	 xor	 rcx, rsp
  000ef	e8 00 00 00 00	 call	 __security_check_cookie
  000f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000f8	c3		 ret	 0
?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__bmp_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
i$ = 48
z$1 = 52
z$2 = 56
j$ = 60
out$ = 64
target$ = 72
a$3 = 76
v$4 = 80
ma$ = 84
t$5 = 88
psize$ = 92
width$ = 96
mr$ = 100
mg$ = 104
mb$ = 108
bit_offset$6 = 112
easy$7 = 116
all_a$ = 120
v$8 = 124
pad$ = 128
color$9 = 132
rcount$10 = 136
gcount$11 = 140
bcount$12 = 144
acount$13 = 148
tv80 = 152
tv87 = 156
tv174 = 160
tv181 = 164
tv196 = 168
tv209 = 172
tv218 = 176
tv253 = 180
tv272 = 184
v$14 = 188
v2$15 = 192
tv381 = 196
tv442 = 200
tv472 = 204
tv504 = 208
tv521 = 212
rshift$16 = 216
gshift$17 = 220
bshift$18 = 224
ashift$19 = 228
tv561 = 232
a$20 = 236
tv70 = 240
flip_vertically$ = 244
bpp$21 = 248
p1$22 = 256
p2$23 = 264
info$ = 272
pal$ = 320
__$ArrayPad$ = 1344
s$ = 1376
x$ = 1384
y$ = 1392
comp$ = 1400
req_comp$ = 1408
ri$ = 1416
?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__bmp_load

; 5468 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 58 05
	00 00		 sub	 rsp, 1368		; 00000558H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5469 :     stbi_uc *out;
; 5470 :     unsigned int mr=0,mg=0,mb=0,ma=0, all_a;

  0002d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR mr$[rsp], 0
  00035	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR mg$[rsp], 0
  0003d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR mb$[rsp], 0
  00045	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ma$[rsp], 0

; 5471 :     stbi_uc pal[256][4];
; 5472 :     int psize=0,i,j,width;

  0004d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR psize$[rsp], 0

; 5473 :     int flip_vertically, pad, target;
; 5474 :     stbi__bmp_data info;
; 5475 :     STBI_NOTUSED(ri);
; 5476 :     
; 5477 :     info.all_a = 255;

  00055	c7 84 24 2c 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR info$[rsp+28], 255 ; 000000ffH

; 5478 :     if (stbi__bmp_parse_header(s, &info) == NULL)

  00060	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  00068	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00070	e8 00 00 00 00	 call	 ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
  00075	48 85 c0	 test	 rax, rax
  00078	75 07		 jne	 SHORT $LN35@stbi__bmp_

; 5479 :         return NULL; // error code already set

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 2e 11 00 00	 jmp	 $LN1@stbi__bmp_
$LN35@stbi__bmp_:

; 5480 :     
; 5481 :     flip_vertically = ((int) s->img_y) > 0;

  00081	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00089	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0008d	7e 0d		 jle	 SHORT $LN93@stbi__bmp_
  0008f	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv70[rsp], 1
  0009a	eb 0b		 jmp	 SHORT $LN94@stbi__bmp_
$LN93@stbi__bmp_:
  0009c	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
$LN94@stbi__bmp_:
  000a7	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv70[rsp]
  000ae	89 84 24 f4 00
	00 00		 mov	 DWORD PTR flip_vertically$[rsp], eax

; 5482 :     s->img_y = abs((int) s->img_y);

  000b5	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bd	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000c0	99		 cdq
  000c1	8b ca		 mov	 ecx, edx
  000c3	33 c1		 xor	 eax, ecx
  000c5	2b c1		 sub	 eax, ecx
  000c7	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5483 :     
; 5484 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  000d2	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000da	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  000e1	76 35		 jbe	 SHORT $LN36@stbi__bmp_
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39732
  000ea	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000ef	85 c0		 test	 eax, eax
  000f1	74 0d		 je	 SHORT $LN95@stbi__bmp_
  000f3	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
  000fe	eb 0b		 jmp	 SHORT $LN96@stbi__bmp_
$LN95@stbi__bmp_:
  00100	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
$LN96@stbi__bmp_:
  0010b	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv80[rsp]
  00113	e9 97 10 00 00	 jmp	 $LN1@stbi__bmp_
$LN36@stbi__bmp_:

; 5485 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00118	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00120	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00126	76 35		 jbe	 SHORT $LN37@stbi__bmp_
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39734
  0012f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00134	85 c0		 test	 eax, eax
  00136	74 0d		 je	 SHORT $LN97@stbi__bmp_
  00138	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv87[rsp], 0
  00143	eb 0b		 jmp	 SHORT $LN98@stbi__bmp_
$LN97@stbi__bmp_:
  00145	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv87[rsp], 0
$LN98@stbi__bmp_:
  00150	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv87[rsp]
  00158	e9 52 10 00 00	 jmp	 $LN1@stbi__bmp_
$LN37@stbi__bmp_:

; 5486 :     
; 5487 :     mr = info.mr;

  0015d	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+12]
  00164	89 44 24 64	 mov	 DWORD PTR mr$[rsp], eax

; 5488 :     mg = info.mg;

  00168	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+16]
  0016f	89 44 24 68	 mov	 DWORD PTR mg$[rsp], eax

; 5489 :     mb = info.mb;

  00173	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+20]
  0017a	89 44 24 6c	 mov	 DWORD PTR mb$[rsp], eax

; 5490 :     ma = info.ma;

  0017e	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+24]
  00185	89 44 24 54	 mov	 DWORD PTR ma$[rsp], eax

; 5491 :     all_a = info.all_a;

  00189	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+28]
  00190	89 44 24 78	 mov	 DWORD PTR all_a$[rsp], eax

; 5492 :     
; 5493 :     if (info.hsz == 12) {

  00194	83 bc 24 18 01
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  0019c	75 2d		 jne	 SHORT $LN38@stbi__bmp_

; 5494 :         if (info.bpp < 24)

  0019e	83 bc 24 10 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  001a6	7d 21		 jge	 SHORT $LN40@stbi__bmp_

; 5495 :             psize = (info.offset - info.extra_read - 24) / 3;

  001a8	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  001af	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  001b6	2b c8		 sub	 ecx, eax
  001b8	8b c1		 mov	 eax, ecx
  001ba	83 e8 18	 sub	 eax, 24
  001bd	99		 cdq
  001be	b9 03 00 00 00	 mov	 ecx, 3
  001c3	f7 f9		 idiv	 ecx
  001c5	89 44 24 5c	 mov	 DWORD PTR psize$[rsp], eax
$LN40@stbi__bmp_:

; 5496 :     } else {

  001c9	eb 2a		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:

; 5497 :         if (info.bpp < 16)

  001cb	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  001d3	7d 20		 jge	 SHORT $LN41@stbi__bmp_

; 5498 :             psize = (info.offset - info.extra_read - info.hsz) >> 2;

  001d5	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  001dc	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  001e3	2b c8		 sub	 ecx, eax
  001e5	8b c1		 mov	 eax, ecx
  001e7	2b 84 24 18 01
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  001ee	c1 f8 02	 sar	 eax, 2
  001f1	89 44 24 5c	 mov	 DWORD PTR psize$[rsp], eax
$LN41@stbi__bmp_:
$LN39@stbi__bmp_:

; 5499 :     }
; 5500 :     if (psize == 0) {

  001f5	83 7c 24 5c 00	 cmp	 DWORD PTR psize$[rsp], 0
  001fa	75 75		 jne	 SHORT $LN42@stbi__bmp_

; 5501 :         if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {

  001fc	48 63 84 24 14
	01 00 00	 movsxd	 rax, DWORD PTR info$[rsp+4]
  00204	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0020c	48 63 89 b8 00
	00 00		 movsxd	 rcx, DWORD PTR [rcx+184]
  00213	48 8b 94 24 60
	05 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0021b	4c 8b 84 24 60
	05 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00223	4d 8b 80 d0 00
	00 00		 mov	 r8, QWORD PTR [r8+208]
  0022a	48 8b 92 c0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+192]
  00231	49 2b d0	 sub	 rdx, r8
  00234	48 03 ca	 add	 rcx, rdx
  00237	48 3b c1	 cmp	 rax, rcx
  0023a	74 35		 je	 SHORT $LN43@stbi__bmp_

; 5502 :             return stbi__errpuc("bad offset", "Corrupt BMP");

  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39741
  00243	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00248	85 c0		 test	 eax, eax
  0024a	74 0d		 je	 SHORT $LN99@stbi__bmp_
  0024c	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
  00257	eb 0b		 jmp	 SHORT $LN100@stbi__bmp_
$LN99@stbi__bmp_:
  00259	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN100@stbi__bmp_:
  00264	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  0026c	e9 3e 0f 00 00	 jmp	 $LN1@stbi__bmp_
$LN43@stbi__bmp_:
$LN42@stbi__bmp_:

; 5503 :         }
; 5504 :     }
; 5505 :     
; 5506 :     if (info.bpp == 24 && ma == 0xff000000)

  00271	83 bc 24 10 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00279	75 1b		 jne	 SHORT $LN44@stbi__bmp_
  0027b	81 7c 24 54 00
	00 00 ff	 cmp	 DWORD PTR ma$[rsp], -16777216 ; ff000000H
  00283	75 11		 jne	 SHORT $LN44@stbi__bmp_

; 5507 :         s->img_n = 3;

  00285	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0028d	c7 40 08 03 00
	00 00		 mov	 DWORD PTR [rax+8], 3
  00294	eb 31		 jmp	 SHORT $LN45@stbi__bmp_
$LN44@stbi__bmp_:

; 5508 :     else
; 5509 :         s->img_n = ma ? 4 : 3;

  00296	83 7c 24 54 00	 cmp	 DWORD PTR ma$[rsp], 0
  0029b	74 0d		 je	 SHORT $LN101@stbi__bmp_
  0029d	c7 84 24 a4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv181[rsp], 4
  002a8	eb 0b		 jmp	 SHORT $LN102@stbi__bmp_
$LN101@stbi__bmp_:
  002aa	c7 84 24 a4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv181[rsp], 3
$LN102@stbi__bmp_:
  002b5	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002bd	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv181[rsp]
  002c4	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN45@stbi__bmp_:

; 5510 :     if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

  002c7	83 bc 24 80 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  002cf	74 17		 je	 SHORT $LN46@stbi__bmp_
  002d1	83 bc 24 80 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  002d9	7c 0d		 jl	 SHORT $LN46@stbi__bmp_

; 5511 :         target = req_comp;

  002db	8b 84 24 80 05
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  002e2	89 44 24 48	 mov	 DWORD PTR target$[rsp], eax
  002e6	eb 0f		 jmp	 SHORT $LN47@stbi__bmp_
$LN46@stbi__bmp_:

; 5512 :     else
; 5513 :         target = s->img_n; // if they want monochrome, we'll post-convert

  002e8	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002f0	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002f3	89 44 24 48	 mov	 DWORD PTR target$[rsp], eax
$LN47@stbi__bmp_:

; 5514 :     
; 5515 :     // sanity-check size
; 5516 :     if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))

  002f7	45 33 c9	 xor	 r9d, r9d
  002fa	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00302	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00306	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0030e	8b 10		 mov	 edx, DWORD PTR [rax]
  00310	8b 4c 24 48	 mov	 ecx, DWORD PTR target$[rsp]
  00314	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  00319	85 c0		 test	 eax, eax
  0031b	75 35		 jne	 SHORT $LN48@stbi__bmp_

; 5517 :         return stbi__errpuc("too large", "Corrupt BMP");

  0031d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39747
  00324	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00329	85 c0		 test	 eax, eax
  0032b	74 0d		 je	 SHORT $LN103@stbi__bmp_
  0032d	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv196[rsp], 0
  00338	eb 0b		 jmp	 SHORT $LN104@stbi__bmp_
$LN103@stbi__bmp_:
  0033a	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv196[rsp], 0
$LN104@stbi__bmp_:
  00345	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv196[rsp]
  0034d	e9 5d 0e 00 00	 jmp	 $LN1@stbi__bmp_
$LN48@stbi__bmp_:

; 5518 :     
; 5519 :     out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);

  00352	45 33 c9	 xor	 r9d, r9d
  00355	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0035d	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00361	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00369	8b 10		 mov	 edx, DWORD PTR [rax]
  0036b	8b 4c 24 48	 mov	 ecx, DWORD PTR target$[rsp]
  0036f	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00374	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax

; 5520 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  00379	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  0037f	75 35		 jne	 SHORT $LN49@stbi__bmp_
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39749
  00388	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0038d	85 c0		 test	 eax, eax
  0038f	74 0d		 je	 SHORT $LN105@stbi__bmp_
  00391	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv209[rsp], 0
  0039c	eb 0b		 jmp	 SHORT $LN106@stbi__bmp_
$LN105@stbi__bmp_:
  0039e	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv209[rsp], 0
$LN106@stbi__bmp_:
  003a9	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR tv209[rsp]
  003b1	e9 f9 0d 00 00	 jmp	 $LN1@stbi__bmp_
$LN49@stbi__bmp_:

; 5521 :     if (info.bpp < 16) {

  003b6	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  003be	0f 8d 52 06 00
	00		 jge	 $LN50@stbi__bmp_

; 5522 :         int z=0;

  003c4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR z$1[rsp], 0

; 5523 :         if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

  003cc	83 7c 24 5c 00	 cmp	 DWORD PTR psize$[rsp], 0
  003d1	74 0a		 je	 SHORT $LN53@stbi__bmp_
  003d3	81 7c 24 5c 00
	01 00 00	 cmp	 DWORD PTR psize$[rsp], 256 ; 00000100H
  003db	7e 3f		 jle	 SHORT $LN52@stbi__bmp_
$LN53@stbi__bmp_:
  003dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  003e2	e8 00 00 00 00	 call	 free
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39754
  003ee	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003f3	85 c0		 test	 eax, eax
  003f5	74 0d		 je	 SHORT $LN107@stbi__bmp_
  003f7	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
  00402	eb 0b		 jmp	 SHORT $LN108@stbi__bmp_
$LN107@stbi__bmp_:
  00404	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
$LN108@stbi__bmp_:
  0040f	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv218[rsp]
  00417	e9 93 0d 00 00	 jmp	 $LN1@stbi__bmp_
$LN52@stbi__bmp_:

; 5524 :         for (i=0; i < psize; ++i) {

  0041c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00424	eb 0a		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  00426	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0042a	ff c0		 inc	 eax
  0042c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__bmp_:
  00430	8b 44 24 5c	 mov	 eax, DWORD PTR psize$[rsp]
  00434	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00438	0f 8d a8 00 00
	00		 jge	 $LN3@stbi__bmp_

; 5525 :             pal[i][2] = stbi__get8(s);

  0043e	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00446	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0044b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00450	48 8d 8c 8c 40
	01 00 00	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  00458	ba 01 00 00 00	 mov	 edx, 1
  0045d	48 6b d2 02	 imul	 rdx, rdx, 2
  00461	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5526 :             pal[i][1] = stbi__get8(s);

  00464	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0046c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00471	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00476	48 8d 8c 8c 40
	01 00 00	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  0047e	ba 01 00 00 00	 mov	 edx, 1
  00483	48 6b d2 01	 imul	 rdx, rdx, 1
  00487	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5527 :             pal[i][0] = stbi__get8(s);

  0048a	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00492	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00497	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0049c	48 8d 8c 8c 40
	01 00 00	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  004a4	ba 01 00 00 00	 mov	 edx, 1
  004a9	48 6b d2 00	 imul	 rdx, rdx, 0
  004ad	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5528 :             if (info.hsz != 12) stbi__get8(s);

  004b0	83 bc 24 18 01
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  004b8	74 0d		 je	 SHORT $LN54@stbi__bmp_
  004ba	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004c2	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
$LN54@stbi__bmp_:

; 5529 :             pal[i][3] = 255;

  004c7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004cc	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  004d4	b9 01 00 00 00	 mov	 ecx, 1
  004d9	48 6b c9 03	 imul	 rcx, rcx, 3
  004dd	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 5530 :         }

  004e1	e9 40 ff ff ff	 jmp	 $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5531 :         stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

  004e6	83 bc 24 18 01
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  004ee	75 0d		 jne	 SHORT $LN109@stbi__bmp_
  004f0	c7 84 24 b4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv253[rsp], 3
  004fb	eb 0b		 jmp	 SHORT $LN110@stbi__bmp_
$LN109@stbi__bmp_:
  004fd	c7 84 24 b4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv253[rsp], 4
$LN110@stbi__bmp_:
  00508	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  0050f	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  00516	2b c8		 sub	 ecx, eax
  00518	8b c1		 mov	 eax, ecx
  0051a	2b 84 24 18 01
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  00521	8b 4c 24 5c	 mov	 ecx, DWORD PTR psize$[rsp]
  00525	0f af 8c 24 b4
	00 00 00	 imul	 ecx, DWORD PTR tv253[rsp]
  0052d	2b c1		 sub	 eax, ecx
  0052f	8b d0		 mov	 edx, eax
  00531	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00539	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5532 :         if (info.bpp == 1) width = (s->img_x + 7) >> 3;

  0053e	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR info$[rsp], 1
  00546	75 16		 jne	 SHORT $LN55@stbi__bmp_
  00548	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00550	8b 00		 mov	 eax, DWORD PTR [rax]
  00552	83 c0 07	 add	 eax, 7
  00555	c1 e8 03	 shr	 eax, 3
  00558	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  0055c	eb 77		 jmp	 SHORT $LN56@stbi__bmp_
$LN55@stbi__bmp_:

; 5533 :         else if (info.bpp == 4) width = (s->img_x + 1) >> 1;

  0055e	83 bc 24 10 01
	00 00 04	 cmp	 DWORD PTR info$[rsp], 4
  00566	75 14		 jne	 SHORT $LN57@stbi__bmp_
  00568	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00570	8b 00		 mov	 eax, DWORD PTR [rax]
  00572	ff c0		 inc	 eax
  00574	d1 e8		 shr	 eax, 1
  00576	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  0057a	eb 59		 jmp	 SHORT $LN58@stbi__bmp_
$LN57@stbi__bmp_:

; 5534 :         else if (info.bpp == 8) width = s->img_x;

  0057c	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR info$[rsp], 8
  00584	75 10		 jne	 SHORT $LN59@stbi__bmp_
  00586	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0058e	8b 00		 mov	 eax, DWORD PTR [rax]
  00590	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  00594	eb 3f		 jmp	 SHORT $LN60@stbi__bmp_
$LN59@stbi__bmp_:

; 5535 :         else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

  00596	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0059b	e8 00 00 00 00	 call	 free
  005a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39762
  005a7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005ac	85 c0		 test	 eax, eax
  005ae	74 0d		 je	 SHORT $LN111@stbi__bmp_
  005b0	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv272[rsp], 0
  005bb	eb 0b		 jmp	 SHORT $LN112@stbi__bmp_
$LN111@stbi__bmp_:
  005bd	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv272[rsp], 0
$LN112@stbi__bmp_:
  005c8	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv272[rsp]
  005d0	e9 da 0b 00 00	 jmp	 $LN1@stbi__bmp_
$LN60@stbi__bmp_:
$LN58@stbi__bmp_:
$LN56@stbi__bmp_:

; 5536 :         pad = (-width)&3;

  005d5	8b 44 24 60	 mov	 eax, DWORD PTR width$[rsp]
  005d9	f7 d8		 neg	 eax
  005db	83 e0 03	 and	 eax, 3
  005de	89 84 24 80 00
	00 00		 mov	 DWORD PTR pad$[rsp], eax

; 5537 :         if (info.bpp == 1) {

  005e5	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR info$[rsp], 1
  005ed	0f 85 af 01 00
	00		 jne	 $LN61@stbi__bmp_

; 5538 :             for (j=0; j < (int) s->img_y; ++j) {

  005f3	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  005fb	eb 0a		 jmp	 SHORT $LN7@stbi__bmp_
$LN5@stbi__bmp_:
  005fd	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00601	ff c0		 inc	 eax
  00603	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__bmp_:
  00607	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0060f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00612	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  00616	0f 8d 81 01 00
	00		 jge	 $LN6@stbi__bmp_

; 5539 :                 int bit_offset = 7, v = stbi__get8(s);

  0061c	c7 44 24 70 07
	00 00 00	 mov	 DWORD PTR bit_offset$6[rsp], 7
  00624	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0062c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00631	0f b6 c0	 movzx	 eax, al
  00634	89 84 24 bc 00
	00 00		 mov	 DWORD PTR v$14[rsp], eax

; 5540 :                 for (i=0; i < (int) s->img_x; ++i) {

  0063b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00643	eb 0a		 jmp	 SHORT $LN10@stbi__bmp_
$LN8@stbi__bmp_:
  00645	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00649	ff c0		 inc	 eax
  0064b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__bmp_:
  0064f	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00657	8b 00		 mov	 eax, DWORD PTR [rax]
  00659	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0065d	0f 8d 21 01 00
	00		 jge	 $LN9@stbi__bmp_

; 5541 :                     int color = (v>>bit_offset)&0x1;

  00663	8b 44 24 70	 mov	 eax, DWORD PTR bit_offset$6[rsp]
  00667	0f b6 c8	 movzx	 ecx, al
  0066a	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR v$14[rsp]
  00671	d3 f8		 sar	 eax, cl
  00673	83 e0 01	 and	 eax, 1
  00676	89 84 24 84 00
	00 00		 mov	 DWORD PTR color$9[rsp], eax

; 5542 :                     out[z++] = pal[color][0];

  0067d	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR color$9[rsp]
  00685	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0068d	b9 01 00 00 00	 mov	 ecx, 1
  00692	48 6b c9 00	 imul	 rcx, rcx, 0
  00696	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  0069b	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  006a0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  006a4	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  006a8	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  006ac	ff c0		 inc	 eax
  006ae	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5543 :                     out[z++] = pal[color][1];

  006b2	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR color$9[rsp]
  006ba	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  006c2	b9 01 00 00 00	 mov	 ecx, 1
  006c7	48 6b c9 01	 imul	 rcx, rcx, 1
  006cb	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  006d0	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  006d5	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  006d9	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  006dd	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  006e1	ff c0		 inc	 eax
  006e3	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5544 :                     out[z++] = pal[color][2];

  006e7	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR color$9[rsp]
  006ef	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  006f7	b9 01 00 00 00	 mov	 ecx, 1
  006fc	48 6b c9 02	 imul	 rcx, rcx, 2
  00700	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00705	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  0070a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0070e	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00712	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00716	ff c0		 inc	 eax
  00718	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5545 :                     if (target == 4) out[z++] = 255;

  0071c	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  00721	75 18		 jne	 SHORT $LN63@stbi__bmp_
  00723	48 63 44 24 34	 movsxd	 rax, DWORD PTR z$1[rsp]
  00728	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0072d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00731	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00735	ff c0		 inc	 eax
  00737	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax
$LN63@stbi__bmp_:

; 5546 :                     if (i+1 == (int) s->img_x) break;

  0073b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0073f	ff c0		 inc	 eax
  00741	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00749	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0074b	75 02		 jne	 SHORT $LN64@stbi__bmp_
  0074d	eb 35		 jmp	 SHORT $LN9@stbi__bmp_
$LN64@stbi__bmp_:

; 5547 :                     if((--bit_offset) < 0) {

  0074f	8b 44 24 70	 mov	 eax, DWORD PTR bit_offset$6[rsp]
  00753	ff c8		 dec	 eax
  00755	89 44 24 70	 mov	 DWORD PTR bit_offset$6[rsp], eax
  00759	83 7c 24 70 00	 cmp	 DWORD PTR bit_offset$6[rsp], 0
  0075e	7d 1f		 jge	 SHORT $LN65@stbi__bmp_

; 5548 :                         bit_offset = 7;

  00760	c7 44 24 70 07
	00 00 00	 mov	 DWORD PTR bit_offset$6[rsp], 7

; 5549 :                         v = stbi__get8(s);

  00768	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00770	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00775	0f b6 c0	 movzx	 eax, al
  00778	89 84 24 bc 00
	00 00		 mov	 DWORD PTR v$14[rsp], eax
$LN65@stbi__bmp_:

; 5550 :                     }
; 5551 :                 }

  0077f	e9 c1 fe ff ff	 jmp	 $LN8@stbi__bmp_
$LN9@stbi__bmp_:

; 5552 :                 stbi__skip(s, pad);

  00784	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  0078b	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00793	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5553 :             }

  00798	e9 60 fe ff ff	 jmp	 $LN5@stbi__bmp_
$LN6@stbi__bmp_:

; 5554 :         } else {

  0079d	e9 6f 02 00 00	 jmp	 $LN62@stbi__bmp_
$LN61@stbi__bmp_:

; 5555 :             for (j=0; j < (int) s->img_y; ++j) {

  007a2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  007aa	eb 0a		 jmp	 SHORT $LN13@stbi__bmp_
$LN11@stbi__bmp_:
  007ac	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  007b0	ff c0		 inc	 eax
  007b2	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN13@stbi__bmp_:
  007b6	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007be	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  007c1	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  007c5	0f 8d 46 02 00
	00		 jge	 $LN12@stbi__bmp_

; 5556 :                 for (i=0; i < (int) s->img_x; i += 2) {

  007cb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007d3	eb 0b		 jmp	 SHORT $LN16@stbi__bmp_
$LN14@stbi__bmp_:
  007d5	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007d9	83 c0 02	 add	 eax, 2
  007dc	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@stbi__bmp_:
  007e0	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007e8	8b 00		 mov	 eax, DWORD PTR [rax]
  007ea	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  007ee	0f 8d 04 02 00
	00		 jge	 $LN15@stbi__bmp_

; 5557 :                     int v=stbi__get8(s),v2=0;

  007f4	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007fc	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00801	0f b6 c0	 movzx	 eax, al
  00804	89 44 24 50	 mov	 DWORD PTR v$4[rsp], eax
  00808	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR v2$15[rsp], 0

; 5558 :                     if (info.bpp == 4) {

  00813	83 bc 24 10 01
	00 00 04	 cmp	 DWORD PTR info$[rsp], 4
  0081b	75 19		 jne	 SHORT $LN66@stbi__bmp_

; 5559 :                         v2 = v & 15;

  0081d	8b 44 24 50	 mov	 eax, DWORD PTR v$4[rsp]
  00821	83 e0 0f	 and	 eax, 15
  00824	89 84 24 c0 00
	00 00		 mov	 DWORD PTR v2$15[rsp], eax

; 5560 :                         v >>= 4;

  0082b	8b 44 24 50	 mov	 eax, DWORD PTR v$4[rsp]
  0082f	c1 f8 04	 sar	 eax, 4
  00832	89 44 24 50	 mov	 DWORD PTR v$4[rsp], eax
$LN66@stbi__bmp_:

; 5561 :                     }
; 5562 :                     out[z++] = pal[v][0];

  00836	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  0083b	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00843	b9 01 00 00 00	 mov	 ecx, 1
  00848	48 6b c9 00	 imul	 rcx, rcx, 0
  0084c	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00851	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00856	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0085a	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  0085e	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00862	ff c0		 inc	 eax
  00864	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5563 :                     out[z++] = pal[v][1];

  00868	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  0086d	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00875	b9 01 00 00 00	 mov	 ecx, 1
  0087a	48 6b c9 01	 imul	 rcx, rcx, 1
  0087e	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00883	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00888	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0088c	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00890	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00894	ff c0		 inc	 eax
  00896	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5564 :                     out[z++] = pal[v][2];

  0089a	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  0089f	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  008a7	b9 01 00 00 00	 mov	 ecx, 1
  008ac	48 6b c9 02	 imul	 rcx, rcx, 2
  008b0	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  008b5	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  008ba	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  008be	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  008c2	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  008c6	ff c0		 inc	 eax
  008c8	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5565 :                     if (target == 4) out[z++] = 255;

  008cc	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  008d1	75 18		 jne	 SHORT $LN67@stbi__bmp_
  008d3	48 63 44 24 34	 movsxd	 rax, DWORD PTR z$1[rsp]
  008d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  008dd	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  008e1	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  008e5	ff c0		 inc	 eax
  008e7	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax
$LN67@stbi__bmp_:

; 5566 :                     if (i+1 == (int) s->img_x) break;

  008eb	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  008ef	ff c0		 inc	 eax
  008f1	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008f9	3b 01		 cmp	 eax, DWORD PTR [rcx]
  008fb	75 05		 jne	 SHORT $LN68@stbi__bmp_
  008fd	e9 f6 00 00 00	 jmp	 $LN15@stbi__bmp_
$LN68@stbi__bmp_:

; 5567 :                     v = (info.bpp == 8) ? stbi__get8(s) : v2;

  00902	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR info$[rsp], 8
  0090a	75 19		 jne	 SHORT $LN113@stbi__bmp_
  0090c	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00914	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00919	0f b6 c0	 movzx	 eax, al
  0091c	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv381[rsp], eax
  00923	eb 0e		 jmp	 SHORT $LN114@stbi__bmp_
$LN113@stbi__bmp_:
  00925	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR v2$15[rsp]
  0092c	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv381[rsp], eax
$LN114@stbi__bmp_:
  00933	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv381[rsp]
  0093a	89 44 24 50	 mov	 DWORD PTR v$4[rsp], eax

; 5568 :                     out[z++] = pal[v][0];

  0093e	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  00943	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0094b	b9 01 00 00 00	 mov	 ecx, 1
  00950	48 6b c9 00	 imul	 rcx, rcx, 0
  00954	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00959	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  0095e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00962	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00966	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  0096a	ff c0		 inc	 eax
  0096c	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5569 :                     out[z++] = pal[v][1];

  00970	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  00975	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0097d	b9 01 00 00 00	 mov	 ecx, 1
  00982	48 6b c9 01	 imul	 rcx, rcx, 1
  00986	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  0098b	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00990	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00994	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00998	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  0099c	ff c0		 inc	 eax
  0099e	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5570 :                     out[z++] = pal[v][2];

  009a2	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  009a7	48 8d 84 84 40
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  009af	b9 01 00 00 00	 mov	 ecx, 1
  009b4	48 6b c9 02	 imul	 rcx, rcx, 2
  009b8	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  009bd	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  009c2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  009c6	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  009ca	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  009ce	ff c0		 inc	 eax
  009d0	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5571 :                     if (target == 4) out[z++] = 255;

  009d4	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  009d9	75 18		 jne	 SHORT $LN69@stbi__bmp_
  009db	48 63 44 24 34	 movsxd	 rax, DWORD PTR z$1[rsp]
  009e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  009e5	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  009e9	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  009ed	ff c0		 inc	 eax
  009ef	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax
$LN69@stbi__bmp_:

; 5572 :                 }

  009f3	e9 dd fd ff ff	 jmp	 $LN14@stbi__bmp_
$LN15@stbi__bmp_:

; 5573 :                 stbi__skip(s, pad);

  009f8	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  009ff	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a07	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5574 :             }

  00a0c	e9 9b fd ff ff	 jmp	 $LN11@stbi__bmp_
$LN12@stbi__bmp_:
$LN62@stbi__bmp_:

; 5575 :         }
; 5576 :     } else {

  00a11	e9 89 05 00 00	 jmp	 $LN51@stbi__bmp_
$LN50@stbi__bmp_:

; 5577 :         int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;

  00a16	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rshift$16[rsp], 0
  00a21	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR gshift$17[rsp], 0
  00a2c	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR bshift$18[rsp], 0
  00a37	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ashift$19[rsp], 0
  00a42	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rcount$10[rsp], 0
  00a4d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR gcount$11[rsp], 0
  00a58	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR bcount$12[rsp], 0
  00a63	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR acount$13[rsp], 0

; 5578 :         int z = 0;

  00a6e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR z$2[rsp], 0

; 5579 :         int easy=0;

  00a76	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR easy$7[rsp], 0

; 5580 :         stbi__skip(s, info.offset - info.extra_read - info.hsz);

  00a7e	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  00a85	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  00a8c	2b c8		 sub	 ecx, eax
  00a8e	8b c1		 mov	 eax, ecx
  00a90	2b 84 24 18 01
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  00a97	8b d0		 mov	 edx, eax
  00a99	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aa1	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5581 :         if (info.bpp == 24) width = 3 * s->img_x;

  00aa6	83 bc 24 10 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00aae	75 11		 jne	 SHORT $LN70@stbi__bmp_
  00ab0	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ab8	6b 00 03	 imul	 eax, DWORD PTR [rax], 3
  00abb	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  00abf	eb 24		 jmp	 SHORT $LN71@stbi__bmp_
$LN70@stbi__bmp_:

; 5582 :         else if (info.bpp == 16) width = 2*s->img_x;

  00ac1	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  00ac9	75 12		 jne	 SHORT $LN72@stbi__bmp_
  00acb	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ad3	8b 00		 mov	 eax, DWORD PTR [rax]
  00ad5	d1 e0		 shl	 eax, 1
  00ad7	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  00adb	eb 08		 jmp	 SHORT $LN73@stbi__bmp_
$LN72@stbi__bmp_:

; 5583 :         else /* bpp = 32 and pad = 0 */ width=0;

  00add	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR width$[rsp], 0
$LN73@stbi__bmp_:
$LN71@stbi__bmp_:

; 5584 :         pad = (-width) & 3;

  00ae5	8b 44 24 60	 mov	 eax, DWORD PTR width$[rsp]
  00ae9	f7 d8		 neg	 eax
  00aeb	83 e0 03	 and	 eax, 3
  00aee	89 84 24 80 00
	00 00		 mov	 DWORD PTR pad$[rsp], eax

; 5585 :         if (info.bpp == 24) {

  00af5	83 bc 24 10 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00afd	75 0a		 jne	 SHORT $LN74@stbi__bmp_

; 5586 :             easy = 1;

  00aff	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR easy$7[rsp], 1
  00b07	eb 3a		 jmp	 SHORT $LN75@stbi__bmp_
$LN74@stbi__bmp_:

; 5587 :         } else if (info.bpp == 32) {

  00b09	83 bc 24 10 01
	00 00 20	 cmp	 DWORD PTR info$[rsp], 32 ; 00000020H
  00b11	75 30		 jne	 SHORT $LN76@stbi__bmp_

; 5588 :             if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

  00b13	81 7c 24 6c ff
	00 00 00	 cmp	 DWORD PTR mb$[rsp], 255	; 000000ffH
  00b1b	75 26		 jne	 SHORT $LN77@stbi__bmp_
  00b1d	81 7c 24 68 00
	ff 00 00	 cmp	 DWORD PTR mg$[rsp], 65280 ; 0000ff00H
  00b25	75 1c		 jne	 SHORT $LN77@stbi__bmp_
  00b27	81 7c 24 64 00
	00 ff 00	 cmp	 DWORD PTR mr$[rsp], 16711680 ; 00ff0000H
  00b2f	75 12		 jne	 SHORT $LN77@stbi__bmp_
  00b31	81 7c 24 54 00
	00 00 ff	 cmp	 DWORD PTR ma$[rsp], -16777216 ; ff000000H
  00b39	75 08		 jne	 SHORT $LN77@stbi__bmp_

; 5589 :                 easy = 2;

  00b3b	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR easy$7[rsp], 2
$LN77@stbi__bmp_:
$LN76@stbi__bmp_:
$LN75@stbi__bmp_:

; 5590 :         }
; 5591 :         if (!easy) {

  00b43	83 7c 24 74 00	 cmp	 DWORD PTR easy$7[rsp], 0
  00b48	0f 85 47 01 00
	00		 jne	 $LN78@stbi__bmp_

; 5592 :             if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  00b4e	83 7c 24 64 00	 cmp	 DWORD PTR mr$[rsp], 0
  00b53	74 0e		 je	 SHORT $LN80@stbi__bmp_
  00b55	83 7c 24 68 00	 cmp	 DWORD PTR mg$[rsp], 0
  00b5a	74 07		 je	 SHORT $LN80@stbi__bmp_
  00b5c	83 7c 24 6c 00	 cmp	 DWORD PTR mb$[rsp], 0
  00b61	75 3f		 jne	 SHORT $LN79@stbi__bmp_
$LN80@stbi__bmp_:
  00b63	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00b68	e8 00 00 00 00	 call	 free
  00b6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39783
  00b74	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00b79	85 c0		 test	 eax, eax
  00b7b	74 0d		 je	 SHORT $LN115@stbi__bmp_
  00b7d	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv442[rsp], 0
  00b88	eb 0b		 jmp	 SHORT $LN116@stbi__bmp_
$LN115@stbi__bmp_:
  00b8a	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv442[rsp], 0
$LN116@stbi__bmp_:
  00b95	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR tv442[rsp]
  00b9d	e9 0d 06 00 00	 jmp	 $LN1@stbi__bmp_
$LN79@stbi__bmp_:

; 5593 :             // right shift amt to put high bit in position #7
; 5594 :             rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);

  00ba2	8b 4c 24 64	 mov	 ecx, DWORD PTR mr$[rsp]
  00ba6	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00bab	83 e8 07	 sub	 eax, 7
  00bae	89 84 24 d8 00
	00 00		 mov	 DWORD PTR rshift$16[rsp], eax
  00bb5	8b 4c 24 64	 mov	 ecx, DWORD PTR mr$[rsp]
  00bb9	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00bbe	89 84 24 88 00
	00 00		 mov	 DWORD PTR rcount$10[rsp], eax

; 5595 :             gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

  00bc5	8b 4c 24 68	 mov	 ecx, DWORD PTR mg$[rsp]
  00bc9	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00bce	83 e8 07	 sub	 eax, 7
  00bd1	89 84 24 dc 00
	00 00		 mov	 DWORD PTR gshift$17[rsp], eax
  00bd8	8b 4c 24 68	 mov	 ecx, DWORD PTR mg$[rsp]
  00bdc	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00be1	89 84 24 8c 00
	00 00		 mov	 DWORD PTR gcount$11[rsp], eax

; 5596 :             bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

  00be8	8b 4c 24 6c	 mov	 ecx, DWORD PTR mb$[rsp]
  00bec	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00bf1	83 e8 07	 sub	 eax, 7
  00bf4	89 84 24 e0 00
	00 00		 mov	 DWORD PTR bshift$18[rsp], eax
  00bfb	8b 4c 24 6c	 mov	 ecx, DWORD PTR mb$[rsp]
  00bff	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00c04	89 84 24 90 00
	00 00		 mov	 DWORD PTR bcount$12[rsp], eax

; 5597 :             ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

  00c0b	8b 4c 24 54	 mov	 ecx, DWORD PTR ma$[rsp]
  00c0f	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00c14	83 e8 07	 sub	 eax, 7
  00c17	89 84 24 e4 00
	00 00		 mov	 DWORD PTR ashift$19[rsp], eax
  00c1e	8b 4c 24 54	 mov	 ecx, DWORD PTR ma$[rsp]
  00c22	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00c27	89 84 24 94 00
	00 00		 mov	 DWORD PTR acount$13[rsp], eax

; 5598 :             if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  00c2e	83 bc 24 88 00
	00 00 08	 cmp	 DWORD PTR rcount$10[rsp], 8
  00c36	7f 1e		 jg	 SHORT $LN82@stbi__bmp_
  00c38	83 bc 24 8c 00
	00 00 08	 cmp	 DWORD PTR gcount$11[rsp], 8
  00c40	7f 14		 jg	 SHORT $LN82@stbi__bmp_
  00c42	83 bc 24 90 00
	00 00 08	 cmp	 DWORD PTR bcount$12[rsp], 8
  00c4a	7f 0a		 jg	 SHORT $LN82@stbi__bmp_
  00c4c	83 bc 24 94 00
	00 00 08	 cmp	 DWORD PTR acount$13[rsp], 8
  00c54	7e 3f		 jle	 SHORT $LN81@stbi__bmp_
$LN82@stbi__bmp_:
  00c56	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00c5b	e8 00 00 00 00	 call	 free
  00c60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG39786
  00c67	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00c6c	85 c0		 test	 eax, eax
  00c6e	74 0d		 je	 SHORT $LN117@stbi__bmp_
  00c70	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv472[rsp], 0
  00c7b	eb 0b		 jmp	 SHORT $LN118@stbi__bmp_
$LN117@stbi__bmp_:
  00c7d	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv472[rsp], 0
$LN118@stbi__bmp_:
  00c88	48 63 84 24 cc
	00 00 00	 movsxd	 rax, DWORD PTR tv472[rsp]
  00c90	e9 1a 05 00 00	 jmp	 $LN1@stbi__bmp_
$LN81@stbi__bmp_:
$LN78@stbi__bmp_:

; 5599 :         }
; 5600 :         for (j=0; j < (int) s->img_y; ++j) {

  00c95	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00c9d	eb 0a		 jmp	 SHORT $LN19@stbi__bmp_
$LN17@stbi__bmp_:
  00c9f	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00ca3	ff c0		 inc	 eax
  00ca5	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN19@stbi__bmp_:
  00ca9	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cb1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00cb4	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  00cb8	0f 8d e1 02 00
	00		 jge	 $LN18@stbi__bmp_

; 5601 :             if (easy) {

  00cbe	83 7c 24 74 00	 cmp	 DWORD PTR easy$7[rsp], 0
  00cc3	0f 84 01 01 00
	00		 je	 $LN83@stbi__bmp_

; 5602 :                 for (i=0; i < (int) s->img_x; ++i) {

  00cc9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00cd1	eb 0a		 jmp	 SHORT $LN22@stbi__bmp_
$LN20@stbi__bmp_:
  00cd3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00cd7	ff c0		 inc	 eax
  00cd9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN22@stbi__bmp_:
  00cdd	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ce5	8b 00		 mov	 eax, DWORD PTR [rax]
  00ce7	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00ceb	0f 8d d4 00 00
	00		 jge	 $LN21@stbi__bmp_

; 5603 :                     unsigned char a;
; 5604 :                     out[z+2] = stbi__get8(s);

  00cf1	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cf9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00cfe	8b 4c 24 38	 mov	 ecx, DWORD PTR z$2[rsp]
  00d02	83 c1 02	 add	 ecx, 2
  00d05	48 63 c9	 movsxd	 rcx, ecx
  00d08	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00d0d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5605 :                     out[z+1] = stbi__get8(s);

  00d10	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d18	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00d1d	8b 4c 24 38	 mov	 ecx, DWORD PTR z$2[rsp]
  00d21	ff c1		 inc	 ecx
  00d23	48 63 c9	 movsxd	 rcx, ecx
  00d26	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00d2b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5606 :                     out[z+0] = stbi__get8(s);

  00d2e	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d36	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00d3b	8b 4c 24 38	 mov	 ecx, DWORD PTR z$2[rsp]
  00d3f	48 63 c9	 movsxd	 rcx, ecx
  00d42	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00d47	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5607 :                     z += 3;

  00d4a	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00d4e	83 c0 03	 add	 eax, 3
  00d51	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5608 :                     a = (easy == 2 ? stbi__get8(s) : 255);

  00d55	83 7c 24 74 02	 cmp	 DWORD PTR easy$7[rsp], 2
  00d5a	75 19		 jne	 SHORT $LN119@stbi__bmp_
  00d5c	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d64	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00d69	0f b6 c0	 movzx	 eax, al
  00d6c	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv504[rsp], eax
  00d73	eb 0b		 jmp	 SHORT $LN120@stbi__bmp_
$LN119@stbi__bmp_:
  00d75	c7 84 24 d0 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv504[rsp], 255 ; 000000ffH
$LN120@stbi__bmp_:
  00d80	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR tv504[rsp]
  00d88	88 44 24 4c	 mov	 BYTE PTR a$3[rsp], al

; 5609 :                     all_a |= a;

  00d8c	0f b6 44 24 4c	 movzx	 eax, BYTE PTR a$3[rsp]
  00d91	8b 4c 24 78	 mov	 ecx, DWORD PTR all_a$[rsp]
  00d95	0b c8		 or	 ecx, eax
  00d97	8b c1		 mov	 eax, ecx
  00d99	89 44 24 78	 mov	 DWORD PTR all_a$[rsp], eax

; 5610 :                     if (target == 4) out[z++] = a;

  00d9d	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  00da2	75 1c		 jne	 SHORT $LN85@stbi__bmp_
  00da4	48 63 44 24 38	 movsxd	 rax, DWORD PTR z$2[rsp]
  00da9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00dae	0f b6 54 24 4c	 movzx	 edx, BYTE PTR a$3[rsp]
  00db3	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00db6	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00dba	ff c0		 inc	 eax
  00dbc	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax
$LN85@stbi__bmp_:

; 5611 :                 }

  00dc0	e9 0e ff ff ff	 jmp	 $LN20@stbi__bmp_
$LN21@stbi__bmp_:

; 5612 :             } else {

  00dc5	e9 bc 01 00 00	 jmp	 $LN84@stbi__bmp_
$LN83@stbi__bmp_:

; 5613 :                 int bpp = info.bpp;

  00dca	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR info$[rsp]
  00dd1	89 84 24 f8 00
	00 00		 mov	 DWORD PTR bpp$21[rsp], eax

; 5614 :                 for (i=0; i < (int) s->img_x; ++i) {

  00dd8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00de0	eb 0a		 jmp	 SHORT $LN25@stbi__bmp_
$LN23@stbi__bmp_:
  00de2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00de6	ff c0		 inc	 eax
  00de8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN25@stbi__bmp_:
  00dec	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00df4	8b 00		 mov	 eax, DWORD PTR [rax]
  00df6	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00dfa	0f 8d 86 01 00
	00		 jge	 $LN24@stbi__bmp_

; 5615 :                     stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));

  00e00	83 bc 24 f8 00
	00 00 10	 cmp	 DWORD PTR bpp$21[rsp], 16
  00e08	75 16		 jne	 SHORT $LN121@stbi__bmp_
  00e0a	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e12	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00e17	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv521[rsp], eax
  00e1e	eb 14		 jmp	 SHORT $LN122@stbi__bmp_
$LN121@stbi__bmp_:
  00e20	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e28	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00e2d	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv521[rsp], eax
$LN122@stbi__bmp_:
  00e34	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv521[rsp]
  00e3b	89 44 24 7c	 mov	 DWORD PTR v$8[rsp], eax

; 5616 :                     unsigned int a;
; 5617 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

  00e3f	8b 44 24 64	 mov	 eax, DWORD PTR mr$[rsp]
  00e43	8b 4c 24 7c	 mov	 ecx, DWORD PTR v$8[rsp]
  00e47	23 c8		 and	 ecx, eax
  00e49	8b c1		 mov	 eax, ecx
  00e4b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR rcount$10[rsp]
  00e53	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR rshift$16[rsp]
  00e5a	8b c8		 mov	 ecx, eax
  00e5c	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00e61	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e66	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00e6b	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00e70	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00e73	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00e77	ff c0		 inc	 eax
  00e79	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5618 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

  00e7d	8b 44 24 68	 mov	 eax, DWORD PTR mg$[rsp]
  00e81	8b 4c 24 7c	 mov	 ecx, DWORD PTR v$8[rsp]
  00e85	23 c8		 and	 ecx, eax
  00e87	8b c1		 mov	 eax, ecx
  00e89	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR gcount$11[rsp]
  00e91	8b 94 24 dc 00
	00 00		 mov	 edx, DWORD PTR gshift$17[rsp]
  00e98	8b c8		 mov	 ecx, eax
  00e9a	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00e9f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ea4	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00ea9	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00eae	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00eb1	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00eb5	ff c0		 inc	 eax
  00eb7	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5619 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

  00ebb	8b 44 24 6c	 mov	 eax, DWORD PTR mb$[rsp]
  00ebf	8b 4c 24 7c	 mov	 ecx, DWORD PTR v$8[rsp]
  00ec3	23 c8		 and	 ecx, eax
  00ec5	8b c1		 mov	 eax, ecx
  00ec7	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR bcount$12[rsp]
  00ecf	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR bshift$18[rsp]
  00ed6	8b c8		 mov	 ecx, eax
  00ed8	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00edd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ee2	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00ee7	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00eec	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00eef	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00ef3	ff c0		 inc	 eax
  00ef5	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5620 :                     a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

  00ef9	83 7c 24 54 00	 cmp	 DWORD PTR ma$[rsp], 0
  00efe	74 2b		 je	 SHORT $LN123@stbi__bmp_
  00f00	8b 44 24 54	 mov	 eax, DWORD PTR ma$[rsp]
  00f04	8b 4c 24 7c	 mov	 ecx, DWORD PTR v$8[rsp]
  00f08	23 c8		 and	 ecx, eax
  00f0a	8b c1		 mov	 eax, ecx
  00f0c	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR acount$13[rsp]
  00f14	8b 94 24 e4 00
	00 00		 mov	 edx, DWORD PTR ashift$19[rsp]
  00f1b	8b c8		 mov	 ecx, eax
  00f1d	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00f22	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv561[rsp], eax
  00f29	eb 0b		 jmp	 SHORT $LN124@stbi__bmp_
$LN123@stbi__bmp_:
  00f2b	c7 84 24 e8 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv561[rsp], 255 ; 000000ffH
$LN124@stbi__bmp_:
  00f36	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv561[rsp]
  00f3d	89 84 24 ec 00
	00 00		 mov	 DWORD PTR a$20[rsp], eax

; 5621 :                     all_a |= a;

  00f44	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR a$20[rsp]
  00f4b	8b 4c 24 78	 mov	 ecx, DWORD PTR all_a$[rsp]
  00f4f	0b c8		 or	 ecx, eax
  00f51	8b c1		 mov	 eax, ecx
  00f53	89 44 24 78	 mov	 DWORD PTR all_a$[rsp], eax

; 5622 :                     if (target == 4) out[z++] = STBI__BYTECAST(a);

  00f57	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  00f5c	75 23		 jne	 SHORT $LN86@stbi__bmp_
  00f5e	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR a$20[rsp]
  00f65	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f6a	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00f6f	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00f74	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f77	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00f7b	ff c0		 inc	 eax
  00f7d	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax
$LN86@stbi__bmp_:

; 5623 :                 }

  00f81	e9 5c fe ff ff	 jmp	 $LN23@stbi__bmp_
$LN24@stbi__bmp_:
$LN84@stbi__bmp_:

; 5624 :             }
; 5625 :             stbi__skip(s, pad);

  00f86	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  00f8d	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f95	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5626 :         }

  00f9a	e9 00 fd ff ff	 jmp	 $LN17@stbi__bmp_
$LN18@stbi__bmp_:
$LN51@stbi__bmp_:

; 5627 :     }
; 5628 :     
; 5629 :     // if alpha channel is all 0s, replace with all 255s
; 5630 :     if (target == 4 && all_a == 0)

  00f9f	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  00fa4	75 4a		 jne	 SHORT $LN87@stbi__bmp_
  00fa6	83 7c 24 78 00	 cmp	 DWORD PTR all_a$[rsp], 0
  00fab	75 43		 jne	 SHORT $LN87@stbi__bmp_

; 5631 :         for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)

  00fad	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00fb5	8b 00		 mov	 eax, DWORD PTR [rax]
  00fb7	c1 e0 02	 shl	 eax, 2
  00fba	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00fc2	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00fc6	ff c8		 dec	 eax
  00fc8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00fcc	eb 0b		 jmp	 SHORT $LN28@stbi__bmp_
$LN26@stbi__bmp_:
  00fce	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00fd2	83 e8 04	 sub	 eax, 4
  00fd5	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__bmp_:
  00fd9	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  00fde	7c 10		 jl	 SHORT $LN27@stbi__bmp_

; 5632 :         out[i] = 255;

  00fe0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00fe5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00fea	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00fee	eb de		 jmp	 SHORT $LN26@stbi__bmp_
$LN27@stbi__bmp_:
$LN87@stbi__bmp_:

; 5633 :     
; 5634 :     if (flip_vertically) {

  00ff0	83 bc 24 f4 00
	00 00 00	 cmp	 DWORD PTR flip_vertically$[rsp], 0
  00ff8	0f 84 08 01 00
	00		 je	 $LN88@stbi__bmp_

; 5635 :         stbi_uc t;
; 5636 :         for (j=0; j < (int) s->img_y>>1; ++j) {

  00ffe	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  01006	eb 0a		 jmp	 SHORT $LN31@stbi__bmp_
$LN29@stbi__bmp_:
  01008	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  0100c	ff c0		 inc	 eax
  0100e	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN31@stbi__bmp_:
  01012	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0101a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0101d	d1 f8		 sar	 eax, 1
  0101f	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  01023	0f 8d dd 00 00
	00		 jge	 $LN30@stbi__bmp_

; 5637 :             stbi_uc *p1 = out +      j     *s->img_x*target;

  01029	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01031	8b 4c 24 3c	 mov	 ecx, DWORD PTR j$[rsp]
  01035	0f af 08	 imul	 ecx, DWORD PTR [rax]
  01038	8b c1		 mov	 eax, ecx
  0103a	0f af 44 24 48	 imul	 eax, DWORD PTR target$[rsp]
  0103f	8b c0		 mov	 eax, eax
  01041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  01046	48 03 c8	 add	 rcx, rax
  01049	48 8b c1	 mov	 rax, rcx
  0104c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR p1$22[rsp], rax

; 5638 :             stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;

  01054	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0105c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0105f	ff c8		 dec	 eax
  01061	2b 44 24 3c	 sub	 eax, DWORD PTR j$[rsp]
  01065	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0106d	0f af 01	 imul	 eax, DWORD PTR [rcx]
  01070	0f af 44 24 48	 imul	 eax, DWORD PTR target$[rsp]
  01075	8b c0		 mov	 eax, eax
  01077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0107c	48 03 c8	 add	 rcx, rax
  0107f	48 8b c1	 mov	 rax, rcx
  01082	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR p2$23[rsp], rax

; 5639 :             for (i=0; i < (int) s->img_x*target; ++i) {

  0108a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01092	eb 0a		 jmp	 SHORT $LN34@stbi__bmp_
$LN32@stbi__bmp_:
  01094	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  01098	ff c0		 inc	 eax
  0109a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN34@stbi__bmp_:
  0109e	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010a6	8b 00		 mov	 eax, DWORD PTR [rax]
  010a8	0f af 44 24 48	 imul	 eax, DWORD PTR target$[rsp]
  010ad	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  010b1	7d 4e		 jge	 SHORT $LN33@stbi__bmp_

; 5640 :                 t = p1[i]; p1[i] = p2[i]; p2[i] = t;

  010b3	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  010b8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR p1$22[rsp]
  010c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010c4	88 44 24 58	 mov	 BYTE PTR t$5[rsp], al
  010c8	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  010cd	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  010d2	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p1$22[rsp]
  010da	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR p2$23[rsp]
  010e2	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  010e7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  010ea	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  010ef	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR p2$23[rsp]
  010f7	0f b6 54 24 58	 movzx	 edx, BYTE PTR t$5[rsp]
  010fc	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5641 :             }

  010ff	eb 93		 jmp	 SHORT $LN32@stbi__bmp_
$LN33@stbi__bmp_:

; 5642 :         }

  01101	e9 02 ff ff ff	 jmp	 $LN29@stbi__bmp_
$LN30@stbi__bmp_:
$LN88@stbi__bmp_:

; 5643 :     }
; 5644 :     
; 5645 :     if (req_comp && req_comp != target) {

  01106	83 bc 24 80 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0110e	74 51		 je	 SHORT $LN89@stbi__bmp_
  01110	8b 44 24 48	 mov	 eax, DWORD PTR target$[rsp]
  01114	39 84 24 80 05
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  0111b	74 44		 je	 SHORT $LN89@stbi__bmp_

; 5646 :         out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

  0111d	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01125	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01128	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0112c	48 8b 84 24 60
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01134	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  01137	44 8b 84 24 80
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  0113f	8b 54 24 48	 mov	 edx, DWORD PTR target$[rsp]
  01143	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  01148	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  0114d	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax

; 5647 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  01152	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  01158	75 07		 jne	 SHORT $LN90@stbi__bmp_
  0115a	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
  0115f	eb 4e		 jmp	 SHORT $LN1@stbi__bmp_
$LN90@stbi__bmp_:
$LN89@stbi__bmp_:

; 5648 :     }
; 5649 :     
; 5650 :     *x = s->img_x;

  01161	48 8b 84 24 68
	05 00 00	 mov	 rax, QWORD PTR x$[rsp]
  01169	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01171	8b 09		 mov	 ecx, DWORD PTR [rcx]
  01173	89 08		 mov	 DWORD PTR [rax], ecx

; 5651 :     *y = s->img_y;

  01175	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR y$[rsp]
  0117d	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01185	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  01188	89 08		 mov	 DWORD PTR [rax], ecx

; 5652 :     if (comp) *comp = s->img_n;

  0118a	48 83 bc 24 78
	05 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  01193	74 15		 je	 SHORT $LN91@stbi__bmp_
  01195	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  0119d	48 8b 8c 24 60
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  011a5	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  011a8	89 08		 mov	 DWORD PTR [rax], ecx
$LN91@stbi__bmp_:

; 5653 :     return out;

  011aa	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__bmp_:

; 5654 : }

  011af	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  011b7	48 33 cc	 xor	 rcx, rsp
  011ba	e8 00 00 00 00	 call	 __security_check_cookie
  011bf	48 81 c4 58 05
	00 00		 add	 rsp, 1368		; 00000558H
  011c6	c3		 ret	 0
?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__bmp_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__bmp_test

; 5298 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5299 :     int r = stbi__bmp_test_raw(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__bmp_test_raw
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5300 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5301 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 5302 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__bmp_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 32
s$ = 96
?stbi__png_is16@@YAHPEAUstbi__context@@@Z PROC		; stbi__png_is16

; 5266 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5267 :     stbi__png p;
; 5268 :     p.s = s;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 5269 :     if (!stbi__png_info_raw(&p, NULL, NULL, NULL))

  00013	45 33 c9	 xor	 r9d, r9d
  00016	45 33 c0	 xor	 r8d, r8d
  00019	33 d2		 xor	 edx, edx
  0001b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR p$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ; stbi__png_info_raw
  00025	85 c0		 test	 eax, eax
  00027	75 04		 jne	 SHORT $LN2@stbi__png_

; 5270 :         return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 1a		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5271 :     if (p.depth != 16) {

  0002d	83 7c 24 40 10	 cmp	 DWORD PTR p$[rsp+32], 16
  00032	74 0e		 je	 SHORT $LN3@stbi__png_

; 5272 :         stbi__rewind(p.s);

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5273 :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 05		 jmp	 SHORT $LN1@stbi__png_
$LN3@stbi__png_:

; 5274 :     }
; 5275 :     return 1;

  00042	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 5276 : }

  00047	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0004b	c3		 ret	 0
?stbi__png_is16@@YAHPEAUstbi__context@@@Z ENDP		; stbi__png_is16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 32
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__png_info

; 5259 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5260 :     stbi__png p;
; 5261 :     p.s = s;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 5262 :     return stbi__png_info_raw(&p, x, y, comp);

  00022	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00027	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  0002c	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00031	48 8d 4c 24 20	 lea	 rcx, QWORD PTR p$[rsp]
  00036	e8 00 00 00 00	 call	 ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ; stbi__png_info_raw

; 5263 : }

  0003b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0003f	c3		 ret	 0
?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__png_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 48
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
req_comp$ = 144
ri$ = 152
?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__png_load

; 5232 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5233 :     stbi__png p;
; 5234 :     p.s = s;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5235 :     return stbi__do_png(&p, x,y,comp,req_comp, ri);

  00022	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0002a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00036	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0003a	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00042	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0004a	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR p$[rsp]
  00054	e8 00 00 00 00	 call	 ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__do_png

; 5236 : }

  00059	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0005d	c3		 ret	 0
?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__png_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__png_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__png_test

; 5239 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5240 :     int r;
; 5241 :     r = stbi__check_png_header(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5242 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5243 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 5244 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__png_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__png_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
result$ = 32
j$ = 40
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__jpeg_info

; 4013 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4014 :     int result;
; 4015 :     stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));

  00018	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0001d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00022	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax

; 4016 :     if (!j) return stbi__err("outofmem", "Out of memory");

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR j$[rsp], 0
  0002d	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38395
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	eb 38		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4017 :     j->s = s;

  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4018 :     result = stbi__jpeg_info_raw(j, x, y, comp);

  0004a	4c 8b 4c 24 58	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 44 24 50	 mov	 r8, QWORD PTR y$[rsp]
  00054	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0005e	e8 00 00 00 00	 call	 ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z ; stbi__jpeg_info_raw
  00063	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 4019 :     STBI_FREE(j);

  00067	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0006c	e8 00 00 00 00	 call	 free

; 4020 :     return result;

  00071	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi__jpeg:

; 4021 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__jpeg_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv70 = 48
j$ = 56
result$ = 64
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__jpeg_load

; 3975 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3976 :     unsigned char* result;
; 3977 :     stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));

  00018	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0001d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00022	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 3978 :     if (!j) return stbi__errpuc("outofmem", "Out of memory");

  00027	48 83 7c 24 38
	00		 cmp	 QWORD PTR j$[rsp], 0
  0002d	75 29		 jne	 SHORT $LN2@stbi__jpeg
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38364
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN4@stbi__jpeg
  0003f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00047	eb 08		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:
  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN5@stbi__jpeg:
  00051	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv70[rsp]
  00056	eb 4f		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3979 :     STBI_NOTUSED(ri);
; 3980 :     j->s = s;

  00058	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00062	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3981 :     stbi__setup_jpeg(j);

  00065	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  0006a	e8 00 00 00 00	 call	 ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 3982 :     result = load_jpeg_image(j, x,y,comp,req_comp);

  0006f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00076	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0007f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00084	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00089	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  0008e	e8 00 00 00 00	 call	 ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ; load_jpeg_image
  00093	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 3983 :     STBI_FREE(j);

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  0009d	e8 00 00 00 00	 call	 free

; 3984 :     return result;

  000a2	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__jpeg:

; 3985 : }

  000a7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ab	c3		 ret	 0
?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__jpeg_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
r$ = 32
j$ = 40
s$ = 64
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__jpeg_test

; 3988 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3989 :     int r;
; 3990 :     stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

  00009	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0000e	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00013	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax

; 3991 :     if (!j) return stbi__err("outofmem", "Out of memory");

  00018	48 83 7c 24 28
	00		 cmp	 QWORD PTR j$[rsp], 0
  0001e	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG38373
  00027	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0002c	eb 42		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3992 :     j->s = s;

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00038	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3993 :     stbi__setup_jpeg(j);

  0003b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00040	e8 00 00 00 00	 call	 ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 3994 :     r = stbi__decode_jpeg_header(j, STBI__SCAN_type);

  00045	ba 01 00 00 00	 mov	 edx, 1
  0004a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0004f	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
  00054	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 3995 :     stbi__rewind(s);

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005d	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 3996 :     STBI_FREE(j);

  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00067	e8 00 00 00 00	 call	 free

; 3997 :     return r;

  0006c	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]
$LN1@stbi__jpeg:

; 3998 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__jpeg_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 8
?stbi__rewind@@YAXPEAUstbi__context@@@Z PROC		; stbi__rewind

; 884  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 885  :     // conceptually rewind SHOULD rewind to the beginning of the stream,
; 886  :     // but we just rewind to the beginning of the initial buffer, because
; 887  :     // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 888  :     s->img_buffer = s->img_buffer_original;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0000a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  0000f	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00016	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 889  :     s->img_buffer_end = s->img_buffer_original_end;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00022	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00027	48 8b 89 d8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+216]
  0002e	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 890  : }

  00035	c3		 ret	 0
?stbi__rewind@@YAXPEAUstbi__context@@@Z ENDP		; stbi__rewind
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
f$ = 56
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z PROC ; stbi__start_file

; 875  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 876  :     stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR f$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 877  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ENDP ; stbi__start_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv70 = 32
user$ = 64
?stbi__stdio_eof@@YAHPEAX@Z PROC			; stbi__stdio_eof

; 863  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 864  :     return feof((FILE*) user) || ferror((FILE *) user);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0000e	e8 00 00 00 00	 call	 feof
  00013	85 c0		 test	 eax, eax
  00015	75 18		 jne	 SHORT $LN3@stbi__stdi
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0001c	e8 00 00 00 00	 call	 ferror
  00021	85 c0		 test	 eax, eax
  00023	75 0a		 jne	 SHORT $LN3@stbi__stdi
  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0002d	eb 08		 jmp	 SHORT $LN4@stbi__stdi
$LN3@stbi__stdi:
  0002f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN4@stbi__stdi:
  00037	8b 44 24 20	 mov	 eax, DWORD PTR tv70[rsp]

; 865  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?stbi__stdio_eof@@YAHPEAX@Z ENDP			; stbi__stdio_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
ch$ = 32
user$ = 64
n$ = 72
?stbi__stdio_skip@@YAXPEAXH@Z PROC			; stbi__stdio_skip

; 853  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 854  :     int ch;
; 855  :     fseek((FILE*) user, n, SEEK_CUR);

  0000d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00013	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0001c	e8 00 00 00 00	 call	 fseek

; 856  :     ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */

  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  00026	e8 00 00 00 00	 call	 fgetc
  0002b	89 44 24 20	 mov	 DWORD PTR ch$[rsp], eax

; 857  :     if (ch != EOF) {

  0002f	83 7c 24 20 ff	 cmp	 DWORD PTR ch$[rsp], -1
  00034	74 0e		 je	 SHORT $LN2@stbi__stdi

; 858  :         ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */

  00036	48 8b 54 24 40	 mov	 rdx, QWORD PTR user$[rsp]
  0003b	8b 4c 24 20	 mov	 ecx, DWORD PTR ch$[rsp]
  0003f	e8 00 00 00 00	 call	 ungetc
$LN2@stbi__stdi:

; 859  :     }
; 860  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
?stbi__stdio_skip@@YAXPEAXH@Z ENDP			; stbi__stdio_skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
user$ = 48
data$ = 56
size$ = 64
?stbi__stdio_read@@YAHPEAXPEADH@Z PROC			; stbi__stdio_read

; 848  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 849  :     return (int) fread(data,1,size,(FILE*) user);

  00013	48 63 44 24 40	 movsxd	 rax, DWORD PTR size$[rsp]
  00018	4c 8b 4c 24 30	 mov	 r9, QWORD PTR user$[rsp]
  0001d	4c 8b c0	 mov	 r8, rax
  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0002a	e8 00 00 00 00	 call	 fread

; 850  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
?stbi__stdio_read@@YAHPEAXPEADH@Z ENDP			; stbi__stdio_read
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv72 = 32
s$ = 80
c$ = 88
user$ = 96
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z PROC ; stbi__start_callbacks

; 834  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 835  :     s->io = *c;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001a	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0001e	48 8b 74 24 58	 mov	 rsi, QWORD PTR c$[rsp]
  00023	b9 18 00 00 00	 mov	 ecx, 24
  00028	f3 a4		 rep movsb

; 836  :     s->io_user_data = user;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR user$[rsp]
  00034	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 837  :     s->buflen = sizeof(s->buffer_start);

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0003d	c7 40 34 80 00
	00 00		 mov	 DWORD PTR [rax+52], 128	; 00000080H

; 838  :     s->read_from_callbacks = 1;

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00049	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [rax+48], 1

; 839  :     s->callback_already_read = 0;

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00055	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 840  :     s->img_buffer = s->img_buffer_original = s->buffer_start;

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00064	48 83 c0 38	 add	 rax, 56			; 00000038H
  00068	48 89 44 24 20	 mov	 QWORD PTR tv72[rsp], rax
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00077	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00088	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 841  :     stbi__refill_buffer(s);

  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 842  :     s->img_buffer_original_end = s->img_buffer_end;

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a3	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000aa	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 843  : }

  000b1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b5	5f		 pop	 rdi
  000b6	5e		 pop	 rsi
  000b7	c3		 ret	 0
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ENDP ; stbi__start_callbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv73 = 0
s$ = 32
buffer$ = 40
len$ = 48
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z PROC	; stbi__start_mem

; 824  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 825  :     s->io.read = NULL;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00018	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 826  :     s->read_from_callbacks = 0;

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 827  :     s->callback_already_read = 0;

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00031	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 828  :     s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00040	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer$[rsp]
  00045	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer$[rsp]
  00056	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 829  :     s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

  0005d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer$[rsp]
  00067	48 03 c8	 add	 rcx, rax
  0006a	48 89 0c 24	 mov	 QWORD PTR tv73[rsp], rcx
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00073	48 8b 0c 24	 mov	 rcx, QWORD PTR tv73[rsp]
  00077	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 0c 24	 mov	 rcx, QWORD PTR tv73[rsp]
  00087	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 830  : }

  0008e	48 83 c4 18	 add	 rsp, 24
  00092	c3		 ret	 0
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ENDP	; stbi__start_mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
n$ = 32
s$ = 64
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z PROC	; stbi__refill_buffer

; 1578 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1579 :     int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00017	44 8b 41 34	 mov	 r8d, DWORD PTR [rcx+52]
  0001b	48 8b d0	 mov	 rdx, rax
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00023	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002c	ff 50 10	 call	 QWORD PTR [rax+16]
  0002f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1580 :     s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00044	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004b	48 2b c1	 sub	 rax, rcx
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 1581 :     if (n == 0) {

  00064	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00069	75 47		 jne	 SHORT $LN2@stbi__refi

; 1582 :         // at end of file, treat same as if from memory, but need to handle case
; 1583 :         // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1584 :         s->read_from_callbacks = 0;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00070	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1585 :         s->img_buffer = s->buffer_start;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0007c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00085	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1586 :         s->img_buffer_end = s->buffer_start+1;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00091	48 83 c0 39	 add	 rax, 57			; 00000039H
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 1587 :         *s->img_buffer = 0;

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ad	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1588 :     } else {

  000b0	eb 30		 jmp	 SHORT $LN3@stbi__refi
$LN2@stbi__refi:

; 1589 :         s->img_buffer = s->buffer_start;

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b7	48 83 c0 38	 add	 rax, 56			; 00000038H
  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1590 :         s->img_buffer_end = s->buffer_start + n;

  000c7	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d1	48 8d 44 01 38	 lea	 rax, QWORD PTR [rcx+rax+56]
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000db	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax
$LN3@stbi__refi:

; 1591 :     }
; 1592 : }

  000e2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e6	c3		 ret	 0
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ENDP	; stbi__refill_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv68 = 32
info3$ = 36
?stbi__sse2_available@@YAHXZ PROC			; stbi__sse2_available

; 752  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 753  :     int info3 = stbi__cpuid3();

  00004	e8 00 00 00 00	 call	 ?stbi__cpuid3@@YAHXZ	; stbi__cpuid3
  00009	89 44 24 24	 mov	 DWORD PTR info3$[rsp], eax

; 754  :     return ((info3 >> 26) & 1) != 0;

  0000d	8b 44 24 24	 mov	 eax, DWORD PTR info3$[rsp]
  00011	c1 f8 1a	 sar	 eax, 26
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 0a		 je	 SHORT $LN3@stbi__sse2
  0001b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00023	eb 08		 jmp	 SHORT $LN4@stbi__sse2
$LN3@stbi__sse2:
  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@stbi__sse2:
  0002d	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 755  : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
?stbi__sse2_available@@YAHXZ ENDP			; stbi__sse2_available
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
info$ = 0
__$ArrayPad$ = 16
?stbi__cpuid3@@YAHXZ PROC				; stbi__cpuid3

; 730  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 731  :     int info[4];
; 732  :     __cpuid(info,1);

  00015	b8 01 00 00 00	 mov	 eax, 1
  0001a	33 c9		 xor	 ecx, ecx
  0001c	0f a2		 cpuid
  0001e	4c 8d 04 24	 lea	 r8, QWORD PTR info$[rsp]
  00022	41 89 00	 mov	 DWORD PTR [r8], eax
  00025	41 89 58 04	 mov	 DWORD PTR [r8+4], ebx
  00029	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx
  0002d	41 89 50 0c	 mov	 DWORD PTR [r8+12], edx

; 733  :     return info[3];

  00031	b8 04 00 00 00	 mov	 eax, 4
  00036	48 6b c0 03	 imul	 rax, rax, 3
  0003a	8b 04 04	 mov	 eax, DWORD PTR info$[rsp+rax]

; 734  : }

  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00042	48 33 cc	 xor	 rcx, rsp
  00045	e8 00 00 00 00	 call	 __security_check_cookie
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
?stbi__cpuid3@@YAHXZ ENDP				; stbi__cpuid3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 48
__$ArrayPad$ = 4144
obuffer$ = 4176
olen$ = 4184
ibuffer$ = 4192
ilen$ = 4200
stbi_zlib_decode_noheader_buffer PROC

; 4507 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 48 10 00 00	 mov	 eax, 4168		; 00001048H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 30
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4508 :     stbi__zbuf a;
; 4509 :     a.zbuffer = (stbi_uc *) ibuffer;

  00032	48 8b 84 24 60
	10 00 00	 mov	 rax, QWORD PTR ibuffer$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 4510 :     a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

  0003f	48 63 84 24 68
	10 00 00	 movsxd	 rax, DWORD PTR ilen$[rsp]
  00047	48 8b 8c 24 60
	10 00 00	 mov	 rcx, QWORD PTR ibuffer$[rsp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 89 44 24 38	 mov	 QWORD PTR a$[rsp+8], rax

; 4511 :     if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

  0005a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00062	45 33 c9	 xor	 r9d, r9d
  00065	44 8b 84 24 58
	10 00 00	 mov	 r8d, DWORD PTR olen$[rsp]
  0006d	48 8b 94 24 50
	10 00 00	 mov	 rdx, QWORD PTR obuffer$[rsp]
  00075	48 8d 4c 24 30	 lea	 rcx, QWORD PTR a$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  0007f	85 c0		 test	 eax, eax
  00081	74 14		 je	 SHORT $LN2@stbi_zlib_

; 4512 :         return (int) (a.zout - a.zout_start);

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp+32]
  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR a$[rsp+24]
  0008d	48 2b c8	 sub	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  00095	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4513 :     else
; 4514 :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4515 : }

  0009c	48 8b 8c 24 30
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a4	48 33 cc	 xor	 rcx, rsp
  000a7	e8 00 00 00 00	 call	 __security_check_cookie
  000ac	48 81 c4 48 10
	00 00		 add	 rsp, 4168		; 00001048H
  000b3	c3		 ret	 0
stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4160
buffer$ = 4192
len$ = 4200
outlen$ = 4208
stbi_zlib_decode_noheader_malloc PROC

; 4491 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	b8 58 10 00 00	 mov	 eax, 4184		; 00001058H
  00013	e8 00 00 00 00	 call	 __chkstk
  00018	48 2b e0	 sub	 rsp, rax
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 40
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4492 :     stbi__zbuf a;
; 4493 :     char *p = (char *) stbi__malloc(16384);

  0002d	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00032	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00037	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4494 :     if (p == NULL) return NULL;

  0003c	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  00042	75 07		 jne	 SHORT $LN2@stbi_zlib_
  00044	33 c0		 xor	 eax, eax
  00046	e9 89 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4495 :     a.zbuffer = (stbi_uc *) buffer;

  0004b	48 8b 84 24 60
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00053	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4496 :     a.zbuffer_end = (stbi_uc *) buffer+len;

  00058	48 63 84 24 68
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00060	48 8b 8c 24 60
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4497 :     if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

  00073	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0007b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00081	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  00087	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0008c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  00091	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  00096	85 c0		 test	 eax, eax
  00098	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4498 :         if (outlen) *outlen = (int) (a.zout - a.zout_start);

  0009a	48 83 bc 24 70
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000a3	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000a5	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000af	48 2b c8	 sub	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000bd	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4499 :         return a.zout_start;

  000bf	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000c4	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4500 :     } else {

  000c6	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4501 :         STBI_FREE(a.zout_start);

  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000cd	e8 00 00 00 00	 call	 free

; 4502 :         return NULL;

  000d2	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4503 :     }
; 4504 : }

  000d4	48 8b 8c 24 40
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dc	48 33 cc	 xor	 rcx, rsp
  000df	e8 00 00 00 00	 call	 __security_check_cookie
  000e4	48 81 c4 58 10
	00 00		 add	 rsp, 4184		; 00001058H
  000eb	c3		 ret	 0
stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
a$ = 48
__$ArrayPad$ = 4144
obuffer$ = 4176
olen$ = 4184
ibuffer$ = 4192
ilen$ = 4200
stbi_zlib_decode_buffer PROC

; 4480 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 48 10 00 00	 mov	 eax, 4168		; 00001048H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 30
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4481 :     stbi__zbuf a;
; 4482 :     a.zbuffer = (stbi_uc *) ibuffer;

  00032	48 8b 84 24 60
	10 00 00	 mov	 rax, QWORD PTR ibuffer$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 4483 :     a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

  0003f	48 63 84 24 68
	10 00 00	 movsxd	 rax, DWORD PTR ilen$[rsp]
  00047	48 8b 8c 24 60
	10 00 00	 mov	 rcx, QWORD PTR ibuffer$[rsp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 89 44 24 38	 mov	 QWORD PTR a$[rsp+8], rax

; 4484 :     if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

  0005a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00062	45 33 c9	 xor	 r9d, r9d
  00065	44 8b 84 24 58
	10 00 00	 mov	 r8d, DWORD PTR olen$[rsp]
  0006d	48 8b 94 24 50
	10 00 00	 mov	 rdx, QWORD PTR obuffer$[rsp]
  00075	48 8d 4c 24 30	 lea	 rcx, QWORD PTR a$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  0007f	85 c0		 test	 eax, eax
  00081	74 14		 je	 SHORT $LN2@stbi_zlib_

; 4485 :         return (int) (a.zout - a.zout_start);

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp+32]
  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR a$[rsp+24]
  0008d	48 2b c8	 sub	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  00095	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4486 :     else
; 4487 :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4488 : }

  0009c	48 8b 8c 24 30
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a4	48 33 cc	 xor	 rcx, rsp
  000a7	e8 00 00 00 00	 call	 __security_check_cookie
  000ac	48 81 c4 48 10
	00 00		 add	 rsp, 4168		; 00001048H
  000b3	c3		 ret	 0
stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
buffer$ = 48
len$ = 56
outlen$ = 64
stbi_zlib_decode_malloc PROC

; 4459 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4460 :     return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

  00012	4c 8b 4c 24 40	 mov	 r9, QWORD PTR outlen$[rsp]
  00017	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  0001d	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  00026	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize

; 4461 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4160
buffer$ = 4192
len$ = 4200
initial_size$ = 4208
outlen$ = 4216
parse_header$ = 4224
stbi_zlib_decode_malloc_guesssize_headerflag PROC

; 4464 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 58 10 00 00	 mov	 eax, 4184		; 00001058H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 40
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4465 :     stbi__zbuf a;
; 4466 :     char *p = (char *) stbi__malloc(initial_size);

  00032	48 63 84 24 70
	10 00 00	 movsxd	 rax, DWORD PTR initial_size$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00042	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4467 :     if (p == NULL) return NULL;

  00047	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0004f	33 c0		 xor	 eax, eax
  00051	e9 8e 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4468 :     a.zbuffer = (stbi_uc *) buffer;

  00056	48 8b 84 24 60
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0005e	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4469 :     a.zbuffer_end = (stbi_uc *) buffer + len;

  00063	48 63 84 24 68
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0006b	48 8b 8c 24 60
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4470 :     if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

  0007e	8b 84 24 80 10
	00 00		 mov	 eax, DWORD PTR parse_header$[rsp]
  00085	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00089	41 b9 01 00 00
	00		 mov	 r9d, 1
  0008f	44 8b 84 24 70
	10 00 00	 mov	 r8d, DWORD PTR initial_size$[rsp]
  00097	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0009c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000a1	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  000a6	85 c0		 test	 eax, eax
  000a8	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4471 :         if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000aa	48 83 bc 24 78
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000b3	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000b5	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000bf	48 2b c8	 sub	 rcx, rax
  000c2	48 8b c1	 mov	 rax, rcx
  000c5	48 8b 8c 24 78
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000cd	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4472 :         return a.zout_start;

  000cf	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000d4	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4473 :     } else {

  000d6	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4474 :         STBI_FREE(a.zout_start);

  000d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000dd	e8 00 00 00 00	 call	 free

; 4475 :         return NULL;

  000e2	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4476 :     }
; 4477 : }

  000e4	48 8b 8c 24 40
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ec	48 33 cc	 xor	 rcx, rsp
  000ef	e8 00 00 00 00	 call	 __security_check_cookie
  000f4	48 81 c4 58 10
	00 00		 add	 rsp, 4184		; 00001058H
  000fb	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4160
buffer$ = 4192
len$ = 4200
initial_size$ = 4208
outlen$ = 4216
stbi_zlib_decode_malloc_guesssize PROC

; 4443 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 58 10 00 00	 mov	 eax, 4184		; 00001058H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 40
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4444 :     stbi__zbuf a;
; 4445 :     char *p = (char *) stbi__malloc(initial_size);

  00032	48 63 84 24 70
	10 00 00	 movsxd	 rax, DWORD PTR initial_size$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00042	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4446 :     if (p == NULL) return NULL;

  00047	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0004f	33 c0		 xor	 eax, eax
  00051	e9 8b 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4447 :     a.zbuffer = (stbi_uc *) buffer;

  00056	48 8b 84 24 60
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0005e	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4448 :     a.zbuffer_end = (stbi_uc *) buffer + len;

  00063	48 63 84 24 68
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0006b	48 8b 8c 24 60
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4449 :     if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

  0007e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00086	41 b9 01 00 00
	00		 mov	 r9d, 1
  0008c	44 8b 84 24 70
	10 00 00	 mov	 r8d, DWORD PTR initial_size$[rsp]
  00094	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00099	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  0009e	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  000a3	85 c0		 test	 eax, eax
  000a5	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4450 :         if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000a7	48 83 bc 24 78
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000b0	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000b2	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp+24]
  000bc	48 2b c8	 sub	 rcx, rax
  000bf	48 8b c1	 mov	 rax, rcx
  000c2	48 8b 8c 24 78
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000ca	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4451 :         return a.zout_start;

  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp+32]
  000d1	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4452 :     } else {

  000d3	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4453 :         STBI_FREE(a.zout_start);

  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000da	e8 00 00 00 00	 call	 free

; 4454 :         return NULL;

  000df	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4455 :     }
; 4456 : }

  000e1	48 8b 8c 24 40
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e9	48 33 cc	 xor	 rcx, rsp
  000ec	e8 00 00 00 00	 call	 __security_check_cookie
  000f1	48 81 c4 58 10
	00 00		 add	 rsp, 4184		; 00001058H
  000f8	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 8
stbi_set_flip_vertically_on_load_thread PROC

; 1107 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1108 :     stbi__vertically_flip_on_load_local = flag_true_if_should_flip;

  00004	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  00009	8b c0		 mov	 eax, eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00011	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR flag_true_if_should_flip$[rsp]
  00022	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 1109 :     stbi__vertically_flip_on_load_set = 1;

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003f	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 1110 : }

  00046	c3		 ret	 0
stbi_set_flip_vertically_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 8
stbi_convert_iphone_png_to_rgb_thread PROC

; 4965 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4966 :     stbi__de_iphone_flag_local = flag_true_if_should_convert;

  00004	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_local@@3HA
  00009	8b c0		 mov	 eax, eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00011	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR flag_true_if_should_convert$[rsp]
  00022	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 4967 :     stbi__de_iphone_flag_set = 1;

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_set@@3HA
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003f	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 4968 : }

  00046	c3		 ret	 0
stbi_convert_iphone_png_to_rgb_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 8
stbi_set_flip_vertically_on_load PROC

; 1097 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1098 :     stbi__vertically_flip_on_load_global = flag_true_if_should_flip;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR flag_true_if_should_flip$[rsp]
  00008	89 05 00 00 00
	00		 mov	 DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA, eax

; 1099 : }

  0000e	c3		 ret	 0
stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 8
stbi_convert_iphone_png_to_rgb PROC

; 4947 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4948 :     stbi__de_iphone_flag_global = flag_true_if_should_convert;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR flag_true_if_should_convert$[rsp]
  00008	89 05 00 00 00
	00		 mov	 DWORD PTR ?stbi__de_iphone_flag_global@@3HA, eax

; 4949 : }

  0000e	c3		 ret	 0
stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 8
stbi_set_unpremultiply_on_load PROC

; 4942 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4943 :     stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
  00008	89 05 00 00 00
	00		 mov	 DWORD PTR ?stbi__unpremultiply_on_load_global@@3HA, eax

; 4944 : }

  0000e	c3		 ret	 0
stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
pos$ = 32
r$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
stbi_is_16_bit_from_file PROC

; 7632 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7633 :     int r;
; 7634 :     stbi__context s;
; 7635 :     long pos = ftell(f);

  0001e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00026	e8 00 00 00 00	 call	 ftell
  0002b	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 7636 :     stbi__start_file(&s, f);

  0002f	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003c	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 7637 :     r = stbi__is_16_main(&s);

  00041	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00046	e8 00 00 00 00	 call	 ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ; stbi__is_16_main
  0004b	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 7638 :     fseek(f,pos,SEEK_SET);

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  00056	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0005e	e8 00 00 00 00	 call	 fseek

; 7639 :     return r;

  00063	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]

; 7640 : }

  00067	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006f	48 33 cc	 xor	 rcx, rsp
  00072	e8 00 00 00 00	 call	 __security_check_cookie
  00077	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0007e	c3		 ret	 0
stbi_is_16_bit_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
stbi_is_16_bit PROC

; 7622 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7623 :     FILE *f = stbi__fopen(filename, "rb");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41181
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  0001a	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 7624 :     int result;
; 7625 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  0001f	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  00025	75 0e		 jne	 SHORT $LN2@stbi_is_16
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41183
  0002e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00033	eb 1c		 jmp	 SHORT $LN1@stbi_is_16
$LN2@stbi_is_16:

; 7626 :     result = stbi_is_16_bit_from_file(f);

  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  0003a	e8 00 00 00 00	 call	 stbi_is_16_bit_from_file
  0003f	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 7627 :     fclose(f);

  00043	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00048	e8 00 00 00 00	 call	 fclose

; 7628 :     return result;

  0004d	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi_is_16:

; 7629 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
stbi_is_16_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
pos$ = 32
r$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
x$ = 312
y$ = 320
comp$ = 328
stbi_info_from_file PROC

; 7611 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7612 :     int r;
; 7613 :     stbi__context s;
; 7614 :     long pos = ftell(f);

  0002d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00035	e8 00 00 00 00	 call	 ftell
  0003a	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 7615 :     stbi__start_file(&s, f);

  0003e	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00046	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 7616 :     r = stbi__info_main(&s,x,y,comp);

  00050	4c 8b 8c 24 48
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00058	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00060	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00068	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006d	e8 00 00 00 00	 call	 ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main
  00072	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 7617 :     fseek(f,pos,SEEK_SET);

  00076	45 33 c0	 xor	 r8d, r8d
  00079	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  0007d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00085	e8 00 00 00 00	 call	 fseek

; 7618 :     return r;

  0008a	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]

; 7619 : }

  0008e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00096	48 33 cc	 xor	 rcx, rsp
  00099	e8 00 00 00 00	 call	 __security_check_cookie
  0009e	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  000a5	c3		 ret	 0
stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi_info PROC

; 7601 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7602 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41164
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 7603 :     int result;
; 7604 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 0e		 jne	 SHORT $LN2@stbi_info
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41166
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	eb 2b		 jmp	 SHORT $LN1@stbi_info
$LN2@stbi_info:

; 7605 :     result = stbi_info_from_file(f, x, y, comp);

  00044	4c 8b 4c 24 58	 mov	 r9, QWORD PTR comp$[rsp]
  00049	4c 8b 44 24 50	 mov	 r8, QWORD PTR y$[rsp]
  0004e	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00058	e8 00 00 00 00	 call	 stbi_info_from_file
  0005d	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 7606 :     fclose(f);

  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00066	e8 00 00 00 00	 call	 fclose

; 7607 :     return result;

  0006b	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi_info:

; 7608 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
c$ = 288
user$ = 296
stbi_is_16_bit_from_callbacks PROC

; 7665 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7666 :     stbi__context s;
; 7667 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

  00023	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0002b	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00038	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 7668 :     return stbi__is_16_main(&s);

  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ; stbi__is_16_main

; 7669 : }

  00047	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004f	48 33 cc	 xor	 rcx, rsp
  00052	e8 00 00 00 00	 call	 __security_check_cookie
  00057	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005e	c3		 ret	 0
stbi_is_16_bit_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
stbi_is_16_bit_from_memory PROC

; 7658 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7659 :     stbi__context s;
; 7660 :     stbi__start_mem(&s,buffer,len);

  00022	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0002a	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 7661 :     return stbi__is_16_main(&s);

  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ; stbi__is_16_main

; 7662 : }

  00046	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004e	48 33 cc	 xor	 rcx, rsp
  00051	e8 00 00 00 00	 call	 __security_check_cookie
  00056	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005d	c3		 ret	 0
stbi_is_16_bit_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
c$ = 288
user$ = 296
x$ = 304
y$ = 312
comp$ = 320
stbi_info_from_callbacks PROC

; 7651 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7652 :     stbi__context s;
; 7653 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

  0002d	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 7654 :     return stbi__info_main(&s,x,y,comp);

  00047	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00057	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main

; 7655 : }

  00069	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00071	48 33 cc	 xor	 rcx, rsp
  00074	e8 00 00 00 00	 call	 __security_check_cookie
  00079	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00080	c3		 ret	 0
stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
x$ = 304
y$ = 312
comp$ = 320
stbi_info_from_memory PROC

; 7644 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7645 :     stbi__context s;
; 7646 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 7647 :     return stbi__info_main(&s,x,y,comp);

  00046	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004e	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00056	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main

; 7648 : }

  00068	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00070	48 33 cc	 xor	 rcx, rsp
  00073	e8 00 00 00 00	 call	 __security_check_cookie
  00078	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0007f	c3		 ret	 0
stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
retval_from_stbi_load$ = 48
stbi_image_free PROC

; 1082 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1083 :     STBI_FREE(retval_from_stbi_load);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retval_from_stbi_load$[rsp]
  0000e	e8 00 00 00 00	 call	 free

; 1084 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
stbi_failure_reason PROC

; 971  :     return stbi__g_failure_reason;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
  00005	8b c0		 mov	 eax, eax
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0000d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00016	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001a	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]

; 972  : }

  0001e	c3		 ret	 0
stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
pos$ = 32
res$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
stbi_is_hdr_from_file PROC

; 1523 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1524 : #ifndef STBI_NO_HDR
; 1525 :     long pos = ftell(f);

  0001e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00026	e8 00 00 00 00	 call	 ftell
  0002b	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 1526 :     int res;
; 1527 :     stbi__context s;
; 1528 :     stbi__start_file(&s,f);

  0002f	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003c	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1529 :     res = stbi__hdr_test(&s);

  00041	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00046	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  0004b	89 44 24 24	 mov	 DWORD PTR res$[rsp], eax

; 1530 :     fseek(f, pos, SEEK_SET);

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  00056	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0005e	e8 00 00 00 00	 call	 fseek

; 1531 :     return res;

  00063	8b 44 24 24	 mov	 eax, DWORD PTR res$[rsp]

; 1532 : #else
; 1533 :     STBI_NOTUSED(f);
; 1534 :     return 0;
; 1535 : #endif
; 1536 : }

  00067	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006f	48 33 cc	 xor	 rcx, rsp
  00072	e8 00 00 00 00	 call	 __security_check_cookie
  00077	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0007e	c3		 ret	 0
stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
stbi_is_hdr PROC

; 1512 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1513 :     FILE *f = stbi__fopen(filename, "rb");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG35701
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  0001a	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 1514 :     int result=0;

  0001f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 1515 :     if (f) {

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  0002d	74 18		 je	 SHORT $LN2@stbi_is_hd

; 1516 :         result = stbi_is_hdr_from_file(f);

  0002f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00034	e8 00 00 00 00	 call	 stbi_is_hdr_from_file
  00039	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 1517 :         fclose(f);

  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00042	e8 00 00 00 00	 call	 fclose
$LN2@stbi_is_hd:

; 1518 :     }
; 1519 :     return result;

  00047	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 1520 : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
stbi_is_hdr_from_memory PROC

; 1498 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1499 : #ifndef STBI_NO_HDR
; 1500 :     stbi__context s;
; 1501 :     stbi__start_mem(&s,buffer,len);

  00022	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0002a	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1502 :     return stbi__hdr_test(&s);

  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1503 : #else
; 1504 :     STBI_NOTUSED(buffer);
; 1505 :     STBI_NOTUSED(len);
; 1506 :     return 0;
; 1507 : #endif
; 1508 : }

  00046	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004e	48 33 cc	 xor	 rcx, rsp
  00051	e8 00 00 00 00	 call	 __security_check_cookie
  00056	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005d	c3		 ret	 0
stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
clbk$ = 288
user$ = 296
stbi_is_hdr_from_callbacks PROC

; 1540 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1541 : #ifndef STBI_NO_HDR
; 1542 :     stbi__context s;
; 1543 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00023	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0002b	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00038	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1544 :     return stbi__hdr_test(&s);

  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1545 : #else
; 1546 :     STBI_NOTUSED(clbk);
; 1547 :     STBI_NOTUSED(user);
; 1548 :     return 0;
; 1549 : #endif
; 1550 : }

  00047	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004f	48 33 cc	 xor	 rcx, rsp
  00052	e8 00 00 00 00	 call	 __security_check_cookie
  00057	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005e	c3		 ret	 0
stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
scale$ = 8
stbi_ldr_to_hdr_scale PROC

; 1556 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR scale$[rsp]
  0000c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__l2h_scale@@3MA, xmm0
  00014	c3		 ret	 0
stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
gamma$ = 8
stbi_ldr_to_hdr_gamma PROC

; 1555 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR gamma$[rsp]
  0000c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__l2h_gamma@@3MA, xmm0
  00014	c3		 ret	 0
stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
scale$ = 8
stbi_hdr_to_ldr_scale PROC

; 1562 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000e	f3 0f 5e 44 24
	08		 divss	 xmm0, DWORD PTR scale$[rsp]
  00014	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__h2l_scale_i@@3MA, xmm0
  0001c	c3		 ret	 0
stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
gamma$ = 8
stbi_hdr_to_ldr_gamma PROC

; 1561 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000e	f3 0f 5e 44 24
	08		 divss	 xmm0, DWORD PTR gamma$[rsp]
  00014	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__h2l_gamma_i@@3MA, xmm0
  0001c	c3		 ret	 0
stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
f$ = 304
x$ = 312
y$ = 320
comp$ = 328
req_comp$ = 336
stbi_loadf_from_file PROC

; 1484 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1485 :     stbi__context s;
; 1486 :     stbi__start_file(&s,f);

  0002d	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00035	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1487 :     return stbi__loadf_main(&s,x,y,comp,req_comp);

  0003f	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 48
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00062	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1488 : }

  0006c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00074	48 33 cc	 xor	 rcx, rsp
  00077	e8 00 00 00 00	 call	 __security_check_cookie
  0007c	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00083	c3		 ret	 0
stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv71 = 48
f$ = 56
result$ = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_loadf PROC

; 1474 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1475 :     float *result;
; 1476 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG35680
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1477 :     if (!f) return stbi__errpf("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 29		 jne	 SHORT $LN2@stbi_loadf
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35682
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN4@stbi_loadf
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004e	eb 08		 jmp	 SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
  00050	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@stbi_loadf:
  00058	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv71[rsp]
  0005d	eb 38		 jmp	 SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 1478 :     result = stbi_loadf_from_file(f,x,y,comp,req_comp);

  0005f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00066	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0006f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00074	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00079	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi_loadf_from_file
  00083	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1479 :     fclose(f);

  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 fclose

; 1480 :     return result;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_loadf:

; 1481 : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_loadf_from_callbacks PROC

; 1466 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1467 :     stbi__context s;
; 1468 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  0002d	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1469 :     return stbi__loadf_main(&s,x,y,comp,req_comp);

  00047	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0005a	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00062	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1470 : }

  00074	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008b	c3		 ret	 0
stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_loadf_from_memory PROC

; 1459 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1460 :     stbi__context s;
; 1461 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1462 :     return stbi__loadf_main(&s,x,y,comp,req_comp);

  00046	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00059	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00061	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1463 : }

  00073	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007b	48 33 cc	 xor	 rcx, rsp
  0007e	e8 00 00 00 00	 call	 __security_check_cookie
  00083	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008a	c3		 ret	 0
stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 64
__$ArrayPad$ = 288
f$ = 320
x$ = 328
y$ = 336
comp$ = 344
req_comp$ = 352
stbi_load_from_file_16 PROC

; 1370 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1371 :     stbi__uint16 *result;
; 1372 :     stbi__context s;
; 1373 :     stbi__start_file(&s,f);

  0002d	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00035	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1374 :     result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);

  0003f	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 58
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_16bit
  0006c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1375 :     if (result) {

  00071	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	74 2d		 je	 SHORT $LN2@stbi_load_

; 1376 :         // need to 'unget' all the characters in the IO buffer
; 1377 :         fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

  00079	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp+192]
  00081	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp+200]
  00089	48 2b c8	 sub	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	f7 d8		 neg	 eax
  00091	41 b8 01 00 00
	00		 mov	 r8d, 1
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000a1	e8 00 00 00 00	 call	 fseek
$LN2@stbi_load_:

; 1378 :     }
; 1379 :     return result;

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1380 : }

  000ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b3	48 33 cc	 xor	 rcx, rsp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000c2	c3		 ret	 0
stbi_load_from_file_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv71 = 48
f$ = 56
result$ = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_load_16 PROC

; 1383 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1384 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG35579
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1385 :     stbi__uint16 *result;
; 1386 :     if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 29		 jne	 SHORT $LN2@stbi_load_
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35581
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN4@stbi_load_
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004e	eb 08		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  00050	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@stbi_load_:
  00058	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv71[rsp]
  0005d	eb 38		 jmp	 SHORT $LN1@stbi_load_
$LN2@stbi_load_:

; 1387 :     result = stbi_load_from_file_16(f,x,y,comp,req_comp);

  0005f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00066	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0006f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00074	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00079	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi_load_from_file_16
  00083	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1388 :     fclose(f);

  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 fclose

; 1389 :     return result;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_load_:

; 1390 : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
stbi_load_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
channels_in_file$ = 336
desired_channels$ = 344
stbi_load_16_from_callbacks PROC

; 1403 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1404 :     stbi__context s;
; 1405 :     stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);

  0002d	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1406 :     return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

  00047	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR desired_channels$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR channels_in_file$[rsp]
  0005a	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00062	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_16bit

; 1407 : }

  00074	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008b	c3		 ret	 0
stbi_load_16_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
channels_in_file$ = 336
desired_channels$ = 344
stbi_load_16_from_memory PROC

; 1396 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1397 :     stbi__context s;
; 1398 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1399 :     return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

  00046	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR desired_channels$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR channels_in_file$[rsp]
  00059	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00061	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_16bit

; 1400 : }

  00073	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007b	48 33 cc	 xor	 rcx, rsp
  0007e	e8 00 00 00 00	 call	 __security_check_cookie
  00083	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008a	c3		 ret	 0
stbi_load_16_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv88 = 64
result$ = 72
s$ = 80
__$ArrayPad$ = 304
buffer$ = 336
len$ = 344
delays$ = 352
x$ = 360
y$ = 368
z$ = 376
comp$ = 384
req_comp$ = 392
stbi_load_gif_from_memory PROC

; 1425 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1426 :     unsigned char *result;
; 1427 :     stbi__context s;
; 1428 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1429 :     
; 1430 :     result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);

  00046	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00051	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00059	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006b	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR y$[rsp]
  00073	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR x$[rsp]
  0007b	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR delays$[rsp]
  00083	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  00088	e8 00 00 00 00	 call	 ?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z ; stbi__load_gif_main
  0008d	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 1431 :     if (stbi__vertically_flip_on_load) {

  00092	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  00097	8b c0		 mov	 eax, eax
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0009f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000ac	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  000b0	74 23		 je	 SHORT $LN4@stbi_load_
  000b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  000b7	8b c0		 mov	 eax, eax
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000cc	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  000cf	89 44 24 40	 mov	 DWORD PTR tv88[rsp], eax
  000d3	eb 0a		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  000d5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  000db	89 44 24 40	 mov	 DWORD PTR tv88[rsp], eax
$LN5@stbi_load_:
  000df	83 7c 24 40 00	 cmp	 DWORD PTR tv88[rsp], 0
  000e4	74 38		 je	 SHORT $LN2@stbi_load_

; 1432 :         stbi__vertical_flip_slices( result, *x, *y, *z, *comp );

  000e6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000ee	8b 00		 mov	 eax, DWORD PTR [rax]
  000f0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f4	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000fc	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  000ff	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00107	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0010a	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00112	8b 10		 mov	 edx, DWORD PTR [rax]
  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00119	e8 00 00 00 00	 call	 ?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z ; stbi__vertical_flip_slices
$LN2@stbi_load_:

; 1433 :     }
; 1434 :     
; 1435 :     return result;

  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]

; 1436 : }

  00123	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012b	48 33 cc	 xor	 rcx, rsp
  0012e	e8 00 00 00 00	 call	 __security_check_cookie
  00133	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0013a	c3		 ret	 0
stbi_load_gif_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 64
__$ArrayPad$ = 288
f$ = 320
x$ = 328
y$ = 336
comp$ = 344
req_comp$ = 352
stbi_load_from_file PROC

; 1357 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1358 :     unsigned char *result;
; 1359 :     stbi__context s;
; 1360 :     stbi__start_file(&s,f);

  0002d	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00035	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1361 :     result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  0003f	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 58
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
  0006c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1362 :     if (result) {

  00071	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	74 2d		 je	 SHORT $LN2@stbi_load_

; 1363 :         // need to 'unget' all the characters in the IO buffer
; 1364 :         fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

  00079	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp+192]
  00081	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp+200]
  00089	48 2b c8	 sub	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	f7 d8		 neg	 eax
  00091	41 b8 01 00 00
	00		 mov	 r8d, 1
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000a1	e8 00 00 00 00	 call	 fseek
$LN2@stbi_load_:

; 1365 :     }
; 1366 :     return result;

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1367 : }

  000ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b3	48 33 cc	 xor	 rcx, rsp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000c2	c3		 ret	 0
stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
tv71 = 48
f$ = 56
result$ = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_load PROC

; 1347 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1348 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG35542
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1349 :     unsigned char *result;
; 1350 :     if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 29		 jne	 SHORT $LN2@stbi_load
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG35544
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN4@stbi_load
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004e	eb 08		 jmp	 SHORT $LN5@stbi_load
$LN4@stbi_load:
  00050	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@stbi_load:
  00058	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv71[rsp]
  0005d	eb 38		 jmp	 SHORT $LN1@stbi_load
$LN2@stbi_load:

; 1351 :     result = stbi_load_from_file(f,x,y,comp,req_comp);

  0005f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00066	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0006f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00074	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00079	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi_load_from_file
  00083	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1352 :     fclose(f);

  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 fclose

; 1353 :     return result;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_load:

; 1354 : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_load_from_callbacks PROC

; 1417 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1418 :     stbi__context s;
; 1419 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  0002d	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1420 :     return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  00047	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0005a	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00062	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit

; 1421 : }

  00074	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008b	c3		 ret	 0
stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_load_from_memory PROC

; 1410 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1411 :     stbi__context s;
; 1412 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1413 :     return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  00046	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00059	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00061	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit

; 1414 : }

  00073	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007b	48 33 cc	 xor	 rcx, rsp
  0007e	e8 00 00 00 00	 call	 __security_check_cookie
  00083	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008a	c3		 ret	 0
stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_ui.cpp
_TEXT	SEGMENT
Hovered$ = 80
StringSpacing$ = 84
StringWidth$ = 88
OutlineZ$1 = 92
OutlineWidth$2 = 96
$T3 = 112
$T4 = 128
$T5 = 144
$T6 = 160
$T7 = 176
$T8 = 192
$T9 = 208
$T10 = 224
$T11 = 240
$T12 = 256
$T13 = 320
$T14 = 384
$T15 = 448
TogglePosition$16 = 512
$T17 = 520
TopRight$ = 528
BoxBottomLeft$ = 536
BoxTopRight$ = 544
BottomLeft$ = 552
StringPos$ = 560
OutlineColor$18 = 568
$T19 = 584
$T20 = 600
$T21 = 616
$T22 = 632
Transform$23 = 656
Constants$24 = 720
$T25 = 816
$T26 = 880
__$ArrayPad$ = 944
Position$ = 992
BoxDimension$ = 1000
Thickness$ = 1008
Text$ = 1016
Font$ = 1024
Color$ = 1032
StringColor$ = 1040
Projection$ = 1048
Z$ = 1056
IsHoverable$ = 1064
IsSelected$ = 1072
IsToggled$ = 1080
?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z PROC ; UIToggle

; 214  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 81 ec c8 03
	00 00		 sub	 rsp, 968		; 000003c8H
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c4	 xor	 rax, rsp
  00028	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 215  :     v2 BoxBottomLeft = { Position.x, Position.y + BoxDimension.y };

  00030	f3 0f 10 84 24
	e0 03 00 00	 movss	 xmm0, DWORD PTR Position$[rsp]
  00039	f3 0f 11 84 24
	18 02 00 00	 movss	 DWORD PTR BoxBottomLeft$[rsp], xmm0
  00042	f3 0f 10 84 24
	e4 03 00 00	 movss	 xmm0, DWORD PTR Position$[rsp+4]
  0004b	f3 0f 58 84 24
	ec 03 00 00	 addss	 xmm0, DWORD PTR BoxDimension$[rsp+4]
  00054	f3 0f 11 84 24
	1c 02 00 00	 movss	 DWORD PTR BoxBottomLeft$[rsp+4], xmm0

; 216  :     v2 BoxTopRight = { Position.x + BoxDimension.x, Position.y };

  0005d	f3 0f 10 84 24
	e0 03 00 00	 movss	 xmm0, DWORD PTR Position$[rsp]
  00066	f3 0f 58 84 24
	e8 03 00 00	 addss	 xmm0, DWORD PTR BoxDimension$[rsp]
  0006f	f3 0f 11 84 24
	20 02 00 00	 movss	 DWORD PTR BoxTopRight$[rsp], xmm0
  00078	f3 0f 10 84 24
	e4 03 00 00	 movss	 xmm0, DWORD PTR Position$[rsp+4]
  00081	f3 0f 11 84 24
	24 02 00 00	 movss	 DWORD PTR BoxTopRight$[rsp+4], xmm0

; 217  :     if(IsToggled && !State->DevMode)

  0008a	83 bc 24 38 04
	00 00 00	 cmp	 DWORD PTR IsToggled$[rsp], 0
  00092	0f 84 79 02 00
	00		 je	 $LN2@UIToggle
  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0009f	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  000a6	0f 85 65 02 00
	00		 jne	 $LN2@UIToggle

; 218  :     {
; 219  :         v2 TogglePosition = { BoxBottomLeft.x + BoxDimension.x/2.0f, BoxTopRight.y + BoxDimension.y/2.0f };

  000ac	f3 0f 10 84 24
	e8 03 00 00	 movss	 xmm0, DWORD PTR BoxDimension$[rsp]
  000b5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000bd	f3 0f 10 8c 24
	18 02 00 00	 movss	 xmm1, DWORD PTR BoxBottomLeft$[rsp]
  000c6	f3 0f 58 c8	 addss	 xmm1, xmm0
  000ca	0f 28 c1	 movaps	 xmm0, xmm1
  000cd	f3 0f 11 84 24
	00 02 00 00	 movss	 DWORD PTR TogglePosition$16[rsp], xmm0
  000d6	f3 0f 10 84 24
	ec 03 00 00	 movss	 xmm0, DWORD PTR BoxDimension$[rsp+4]
  000df	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000e7	f3 0f 10 8c 24
	24 02 00 00	 movss	 xmm1, DWORD PTR BoxTopRight$[rsp+4]
  000f0	f3 0f 58 c8	 addss	 xmm1, xmm0
  000f4	0f 28 c1	 movaps	 xmm0, xmm1
  000f7	f3 0f 11 84 24
	04 02 00 00	 movss	 DWORD PTR TogglePosition$16[rsp+4], xmm0

; 220  :         
; 221  :         mat4 Transform = Mat4Identity();

  00100	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  00108	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  0010d	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00115	48 8b f9	 mov	 rdi, rcx
  00118	48 8b f0	 mov	 rsi, rax
  0011b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00120	f3 a4		 rep movsb
  00122	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR Transform$23[rsp]
  0012a	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00132	48 8b f8	 mov	 rdi, rax
  00135	48 8b f1	 mov	 rsi, rcx
  00138	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0013d	f3 a4		 rep movsb

; 222  :         TranslateMat4(&Transform, V3(TogglePosition, 0.0f));

  0013f	0f 57 d2	 xorps	 xmm2, xmm2
  00142	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR TogglePosition$16[rsp]
  0014a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00152	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@Tv2@@M@Z	; V3
  00157	48 8d 8c 24 58
	02 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  0015f	48 8b f9	 mov	 rdi, rcx
  00162	48 8b f0	 mov	 rsi, rax
  00165	b9 0c 00 00 00	 mov	 ecx, 12
  0016a	f3 a4		 rep movsb
  0016c	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  00174	48 8d 8c 24 58
	02 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  0017c	48 8b f8	 mov	 rdi, rax
  0017f	48 8b f1	 mov	 rsi, rcx
  00182	b9 0c 00 00 00	 mov	 ecx, 12
  00187	f3 a4		 rep movsb
  00189	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  00191	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR Transform$23[rsp]
  00199	e8 00 00 00 00	 call	 ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z ; TranslateMat4

; 223  :         ScaleMat4(&Transform, V3(BoxDimension / 2.0f, 1.0f));

  0019e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  001a6	48 8b 8c 24 e8
	03 00 00	 mov	 rcx, QWORD PTR BoxDimension$[rsp]
  001ae	e8 00 00 00 00	 call	 ??K@YA?ATv2@@T0@M@Z	; operator/
  001b3	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR $T17[rsp], rax
  001bb	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  001c3	48 8b 94 24 08
	02 00 00	 mov	 rdx, QWORD PTR $T17[rsp]
  001cb	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  001d3	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@Tv2@@M@Z	; V3
  001d8	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  001e0	48 8b f9	 mov	 rdi, rcx
  001e3	48 8b f0	 mov	 rsi, rax
  001e6	b9 0c 00 00 00	 mov	 ecx, 12
  001eb	f3 a4		 rep movsb
  001ed	48 8d 44 24 70	 lea	 rax, QWORD PTR $T3[rsp]
  001f2	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  001fa	48 8b f8	 mov	 rdi, rax
  001fd	48 8b f1	 mov	 rsi, rcx
  00200	b9 0c 00 00 00	 mov	 ecx, 12
  00205	f3 a4		 rep movsb
  00207	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  0020c	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR Transform$23[rsp]
  00214	e8 00 00 00 00	 call	 ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z ; ScaleMat4

; 224  :         
; 225  :         ui_shader_constants Constants;
; 226  :         Constants.M = Transform * *Projection;

  00219	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  00221	48 8b f8	 mov	 rdi, rax
  00224	48 8b b4 24 18
	04 00 00	 mov	 rsi, QWORD PTR Projection$[rsp]
  0022c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00231	f3 a4		 rep movsb
  00233	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR $T13[rsp]
  0023b	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR Transform$23[rsp]
  00243	48 8b f8	 mov	 rdi, rax
  00246	48 8b f1	 mov	 rsi, rcx
  00249	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0024e	f3 a4		 rep movsb
  00250	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR $T12[rsp]
  00258	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  00260	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00268	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  0026d	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  00275	48 8b f9	 mov	 rdi, rcx
  00278	48 8b f0	 mov	 rsi, rax
  0027b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00280	f3 a4		 rep movsb
  00282	48 8d 84 24 e0
	02 00 00	 lea	 rax, QWORD PTR Constants$24[rsp+16]
  0028a	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  00292	48 8b f8	 mov	 rdi, rax
  00295	48 8b f1	 mov	 rsi, rcx
  00298	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0029d	f3 a4		 rep movsb

; 227  :         Constants.Color = Color;

  0029f	48 8d 84 24 d0
	02 00 00	 lea	 rax, QWORD PTR Constants$24[rsp]
  002a7	48 8b f8	 mov	 rdi, rax
  002aa	48 8b b4 24 08
	04 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  002b2	b9 10 00 00 00	 mov	 ecx, 16
  002b7	f3 a4		 rep movsb

; 228  :         Constants.Z = Z;

  002b9	f3 0f 10 84 24
	20 04 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  002c2	f3 0f 11 84 24
	20 03 00 00	 movss	 DWORD PTR Constants$24[rsp+80], xmm0

; 229  :         Platform->RenderMesh(State->Quad, State->BasicTexture, State->UIShader, &Constants, true);

  002cb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  002d3	4c 8d 8c 24 d0
	02 00 00	 lea	 r9, QWORD PTR Constants$24[rsp]
  002db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  002e2	4c 8b 80 18 01
	00 00		 mov	 r8, QWORD PTR [rax+280]
  002e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  002f0	48 8b 90 08 01
	00 00		 mov	 rdx, QWORD PTR [rax+264]
  002f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  002fe	48 8b 88 00 01
	00 00		 mov	 rcx, QWORD PTR [rax+256]
  00305	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0030c	ff 50 50	 call	 QWORD PTR [rax+80]

; 230  :     }

  0030f	eb 5c		 jmp	 SHORT $LN3@UIToggle
$LN2@UIToggle:

; 231  :     else
; 232  :     {
; 233  :         RenderBox(BoxBottomLeft, BoxTopRight, Color, Thickness, Projection, Z);

  00311	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  00319	48 8b f8	 mov	 rdi, rax
  0031c	48 8b b4 24 08
	04 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  00324	b9 10 00 00 00	 mov	 ecx, 16
  00329	f3 a4		 rep movsb
  0032b	f3 0f 10 84 24
	20 04 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  00334	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0033a	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR Projection$[rsp]
  00342	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00347	f3 0f 10 9c 24
	f0 03 00 00	 movss	 xmm3, DWORD PTR Thickness$[rsp]
  00350	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR $T7[rsp]
  00358	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR BoxTopRight$[rsp]
  00360	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR BoxBottomLeft$[rsp]
  00368	e8 00 00 00 00	 call	 ?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z ; RenderBox
$LN3@UIToggle:

; 234  :     }
; 235  :     
; 236  :     f32 StringSpacing = Thickness/2.0f;

  0036d	f3 0f 10 84 24
	f0 03 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  00376	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0037e	f3 0f 11 44 24
	54		 movss	 DWORD PTR StringSpacing$[rsp], xmm0

; 237  :     v2 StringPos;
; 238  :     StringPos.x = BoxTopRight.x + StringSpacing;

  00384	f3 0f 10 84 24
	20 02 00 00	 movss	 xmm0, DWORD PTR BoxTopRight$[rsp]
  0038d	f3 0f 58 44 24
	54		 addss	 xmm0, DWORD PTR StringSpacing$[rsp]
  00393	f3 0f 11 84 24
	30 02 00 00	 movss	 DWORD PTR StringPos$[rsp], xmm0

; 239  :     StringPos.y = BoxBottomLeft.y - Font->CharacterHeight/4.0f;

  0039c	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR Font$[rsp]
  003a4	f3 0f 10 80 10
	03 00 00	 movss	 xmm0, DWORD PTR [rax+784]
  003ac	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  003b4	f3 0f 10 8c 24
	1c 02 00 00	 movss	 xmm1, DWORD PTR BoxBottomLeft$[rsp+4]
  003bd	f3 0f 5c c8	 subss	 xmm1, xmm0
  003c1	0f 28 c1	 movaps	 xmm0, xmm1
  003c4	f3 0f 11 84 24
	34 02 00 00	 movss	 DWORD PTR StringPos$[rsp+4], xmm0

; 240  :     
; 241  :     f32 StringWidth;
; 242  :     UIString(StringPos, Text, Font, StringColor, Projection, Z, false, false, &StringWidth);

  003cd	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  003d5	48 8b f8	 mov	 rdi, rax
  003d8	48 8b b4 24 10
	04 00 00	 mov	 rsi, QWORD PTR StringColor$[rsp]
  003e0	b9 10 00 00 00	 mov	 ecx, 16
  003e5	f3 a4		 rep movsb
  003e7	48 8d 44 24 58	 lea	 rax, QWORD PTR StringWidth$[rsp]
  003ec	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  003f1	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  003f9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00401	f3 0f 10 84 24
	20 04 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  0040a	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00410	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR Projection$[rsp]
  00418	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041d	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR $T6[rsp]
  00425	4c 8b 84 24 00
	04 00 00	 mov	 r8, QWORD PTR Font$[rsp]
  0042d	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR Text$[rsp]
  00435	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR StringPos$[rsp]
  0043d	e8 00 00 00 00	 call	 ?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z ; UIString

; 243  :     
; 244  :     b32 Hovered = false;

  00442	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR Hovered$[rsp], 0

; 245  :     v2 BottomLeft = {0};

  0044a	0f 57 c0	 xorps	 xmm0, xmm0
  0044d	f3 0f 11 84 24
	28 02 00 00	 movss	 DWORD PTR BottomLeft$[rsp], xmm0
  00456	48 8d 84 24 2c
	02 00 00	 lea	 rax, QWORD PTR BottomLeft$[rsp+4]
  0045e	48 8b f8	 mov	 rdi, rax
  00461	33 c0		 xor	 eax, eax
  00463	b9 04 00 00 00	 mov	 ecx, 4
  00468	f3 aa		 rep stosb

; 246  :     v2 TopRight = {0};

  0046a	0f 57 c0	 xorps	 xmm0, xmm0
  0046d	f3 0f 11 84 24
	10 02 00 00	 movss	 DWORD PTR TopRight$[rsp], xmm0
  00476	48 8d 84 24 14
	02 00 00	 lea	 rax, QWORD PTR TopRight$[rsp+4]
  0047e	48 8b f8	 mov	 rdi, rax
  00481	33 c0		 xor	 eax, eax
  00483	b9 04 00 00 00	 mov	 ecx, 4
  00488	f3 aa		 rep stosb

; 247  :     if(IsHoverable)

  0048a	83 bc 24 28 04
	00 00 00	 cmp	 DWORD PTR IsHoverable$[rsp], 0
  00492	0f 84 a2 00 00
	00		 je	 $LN4@UIToggle

; 248  :     {
; 249  :         BottomLeft = BoxBottomLeft;

  00498	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR BoxBottomLeft$[rsp]
  004a0	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR BottomLeft$[rsp], rax

; 250  :         TopRight.x = StringPos.x + StringWidth;

  004a8	f3 0f 10 84 24
	30 02 00 00	 movss	 xmm0, DWORD PTR StringPos$[rsp]
  004b1	f3 0f 58 44 24
	58		 addss	 xmm0, DWORD PTR StringWidth$[rsp]
  004b7	f3 0f 11 84 24
	10 02 00 00	 movss	 DWORD PTR TopRight$[rsp], xmm0

; 251  :         TopRight.y = BoxTopRight.y;

  004c0	f3 0f 10 84 24
	24 02 00 00	 movss	 xmm0, DWORD PTR BoxTopRight$[rsp+4]
  004c9	f3 0f 11 84 24
	14 02 00 00	 movss	 DWORD PTR TopRight$[rsp+4], xmm0

; 252  :         
; 253  :         if(Input->Mouse.X > BottomLeft.x && Input->Mouse.X < TopRight.x &&
; 254  :            Input->Mouse.Y < BottomLeft.y && Input->Mouse.Y > TopRight.y)

  004d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  004d9	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  004de	0f 2f 84 24 28
	02 00 00	 comiss	 xmm0, DWORD PTR BottomLeft$[rsp]
  004e6	76 52		 jbe	 SHORT $LN5@UIToggle
  004e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  004ef	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  004f4	f3 0f 10 8c 24
	10 02 00 00	 movss	 xmm1, DWORD PTR TopRight$[rsp]
  004fd	0f 2f c8	 comiss	 xmm1, xmm0
  00500	76 38		 jbe	 SHORT $LN5@UIToggle
  00502	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00509	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  0050e	f3 0f 10 8c 24
	2c 02 00 00	 movss	 xmm1, DWORD PTR BottomLeft$[rsp+4]
  00517	0f 2f c8	 comiss	 xmm1, xmm0
  0051a	76 1e		 jbe	 SHORT $LN5@UIToggle
  0051c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00523	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  00528	0f 2f 84 24 14
	02 00 00	 comiss	 xmm0, DWORD PTR TopRight$[rsp+4]
  00530	76 08		 jbe	 SHORT $LN5@UIToggle

; 255  :         {
; 256  :             Hovered = true;

  00532	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR Hovered$[rsp], 1
$LN5@UIToggle:
$LN4@UIToggle:

; 257  :         }
; 258  :     }
; 259  :     
; 260  :     if(State->DevMode && (Hovered || IsSelected))

  0053a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00541	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  00548	0f 84 98 01 00
	00		 je	 $LN6@UIToggle
  0054e	83 7c 24 50 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  00553	75 0e		 jne	 SHORT $LN7@UIToggle
  00555	83 bc 24 30 04
	00 00 00	 cmp	 DWORD PTR IsSelected$[rsp], 0
  0055d	0f 84 83 01 00
	00		 je	 $LN6@UIToggle
$LN7@UIToggle:

; 261  :     {
; 262  :         v4 OutlineColor = {0};

  00563	0f 57 c0	 xorps	 xmm0, xmm0
  00566	f3 0f 11 84 24
	38 02 00 00	 movss	 DWORD PTR OutlineColor$18[rsp], xmm0
  0056f	48 8d 84 24 3c
	02 00 00	 lea	 rax, QWORD PTR OutlineColor$18[rsp+4]
  00577	48 8b f8	 mov	 rdi, rax
  0057a	33 c0		 xor	 eax, eax
  0057c	b9 0c 00 00 00	 mov	 ecx, 12
  00581	f3 aa		 rep stosb

; 263  :         if(Hovered && !IsSelected)

  00583	83 7c 24 50 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  00588	74 6f		 je	 SHORT $LN8@UIToggle
  0058a	83 bc 24 30 04
	00 00 00	 cmp	 DWORD PTR IsSelected$[rsp], 0
  00592	75 65		 jne	 SHORT $LN8@UIToggle

; 264  :         {
; 265  :             OutlineColor = V4(0.8f, 0.8f, 0.8f, 1.0f);

  00594	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0059c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  005a2	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f4ccccd
  005aa	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f4ccccd
  005b2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f4ccccd
  005ba	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  005c2	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  005c7	48 8d 8c 24 68
	02 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  005cf	48 8b f9	 mov	 rdi, rcx
  005d2	48 8b f0	 mov	 rsi, rax
  005d5	b9 10 00 00 00	 mov	 ecx, 16
  005da	f3 a4		 rep movsb
  005dc	48 8d 84 24 38
	02 00 00	 lea	 rax, QWORD PTR OutlineColor$18[rsp]
  005e4	48 8d 8c 24 68
	02 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  005ec	48 8b f8	 mov	 rdi, rax
  005ef	48 8b f1	 mov	 rsi, rcx
  005f2	b9 10 00 00 00	 mov	 ecx, 16
  005f7	f3 a4		 rep movsb
$LN8@UIToggle:

; 266  :         }
; 267  :         if(IsSelected)

  005f9	83 bc 24 30 04
	00 00 00	 cmp	 DWORD PTR IsSelected$[rsp], 0
  00601	74 65		 je	 SHORT $LN9@UIToggle

; 268  :         {
; 269  :             OutlineColor = V4(0.5f, 0.5f, 0.5f, 1.0f);

  00603	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0060b	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00611	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f000000
  00619	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  00621	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  00629	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  00631	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  00636	48 8d 8c 24 78
	02 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0063e	48 8b f9	 mov	 rdi, rcx
  00641	48 8b f0	 mov	 rsi, rax
  00644	b9 10 00 00 00	 mov	 ecx, 16
  00649	f3 a4		 rep movsb
  0064b	48 8d 84 24 38
	02 00 00	 lea	 rax, QWORD PTR OutlineColor$18[rsp]
  00653	48 8d 8c 24 78
	02 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0065b	48 8b f8	 mov	 rdi, rax
  0065e	48 8b f1	 mov	 rsi, rcx
  00661	b9 10 00 00 00	 mov	 ecx, 16
  00666	f3 a4		 rep movsb
$LN9@UIToggle:

; 270  :         }
; 271  :         
; 272  :         f32 OutlineWidth = 3.0f;

  00668	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00670	f3 0f 11 44 24
	60		 movss	 DWORD PTR OutlineWidth$2[rsp], xmm0

; 273  :         f32 OutlineZ = Z + 0.0001f;

  00676	f3 0f 10 84 24
	20 04 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  0067f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@38d1b717
  00687	f3 0f 11 44 24
	5c		 movss	 DWORD PTR OutlineZ$1[rsp], xmm0

; 274  :         
; 275  :         RenderBox(BottomLeft, TopRight, OutlineColor, OutlineWidth, Projection, OutlineZ);

  0068d	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00695	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR OutlineColor$18[rsp]
  0069d	48 8b f8	 mov	 rdi, rax
  006a0	48 8b f1	 mov	 rsi, rcx
  006a3	b9 10 00 00 00	 mov	 ecx, 16
  006a8	f3 a4		 rep movsb
  006aa	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR OutlineZ$1[rsp]
  006b0	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  006b6	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR Projection$[rsp]
  006be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006c3	f3 0f 10 5c 24
	60		 movss	 xmm3, DWORD PTR OutlineWidth$2[rsp]
  006c9	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR $T5[rsp]
  006d1	48 8b 94 24 10
	02 00 00	 mov	 rdx, QWORD PTR TopRight$[rsp]
  006d9	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR BottomLeft$[rsp]
  006e1	e8 00 00 00 00	 call	 ?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z ; RenderBox
$LN6@UIToggle:

; 276  :     }
; 277  :     
; 278  :     return(Hovered);

  006e6	8b 44 24 50	 mov	 eax, DWORD PTR Hovered$[rsp]

; 279  : }

  006ea	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006f2	48 33 cc	 xor	 rcx, rsp
  006f5	e8 00 00 00 00	 call	 __security_check_cookie
  006fa	48 81 c4 c8 03
	00 00		 add	 rsp, 968		; 000003c8H
  00701	5f		 pop	 rdi
  00702	5e		 pop	 rsi
  00703	c3		 ret	 0
?UIToggle@@YAHTv2@@0MPEADPEAUfont@@Tv4@@3PEATmat4@@MHHH@Z ENDP ; UIToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_ui.cpp
_TEXT	SEGMENT
Hovered$ = 80
tv87 = 84
OutlineZ$1 = 88
OutlineWidth$2 = 92
Mesh$3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
$T7 = 160
$T8 = 176
Image$ = 192
TopRight$ = 208
BottomLeft$ = 216
Quad$9 = 224
QuadPos$10 = 256
OriginalPosition$ = 264
OutlineColor$11 = 272
$T12 = 288
$T13 = 296
$T14 = 304
$T15 = 320
Indices$16 = 336
Vertices$17 = 368
__$ArrayPad$ = 432
Position$ = 480
Text$ = 488
Font$ = 496
Color$ = 504
Projection$ = 512
Z$ = 520
IsHoverable$ = 528
IsSelected$ = 536
Width$ = 544
?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z PROC ; UIString

; 132  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 133  :     loaded_image Image;
; 134  :     Image.Platform = Font->Image;

  0002f	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR Font$[rsp]
  00037	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0003b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR Image$[rsp], rax

; 135  :     
; 136  :     v2 OriginalPosition = Position;

  00043	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR Position$[rsp]
  0004b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR OriginalPosition$[rsp], rax
$LN2@UIString:

; 137  :     
; 138  :     while(*Text)

  00053	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Text$[rsp]
  0005b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 64 03 00
	00		 je	 $LN3@UIString

; 139  :     {
; 140  :         if(*Text >= 32 && *Text < 128)

  00066	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Text$[rsp]
  0006e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00071	83 f8 20	 cmp	 eax, 32			; 00000020H
  00074	0f 8c 38 03 00
	00		 jl	 $LN4@UIString
  0007a	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Text$[rsp]
  00082	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00085	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0008a	0f 8d 22 03 00
	00		 jge	 $LN4@UIString

; 141  :         {
; 142  :             stbtt_aligned_quad Quad;
; 143  :             stbtt_GetBakedQuad(Font->CData, Font->Width, Font->Height, *Text - ' ',

  00090	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Text$[rsp]
  00098	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009b	83 e8 20	 sub	 eax, 32			; 00000020H
  0009e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  000a6	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR Quad$9[rsp]
  000ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b3	48 8d 8c 24 e4
	01 00 00	 lea	 rcx, QWORD PTR Position$[rsp+4]
  000bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c0	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR Position$[rsp]
  000c8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000cd	44 8b c8	 mov	 r9d, eax
  000d0	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR Font$[rsp]
  000d8	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  000dc	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR Font$[rsp]
  000e4	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  000e7	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR Font$[rsp]
  000ef	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000f2	e8 00 00 00 00	 call	 stbtt_GetBakedQuad

; 144  :                                &Position.x, &Position.y, &Quad, 0);
; 145  :             
; 146  :             v2 QuadPos;
; 147  :             QuadPos.x = Quad.x0;

  000f7	f3 0f 10 84 24
	e0 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp]
  00100	f3 0f 11 84 24
	00 01 00 00	 movss	 DWORD PTR QuadPos$10[rsp], xmm0

; 148  :             QuadPos.y = Quad.y0;

  00109	f3 0f 10 84 24
	e4 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+4]
  00112	f3 0f 11 84 24
	04 01 00 00	 movss	 DWORD PTR QuadPos$10[rsp+4], xmm0

; 149  :             
; 150  :             Image.Size = V2(Quad.x1 - Quad.x0, Quad.y1 - Quad.y0);

  0011b	f3 0f 10 84 24
	f4 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+20]
  00124	f3 0f 5c 84 24
	e4 00 00 00	 subss	 xmm0, DWORD PTR Quad$9[rsp+4]
  0012d	f3 0f 10 8c 24
	f0 00 00 00	 movss	 xmm1, DWORD PTR Quad$9[rsp+16]
  00136	f3 0f 5c 8c 24
	e0 00 00 00	 subss	 xmm1, DWORD PTR Quad$9[rsp]
  0013f	f3 0f 11 4c 24
	54		 movss	 DWORD PTR tv87[rsp], xmm1
  00145	0f 28 c8	 movaps	 xmm1, xmm0
  00148	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR tv87[rsp]
  0014e	e8 00 00 00 00	 call	 ?V2@@YA?ATv2@@MM@Z	; V2
  00153	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR $T12[rsp], rax
  0015b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR $T12[rsp]
  00163	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR Image$[rsp+8], rax

; 151  :             
; 152  :             ui_vertex Vertices[4] =
; 153  :             {
; 154  :                 { { +1.0f, +1.0f }, { Quad.s1, Quad.t1 } }, // Top right

  0016b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00173	f3 0f 11 84 24
	70 01 00 00	 movss	 DWORD PTR Vertices$17[rsp], xmm0
  0017c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00184	f3 0f 11 84 24
	74 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+4], xmm0
  0018d	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+24]
  00196	f3 0f 11 84 24
	78 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+8], xmm0
  0019f	f3 0f 10 84 24
	fc 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+28]
  001a8	f3 0f 11 84 24
	7c 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+12], xmm0

; 155  :                 { { +1.0f, -1.0f }, { Quad.s1, Quad.t0 } }, // Bottom right

  001b1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b9	f3 0f 11 84 24
	80 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+16], xmm0
  001c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001ca	f3 0f 11 84 24
	84 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+20], xmm0
  001d3	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+24]
  001dc	f3 0f 11 84 24
	88 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+24], xmm0
  001e5	f3 0f 10 84 24
	ec 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+12]
  001ee	f3 0f 11 84 24
	8c 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+28], xmm0

; 156  :                 { { -1.0f, -1.0f }, { Quad.s0, Quad.t0 } }, // Bottom left

  001f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001ff	f3 0f 11 84 24
	90 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+32], xmm0
  00208	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00210	f3 0f 11 84 24
	94 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+36], xmm0
  00219	f3 0f 10 84 24
	e8 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+8]
  00222	f3 0f 11 84 24
	98 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+40], xmm0
  0022b	f3 0f 10 84 24
	ec 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+12]
  00234	f3 0f 11 84 24
	9c 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+44], xmm0

; 157  :                 { { -1.0f, +1.0f }, { Quad.s0, Quad.t1 } }  // Top left

  0023d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00245	f3 0f 11 84 24
	a0 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+48], xmm0
  0024e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00256	f3 0f 11 84 24
	a4 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+52], xmm0
  0025f	f3 0f 10 84 24
	e8 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+8]
  00268	f3 0f 11 84 24
	a8 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+56], xmm0
  00271	f3 0f 10 84 24
	fc 00 00 00	 movss	 xmm0, DWORD PTR Quad$9[rsp+28]
  0027a	f3 0f 11 84 24
	ac 01 00 00	 movss	 DWORD PTR Vertices$17[rsp+60], xmm0

; 158  :             };
; 159  :             
; 160  :             u32 Indices[6] =
; 161  :             {
; 162  :                 0, 1, 3,

  00283	c7 84 24 50 01
	00 00 00 00 00
	00		 mov	 DWORD PTR Indices$16[rsp], 0
  0028e	c7 84 24 54 01
	00 00 01 00 00
	00		 mov	 DWORD PTR Indices$16[rsp+4], 1
  00299	c7 84 24 58 01
	00 00 03 00 00
	00		 mov	 DWORD PTR Indices$16[rsp+8], 3

; 163  :                 1, 2, 3

  002a4	c7 84 24 5c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR Indices$16[rsp+12], 1
  002af	c7 84 24 60 01
	00 00 02 00 00
	00		 mov	 DWORD PTR Indices$16[rsp+16], 2
  002ba	c7 84 24 64 01
	00 00 03 00 00
	00		 mov	 DWORD PTR Indices$16[rsp+20], 3

; 164  :             };
; 165  :             
; 166  :             void *Mesh = Platform->CreateMesh(Vertices, ArrayCount(Vertices),

  002c5	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  002cd	41 b9 06 00 00
	00		 mov	 r9d, 6
  002d3	4c 8d 84 24 50
	01 00 00	 lea	 r8, QWORD PTR Indices$16[rsp]
  002db	ba 04 00 00 00	 mov	 edx, 4
  002e0	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR Vertices$17[rsp]
  002e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  002ef	ff 50 30	 call	 QWORD PTR [rax+48]
  002f2	48 89 44 24 60	 mov	 QWORD PTR Mesh$3[rsp], rax

; 167  :                                               Indices, ArrayCount(Indices), true);
; 168  :             
; 169  :             UIImage(Image, QuadPos, V2(1.0f, 1.0f), Color, Projection, Z, false, false, false, Mesh);

  002f7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  002ff	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00307	e8 00 00 00 00	 call	 ?V2@@YA?ATv2@@MM@Z	; V2
  0030c	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR $T13[rsp], rax
  00314	48 8d 44 24 70	 lea	 rax, QWORD PTR $T4[rsp]
  00319	48 8b f8	 mov	 rdi, rax
  0031c	48 8b b4 24 f8
	01 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  00324	b9 10 00 00 00	 mov	 ecx, 16
  00329	f3 a4		 rep movsb
  0032b	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00333	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR Image$[rsp]
  0033b	48 8b f8	 mov	 rdi, rax
  0033e	48 8b f1	 mov	 rsi, rcx
  00341	b9 10 00 00 00	 mov	 ecx, 16
  00346	f3 a4		 rep movsb
  00348	48 8b 44 24 60	 mov	 rax, QWORD PTR Mesh$3[rsp]
  0034d	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00352	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  0035a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR [rsp+56], 0
  00362	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0036a	f3 0f 10 84 24
	08 02 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  00373	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00379	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR Projection$[rsp]
  00381	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00386	4c 8d 4c 24 70	 lea	 r9, QWORD PTR $T4[rsp]
  0038b	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR $T13[rsp]
  00393	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR QuadPos$10[rsp]
  0039b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  003a3	e8 00 00 00 00	 call	 ?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z ; UIImage

; 170  :             
; 171  :             Platform->PopMesh();

  003a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  003af	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@UIString:

; 172  :         }
; 173  :         ++Text;

  003b2	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Text$[rsp]
  003ba	48 ff c0	 inc	 rax
  003bd	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR Text$[rsp], rax

; 174  :     }

  003c5	e9 89 fc ff ff	 jmp	 $LN2@UIString
$LN3@UIString:

; 175  :     
; 176  :     b32 Hovered = false;

  003ca	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR Hovered$[rsp], 0

; 177  :     v2 BottomLeft = OriginalPosition;

  003d2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR OriginalPosition$[rsp]
  003da	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR BottomLeft$[rsp], rax

; 178  :     v2 TopRight = { Position.x, Position.y - Font->CharacterHeight/2.0f };

  003e2	f3 0f 10 84 24
	e0 01 00 00	 movss	 xmm0, DWORD PTR Position$[rsp]
  003eb	f3 0f 11 84 24
	d0 00 00 00	 movss	 DWORD PTR TopRight$[rsp], xmm0
  003f4	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR Font$[rsp]
  003fc	f3 0f 10 80 10
	03 00 00	 movss	 xmm0, DWORD PTR [rax+784]
  00404	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0040c	f3 0f 10 8c 24
	e4 01 00 00	 movss	 xmm1, DWORD PTR Position$[rsp+4]
  00415	f3 0f 5c c8	 subss	 xmm1, xmm0
  00419	0f 28 c1	 movaps	 xmm0, xmm1
  0041c	f3 0f 11 84 24
	d4 00 00 00	 movss	 DWORD PTR TopRight$[rsp+4], xmm0

; 179  :     if(Width) *Width = TopRight.x - OriginalPosition.x;

  00425	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR Width$[rsp], 0
  0042e	74 1e		 je	 SHORT $LN5@UIString
  00430	f3 0f 10 84 24
	d0 00 00 00	 movss	 xmm0, DWORD PTR TopRight$[rsp]
  00439	f3 0f 5c 84 24
	08 01 00 00	 subss	 xmm0, DWORD PTR OriginalPosition$[rsp]
  00442	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR Width$[rsp]
  0044a	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
$LN5@UIString:

; 180  :     if(IsHoverable)

  0044e	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR IsHoverable$[rsp], 0
  00456	74 68		 je	 SHORT $LN6@UIString

; 181  :     {
; 182  :         if(Input->Mouse.X > BottomLeft.x && Input->Mouse.X < TopRight.x &&
; 183  :            Input->Mouse.Y < BottomLeft.y && Input->Mouse.Y > TopRight.y)

  00458	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0045f	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  00464	0f 2f 84 24 d8
	00 00 00	 comiss	 xmm0, DWORD PTR BottomLeft$[rsp]
  0046c	76 52		 jbe	 SHORT $LN7@UIString
  0046e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00475	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  0047a	f3 0f 10 8c 24
	d0 00 00 00	 movss	 xmm1, DWORD PTR TopRight$[rsp]
  00483	0f 2f c8	 comiss	 xmm1, xmm0
  00486	76 38		 jbe	 SHORT $LN7@UIString
  00488	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0048f	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  00494	f3 0f 10 8c 24
	dc 00 00 00	 movss	 xmm1, DWORD PTR BottomLeft$[rsp+4]
  0049d	0f 2f c8	 comiss	 xmm1, xmm0
  004a0	76 1e		 jbe	 SHORT $LN7@UIString
  004a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  004a9	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  004ae	0f 2f 84 24 d4
	00 00 00	 comiss	 xmm0, DWORD PTR TopRight$[rsp+4]
  004b6	76 08		 jbe	 SHORT $LN7@UIString

; 184  :         {
; 185  :             Hovered = true;

  004b8	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR Hovered$[rsp], 1
$LN7@UIString:
$LN6@UIString:

; 186  :         }
; 187  :     }
; 188  :     
; 189  :     if(State->DevMode && (Hovered || IsSelected))

  004c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  004c7	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  004ce	0f 84 98 01 00
	00		 je	 $LN8@UIString
  004d4	83 7c 24 50 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  004d9	75 0e		 jne	 SHORT $LN9@UIString
  004db	83 bc 24 18 02
	00 00 00	 cmp	 DWORD PTR IsSelected$[rsp], 0
  004e3	0f 84 83 01 00
	00		 je	 $LN8@UIString
$LN9@UIString:

; 190  :     {
; 191  :         v4 OutlineColor = {0};

  004e9	0f 57 c0	 xorps	 xmm0, xmm0
  004ec	f3 0f 11 84 24
	10 01 00 00	 movss	 DWORD PTR OutlineColor$11[rsp], xmm0
  004f5	48 8d 84 24 14
	01 00 00	 lea	 rax, QWORD PTR OutlineColor$11[rsp+4]
  004fd	48 8b f8	 mov	 rdi, rax
  00500	33 c0		 xor	 eax, eax
  00502	b9 0c 00 00 00	 mov	 ecx, 12
  00507	f3 aa		 rep stosb

; 192  :         if(Hovered && !IsSelected)

  00509	83 7c 24 50 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  0050e	74 6f		 je	 SHORT $LN10@UIString
  00510	83 bc 24 18 02
	00 00 00	 cmp	 DWORD PTR IsSelected$[rsp], 0
  00518	75 65		 jne	 SHORT $LN10@UIString

; 193  :         {
; 194  :             OutlineColor = V4(0.8f, 0.8f, 0.8f, 1.0f);

  0051a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00522	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00528	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f4ccccd
  00530	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f4ccccd
  00538	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f4ccccd
  00540	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00548	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  0054d	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  00555	48 8b f9	 mov	 rdi, rcx
  00558	48 8b f0	 mov	 rsi, rax
  0055b	b9 10 00 00 00	 mov	 ecx, 16
  00560	f3 a4		 rep movsb
  00562	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR OutlineColor$11[rsp]
  0056a	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  00572	48 8b f8	 mov	 rdi, rax
  00575	48 8b f1	 mov	 rsi, rcx
  00578	b9 10 00 00 00	 mov	 ecx, 16
  0057d	f3 a4		 rep movsb
$LN10@UIString:

; 195  :         }
; 196  :         if(IsSelected)

  0057f	83 bc 24 18 02
	00 00 00	 cmp	 DWORD PTR IsSelected$[rsp], 0
  00587	74 65		 je	 SHORT $LN11@UIString

; 197  :         {
; 198  :             OutlineColor = V4(0.5f, 0.5f, 0.5f, 1.0f);

  00589	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00591	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00597	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f000000
  0059f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  005a7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  005af	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  005b7	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  005bc	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  005c4	48 8b f9	 mov	 rdi, rcx
  005c7	48 8b f0	 mov	 rsi, rax
  005ca	b9 10 00 00 00	 mov	 ecx, 16
  005cf	f3 a4		 rep movsb
  005d1	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR OutlineColor$11[rsp]
  005d9	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  005e1	48 8b f8	 mov	 rdi, rax
  005e4	48 8b f1	 mov	 rsi, rcx
  005e7	b9 10 00 00 00	 mov	 ecx, 16
  005ec	f3 a4		 rep movsb
$LN11@UIString:

; 199  :         }
; 200  :         
; 201  :         f32 OutlineWidth = 3.0f;

  005ee	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  005f6	f3 0f 11 44 24
	5c		 movss	 DWORD PTR OutlineWidth$2[rsp], xmm0

; 202  :         f32 OutlineZ = Z - 0.0001f;

  005fc	f3 0f 10 84 24
	08 02 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  00605	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@38d1b717
  0060d	f3 0f 11 44 24
	58		 movss	 DWORD PTR OutlineZ$1[rsp], xmm0

; 203  :         
; 204  :         RenderBox(BottomLeft, TopRight, OutlineColor, OutlineWidth, Projection, OutlineZ);

  00613	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  0061b	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR OutlineColor$11[rsp]
  00623	48 8b f8	 mov	 rdi, rax
  00626	48 8b f1	 mov	 rsi, rcx
  00629	b9 10 00 00 00	 mov	 ecx, 16
  0062e	f3 a4		 rep movsb
  00630	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR OutlineZ$1[rsp]
  00636	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0063c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR Projection$[rsp]
  00644	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00649	f3 0f 10 5c 24
	5c		 movss	 xmm3, DWORD PTR OutlineWidth$2[rsp]
  0064f	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR $T6[rsp]
  00657	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR TopRight$[rsp]
  0065f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR BottomLeft$[rsp]
  00667	e8 00 00 00 00	 call	 ?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z ; RenderBox
$LN8@UIString:

; 205  :     }
; 206  :     
; 207  :     return(Hovered);

  0066c	8b 44 24 50	 mov	 eax, DWORD PTR Hovered$[rsp]

; 208  : }

  00670	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00678	48 33 cc	 xor	 rcx, rsp
  0067b	e8 00 00 00 00	 call	 __security_check_cookie
  00680	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00687	5f		 pop	 rdi
  00688	5e		 pop	 rsi
  00689	c3		 ret	 0
?UIString@@YAHTv2@@PEADPEAUfont@@Tv4@@PEATmat4@@MHHPEAM@Z ENDP ; UIString
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_ui.cpp
_TEXT	SEGMENT
Hovered$ = 48
$T1 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
$T7 = 160
$T8 = 176
$T9 = 192
$T10 = 208
$T11 = 224
$T12 = 240
$T13 = 256
$T14 = 272
$T15 = 288
$T16 = 304
$T17 = 320
$T18 = 336
$T19 = 352
$T20 = 368
$T21 = 384
$T22 = 448
$T23 = 512
$T24 = 576
$T25 = 640
$T26 = 704
$T27 = 768
$T28 = 832
$T29 = 896
RotationRadians$ = 904
TopLeft$ = 920
OriginalPosition$ = 928
OriginalSize$ = 936
BottomRight$ = 944
OutlineSize$30 = 952
$T31 = 960
OutlineColor$32 = 976
$T33 = 992
$T34 = 1008
$T35 = 1024
$T36 = 1032
$T37 = 1040
$T38 = 1048
$T39 = 1056
$T40 = 1072
$T41 = 1088
$T42 = 1104
$T43 = 1120
$T44 = 1136
Transform$ = 1152
$T45 = 1216
$T46 = 1232
Constants$ = 1248
$T47 = 1344
$T48 = 1408
$T49 = 1472
$T50 = 1536
__$ArrayPad$ = 1600
Image$ = 1648
Position$ = 1656
Scale$ = 1664
Color$ = 1672
Projection$ = 1680
Z$ = 1688
IsHoverable$ = 1696
Selected$ = 1704
IsButton$ = 1712
Mesh$ = 1720
?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z PROC ; UIImage

; 49   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 58 06
	00 00		 sub	 rsp, 1624		; 00000658H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 40
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 50   :     v2 OriginalSize = Image.Size*Scale;

  0002f	48 8b 94 24 80
	06 00 00	 mov	 rdx, QWORD PTR Scale$[rsp]
  00037	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  0003f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00043	e8 00 00 00 00	 call	 ??D@YA?ATv2@@T0@0@Z	; operator*
  00048	48 89 84 24 00
	04 00 00	 mov	 QWORD PTR $T35[rsp], rax
  00050	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR $T35[rsp]
  00058	48 89 84 24 a8
	03 00 00	 mov	 QWORD PTR OriginalSize$[rsp], rax

; 51   :     v2 OriginalPosition = Position;

  00060	48 8b 84 24 78
	06 00 00	 mov	 rax, QWORD PTR Position$[rsp]
  00068	48 89 84 24 a0
	03 00 00	 mov	 QWORD PTR OriginalPosition$[rsp], rax

; 52   :     Image.Size = OriginalSize/2.0f;

  00070	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  00078	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR OriginalSize$[rsp]
  00080	e8 00 00 00 00	 call	 ??K@YA?ATv2@@T0@M@Z	; operator/
  00085	48 89 84 24 18
	04 00 00	 mov	 QWORD PTR $T38[rsp], rax
  0008d	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  00095	48 8b 8c 24 18
	04 00 00	 mov	 rcx, QWORD PTR $T38[rsp]
  0009d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 53   :     Position = OriginalPosition + Image.Size;

  000a1	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  000a9	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ad	48 8b 8c 24 a0
	03 00 00	 mov	 rcx, QWORD PTR OriginalPosition$[rsp]
  000b5	e8 00 00 00 00	 call	 ??H@YA?ATv2@@T0@0@Z	; operator+
  000ba	48 89 84 24 08
	04 00 00	 mov	 QWORD PTR $T36[rsp], rax
  000c2	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR $T36[rsp]
  000ca	48 89 84 24 78
	06 00 00	 mov	 QWORD PTR Position$[rsp], rax

; 54   :     
; 55   :     mat4 Transform = Mat4Identity();

  000d2	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  000da	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  000df	48 8d 8c 24 40
	05 00 00	 lea	 rcx, QWORD PTR $T47[rsp]
  000e7	48 8b f9	 mov	 rdi, rcx
  000ea	48 8b f0	 mov	 rsi, rax
  000ed	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f2	f3 a4		 rep movsb
  000f4	48 8d 84 24 80
	04 00 00	 lea	 rax, QWORD PTR Transform$[rsp]
  000fc	48 8d 8c 24 40
	05 00 00	 lea	 rcx, QWORD PTR $T47[rsp]
  00104	48 8b f8	 mov	 rdi, rax
  00107	48 8b f1	 mov	 rsi, rcx
  0010a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0010f	f3 a4		 rep movsb

; 56   :     TranslateMat4(&Transform, V3(Position.x, Position.y, 0.0f));

  00111	0f 57 db	 xorps	 xmm3, xmm3
  00114	f3 0f 10 94 24
	7c 06 00 00	 movss	 xmm2, DWORD PTR Position$[rsp+4]
  0011d	f3 0f 10 8c 24
	78 06 00 00	 movss	 xmm1, DWORD PTR Position$[rsp]
  00126	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  0012e	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00133	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  0013b	48 8b f9	 mov	 rdi, rcx
  0013e	48 8b f0	 mov	 rsi, rax
  00141	b9 0c 00 00 00	 mov	 ecx, 12
  00146	f3 a4		 rep movsb
  00148	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  00150	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  00158	48 8b f8	 mov	 rdi, rax
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	b9 0c 00 00 00	 mov	 ecx, 12
  00163	f3 a4		 rep movsb
  00165	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T6[rsp]
  0016d	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  00175	e8 00 00 00 00	 call	 ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z ; TranslateMat4

; 57   :     v3 RotationRadians = { 0.0f, 0.0f, 0.0f };

  0017a	0f 57 c0	 xorps	 xmm0, xmm0
  0017d	f3 0f 11 84 24
	88 03 00 00	 movss	 DWORD PTR RotationRadians$[rsp], xmm0
  00186	0f 57 c0	 xorps	 xmm0, xmm0
  00189	f3 0f 11 84 24
	8c 03 00 00	 movss	 DWORD PTR RotationRadians$[rsp+4], xmm0
  00192	0f 57 c0	 xorps	 xmm0, xmm0
  00195	f3 0f 11 84 24
	90 03 00 00	 movss	 DWORD PTR RotationRadians$[rsp+8], xmm0

; 58   :     if(RotationRadians.x || RotationRadians.y || RotationRadians.z)

  0019e	f3 0f 10 84 24
	88 03 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp]
  001a7	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001ae	7a 2e		 jp	 SHORT $LN3@UIImage
  001b0	75 2c		 jne	 SHORT $LN3@UIImage
  001b2	f3 0f 10 84 24
	8c 03 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+4]
  001bb	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001c2	7a 1a		 jp	 SHORT $LN3@UIImage
  001c4	75 18		 jne	 SHORT $LN3@UIImage
  001c6	f3 0f 10 84 24
	90 03 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+8]
  001cf	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001d6	7a 06		 jp	 SHORT $LN17@UIImage
  001d8	0f 84 9a 00 00
	00		 je	 $LN2@UIImage
$LN17@UIImage:
$LN3@UIImage:

; 59   :     {
; 60   :         RotateMat4(&Transform,

  001de	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  001e3	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  001eb	48 8b f8	 mov	 rdi, rax
  001ee	48 8b f1	 mov	 rsi, rcx
  001f1	b9 0c 00 00 00	 mov	 ecx, 12
  001f6	f3 a4		 rep movsb
  001f8	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  001fd	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00205	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  0020a	48 8d 8c 24 50
	04 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  00212	48 8b f9	 mov	 rdi, rcx
  00215	48 8b f0	 mov	 rsi, rax
  00218	b9 0c 00 00 00	 mov	 ecx, 12
  0021d	f3 a4		 rep movsb
  0021f	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00227	48 8d 8c 24 50
	04 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  0022f	48 8b f8	 mov	 rdi, rax
  00232	48 8b f1	 mov	 rsi, rcx
  00235	b9 0c 00 00 00	 mov	 ecx, 12
  0023a	f3 a4		 rep movsb
  0023c	48 8d 44 24 70	 lea	 rax, QWORD PTR $T4[rsp]
  00241	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  00249	48 8b f8	 mov	 rdi, rax
  0024c	48 8b f1	 mov	 rsi, rcx
  0024f	b9 0c 00 00 00	 mov	 ecx, 12
  00254	f3 a4		 rep movsb
  00256	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  0025b	e8 00 00 00 00	 call	 ?V3Length@@YAMTv3@@@Z	; V3Length
  00260	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR $T5[rsp]
  00268	0f 28 c8	 movaps	 xmm1, xmm0
  0026b	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  00273	e8 00 00 00 00	 call	 ?RotateMat4@@YAXPEATmat4@@MTv3@@@Z ; RotateMat4
$LN2@UIImage:

; 61   :                    V3Length(RotationRadians),
; 62   :                    V3Normalize(RotationRadians));
; 63   :     }
; 64   :     ScaleMat4(&Transform, V3(Image.Size.Width, Image.Size.Height, 1.0f));

  00278	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00280	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  00288	f3 0f 10 50 0c	 movss	 xmm2, DWORD PTR [rax+12]
  0028d	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  00295	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  0029a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  002a2	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  002a7	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  002af	48 8b f9	 mov	 rdi, rcx
  002b2	48 8b f0	 mov	 rsi, rax
  002b5	b9 0c 00 00 00	 mov	 ecx, 12
  002ba	f3 a4		 rep movsb
  002bc	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  002c4	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  002cc	48 8b f8	 mov	 rdi, rax
  002cf	48 8b f1	 mov	 rsi, rcx
  002d2	b9 0c 00 00 00	 mov	 ecx, 12
  002d7	f3 a4		 rep movsb
  002d9	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  002e1	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  002e9	e8 00 00 00 00	 call	 ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z ; ScaleMat4

; 65   :     
; 66   :     b32 Hovered = false;

  002ee	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR Hovered$[rsp], 0

; 67   :     v2 TopLeft = OriginalPosition;

  002f6	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR OriginalPosition$[rsp]
  002fe	48 89 84 24 98
	03 00 00	 mov	 QWORD PTR TopLeft$[rsp], rax

; 68   :     v2 BottomRight = TopLeft + OriginalSize;

  00306	48 8b 94 24 a8
	03 00 00	 mov	 rdx, QWORD PTR OriginalSize$[rsp]
  0030e	48 8b 8c 24 98
	03 00 00	 mov	 rcx, QWORD PTR TopLeft$[rsp]
  00316	e8 00 00 00 00	 call	 ??H@YA?ATv2@@T0@0@Z	; operator+
  0031b	48 89 84 24 10
	04 00 00	 mov	 QWORD PTR $T37[rsp], rax
  00323	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR $T37[rsp]
  0032b	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR BottomRight$[rsp], rax

; 69   :     if(IsHoverable)

  00333	83 bc 24 a0 06
	00 00 00	 cmp	 DWORD PTR IsHoverable$[rsp], 0
  0033b	0f 84 0f 01 00
	00		 je	 $LN4@UIImage

; 70   :     {
; 71   :         if(Input->Mouse.X > TopLeft.x && Input->Mouse.X < BottomRight.x &&
; 72   :            Input->Mouse.Y > TopLeft.y && Input->Mouse.Y < BottomRight.y)

  00341	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00348	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  0034d	0f 2f 84 24 98
	03 00 00	 comiss	 xmm0, DWORD PTR TopLeft$[rsp]
  00355	0f 86 f5 00 00
	00		 jbe	 $LN5@UIImage
  0035b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00362	f3 0f 2a 40 64	 cvtsi2ss xmm0, DWORD PTR [rax+100]
  00367	f3 0f 10 8c 24
	b0 03 00 00	 movss	 xmm1, DWORD PTR BottomRight$[rsp]
  00370	0f 2f c8	 comiss	 xmm1, xmm0
  00373	0f 86 d7 00 00
	00		 jbe	 $LN5@UIImage
  00379	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00380	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  00385	0f 2f 84 24 9c
	03 00 00	 comiss	 xmm0, DWORD PTR TopLeft$[rsp+4]
  0038d	0f 86 bd 00 00
	00		 jbe	 $LN5@UIImage
  00393	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  0039a	f3 0f 2a 40 6c	 cvtsi2ss xmm0, DWORD PTR [rax+108]
  0039f	f3 0f 10 8c 24
	b4 03 00 00	 movss	 xmm1, DWORD PTR BottomRight$[rsp+4]
  003a8	0f 2f c8	 comiss	 xmm1, xmm0
  003ab	0f 86 9f 00 00
	00		 jbe	 $LN5@UIImage

; 73   :         {
; 74   :             Hovered = true;

  003b1	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR Hovered$[rsp], 1

; 75   :             
; 76   :             if(!State->DevMode && !Input->Mouse.LButton)

  003b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  003c0	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  003c7	0f 85 83 00 00
	00		 jne	 $LN6@UIImage
  003cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  003d4	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  003d8	75 76		 jne	 SHORT $LN6@UIImage

; 77   :             {
; 78   :                 Color *= v4{ 0.8f, 0.8f, 0.8f, 1.0f };

  003da	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  003e2	f3 0f 11 84 24
	e0 03 00 00	 movss	 DWORD PTR $T33[rsp], xmm0
  003eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  003f3	f3 0f 11 84 24
	e4 03 00 00	 movss	 DWORD PTR $T33[rsp+4], xmm0
  003fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00404	f3 0f 11 84 24
	e8 03 00 00	 movss	 DWORD PTR $T33[rsp+8], xmm0
  0040d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00415	f3 0f 11 84 24
	ec 03 00 00	 movss	 DWORD PTR $T33[rsp+12], xmm0
  0041e	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  00426	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  0042e	48 8b f8	 mov	 rdi, rax
  00431	48 8b f1	 mov	 rsi, rcx
  00434	b9 10 00 00 00	 mov	 ecx, 16
  00439	f3 a4		 rep movsb
  0043b	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR $T12[rsp]
  00443	48 8b 8c 24 88
	06 00 00	 mov	 rcx, QWORD PTR Color$[rsp]
  0044b	e8 00 00 00 00	 call	 ??X@YAAEATv4@@AEAT0@T0@@Z ; operator*=
$LN6@UIImage:
$LN5@UIImage:
$LN4@UIImage:

; 79   :             }
; 80   :         }
; 81   :     }
; 82   :     
; 83   :     if(!State->DevMode && Hovered && Input->Mouse.LButton)

  00450	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00457	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  0045e	0f 85 8e 00 00
	00		 jne	 $LN7@UIImage
  00464	83 7c 24 30 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  00469	0f 84 83 00 00
	00		 je	 $LN7@UIImage
  0046f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Input@@3PEAUgame_input@@EA
  00476	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  0047a	74 76		 je	 SHORT $LN7@UIImage

; 84   :     {
; 85   :         Color *= v4{ 0.5f, 0.5f, 0.5f, 1.0f };

  0047c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00484	f3 0f 11 84 24
	f0 03 00 00	 movss	 DWORD PTR $T34[rsp], xmm0
  0048d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00495	f3 0f 11 84 24
	f4 03 00 00	 movss	 DWORD PTR $T34[rsp+4], xmm0
  0049e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  004a6	f3 0f 11 84 24
	f8 03 00 00	 movss	 DWORD PTR $T34[rsp+8], xmm0
  004af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004b7	f3 0f 11 84 24
	fc 03 00 00	 movss	 DWORD PTR $T34[rsp+12], xmm0
  004c0	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  004c8	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  004d0	48 8b f8	 mov	 rdi, rax
  004d3	48 8b f1	 mov	 rsi, rcx
  004d6	b9 10 00 00 00	 mov	 ecx, 16
  004db	f3 a4		 rep movsb
  004dd	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T11[rsp]
  004e5	48 8b 8c 24 88
	06 00 00	 mov	 rcx, QWORD PTR Color$[rsp]
  004ed	e8 00 00 00 00	 call	 ??X@YAAEATv4@@AEAT0@T0@@Z ; operator*=
$LN7@UIImage:

; 86   :     }
; 87   :     
; 88   :     ui_shader_constants Constants;
; 89   :     Constants.M = Transform * *Projection;

  004f2	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR $T21[rsp]
  004fa	48 8b f8	 mov	 rdi, rax
  004fd	48 8b b4 24 90
	06 00 00	 mov	 rsi, QWORD PTR Projection$[rsp]
  00505	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0050a	f3 a4		 rep movsb
  0050c	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR $T22[rsp]
  00514	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  0051c	48 8b f8	 mov	 rdi, rax
  0051f	48 8b f1	 mov	 rsi, rcx
  00522	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00527	f3 a4		 rep movsb
  00529	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR $T21[rsp]
  00531	48 8d 94 24 c0
	01 00 00	 lea	 rdx, QWORD PTR $T22[rsp]
  00539	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  00541	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  00546	48 8d 8c 24 c0
	05 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  0054e	48 8b f9	 mov	 rdi, rcx
  00551	48 8b f0	 mov	 rsi, rax
  00554	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00559	f3 a4		 rep movsb
  0055b	48 8d 84 24 f0
	04 00 00	 lea	 rax, QWORD PTR Constants$[rsp+16]
  00563	48 8d 8c 24 c0
	05 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  0056b	48 8b f8	 mov	 rdi, rax
  0056e	48 8b f1	 mov	 rsi, rcx
  00571	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00576	f3 a4		 rep movsb

; 90   :     Constants.Color = Color;

  00578	48 8d 84 24 e0
	04 00 00	 lea	 rax, QWORD PTR Constants$[rsp]
  00580	48 8b f8	 mov	 rdi, rax
  00583	48 8b b4 24 88
	06 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  0058b	b9 10 00 00 00	 mov	 ecx, 16
  00590	f3 a4		 rep movsb

; 91   :     Constants.Z = Z;

  00592	f3 0f 10 84 24
	98 06 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  0059b	f3 0f 11 84 24
	30 05 00 00	 movss	 DWORD PTR Constants$[rsp+80], xmm0

; 92   :     
; 93   :     Platform->RenderMesh(Mesh, Image.Platform, State->UIShader, &Constants, true);

  005a4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  005ac	4c 8d 8c 24 e0
	04 00 00	 lea	 r9, QWORD PTR Constants$[rsp]
  005b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  005bb	4c 8b 80 18 01
	00 00		 mov	 r8, QWORD PTR [rax+280]
  005c2	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  005ca	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  005cd	48 8b 8c 24 b8
	06 00 00	 mov	 rcx, QWORD PTR Mesh$[rsp]
  005d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  005dc	ff 50 50	 call	 QWORD PTR [rax+80]

; 94   :     
; 95   :     if(State->DevMode && (Hovered || Selected))

  005df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  005e6	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  005ed	0f 84 87 04 00
	00		 je	 $LN8@UIImage
  005f3	83 7c 24 30 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  005f8	75 0e		 jne	 SHORT $LN9@UIImage
  005fa	83 bc 24 a8 06
	00 00 00	 cmp	 DWORD PTR Selected$[rsp], 0
  00602	0f 84 72 04 00
	00		 je	 $LN8@UIImage
$LN9@UIImage:

; 96   :     {
; 97   :         v4 OutlineColor = {0};

  00608	0f 57 c0	 xorps	 xmm0, xmm0
  0060b	f3 0f 11 84 24
	d0 03 00 00	 movss	 DWORD PTR OutlineColor$32[rsp], xmm0
  00614	48 8d 84 24 d4
	03 00 00	 lea	 rax, QWORD PTR OutlineColor$32[rsp+4]
  0061c	48 8b f8	 mov	 rdi, rax
  0061f	33 c0		 xor	 eax, eax
  00621	b9 0c 00 00 00	 mov	 ecx, 12
  00626	f3 aa		 rep stosb

; 98   :         if(Hovered && !Selected)

  00628	83 7c 24 30 00	 cmp	 DWORD PTR Hovered$[rsp], 0
  0062d	74 71		 je	 SHORT $LN10@UIImage
  0062f	83 bc 24 a8 06
	00 00 00	 cmp	 DWORD PTR Selected$[rsp], 0
  00637	75 67		 jne	 SHORT $LN10@UIImage

; 99   :         {
; 100  :             OutlineColor = V4(0.8f, 0.8f, 0.8f, 1.0f);

  00639	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00641	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00647	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f4ccccd
  0064f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f4ccccd
  00657	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f4ccccd
  0065f	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00667	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  0066c	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR $T45[rsp]
  00674	48 8b f9	 mov	 rdi, rcx
  00677	48 8b f0	 mov	 rsi, rax
  0067a	b9 10 00 00 00	 mov	 ecx, 16
  0067f	f3 a4		 rep movsb
  00681	48 8d 84 24 d0
	03 00 00	 lea	 rax, QWORD PTR OutlineColor$32[rsp]
  00689	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR $T45[rsp]
  00691	48 8b f8	 mov	 rdi, rax
  00694	48 8b f1	 mov	 rsi, rcx
  00697	b9 10 00 00 00	 mov	 ecx, 16
  0069c	f3 a4		 rep movsb

; 101  :         }

  0069e	eb 6f		 jmp	 SHORT $LN11@UIImage
$LN10@UIImage:

; 102  :         else if(Selected)

  006a0	83 bc 24 a8 06
	00 00 00	 cmp	 DWORD PTR Selected$[rsp], 0
  006a8	74 65		 je	 SHORT $LN12@UIImage

; 103  :         {
; 104  :             OutlineColor = V4(0.5f, 0.5f, 0.5f, 1.0f);

  006aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006b2	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  006b8	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f000000
  006c0	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  006c8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  006d0	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  006d8	e8 00 00 00 00	 call	 ?V4@@YA?ATv4@@MMMM@Z	; V4
  006dd	48 8d 8c 24 d0
	04 00 00	 lea	 rcx, QWORD PTR $T46[rsp]
  006e5	48 8b f9	 mov	 rdi, rcx
  006e8	48 8b f0	 mov	 rsi, rax
  006eb	b9 10 00 00 00	 mov	 ecx, 16
  006f0	f3 a4		 rep movsb
  006f2	48 8d 84 24 d0
	03 00 00	 lea	 rax, QWORD PTR OutlineColor$32[rsp]
  006fa	48 8d 8c 24 d0
	04 00 00	 lea	 rcx, QWORD PTR $T46[rsp]
  00702	48 8b f8	 mov	 rdi, rax
  00705	48 8b f1	 mov	 rsi, rcx
  00708	b9 10 00 00 00	 mov	 ecx, 16
  0070d	f3 a4		 rep movsb
$LN12@UIImage:
$LN11@UIImage:

; 105  :         }
; 106  :         
; 107  :         v2 OutlineSize = { 5.0f, 5.0f };

  0070f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  00717	f3 0f 11 84 24
	b8 03 00 00	 movss	 DWORD PTR OutlineSize$30[rsp], xmm0
  00720	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  00728	f3 0f 11 84 24
	bc 03 00 00	 movss	 DWORD PTR OutlineSize$30[rsp+4], xmm0

; 108  :         
; 109  :         Transform = Mat4Identity();

  00731	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  00739	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  0073e	48 8d 8c 24 00
	06 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  00746	48 8b f9	 mov	 rdi, rcx
  00749	48 8b f0	 mov	 rsi, rax
  0074c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00751	f3 a4		 rep movsb
  00753	48 8d 84 24 80
	04 00 00	 lea	 rax, QWORD PTR Transform$[rsp]
  0075b	48 8d 8c 24 00
	06 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  00763	48 8b f8	 mov	 rdi, rax
  00766	48 8b f1	 mov	 rsi, rcx
  00769	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0076e	f3 a4		 rep movsb

; 110  :         TranslateMat4(&Transform, V3(Position.x, Position.y, 0.0f));

  00770	0f 57 db	 xorps	 xmm3, xmm3
  00773	f3 0f 10 94 24
	7c 06 00 00	 movss	 xmm2, DWORD PTR Position$[rsp+4]
  0077c	f3 0f 10 8c 24
	78 06 00 00	 movss	 xmm1, DWORD PTR Position$[rsp]
  00785	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  0078d	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@MMM@Z	; V3
  00792	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR $T44[rsp]
  0079a	48 8b f9	 mov	 rdi, rcx
  0079d	48 8b f0	 mov	 rsi, rax
  007a0	b9 0c 00 00 00	 mov	 ecx, 12
  007a5	f3 a4		 rep movsb
  007a7	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  007af	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR $T44[rsp]
  007b7	48 8b f8	 mov	 rdi, rax
  007ba	48 8b f1	 mov	 rsi, rcx
  007bd	b9 0c 00 00 00	 mov	 ecx, 12
  007c2	f3 a4		 rep movsb
  007c4	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  007cc	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  007d4	e8 00 00 00 00	 call	 ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z ; TranslateMat4

; 111  :         RotationRadians = { 0.0f, 0.0f, 0.0f };

  007d9	0f 57 c0	 xorps	 xmm0, xmm0
  007dc	f3 0f 11 84 24
	c0 03 00 00	 movss	 DWORD PTR $T31[rsp], xmm0
  007e5	0f 57 c0	 xorps	 xmm0, xmm0
  007e8	f3 0f 11 84 24
	c4 03 00 00	 movss	 DWORD PTR $T31[rsp+4], xmm0
  007f1	0f 57 c0	 xorps	 xmm0, xmm0
  007f4	f3 0f 11 84 24
	c8 03 00 00	 movss	 DWORD PTR $T31[rsp+8], xmm0
  007fd	48 8d 84 24 88
	03 00 00	 lea	 rax, QWORD PTR RotationRadians$[rsp]
  00805	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0080d	48 8b f8	 mov	 rdi, rax
  00810	48 8b f1	 mov	 rsi, rcx
  00813	b9 0c 00 00 00	 mov	 ecx, 12
  00818	f3 a4		 rep movsb

; 112  :         if(RotationRadians.x || RotationRadians.y || RotationRadians.z)

  0081a	f3 0f 10 84 24
	88 03 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp]
  00823	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0082a	7a 2e		 jp	 SHORT $LN14@UIImage
  0082c	75 2c		 jne	 SHORT $LN14@UIImage
  0082e	f3 0f 10 84 24
	8c 03 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+4]
  00837	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0083e	7a 1a		 jp	 SHORT $LN14@UIImage
  00840	75 18		 jne	 SHORT $LN14@UIImage
  00842	f3 0f 10 84 24
	90 03 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+8]
  0084b	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00852	7a 06		 jp	 SHORT $LN16@UIImage
  00854	0f 84 9a 00 00
	00		 je	 $LN13@UIImage
$LN16@UIImage:
$LN14@UIImage:

; 113  :         {
; 114  :             RotateMat4(&Transform,

  0085a	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  00862	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  0086a	48 8b f8	 mov	 rdi, rax
  0086d	48 8b f1	 mov	 rsi, rcx
  00870	b9 0c 00 00 00	 mov	 ecx, 12
  00875	f3 a4		 rep movsb
  00877	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T10[rsp]
  0087f	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00887	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  0088c	48 8d 8c 24 30
	04 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  00894	48 8b f9	 mov	 rdi, rcx
  00897	48 8b f0	 mov	 rsi, rax
  0089a	b9 0c 00 00 00	 mov	 ecx, 12
  0089f	f3 a4		 rep movsb
  008a1	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  008a6	48 8d 8c 24 30
	04 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  008ae	48 8b f8	 mov	 rdi, rax
  008b1	48 8b f1	 mov	 rsi, rcx
  008b4	b9 0c 00 00 00	 mov	 ecx, 12
  008b9	f3 a4		 rep movsb
  008bb	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  008c0	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  008c8	48 8b f8	 mov	 rdi, rax
  008cb	48 8b f1	 mov	 rsi, rcx
  008ce	b9 0c 00 00 00	 mov	 ecx, 12
  008d3	f3 a4		 rep movsb
  008d5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T1[rsp]
  008da	e8 00 00 00 00	 call	 ?V3Length@@YAMTv3@@@Z	; V3Length
  008df	4c 8d 44 24 60	 lea	 r8, QWORD PTR $T3[rsp]
  008e4	0f 28 c8	 movaps	 xmm1, xmm0
  008e7	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  008ef	e8 00 00 00 00	 call	 ?RotateMat4@@YAXPEATmat4@@MTv3@@@Z ; RotateMat4
$LN13@UIImage:

; 115  :                        V3Length(RotationRadians),
; 116  :                        V3Normalize(RotationRadians));
; 117  :         }
; 118  :         ScaleMat4(&Transform, V3(Image.Size + OutlineSize, 1.0f));

  008f4	48 8b 94 24 b8
	03 00 00	 mov	 rdx, QWORD PTR OutlineSize$30[rsp]
  008fc	48 8b 84 24 70
	06 00 00	 mov	 rax, QWORD PTR Image$[rsp]
  00904	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00908	e8 00 00 00 00	 call	 ??H@YA?ATv2@@T0@0@Z	; operator+
  0090d	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR $T29[rsp], rax
  00915	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  0091d	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR $T29[rsp]
  00925	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0092d	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@Tv2@@M@Z	; V3
  00932	48 8d 8c 24 20
	04 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  0093a	48 8b f9	 mov	 rdi, rcx
  0093d	48 8b f0	 mov	 rsi, rax
  00940	b9 0c 00 00 00	 mov	 ecx, 12
  00945	f3 a4		 rep movsb
  00947	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  0094f	48 8d 8c 24 20
	04 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00957	48 8b f8	 mov	 rdi, rax
  0095a	48 8b f1	 mov	 rsi, rcx
  0095d	b9 0c 00 00 00	 mov	 ecx, 12
  00962	f3 a4		 rep movsb
  00964	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  0096c	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  00974	e8 00 00 00 00	 call	 ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z ; ScaleMat4

; 119  :         
; 120  :         Constants.M = Transform * *Projection;

  00979	48 8d 84 24 00
	02 00 00	 lea	 rax, QWORD PTR $T23[rsp]
  00981	48 8b f8	 mov	 rdi, rax
  00984	48 8b b4 24 90
	06 00 00	 mov	 rsi, QWORD PTR Projection$[rsp]
  0098c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00991	f3 a4		 rep movsb
  00993	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR $T24[rsp]
  0099b	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  009a3	48 8b f8	 mov	 rdi, rax
  009a6	48 8b f1	 mov	 rsi, rcx
  009a9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  009ae	f3 a4		 rep movsb
  009b0	4c 8d 84 24 00
	02 00 00	 lea	 r8, QWORD PTR $T23[rsp]
  009b8	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR $T24[rsp]
  009c0	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  009c8	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  009cd	48 8d 8c 24 80
	05 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  009d5	48 8b f9	 mov	 rdi, rcx
  009d8	48 8b f0	 mov	 rsi, rax
  009db	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  009e0	f3 a4		 rep movsb
  009e2	48 8d 84 24 f0
	04 00 00	 lea	 rax, QWORD PTR Constants$[rsp+16]
  009ea	48 8d 8c 24 80
	05 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  009f2	48 8b f8	 mov	 rdi, rax
  009f5	48 8b f1	 mov	 rsi, rcx
  009f8	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  009fd	f3 a4		 rep movsb

; 121  :         Constants.Color = OutlineColor;

  009ff	48 8d 84 24 e0
	04 00 00	 lea	 rax, QWORD PTR Constants$[rsp]
  00a07	48 8d 8c 24 d0
	03 00 00	 lea	 rcx, QWORD PTR OutlineColor$32[rsp]
  00a0f	48 8b f8	 mov	 rdi, rax
  00a12	48 8b f1	 mov	 rsi, rcx
  00a15	b9 10 00 00 00	 mov	 ecx, 16
  00a1a	f3 a4		 rep movsb

; 122  :         Constants.Z = Z + 0.0001f;

  00a1c	f3 0f 10 84 24
	98 06 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  00a25	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@38d1b717
  00a2d	f3 0f 11 84 24
	30 05 00 00	 movss	 DWORD PTR Constants$[rsp+80], xmm0

; 123  :         Platform->RenderMesh(State->Quad, State->BasicTexture, State->UIShader, &Constants, true);

  00a36	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00a3e	4c 8d 8c 24 e0
	04 00 00	 lea	 r9, QWORD PTR Constants$[rsp]
  00a46	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00a4d	4c 8b 80 18 01
	00 00		 mov	 r8, QWORD PTR [rax+280]
  00a54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00a5b	48 8b 90 08 01
	00 00		 mov	 rdx, QWORD PTR [rax+264]
  00a62	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00a69	48 8b 88 00 01
	00 00		 mov	 rcx, QWORD PTR [rax+256]
  00a70	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  00a77	ff 50 50	 call	 QWORD PTR [rax+80]
$LN8@UIImage:

; 124  :     }
; 125  :     
; 126  :     return(Hovered);

  00a7a	8b 44 24 30	 mov	 eax, DWORD PTR Hovered$[rsp]

; 127  : }

  00a7e	48 8b 8c 24 40
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a86	48 33 cc	 xor	 rcx, rsp
  00a89	e8 00 00 00 00	 call	 __security_check_cookie
  00a8e	48 81 c4 58 06
	00 00		 add	 rsp, 1624		; 00000658H
  00a95	5f		 pop	 rdi
  00a96	5e		 pop	 rsi
  00a97	c3		 ret	 0
?UIImage@@YAHUloaded_image@@Tv2@@1Tv4@@PEATmat4@@MHHHPEAX@Z ENDP ; UIImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_ui.cpp
_TEXT	SEGMENT
Width$ = 48
Height$ = 52
$T1 = 64
$T2 = 80
$T3 = 96
$T4 = 112
TopSize$ = 128
SideSize$ = 136
TopPos$ = 144
BottomPos$ = 152
LeftPos$ = 160
RightPos$ = 168
__$ArrayPad$ = 176
BottomLeft$ = 224
TopRight$ = 232
Color$ = 240
Thickness$ = 248
Projection$ = 256
Z$ = 264
?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z PROC		; RenderBox

; 27   : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00025	48 33 c4	 xor	 rax, rsp
  00028	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 28   :     f32 Width = TopRight.x - BottomLeft.x;

  00030	f3 0f 10 84 24
	e8 00 00 00	 movss	 xmm0, DWORD PTR TopRight$[rsp]
  00039	f3 0f 5c 84 24
	e0 00 00 00	 subss	 xmm0, DWORD PTR BottomLeft$[rsp]
  00042	f3 0f 11 44 24
	30		 movss	 DWORD PTR Width$[rsp], xmm0

; 29   :     f32 Height = BottomLeft.y - TopRight.y;

  00048	f3 0f 10 84 24
	e4 00 00 00	 movss	 xmm0, DWORD PTR BottomLeft$[rsp+4]
  00051	f3 0f 5c 84 24
	ec 00 00 00	 subss	 xmm0, DWORD PTR TopRight$[rsp+4]
  0005a	f3 0f 11 44 24
	34		 movss	 DWORD PTR Height$[rsp], xmm0

; 30   :     
; 31   :     v2 TopSize = { Width + Thickness, Thickness };

  00060	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Width$[rsp]
  00066	f3 0f 58 84 24
	f8 00 00 00	 addss	 xmm0, DWORD PTR Thickness$[rsp]
  0006f	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR TopSize$[rsp], xmm0
  00078	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  00081	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR TopSize$[rsp+4], xmm0

; 32   :     v2 TopPos = { BottomLeft.x - Thickness/2.0f, TopRight.y - Thickness/2.0f };

  0008a	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  00093	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0009b	f3 0f 10 8c 24
	e0 00 00 00	 movss	 xmm1, DWORD PTR BottomLeft$[rsp]
  000a4	f3 0f 5c c8	 subss	 xmm1, xmm0
  000a8	0f 28 c1	 movaps	 xmm0, xmm1
  000ab	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR TopPos$[rsp], xmm0
  000b4	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  000bd	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000c5	f3 0f 10 8c 24
	ec 00 00 00	 movss	 xmm1, DWORD PTR TopRight$[rsp+4]
  000ce	f3 0f 5c c8	 subss	 xmm1, xmm0
  000d2	0f 28 c1	 movaps	 xmm0, xmm1
  000d5	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR TopPos$[rsp+4], xmm0

; 33   :     RenderLine(Color, TopPos, TopSize, Projection, Z);

  000de	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  000e3	48 8b f8	 mov	 rdi, rax
  000e6	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  000ee	b9 10 00 00 00	 mov	 ecx, 16
  000f3	f3 a4		 rep movsb
  000f5	f3 0f 10 84 24
	08 01 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  000fe	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00104	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR Projection$[rsp]
  0010c	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR TopSize$[rsp]
  00114	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR TopPos$[rsp]
  0011c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T1[rsp]
  00121	e8 00 00 00 00	 call	 ?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z ; RenderLine

; 34   :     
; 35   :     v2 BottomPos = { BottomLeft.x - Thickness/2.0f, BottomLeft.y - Thickness/2.0f };

  00126	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  0012f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00137	f3 0f 10 8c 24
	e0 00 00 00	 movss	 xmm1, DWORD PTR BottomLeft$[rsp]
  00140	f3 0f 5c c8	 subss	 xmm1, xmm0
  00144	0f 28 c1	 movaps	 xmm0, xmm1
  00147	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR BottomPos$[rsp], xmm0
  00150	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  00159	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00161	f3 0f 10 8c 24
	e4 00 00 00	 movss	 xmm1, DWORD PTR BottomLeft$[rsp+4]
  0016a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0016e	0f 28 c1	 movaps	 xmm0, xmm1
  00171	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR BottomPos$[rsp+4], xmm0

; 36   :     RenderLine(Color, BottomPos, TopSize, Projection, Z);

  0017a	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  0017f	48 8b f8	 mov	 rdi, rax
  00182	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  0018a	b9 10 00 00 00	 mov	 ecx, 16
  0018f	f3 a4		 rep movsb
  00191	f3 0f 10 84 24
	08 01 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  0019a	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  001a0	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR Projection$[rsp]
  001a8	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR TopSize$[rsp]
  001b0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR BottomPos$[rsp]
  001b8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T2[rsp]
  001bd	e8 00 00 00 00	 call	 ?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z ; RenderLine

; 37   :     
; 38   :     v2 SideSize = { Thickness, Height };

  001c2	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  001cb	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR SideSize$[rsp], xmm0
  001d4	f3 0f 10 44 24
	34		 movss	 xmm0, DWORD PTR Height$[rsp]
  001da	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR SideSize$[rsp+4], xmm0

; 39   :     v2 LeftPos = { BottomLeft.x - Thickness/2.0f, TopRight.y };

  001e3	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  001ec	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  001f4	f3 0f 10 8c 24
	e0 00 00 00	 movss	 xmm1, DWORD PTR BottomLeft$[rsp]
  001fd	f3 0f 5c c8	 subss	 xmm1, xmm0
  00201	0f 28 c1	 movaps	 xmm0, xmm1
  00204	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR LeftPos$[rsp], xmm0
  0020d	f3 0f 10 84 24
	ec 00 00 00	 movss	 xmm0, DWORD PTR TopRight$[rsp+4]
  00216	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR LeftPos$[rsp+4], xmm0

; 40   :     RenderLine(Color, LeftPos, SideSize, Projection, Z);

  0021f	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00224	48 8b f8	 mov	 rdi, rax
  00227	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  0022f	b9 10 00 00 00	 mov	 ecx, 16
  00234	f3 a4		 rep movsb
  00236	f3 0f 10 84 24
	08 01 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  0023f	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00245	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR Projection$[rsp]
  0024d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR SideSize$[rsp]
  00255	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR LeftPos$[rsp]
  0025d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  00262	e8 00 00 00 00	 call	 ?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z ; RenderLine

; 41   :     
; 42   :     v2 RightPos = { TopRight.x - Thickness/2.0f, TopRight.y };

  00267	f3 0f 10 84 24
	f8 00 00 00	 movss	 xmm0, DWORD PTR Thickness$[rsp]
  00270	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00278	f3 0f 10 8c 24
	e8 00 00 00	 movss	 xmm1, DWORD PTR TopRight$[rsp]
  00281	f3 0f 5c c8	 subss	 xmm1, xmm0
  00285	0f 28 c1	 movaps	 xmm0, xmm1
  00288	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR RightPos$[rsp], xmm0
  00291	f3 0f 10 84 24
	ec 00 00 00	 movss	 xmm0, DWORD PTR TopRight$[rsp+4]
  0029a	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR RightPos$[rsp+4], xmm0

; 43   :     RenderLine(Color, RightPos, SideSize, Projection, Z);

  002a3	48 8d 44 24 70	 lea	 rax, QWORD PTR $T4[rsp]
  002a8	48 8b f8	 mov	 rdi, rax
  002ab	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  002b3	b9 10 00 00 00	 mov	 ecx, 16
  002b8	f3 a4		 rep movsb
  002ba	f3 0f 10 84 24
	08 01 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  002c3	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  002c9	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR Projection$[rsp]
  002d1	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR SideSize$[rsp]
  002d9	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR RightPos$[rsp]
  002e1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T4[rsp]
  002e6	e8 00 00 00 00	 call	 ?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z ; RenderLine

; 44   : }

  002eb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f3	48 33 cc	 xor	 rcx, rsp
  002f6	e8 00 00 00 00	 call	 __security_check_cookie
  002fb	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00302	5f		 pop	 rdi
  00303	5e		 pop	 rsi
  00304	c3		 ret	 0
?RenderBox@@YAXTv2@@0Tv4@@MPEATmat4@@M@Z ENDP		; RenderBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_ui.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
$T7 = 144
$T8 = 160
$T9 = 176
$T10 = 240
$T11 = 304
$T12 = 368
RotationRadians$ = 432
$T13 = 448
$T14 = 464
$T15 = 480
Transform$ = 496
Constants$ = 560
$T16 = 656
$T17 = 720
__$ArrayPad$ = 784
Color$ = 832
Position$ = 840
Scale$ = 848
Projection$ = 856
Z$ = 864
?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z PROC		; RenderLine

; 3    : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 28 03
	00 00		 sub	 rsp, 808		; 00000328H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4    :     Scale /= 2.0f;

  0002f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  00037	48 8d 8c 24 50
	03 00 00	 lea	 rcx, QWORD PTR Scale$[rsp]
  0003f	e8 00 00 00 00	 call	 ??_0@YAAEATv2@@AEAT0@M@Z ; operator/=

; 5    :     Position += Scale;

  00044	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR Scale$[rsp]
  0004c	48 8d 8c 24 48
	03 00 00	 lea	 rcx, QWORD PTR Position$[rsp]
  00054	e8 00 00 00 00	 call	 ??Y@YAAEATv2@@AEAT0@T0@@Z ; operator+=

; 6    :     
; 7    :     mat4 Transform = Mat4Identity();

  00059	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  00061	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  00066	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0006e	48 8b f9	 mov	 rdi, rcx
  00071	48 8b f0	 mov	 rsi, rax
  00074	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00079	f3 a4		 rep movsb
  0007b	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR Transform$[rsp]
  00083	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0008b	48 8b f8	 mov	 rdi, rax
  0008e	48 8b f1	 mov	 rsi, rcx
  00091	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00096	f3 a4		 rep movsb

; 8    :     TranslateMat4(&Transform, V3(Position, 0.0f));

  00098	0f 57 d2	 xorps	 xmm2, xmm2
  0009b	48 8b 94 24 48
	03 00 00	 mov	 rdx, QWORD PTR Position$[rsp]
  000a3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  000ab	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@Tv2@@M@Z	; V3
  000b0	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  000b8	48 8b f9	 mov	 rdi, rcx
  000bb	48 8b f0	 mov	 rsi, rax
  000be	b9 0c 00 00 00	 mov	 ecx, 12
  000c3	f3 a4		 rep movsb
  000c5	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  000ca	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  000d2	48 8b f8	 mov	 rdi, rax
  000d5	48 8b f1	 mov	 rsi, rcx
  000d8	b9 0c 00 00 00	 mov	 ecx, 12
  000dd	f3 a4		 rep movsb
  000df	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  000e4	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  000ec	e8 00 00 00 00	 call	 ?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z ; TranslateMat4

; 9    :     v3 RotationRadians = { 0.0f, 0.0f, 0.0f };

  000f1	0f 57 c0	 xorps	 xmm0, xmm0
  000f4	f3 0f 11 84 24
	b0 01 00 00	 movss	 DWORD PTR RotationRadians$[rsp], xmm0
  000fd	0f 57 c0	 xorps	 xmm0, xmm0
  00100	f3 0f 11 84 24
	b4 01 00 00	 movss	 DWORD PTR RotationRadians$[rsp+4], xmm0
  00109	0f 57 c0	 xorps	 xmm0, xmm0
  0010c	f3 0f 11 84 24
	b8 01 00 00	 movss	 DWORD PTR RotationRadians$[rsp+8], xmm0

; 10   :     if(RotationRadians.x || RotationRadians.y || RotationRadians.z)

  00115	f3 0f 10 84 24
	b0 01 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp]
  0011e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00125	7a 2e		 jp	 SHORT $LN3@RenderLine
  00127	75 2c		 jne	 SHORT $LN3@RenderLine
  00129	f3 0f 10 84 24
	b4 01 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+4]
  00132	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00139	7a 1a		 jp	 SHORT $LN3@RenderLine
  0013b	75 18		 jne	 SHORT $LN3@RenderLine
  0013d	f3 0f 10 84 24
	b8 01 00 00	 movss	 xmm0, DWORD PTR RotationRadians$[rsp+8]
  00146	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0014d	7a 06		 jp	 SHORT $LN5@RenderLine
  0014f	0f 84 94 00 00
	00		 je	 $LN2@RenderLine
$LN5@RenderLine:
$LN3@RenderLine:

; 11   :     {
; 12   :         RotateMat4(&Transform,

  00155	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0015a	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  00162	48 8b f8	 mov	 rdi, rax
  00165	48 8b f1	 mov	 rsi, rcx
  00168	b9 0c 00 00 00	 mov	 ecx, 12
  0016d	f3 a4		 rep movsb
  0016f	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  00174	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0017c	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  00181	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  00189	48 8b f9	 mov	 rdi, rcx
  0018c	48 8b f0	 mov	 rsi, rax
  0018f	b9 0c 00 00 00	 mov	 ecx, 12
  00194	f3 a4		 rep movsb
  00196	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  0019b	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  001a3	48 8b f8	 mov	 rdi, rax
  001a6	48 8b f1	 mov	 rsi, rcx
  001a9	b9 0c 00 00 00	 mov	 ecx, 12
  001ae	f3 a4		 rep movsb
  001b0	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  001b5	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR RotationRadians$[rsp]
  001bd	48 8b f8	 mov	 rdi, rax
  001c0	48 8b f1	 mov	 rsi, rcx
  001c3	b9 0c 00 00 00	 mov	 ecx, 12
  001c8	f3 a4		 rep movsb
  001ca	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  001cf	e8 00 00 00 00	 call	 ?V3Length@@YAMTv3@@@Z	; V3Length
  001d4	4c 8d 44 24 60	 lea	 r8, QWORD PTR $T4[rsp]
  001d9	0f 28 c8	 movaps	 xmm1, xmm0
  001dc	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  001e4	e8 00 00 00 00	 call	 ?RotateMat4@@YAXPEATmat4@@MTv3@@@Z ; RotateMat4
$LN2@RenderLine:

; 13   :                    V3Length(RotationRadians),
; 14   :                    V3Normalize(RotationRadians));
; 15   :     }
; 16   :     ScaleMat4(&Transform, V3(Scale, 1.0f));

  001e9	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  001f1	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR Scale$[rsp]
  001f9	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00201	e8 00 00 00 00	 call	 ?V3@@YA?ATv3@@Tv2@@M@Z	; V3
  00206	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  0020e	48 8b f9	 mov	 rdi, rcx
  00211	48 8b f0	 mov	 rsi, rax
  00214	b9 0c 00 00 00	 mov	 ecx, 12
  00219	f3 a4		 rep movsb
  0021b	48 8d 44 24 70	 lea	 rax, QWORD PTR $T5[rsp]
  00220	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00228	48 8b f8	 mov	 rdi, rax
  0022b	48 8b f1	 mov	 rsi, rcx
  0022e	b9 0c 00 00 00	 mov	 ecx, 12
  00233	f3 a4		 rep movsb
  00235	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T5[rsp]
  0023a	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  00242	e8 00 00 00 00	 call	 ?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z ; ScaleMat4

; 17   :     
; 18   :     ui_shader_constants Constants;
; 19   :     Constants.M = Transform * *Projection;

  00247	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  0024f	48 8b f8	 mov	 rdi, rax
  00252	48 8b b4 24 58
	03 00 00	 mov	 rsi, QWORD PTR Projection$[rsp]
  0025a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0025f	f3 a4		 rep movsb
  00261	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  00269	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR Transform$[rsp]
  00271	48 8b f8	 mov	 rdi, rax
  00274	48 8b f1	 mov	 rsi, rcx
  00277	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0027c	f3 a4		 rep movsb
  0027e	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR $T9[rsp]
  00286	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR $T10[rsp]
  0028e	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00296	e8 00 00 00 00	 call	 ??D@YA?ATmat4@@T0@0@Z	; operator*
  0029b	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  002a3	48 8b f9	 mov	 rdi, rcx
  002a6	48 8b f0	 mov	 rsi, rax
  002a9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002ae	f3 a4		 rep movsb
  002b0	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR Constants$[rsp+16]
  002b8	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  002c0	48 8b f8	 mov	 rdi, rax
  002c3	48 8b f1	 mov	 rsi, rcx
  002c6	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002cb	f3 a4		 rep movsb

; 20   :     Constants.Color = Color;

  002cd	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR Constants$[rsp]
  002d5	48 8b f8	 mov	 rdi, rax
  002d8	48 8b b4 24 40
	03 00 00	 mov	 rsi, QWORD PTR Color$[rsp]
  002e0	b9 10 00 00 00	 mov	 ecx, 16
  002e5	f3 a4		 rep movsb

; 21   :     Constants.Z = Z;

  002e7	f3 0f 10 84 24
	60 03 00 00	 movss	 xmm0, DWORD PTR Z$[rsp]
  002f0	f3 0f 11 84 24
	80 02 00 00	 movss	 DWORD PTR Constants$[rsp+80], xmm0

; 22   :     Platform->RenderMesh(State->Quad, State->BasicTexture, State->UIShader, &Constants, true);

  002f9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00301	4c 8d 8c 24 30
	02 00 00	 lea	 r9, QWORD PTR Constants$[rsp]
  00309	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  00310	4c 8b 80 18 01
	00 00		 mov	 r8, QWORD PTR [rax+280]
  00317	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0031e	48 8b 90 08 01
	00 00		 mov	 rdx, QWORD PTR [rax+264]
  00325	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?State@@3PEAUgame_state@@EA
  0032c	48 8b 88 00 01
	00 00		 mov	 rcx, QWORD PTR [rax+256]
  00333	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0033a	ff 50 50	 call	 QWORD PTR [rax+80]

; 23   : }

  0033d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00345	48 33 cc	 xor	 rcx, rsp
  00348	e8 00 00 00 00	 call	 __security_check_cookie
  0034d	48 81 c4 28 03
	00 00		 add	 rsp, 808		; 00000328H
  00354	5f		 pop	 rdi
  00355	5e		 pop	 rsi
  00356	c3		 ret	 0
?RenderLine@@YAXTv4@@Tv2@@1PEATmat4@@M@Z ENDP		; RenderLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_camera.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
__$ArrayPad$ = 144
Camera$ = 192
Result$ = 200
?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z PROC	; GetCameraView

; 16   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 17   :     Mat4LookAt(Result, Camera->Position, Camera->Position + Camera->Rotation, Camera->Up);

  00025	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  0002a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR Camera$[rsp]
  00032	48 8b f8	 mov	 rdi, rax
  00035	48 8d 71 0c	 lea	 rsi, QWORD PTR [rcx+12]
  00039	b9 0c 00 00 00	 mov	 ecx, 12
  0003e	f3 a4		 rep movsb
  00040	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00045	48 8b f8	 mov	 rdi, rax
  00048	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR Camera$[rsp]
  00050	b9 0c 00 00 00	 mov	 ecx, 12
  00055	f3 a4		 rep movsb
  00057	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  0005c	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00061	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T6[rsp]
  00066	e8 00 00 00 00	 call	 ??H@YA?ATv3@@T0@0@Z	; operator+
  0006b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00073	48 8b f9	 mov	 rdi, rcx
  00076	48 8b f0	 mov	 rsi, rax
  00079	b9 0c 00 00 00	 mov	 ecx, 12
  0007e	f3 a4		 rep movsb
  00080	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  00085	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR Camera$[rsp]
  0008d	48 8b f8	 mov	 rdi, rax
  00090	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00094	b9 0c 00 00 00	 mov	 ecx, 12
  00099	f3 a4		 rep movsb
  0009b	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  000a0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b f1	 mov	 rsi, rcx
  000ae	b9 0c 00 00 00	 mov	 ecx, 12
  000b3	f3 a4		 rep movsb
  000b5	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  000ba	48 8b f8	 mov	 rdi, rax
  000bd	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR Camera$[rsp]
  000c5	b9 0c 00 00 00	 mov	 ecx, 12
  000ca	f3 a4		 rep movsb
  000cc	4c 8d 4c 24 40	 lea	 r9, QWORD PTR $T3[rsp]
  000d1	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T4[rsp]
  000d6	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T5[rsp]
  000db	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  000e3	e8 00 00 00 00	 call	 ?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z ; Mat4LookAt

; 18   : }

  000e8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f0	48 33 cc	 xor	 rcx, rsp
  000f3	e8 00 00 00 00	 call	 __security_check_cookie
  000f8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  000ff	5f		 pop	 rdi
  00100	5e		 pop	 rsi
  00101	c3		 ret	 0
?GetCameraView@@YAXPEAUcamera@@PEATmat4@@@Z ENDP	; GetCameraView
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_camera.cpp
_TEXT	SEGMENT
Camera$ = 24
Position$ = 32
Rotation$ = 40
Up$ = 48
FOV$ = 56
Near$ = 64
Far$ = 72
?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z PROC	; InitializeCamera

; 4    : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi

; 5    :     Camera->Position = Position;

  00016	48 8b 7c 24 18	 mov	 rdi, QWORD PTR Camera$[rsp]
  0001b	48 8b 74 24 20	 mov	 rsi, QWORD PTR Position$[rsp]
  00020	b9 0c 00 00 00	 mov	 ecx, 12
  00025	f3 a4		 rep movsb

; 6    :     Camera->Rotation = Rotation;

  00027	48 8b 44 24 18	 mov	 rax, QWORD PTR Camera$[rsp]
  0002c	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  00030	48 8b 74 24 28	 mov	 rsi, QWORD PTR Rotation$[rsp]
  00035	b9 0c 00 00 00	 mov	 ecx, 12
  0003a	f3 a4		 rep movsb

; 7    :     Camera->Up = Up;

  0003c	48 8b 44 24 18	 mov	 rax, QWORD PTR Camera$[rsp]
  00041	48 8d 78 18	 lea	 rdi, QWORD PTR [rax+24]
  00045	48 8b 74 24 30	 mov	 rsi, QWORD PTR Up$[rsp]
  0004a	b9 0c 00 00 00	 mov	 ecx, 12
  0004f	f3 a4		 rep movsb

; 8    :     Camera->Euler.Yaw = 90.0f;

  00051	48 8b 44 24 18	 mov	 rax, QWORD PTR Camera$[rsp]
  00056	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42b40000
  0005e	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0

; 9    :     Camera->FOV = FOV;

  00063	48 8b 44 24 18	 mov	 rax, QWORD PTR Camera$[rsp]
  00068	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR FOV$[rsp]
  0006e	f3 0f 11 40 30	 movss	 DWORD PTR [rax+48], xmm0

; 10   :     Camera->Near = Near;

  00073	48 8b 44 24 18	 mov	 rax, QWORD PTR Camera$[rsp]
  00078	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR Near$[rsp]
  0007e	f3 0f 11 40 34	 movss	 DWORD PTR [rax+52], xmm0

; 11   :     Camera->Far = Far;

  00083	48 8b 44 24 18	 mov	 rax, QWORD PTR Camera$[rsp]
  00088	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR Far$[rsp]
  0008e	f3 0f 11 40 38	 movss	 DWORD PTR [rax+56], xmm0

; 12   : }

  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	c3		 ret	 0
?InitializeCamera@@YAXPEAUcamera@@Tv3@@11MMM@Z ENDP	; InitializeCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_string.cpp
_TEXT	SEGMENT
CharacterIndex$1 = 32
Destination$ = 64
Path$ = 72
?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z PROC		; GetPathNoFileName

; 98   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 99   :     for(s32 CharacterIndex = Path.Length - 1;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR Path$[rsp]
  00013	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00016	ff c8		 dec	 eax
  00018	89 44 24 20	 mov	 DWORD PTR CharacterIndex$1[rsp], eax
  0001c	eb 0a		 jmp	 SHORT $LN4@GetPathNoF
$LN2@GetPathNoF:

; 101  :         --CharacterIndex)

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR CharacterIndex$1[rsp]
  00022	ff c8		 dec	 eax
  00024	89 44 24 20	 mov	 DWORD PTR CharacterIndex$1[rsp], eax
$LN4@GetPathNoF:

; 100  :         CharacterIndex > 0;

  00028	83 7c 24 20 00	 cmp	 DWORD PTR CharacterIndex$1[rsp], 0
  0002d	7e 2c		 jle	 SHORT $LN3@GetPathNoF

; 102  :     {
; 103  :         --Path.Length;

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR Path$[rsp]
  00034	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00037	ff c8		 dec	 eax
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Path$[rsp]
  0003e	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 104  :         if(Path.String[CharacterIndex] == '/')

  00041	48 63 44 24 20	 movsxd	 rax, DWORD PTR CharacterIndex$1[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Path$[rsp]
  0004b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00052	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00055	75 02		 jne	 SHORT $LN5@GetPathNoF

; 105  :         {
; 106  :             break;

  00057	eb 02		 jmp	 SHORT $LN3@GetPathNoF
$LN5@GetPathNoF:

; 107  :         }
; 108  :     }

  00059	eb c3		 jmp	 SHORT $LN2@GetPathNoF
$LN3@GetPathNoF:

; 109  :     
; 110  :     Platform->CopyMemory(Destination->String, Path.String, Path.Length);

  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR Path$[rsp]
  00060	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00064	4c 8b c0	 mov	 r8, rax
  00067	48 8b 44 24 48	 mov	 rax, QWORD PTR Path$[rsp]
  0006c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR Destination$[rsp]
  00074	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?Platform@@3PEAUplatform_api@@EA
  0007e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 111  :     Destination->Length = Path.Length;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR Destination$[rsp]
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Path$[rsp]
  0008e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00091	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 112  :     Destination->String[Path.Length] = 0;

  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR Path$[rsp]
  00099	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  0009d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Destination$[rsp]
  000a2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a5	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 113  : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
?GetPathNoFileName@@YAXPEAUstring8@@U1@@Z ENDP		; GetPathNoFileName
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_string.cpp
_TEXT	SEGMENT
Index$1 = 0
A$ = 32
B$ = 40
?CompareStringBinary@@YAHUstring8@@0@Z PROC		; CompareStringBinary

; 56   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 57   :     if(A.Length != B.Length)

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR A$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR B$[rsp]
  00018	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0001b	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0001e	74 04		 je	 SHORT $LN5@CompareStr

; 58   :     {
; 59   :         return(false);

  00020	33 c0		 xor	 eax, eax
  00022	eb 4d		 jmp	 SHORT $LN1@CompareStr
$LN5@CompareStr:

; 60   :     }
; 61   :     
; 62   :     for(s32 Index = 0;

  00024	c7 04 24 00 00
	00 00		 mov	 DWORD PTR Index$1[rsp], 0
  0002b	eb 08		 jmp	 SHORT $LN4@CompareStr
$LN2@CompareStr:

; 64   :         ++Index)

  0002d	8b 04 24	 mov	 eax, DWORD PTR Index$1[rsp]
  00030	ff c0		 inc	 eax
  00032	89 04 24	 mov	 DWORD PTR Index$1[rsp], eax
$LN4@CompareStr:

; 63   :         Index < A.Length;

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR A$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	39 04 24	 cmp	 DWORD PTR Index$1[rsp], eax
  00040	7d 2a		 jge	 SHORT $LN3@CompareStr

; 65   :     {
; 66   :         if(A.String[Index] != B.String[Index])

  00042	48 63 04 24	 movsxd	 rax, DWORD PTR Index$1[rsp]
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR A$[rsp]
  0004b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00052	48 63 0c 24	 movsxd	 rcx, DWORD PTR Index$1[rsp]
  00056	48 8b 54 24 28	 mov	 rdx, QWORD PTR B$[rsp]
  0005b	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0005e	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00062	3b c1		 cmp	 eax, ecx
  00064	74 04		 je	 SHORT $LN6@CompareStr

; 67   :         {
; 68   :             return(false);

  00066	33 c0		 xor	 eax, eax
  00068	eb 07		 jmp	 SHORT $LN1@CompareStr
$LN6@CompareStr:

; 69   :         }
; 70   :     }

  0006a	eb c1		 jmp	 SHORT $LN2@CompareStr
$LN3@CompareStr:

; 71   :     
; 72   :     return(true);

  0006c	b8 01 00 00 00	 mov	 eax, 1
$LN1@CompareStr:

; 73   : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
?CompareStringBinary@@YAHUstring8@@0@Z ENDP		; CompareStringBinary
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_string.cpp
_TEXT	SEGMENT
Index$1 = 0
Ptr$ = 8
Destination$ = 32
Source$ = 40
?StringConcat@@YAXPEAUstring8@@U1@@Z PROC		; StringConcat

; 41   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 42   :     char *Ptr = Destination->String + Destination->Length;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR Destination$[rsp]
  00013	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00017	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Destination$[rsp]
  0001c	48 03 01	 add	 rax, QWORD PTR [rcx]
  0001f	48 89 44 24 08	 mov	 QWORD PTR Ptr$[rsp], rax

; 43   :     for(s32 Index = 0;

  00024	c7 04 24 00 00
	00 00		 mov	 DWORD PTR Index$1[rsp], 0
  0002b	eb 08		 jmp	 SHORT $LN4@StringConc
$LN2@StringConc:

; 45   :         ++Index)

  0002d	8b 04 24	 mov	 eax, DWORD PTR Index$1[rsp]
  00030	ff c0		 inc	 eax
  00032	89 04 24	 mov	 DWORD PTR Index$1[rsp], eax
$LN4@StringConc:

; 44   :         Index < Source.Length;

  00035	48 8b 44 24 28	 mov	 rax, QWORD PTR Source$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	39 04 24	 cmp	 DWORD PTR Index$1[rsp], eax
  00040	7d 34		 jge	 SHORT $LN3@StringConc

; 46   :     {
; 47   :         *Ptr++ = *Source.String++;

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR Source$[rsp]
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR Ptr$[rsp]
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00052	88 01		 mov	 BYTE PTR [rcx], al
  00054	48 8b 44 24 08	 mov	 rax, QWORD PTR Ptr$[rsp]
  00059	48 ff c0	 inc	 rax
  0005c	48 89 44 24 08	 mov	 QWORD PTR Ptr$[rsp], rax
  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR Source$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 ff c0	 inc	 rax
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Source$[rsp]
  00071	48 89 01	 mov	 QWORD PTR [rcx], rax

; 48   :     }

  00074	eb b7		 jmp	 SHORT $LN2@StringConc
$LN3@StringConc:

; 49   :     *Ptr = '\0';

  00076	48 8b 44 24 08	 mov	 rax, QWORD PTR Ptr$[rsp]
  0007b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 50   :     
; 51   :     Destination->Length += Source.Length;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR Destination$[rsp]
  00083	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00086	48 8b 4c 24 28	 mov	 rcx, QWORD PTR Source$[rsp]
  0008b	03 41 08	 add	 eax, DWORD PTR [rcx+8]
  0008e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Destination$[rsp]
  00093	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 52   : }

  00096	48 83 c4 18	 add	 rsp, 24
  0009a	c3		 ret	 0
?StringConcat@@YAXPEAUstring8@@U1@@Z ENDP		; StringConcat
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_string.cpp
_TEXT	SEGMENT
Result$ = 32
$T1 = 80
String$ = 88
?CreateString@@YA?AUstring8@@PEAD@Z PROC		; CreateString

; 19   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 20   :     string8 Result;
; 21   :     Result.String = String;

  00010	48 8b 44 24 58	 mov	 rax, QWORD PTR String$[rsp]
  00015	48 89 44 24 20	 mov	 QWORD PTR Result$[rsp], rax

; 22   :     Result.Length = StringLength(String);

  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR String$[rsp]
  0001f	e8 00 00 00 00	 call	 ?StringLength@@YAHPEAD@Z ; StringLength
  00024	89 44 24 28	 mov	 DWORD PTR Result$[rsp+8], eax

; 23   :     return(Result);

  00028	48 8d 44 24 20	 lea	 rax, QWORD PTR Result$[rsp]
  0002d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR $T1[rsp]
  00032	48 8b f0	 mov	 rsi, rax
  00035	b9 10 00 00 00	 mov	 ecx, 16
  0003a	f3 a4		 rep movsb
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]

; 24   : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	5f		 pop	 rdi
  00046	5e		 pop	 rsi
  00047	c3		 ret	 0
?CreateString@@YA?AUstring8@@PEAD@Z ENDP		; CreateString
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_string.cpp
_TEXT	SEGMENT
Counter$ = 0
tv67 = 4
Ptr$ = 8
Str$ = 32
?StringLength@@YAHPEAD@Z PROC				; StringLength

; 6    : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 7    :     s32 Counter = 0;

  00009	c7 04 24 00 00
	00 00		 mov	 DWORD PTR Counter$[rsp], 0

; 8    :     char *Ptr = Str;

  00010	48 8b 44 24 20	 mov	 rax, QWORD PTR Str$[rsp]
  00015	48 89 44 24 08	 mov	 QWORD PTR Ptr$[rsp], rax
$LN2@StringLeng:

; 9    :     while(*Ptr++)

  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR Ptr$[rsp]
  0001f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00022	89 44 24 04	 mov	 DWORD PTR tv67[rsp], eax
  00026	48 8b 44 24 08	 mov	 rax, QWORD PTR Ptr$[rsp]
  0002b	48 ff c0	 inc	 rax
  0002e	48 89 44 24 08	 mov	 QWORD PTR Ptr$[rsp], rax
  00033	83 7c 24 04 00	 cmp	 DWORD PTR tv67[rsp], 0
  00038	74 0a		 je	 SHORT $LN3@StringLeng

; 10   :     {
; 11   :         ++Counter;

  0003a	8b 04 24	 mov	 eax, DWORD PTR Counter$[rsp]
  0003d	ff c0		 inc	 eax
  0003f	89 04 24	 mov	 DWORD PTR Counter$[rsp], eax

; 12   :     }

  00042	eb d6		 jmp	 SHORT $LN2@StringLeng
$LN3@StringLeng:

; 13   :     
; 14   :     return(Counter);

  00044	8b 04 24	 mov	 eax, DWORD PTR Counter$[rsp]

; 15   : }

  00047	48 83 c4 18	 add	 rsp, 24
  0004b	c3		 ret	 0
?StringLength@@YAHPEAD@Z ENDP				; StringLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
loc$1 = 32
nm$ = 36
i$ = 40
offset$ = 44
count$ = 48
stringOffset$ = 52
fc$ = 56
tv155 = 64
font$ = 96
length$ = 104
platformID$ = 112
encodingID$ = 120
languageID$ = 128
nameID$ = 136
stbtt_GetFontNameString PROC

; 4823 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4824 :    stbtt_int32 i,count,stringOffset;
; 4825 :    stbtt_uint8 *fc = font->data;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR font$[rsp]
  0001d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00021	48 89 44 24 38	 mov	 QWORD PTR fc$[rsp], rax

; 4826 :    stbtt_uint32 offset = font->fontstart;

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR font$[rsp]
  0002b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002e	89 44 24 2c	 mov	 DWORD PTR offset$[rsp], eax

; 4827 :    stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");

  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG44115
  00039	8b 54 24 2c	 mov	 edx, DWORD PTR offset$[rsp]
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00047	89 44 24 24	 mov	 DWORD PTR nm$[rsp], eax

; 4828 :    if (!nm) return NULL;

  0004b	83 7c 24 24 00	 cmp	 DWORD PTR nm$[rsp], 0
  00050	75 07		 jne	 SHORT $LN5@stbtt_GetF
  00052	33 c0		 xor	 eax, eax
  00054	e9 5f 01 00 00	 jmp	 $LN1@stbtt_GetF
$LN5@stbtt_GetF:

; 4829 : 
; 4830 :    count = ttUSHORT(fc+nm+2);

  00059	8b 44 24 24	 mov	 eax, DWORD PTR nm$[rsp]
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  00062	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0006f	0f b7 c0	 movzx	 eax, ax
  00072	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax

; 4831 :    stringOffset = nm + ttUSHORT(fc+nm+4);

  00076	8b 44 24 24	 mov	 eax, DWORD PTR nm$[rsp]
  0007a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  0007f	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0008c	0f b7 c0	 movzx	 eax, ax
  0008f	8b 4c 24 24	 mov	 ecx, DWORD PTR nm$[rsp]
  00093	03 c8		 add	 ecx, eax
  00095	8b c1		 mov	 eax, ecx
  00097	89 44 24 34	 mov	 DWORD PTR stringOffset$[rsp], eax

; 4832 :    for (i=0; i < count; ++i) {

  0009b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a3	eb 0a		 jmp	 SHORT $LN4@stbtt_GetF
$LN2@stbtt_GetF:
  000a5	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000a9	ff c0		 inc	 eax
  000ab	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_GetF:
  000af	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000b3	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000b7	0f 8d f9 00 00
	00		 jge	 $LN3@stbtt_GetF

; 4833 :       stbtt_uint32 loc = nm + 6 + 12 * i;

  000bd	6b 44 24 28 0c	 imul	 eax, DWORD PTR i$[rsp], 12
  000c2	8b 4c 24 24	 mov	 ecx, DWORD PTR nm$[rsp]
  000c6	8d 44 01 06	 lea	 eax, DWORD PTR [rcx+rax+6]
  000ca	89 44 24 20	 mov	 DWORD PTR loc$1[rsp], eax

; 4834 :       if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
; 4835 :           && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {

  000ce	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  000d7	48 03 c8	 add	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 8b c8	 mov	 rcx, rax
  000e0	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000e5	0f b7 c0	 movzx	 eax, ax
  000e8	39 44 24 70	 cmp	 DWORD PTR platformID$[rsp], eax
  000ec	0f 85 bf 00 00
	00		 jne	 $LN6@stbtt_GetF
  000f2	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  000fb	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00100	48 8b c8	 mov	 rcx, rax
  00103	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00108	0f b7 c0	 movzx	 eax, ax
  0010b	39 44 24 78	 cmp	 DWORD PTR encodingID$[rsp], eax
  0010f	0f 85 9c 00 00
	00		 jne	 $LN6@stbtt_GetF
  00115	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  0011e	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00123	48 8b c8	 mov	 rcx, rax
  00126	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0012b	0f b7 c0	 movzx	 eax, ax
  0012e	39 84 24 80 00
	00 00		 cmp	 DWORD PTR languageID$[rsp], eax
  00135	75 7a		 jne	 SHORT $LN6@stbtt_GetF
  00137	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0013b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  00140	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  00145	48 8b c8	 mov	 rcx, rax
  00148	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0014d	0f b7 c0	 movzx	 eax, ax
  00150	39 84 24 88 00
	00 00		 cmp	 DWORD PTR nameID$[rsp], eax
  00157	75 58		 jne	 SHORT $LN6@stbtt_GetF

; 4836 :          *length = ttUSHORT(fc+loc+8);

  00159	8b 44 24 20	 mov	 eax, DWORD PTR loc$1[rsp]
  0015d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  00162	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00167	48 8b c8	 mov	 rcx, rax
  0016a	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0016f	0f b7 c0	 movzx	 eax, ax
  00172	48 8b 4c 24 68	 mov	 rcx, QWORD PTR length$[rsp]
  00177	89 01		 mov	 DWORD PTR [rcx], eax

; 4837 :          return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));

  00179	48 63 44 24 34	 movsxd	 rax, DWORD PTR stringOffset$[rsp]
  0017e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fc$[rsp]
  00183	48 03 c8	 add	 rcx, rax
  00186	48 8b c1	 mov	 rax, rcx
  00189	48 89 44 24 40	 mov	 QWORD PTR tv155[rsp], rax
  0018e	8b 4c 24 20	 mov	 ecx, DWORD PTR loc$1[rsp]
  00192	48 8b 54 24 38	 mov	 rdx, QWORD PTR fc$[rsp]
  00197	48 8d 4c 0a 0a	 lea	 rcx, QWORD PTR [rdx+rcx+10]
  0019c	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001a1	0f b7 c0	 movzx	 eax, ax
  001a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv155[rsp]
  001a9	48 03 c8	 add	 rcx, rax
  001ac	48 8b c1	 mov	 rax, rcx
  001af	eb 07		 jmp	 SHORT $LN1@stbtt_GetF
$LN6@stbtt_GetF:

; 4838 :       }
; 4839 :    }

  001b1	e9 ef fe ff ff	 jmp	 $LN2@stbtt_GetF
$LN3@stbtt_GetF:

; 4840 :    return NULL;

  001b6	33 c0		 xor	 eax, eax
$LN1@stbtt_GetF:

; 4841 : }

  001b8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001bc	c3		 ret	 0
stbtt_GetFontNameString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
s1$ = 48
len1$ = 56
s2$ = 64
len2$ = 72
stbtt_CompareUTF8toUTF16_bigendian PROC

; 4963 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4964 :    return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);

  00017	44 8b 4c 24 48	 mov	 r9d, DWORD PTR len2$[rsp]
  0001c	4c 8b 44 24 40	 mov	 r8, QWORD PTR s2$[rsp]
  00021	8b 54 24 38	 mov	 edx, DWORD PTR len1$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s1$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbtt_CompareUTF8toUTF16_bigendian_internal@@YAHPEADH0H@Z ; stbtt_CompareUTF8toUTF16_bigendian_internal

; 4965 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
stbtt_CompareUTF8toUTF16_bigendian ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
fontdata$ = 48
name$ = 56
flags$ = 64
stbtt_FindMatchingFont PROC

; 4958 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4959 :    return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);

  00013	44 8b 44 24 40	 mov	 r8d, DWORD PTR flags$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR name$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fontdata$[rsp]
  00022	e8 00 00 00 00	 call	 ?stbtt_FindMatchingFont_internal@@YAHPEAEPEADH@Z ; stbtt_FindMatchingFont_internal

; 4960 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
stbtt_FindMatchingFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
scale$ = 104
codepoint$ = 112
padding$ = 120
onedge_value$ = 128
pixel_dist_scale$ = 136
width$ = 144
height$ = 152
xoff$ = 160
yoff$ = 168
stbtt_GetCodepointSDF PROC

; 4761 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4762 :    return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);

  00019	8b 54 24 70	 mov	 edx, DWORD PTR codepoint$[rsp]
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00022	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00027	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR yoff$[rsp]
  0002f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00034	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR xoff$[rsp]
  0003c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00041	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR height$[rsp]
  00049	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0004e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR width$[rsp]
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR pixel_dist_scale$[rsp]
  00064	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0006a	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR onedge_value$[rsp]
  00072	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  00076	44 8b 4c 24 78	 mov	 r9d, DWORD PTR padding$[rsp]
  0007b	44 8b c0	 mov	 r8d, eax
  0007e	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR scale$[rsp]
  00084	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00089	e8 00 00 00 00	 call	 stbtt_GetGlyphSDF

; 4763 : }

  0008e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00092	c3		 ret	 0
stbtt_GetCodepointSDF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$1 = 80
min_dist$2 = 84
t$3 = 88
x0$4 = 92
y0$5 = 96
it$6 = 100
sx$7 = 104
sy$8 = 108
x1$9 = 112
y1$10 = 116
scale_y$ = 120
verts$11 = 128
dist2$12 = 136
scale_x$ = 140
num$13 = 144
ax$14 = 148
ay$15 = 152
x2$16 = 156
y2$17 = 160
px$18 = 164
py$19 = 168
ix0$ = 172
iy0$ = 176
b$20 = 180
j$21 = 184
iy1$ = 188
ix1$ = 192
num_verts$22 = 196
val$23 = 200
y$24 = 204
x$25 = 208
bx$26 = 212
by$27 = 216
a$28 = 220
bx$29 = 224
by$30 = 228
mx$31 = 232
my$32 = 236
a_inv$33 = 240
precompute$34 = 248
dx$35 = 256
dy$36 = 260
w$ = 264
x0$37 = 268
y1$38 = 272
y0$39 = 276
dist$40 = 280
tv191 = 284
dist2$41 = 288
x1$42 = 292
y1$43 = 296
t$44 = 300
dist$45 = 304
tv438 = 308
tv441 = 312
tv442 = 316
tv444 = 320
tv447 = 324
tv480 = 328
tv482 = 332
tv485 = 336
tv486 = 340
tv488 = 344
tv491 = 348
tv492 = 352
c$46 = 356
discriminant$47 = 360
root$48 = 364
h$ = 368
x1$49 = 372
x2$50 = 376
y1$51 = 380
y0$52 = 384
y2$53 = 388
len2$54 = 392
y_gspace$55 = 396
x_gspace$56 = 400
px$57 = 404
py$58 = 408
box_x0$59 = 412
box_x1$60 = 416
box_y0$61 = 420
box_y1$62 = 424
d$63 = 428
c$64 = 432
b$65 = 436
winding$66 = 440
x1$67 = 444
x0$68 = 448
data$ = 456
res$69 = 464
__$ArrayPad$ = 480
info$ = 512
scale$ = 520
glyph$ = 528
padding$ = 536
onedge_value$ = 544
pixel_dist_scale$ = 552
width$ = 560
height$ = 568
xoff$ = 576
yoff$ = 584
stbtt_GetGlyphSDF PROC

; 4576 : {

$LN83:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4577 :    float scale_x = scale, scale_y = scale;

  0002e	f3 0f 10 84 24
	08 02 00 00	 movss	 xmm0, DWORD PTR scale$[rsp]
  00037	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR scale_x$[rsp], xmm0
  00040	f3 0f 10 84 24
	08 02 00 00	 movss	 xmm0, DWORD PTR scale$[rsp]
  00049	f3 0f 11 44 24
	78		 movss	 DWORD PTR scale_y$[rsp], xmm0

; 4578 :    int ix0,iy0,ix1,iy1;
; 4579 :    int w,h;
; 4580 :    unsigned char *data;
; 4581 : 
; 4582 :    if (scale == 0) return NULL;

  0004f	f3 0f 10 84 24
	08 02 00 00	 movss	 xmm0, DWORD PTR scale$[rsp]
  00058	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0005f	7a 09		 jp	 SHORT $LN14@stbtt_GetG
  00061	75 07		 jne	 SHORT $LN14@stbtt_GetG
  00063	33 c0		 xor	 eax, eax
  00065	e9 ce 18 00 00	 jmp	 $LN1@stbtt_GetG
$LN14@stbtt_GetG:

; 4583 : 
; 4584 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

  0006a	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR iy1$[rsp]
  00072	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00077	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR ix1$[rsp]
  0007f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00084	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR iy0$[rsp]
  0008c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00091	48 8d 84 24 ac
	00 00 00	 lea	 rax, QWORD PTR ix0$[rsp]
  00099	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0009e	0f 57 c0	 xorps	 xmm0, xmm0
  000a1	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  000a7	0f 57 c0	 xorps	 xmm0, xmm0
  000aa	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000b0	f3 0f 10 9c 24
	08 02 00 00	 movss	 xmm3, DWORD PTR scale$[rsp]
  000b9	f3 0f 10 94 24
	08 02 00 00	 movss	 xmm2, DWORD PTR scale$[rsp]
  000c2	8b 94 24 10 02
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  000c9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000d1	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 4585 : 
; 4586 :    // if empty, return NULL
; 4587 :    if (ix0 == ix1 || iy0 == iy1)

  000d6	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ix1$[rsp]
  000dd	39 84 24 ac 00
	00 00		 cmp	 DWORD PTR ix0$[rsp], eax
  000e4	74 10		 je	 SHORT $LN16@stbtt_GetG
  000e6	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR iy1$[rsp]
  000ed	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR iy0$[rsp], eax
  000f4	75 07		 jne	 SHORT $LN15@stbtt_GetG
$LN16@stbtt_GetG:

; 4588 :       return NULL;

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 3b 18 00 00	 jmp	 $LN1@stbtt_GetG
$LN15@stbtt_GetG:

; 4589 : 
; 4590 :    ix0 -= padding;

  000fd	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR padding$[rsp]
  00104	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ix0$[rsp]
  0010b	2b c8		 sub	 ecx, eax
  0010d	8b c1		 mov	 eax, ecx
  0010f	89 84 24 ac 00
	00 00		 mov	 DWORD PTR ix0$[rsp], eax

; 4591 :    iy0 -= padding;

  00116	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR padding$[rsp]
  0011d	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iy0$[rsp]
  00124	2b c8		 sub	 ecx, eax
  00126	8b c1		 mov	 eax, ecx
  00128	89 84 24 b0 00
	00 00		 mov	 DWORD PTR iy0$[rsp], eax

; 4592 :    ix1 += padding;

  0012f	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR padding$[rsp]
  00136	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR ix1$[rsp]
  0013d	03 c8		 add	 ecx, eax
  0013f	8b c1		 mov	 eax, ecx
  00141	89 84 24 c0 00
	00 00		 mov	 DWORD PTR ix1$[rsp], eax

; 4593 :    iy1 += padding;

  00148	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR padding$[rsp]
  0014f	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR iy1$[rsp]
  00156	03 c8		 add	 ecx, eax
  00158	8b c1		 mov	 eax, ecx
  0015a	89 84 24 bc 00
	00 00		 mov	 DWORD PTR iy1$[rsp], eax

; 4594 : 
; 4595 :    w = (ix1 - ix0);

  00161	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR ix0$[rsp]
  00168	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR ix1$[rsp]
  0016f	2b c8		 sub	 ecx, eax
  00171	8b c1		 mov	 eax, ecx
  00173	89 84 24 08 01
	00 00		 mov	 DWORD PTR w$[rsp], eax

; 4596 :    h = (iy1 - iy0);

  0017a	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR iy0$[rsp]
  00181	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR iy1$[rsp]
  00188	2b c8		 sub	 ecx, eax
  0018a	8b c1		 mov	 eax, ecx
  0018c	89 84 24 70 01
	00 00		 mov	 DWORD PTR h$[rsp], eax

; 4597 : 
; 4598 :    if (width ) *width  = w;

  00193	48 83 bc 24 30
	02 00 00 00	 cmp	 QWORD PTR width$[rsp], 0
  0019c	74 11		 je	 SHORT $LN17@stbtt_GetG
  0019e	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR width$[rsp]
  001a6	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR w$[rsp]
  001ad	89 08		 mov	 DWORD PTR [rax], ecx
$LN17@stbtt_GetG:

; 4599 :    if (height) *height = h;

  001af	48 83 bc 24 38
	02 00 00 00	 cmp	 QWORD PTR height$[rsp], 0
  001b8	74 11		 je	 SHORT $LN18@stbtt_GetG
  001ba	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR height$[rsp]
  001c2	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR h$[rsp]
  001c9	89 08		 mov	 DWORD PTR [rax], ecx
$LN18@stbtt_GetG:

; 4600 :    if (xoff  ) *xoff   = ix0;

  001cb	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR xoff$[rsp], 0
  001d4	74 11		 je	 SHORT $LN19@stbtt_GetG
  001d6	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR xoff$[rsp]
  001de	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR ix0$[rsp]
  001e5	89 08		 mov	 DWORD PTR [rax], ecx
$LN19@stbtt_GetG:

; 4601 :    if (yoff  ) *yoff   = iy0;

  001e7	48 83 bc 24 48
	02 00 00 00	 cmp	 QWORD PTR yoff$[rsp], 0
  001f0	74 11		 je	 SHORT $LN20@stbtt_GetG
  001f2	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR yoff$[rsp]
  001fa	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iy0$[rsp]
  00201	89 08		 mov	 DWORD PTR [rax], ecx
$LN20@stbtt_GetG:

; 4602 : 
; 4603 :    // invert for y-downwards bitmaps
; 4604 :    scale_y = -scale_y;

  00203	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00209	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00210	f3 0f 11 44 24
	78		 movss	 DWORD PTR scale_y$[rsp], xmm0

; 4605 : 
; 4606 :    {
; 4607 :       int x,y,i,j;
; 4608 :       float *precompute;
; 4609 :       stbtt_vertex *verts;
; 4610 :       int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);

  00216	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR verts$11[rsp]
  0021e	8b 94 24 10 02
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  00225	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0022d	e8 00 00 00 00	 call	 stbtt_GetGlyphShape
  00232	89 84 24 c4 00
	00 00		 mov	 DWORD PTR num_verts$22[rsp], eax

; 4611 :       data = (unsigned char *) STBTT_malloc(w * h, info->userdata);

  00239	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  00240	0f af 84 24 70
	01 00 00	 imul	 eax, DWORD PTR h$[rsp]
  00248	48 98		 cdqe
  0024a	48 8b c8	 mov	 rcx, rax
  0024d	e8 00 00 00 00	 call	 malloc
  00252	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR data$[rsp], rax

; 4612 :       precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

  0025a	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR num_verts$22[rsp]
  00262	48 c1 e0 02	 shl	 rax, 2
  00266	48 8b c8	 mov	 rcx, rax
  00269	e8 00 00 00 00	 call	 malloc
  0026e	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR precompute$34[rsp], rax

; 4613 : 
; 4614 :       for (i=0,j=num_verts-1; i < num_verts; j=i++) {

  00276	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0027e	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR num_verts$22[rsp]
  00285	ff c8		 dec	 eax
  00287	89 84 24 b8 00
	00 00		 mov	 DWORD PTR j$21[rsp], eax
  0028e	eb 15		 jmp	 SHORT $LN4@stbtt_GetG
$LN2@stbtt_GetG:
  00290	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00294	89 84 24 b8 00
	00 00		 mov	 DWORD PTR j$21[rsp], eax
  0029b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0029f	ff c0		 inc	 eax
  002a1	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN4@stbtt_GetG:
  002a5	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR num_verts$22[rsp]
  002ac	39 44 24 50	 cmp	 DWORD PTR i$1[rsp], eax
  002b0	0f 8d dc 03 00
	00		 jge	 $LN3@stbtt_GetG

; 4615 :          if (verts[i].type == STBTT_vline) {

  002b6	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  002bb	48 6b c0 0e	 imul	 rax, rax, 14
  002bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  002c7	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  002cc	83 f8 02	 cmp	 eax, 2
  002cf	0f 85 74 01 00
	00		 jne	 $LN21@stbtt_GetG

; 4616 :             float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

  002d5	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  002da	48 6b c0 0e	 imul	 rax, rax, 14
  002de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  002e6	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  002ea	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002ee	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  002f7	f3 0f 11 84 24
	0c 01 00 00	 movss	 DWORD PTR x0$37[rsp], xmm0
  00300	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00305	48 6b c0 0e	 imul	 rax, rax, 14
  00309	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00311	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00316	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0031a	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  00320	f3 0f 11 84 24
	14 01 00 00	 movss	 DWORD PTR y0$39[rsp], xmm0

; 4617 :             float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;

  00329	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR j$21[rsp]
  00331	48 6b c0 0e	 imul	 rax, rax, 14
  00335	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  0033d	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00341	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00345	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  0034e	f3 0f 11 84 24
	74 01 00 00	 movss	 DWORD PTR x1$49[rsp], xmm0
  00357	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR j$21[rsp]
  0035f	48 6b c0 0e	 imul	 rax, rax, 14
  00363	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  0036b	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00370	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00374	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  0037a	f3 0f 11 84 24
	10 01 00 00	 movss	 DWORD PTR y1$38[rsp], xmm0

; 4618 :             float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));

  00383	f3 0f 10 84 24
	74 01 00 00	 movss	 xmm0, DWORD PTR x1$49[rsp]
  0038c	f3 0f 5c 84 24
	0c 01 00 00	 subss	 xmm0, DWORD PTR x0$37[rsp]
  00395	f3 0f 10 8c 24
	74 01 00 00	 movss	 xmm1, DWORD PTR x1$49[rsp]
  0039e	f3 0f 5c 8c 24
	0c 01 00 00	 subss	 xmm1, DWORD PTR x0$37[rsp]
  003a7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  003ab	f3 0f 10 8c 24
	10 01 00 00	 movss	 xmm1, DWORD PTR y1$38[rsp]
  003b4	f3 0f 5c 8c 24
	14 01 00 00	 subss	 xmm1, DWORD PTR y0$39[rsp]
  003bd	f3 0f 10 94 24
	10 01 00 00	 movss	 xmm2, DWORD PTR y1$38[rsp]
  003c6	f3 0f 5c 94 24
	14 01 00 00	 subss	 xmm2, DWORD PTR y0$39[rsp]
  003cf	f3 0f 59 ca	 mulss	 xmm1, xmm2
  003d3	f3 0f 58 c1	 addss	 xmm0, xmm1
  003d7	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  003db	e8 00 00 00 00	 call	 sqrt
  003e0	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003e4	f3 0f 11 84 24
	18 01 00 00	 movss	 DWORD PTR dist$40[rsp], xmm0

; 4619 :             precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;

  003ed	f3 0f 10 84 24
	18 01 00 00	 movss	 xmm0, DWORD PTR dist$40[rsp]
  003f6	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  003fd	7a 10		 jp	 SHORT $LN53@stbtt_GetG
  003ff	75 0e		 jne	 SHORT $LN53@stbtt_GetG
  00401	0f 57 c0	 xorps	 xmm0, xmm0
  00404	f3 0f 11 84 24
	1c 01 00 00	 movss	 DWORD PTR tv191[rsp], xmm0
  0040d	eb 1a		 jmp	 SHORT $LN54@stbtt_GetG
$LN53@stbtt_GetG:
  0040f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00417	f3 0f 5e 84 24
	18 01 00 00	 divss	 xmm0, DWORD PTR dist$40[rsp]
  00420	f3 0f 11 84 24
	1c 01 00 00	 movss	 DWORD PTR tv191[rsp], xmm0
$LN54@stbtt_GetG:
  00429	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  0042e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  00436	f3 0f 10 84 24
	1c 01 00 00	 movss	 xmm0, DWORD PTR tv191[rsp]
  0043f	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
  00444	e9 44 02 00 00	 jmp	 $LN22@stbtt_GetG
$LN21@stbtt_GetG:

; 4620 :          } else if (verts[i].type == STBTT_vcurve) {

  00449	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  0044e	48 6b c0 0e	 imul	 rax, rax, 14
  00452	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  0045a	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0045f	83 f8 03	 cmp	 eax, 3
  00462	0f 85 10 02 00
	00		 jne	 $LN23@stbtt_GetG

; 4621 :             float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;

  00468	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR j$21[rsp]
  00470	48 6b c0 0e	 imul	 rax, rax, 14
  00474	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  0047c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00480	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00484	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  0048d	f3 0f 11 84 24
	78 01 00 00	 movss	 DWORD PTR x2$50[rsp], xmm0
  00496	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR j$21[rsp]
  0049e	48 6b c0 0e	 imul	 rax, rax, 14
  004a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  004aa	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  004af	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004b3	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  004b9	f3 0f 11 84 24
	84 01 00 00	 movss	 DWORD PTR y2$53[rsp], xmm0

; 4622 :             float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;

  004c2	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  004c7	48 6b c0 0e	 imul	 rax, rax, 14
  004cb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  004d3	0f bf 44 01 04	 movsx	 eax, WORD PTR [rcx+rax+4]
  004d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004dc	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  004e5	f3 0f 11 84 24
	bc 01 00 00	 movss	 DWORD PTR x1$67[rsp], xmm0
  004ee	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  004f3	48 6b c0 0e	 imul	 rax, rax, 14
  004f7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  004ff	0f bf 44 01 06	 movsx	 eax, WORD PTR [rcx+rax+6]
  00504	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00508	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  0050e	f3 0f 11 84 24
	7c 01 00 00	 movss	 DWORD PTR y1$51[rsp], xmm0

; 4623 :             float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;

  00517	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  0051c	48 6b c0 0e	 imul	 rax, rax, 14
  00520	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00528	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0052c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00530	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  00539	f3 0f 11 84 24
	c0 01 00 00	 movss	 DWORD PTR x0$68[rsp], xmm0
  00542	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00547	48 6b c0 0e	 imul	 rax, rax, 14
  0054b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00553	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00558	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0055c	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  00562	f3 0f 11 84 24
	80 01 00 00	 movss	 DWORD PTR y0$52[rsp], xmm0

; 4624 :             float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;

  0056b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00573	f3 0f 59 84 24
	bc 01 00 00	 mulss	 xmm0, DWORD PTR x1$67[rsp]
  0057c	f3 0f 10 8c 24
	c0 01 00 00	 movss	 xmm1, DWORD PTR x0$68[rsp]
  00585	f3 0f 5c c8	 subss	 xmm1, xmm0
  00589	0f 28 c1	 movaps	 xmm0, xmm1
  0058c	f3 0f 58 84 24
	78 01 00 00	 addss	 xmm0, DWORD PTR x2$50[rsp]
  00595	f3 0f 11 84 24
	d4 00 00 00	 movss	 DWORD PTR bx$26[rsp], xmm0
  0059e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  005a6	f3 0f 59 84 24
	7c 01 00 00	 mulss	 xmm0, DWORD PTR y1$51[rsp]
  005af	f3 0f 10 8c 24
	80 01 00 00	 movss	 xmm1, DWORD PTR y0$52[rsp]
  005b8	f3 0f 5c c8	 subss	 xmm1, xmm0
  005bc	0f 28 c1	 movaps	 xmm0, xmm1
  005bf	f3 0f 58 84 24
	84 01 00 00	 addss	 xmm0, DWORD PTR y2$53[rsp]
  005c8	f3 0f 11 84 24
	d8 00 00 00	 movss	 DWORD PTR by$27[rsp], xmm0

; 4625 :             float len2 = bx*bx + by*by;

  005d1	f3 0f 10 84 24
	d4 00 00 00	 movss	 xmm0, DWORD PTR bx$26[rsp]
  005da	f3 0f 59 84 24
	d4 00 00 00	 mulss	 xmm0, DWORD PTR bx$26[rsp]
  005e3	f3 0f 10 8c 24
	d8 00 00 00	 movss	 xmm1, DWORD PTR by$27[rsp]
  005ec	f3 0f 59 8c 24
	d8 00 00 00	 mulss	 xmm1, DWORD PTR by$27[rsp]
  005f5	f3 0f 58 c1	 addss	 xmm0, xmm1
  005f9	f3 0f 11 84 24
	88 01 00 00	 movss	 DWORD PTR len2$54[rsp], xmm0

; 4626 :             if (len2 != 0.0f)

  00602	f3 0f 10 84 24
	88 01 00 00	 movss	 xmm0, DWORD PTR len2$54[rsp]
  0060b	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00612	7a 02		 jp	 SHORT $LN82@stbtt_GetG
  00614	74 4b		 je	 SHORT $LN25@stbtt_GetG
$LN82@stbtt_GetG:

; 4627 :                precompute[i] = 1.0f / (bx*bx + by*by);

  00616	f3 0f 10 84 24
	d4 00 00 00	 movss	 xmm0, DWORD PTR bx$26[rsp]
  0061f	f3 0f 59 84 24
	d4 00 00 00	 mulss	 xmm0, DWORD PTR bx$26[rsp]
  00628	f3 0f 10 8c 24
	d8 00 00 00	 movss	 xmm1, DWORD PTR by$27[rsp]
  00631	f3 0f 59 8c 24
	d8 00 00 00	 mulss	 xmm1, DWORD PTR by$27[rsp]
  0063a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0063e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00646	f3 0f 5e c8	 divss	 xmm1, xmm0
  0064a	0f 28 c1	 movaps	 xmm0, xmm1
  0064d	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00652	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  0065a	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
  0065f	eb 15		 jmp	 SHORT $LN26@stbtt_GetG
$LN25@stbtt_GetG:

; 4628 :             else
; 4629 :                precompute[i] = 0.0f;

  00661	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00666	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  0066e	0f 57 c0	 xorps	 xmm0, xmm0
  00671	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
$LN26@stbtt_GetG:

; 4630 :          } else

  00676	eb 15		 jmp	 SHORT $LN24@stbtt_GetG
$LN23@stbtt_GetG:

; 4631 :             precompute[i] = 0.0f;

  00678	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  0067d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  00685	0f 57 c0	 xorps	 xmm0, xmm0
  00688	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
$LN24@stbtt_GetG:
$LN22@stbtt_GetG:

; 4632 :       }

  0068d	e9 fe fb ff ff	 jmp	 $LN2@stbtt_GetG
$LN3@stbtt_GetG:

; 4633 : 
; 4634 :       for (y=iy0; y < iy1; ++y) {

  00692	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR iy0$[rsp]
  00699	89 84 24 cc 00
	00 00		 mov	 DWORD PTR y$24[rsp], eax
  006a0	eb 10		 jmp	 SHORT $LN7@stbtt_GetG
$LN5@stbtt_GetG:
  006a2	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR y$24[rsp]
  006a9	ff c0		 inc	 eax
  006ab	89 84 24 cc 00
	00 00		 mov	 DWORD PTR y$24[rsp], eax
$LN7@stbtt_GetG:
  006b2	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR iy1$[rsp]
  006b9	39 84 24 cc 00
	00 00		 cmp	 DWORD PTR y$24[rsp], eax
  006c0	0f 8d 50 12 00
	00		 jge	 $LN6@stbtt_GetG

; 4635 :          for (x=ix0; x < ix1; ++x) {

  006c6	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR ix0$[rsp]
  006cd	89 84 24 d0 00
	00 00		 mov	 DWORD PTR x$25[rsp], eax
  006d4	eb 10		 jmp	 SHORT $LN10@stbtt_GetG
$LN8@stbtt_GetG:
  006d6	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR x$25[rsp]
  006dd	ff c0		 inc	 eax
  006df	89 84 24 d0 00
	00 00		 mov	 DWORD PTR x$25[rsp], eax
$LN10@stbtt_GetG:
  006e6	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ix1$[rsp]
  006ed	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR x$25[rsp], eax
  006f4	0f 8d 17 12 00
	00		 jge	 $LN9@stbtt_GetG

; 4636 :             float val;
; 4637 :             float min_dist = 999999.0f;

  006fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@497423f0
  00702	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0

; 4638 :             float sx = (float) x + 0.5f;

  00708	f3 0f 2a 84 24
	d0 00 00 00	 cvtsi2ss xmm0, DWORD PTR x$25[rsp]
  00711	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00719	f3 0f 11 44 24
	68		 movss	 DWORD PTR sx$7[rsp], xmm0

; 4639 :             float sy = (float) y + 0.5f;

  0071f	f3 0f 2a 84 24
	cc 00 00 00	 cvtsi2ss xmm0, DWORD PTR y$24[rsp]
  00728	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00730	f3 0f 11 44 24
	6c		 movss	 DWORD PTR sy$8[rsp], xmm0

; 4640 :             float x_gspace = (sx / scale_x);

  00736	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR sx$7[rsp]
  0073c	f3 0f 5e 84 24
	8c 00 00 00	 divss	 xmm0, DWORD PTR scale_x$[rsp]
  00745	f3 0f 11 84 24
	90 01 00 00	 movss	 DWORD PTR x_gspace$56[rsp], xmm0

; 4641 :             float y_gspace = (sy / scale_y);

  0074e	f3 0f 10 44 24
	6c		 movss	 xmm0, DWORD PTR sy$8[rsp]
  00754	f3 0f 5e 44 24
	78		 divss	 xmm0, DWORD PTR scale_y$[rsp]
  0075a	f3 0f 11 84 24
	8c 01 00 00	 movss	 DWORD PTR y_gspace$55[rsp], xmm0

; 4642 : 
; 4643 :             int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

  00763	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR verts$11[rsp]
  0076b	44 8b 84 24 c4
	00 00 00	 mov	 r8d, DWORD PTR num_verts$22[rsp]
  00773	f3 0f 10 8c 24
	8c 01 00 00	 movss	 xmm1, DWORD PTR y_gspace$55[rsp]
  0077c	f3 0f 10 84 24
	90 01 00 00	 movss	 xmm0, DWORD PTR x_gspace$56[rsp]
  00785	e8 00 00 00 00	 call	 ?stbtt__compute_crossings_x@@YAHMMHPEAUstbtt_vertex@@@Z ; stbtt__compute_crossings_x
  0078a	89 84 24 b8 01
	00 00		 mov	 DWORD PTR winding$66[rsp], eax

; 4644 : 
; 4645 :             for (i=0; i < num_verts; ++i) {

  00791	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00799	eb 0a		 jmp	 SHORT $LN13@stbtt_GetG
$LN11@stbtt_GetG:
  0079b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0079f	ff c0		 inc	 eax
  007a1	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN13@stbtt_GetG:
  007a5	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR num_verts$22[rsp]
  007ac	39 44 24 50	 cmp	 DWORD PTR i$1[rsp], eax
  007b0	0f 8d 8b 10 00
	00		 jge	 $LN12@stbtt_GetG

; 4646 :                float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

  007b6	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  007bb	48 6b c0 0e	 imul	 rax, rax, 14
  007bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  007c7	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  007cb	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  007cf	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  007d8	f3 0f 11 44 24
	5c		 movss	 DWORD PTR x0$4[rsp], xmm0
  007de	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  007e3	48 6b c0 0e	 imul	 rax, rax, 14
  007e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  007ef	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  007f4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  007f8	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  007fe	f3 0f 11 44 24
	60		 movss	 DWORD PTR y0$5[rsp], xmm0

; 4647 : 
; 4648 :                if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {

  00804	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00809	48 6b c0 0e	 imul	 rax, rax, 14
  0080d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00815	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0081a	83 f8 02	 cmp	 eax, 2
  0081d	0f 85 86 02 00
	00		 jne	 $LN27@stbtt_GetG
  00823	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00828	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  00830	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00835	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0083c	7a 06		 jp	 SHORT $LN81@stbtt_GetG
  0083e	0f 84 65 02 00
	00		 je	 $LN27@stbtt_GetG
$LN81@stbtt_GetG:

; 4649 :                   float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

  00844	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00848	ff c8		 dec	 eax
  0084a	48 98		 cdqe
  0084c	48 6b c0 0e	 imul	 rax, rax, 14
  00850	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00858	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0085c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00860	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  00869	f3 0f 11 84 24
	24 01 00 00	 movss	 DWORD PTR x1$42[rsp], xmm0
  00872	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00876	ff c8		 dec	 eax
  00878	48 98		 cdqe
  0087a	48 6b c0 0e	 imul	 rax, rax, 14
  0087e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00886	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  0088b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0088f	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  00895	f3 0f 11 84 24
	28 01 00 00	 movss	 DWORD PTR y1$43[rsp], xmm0

; 4650 : 
; 4651 :                   float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);

  0089e	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  008a4	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  008aa	f3 0f 10 4c 24
	5c		 movss	 xmm1, DWORD PTR x0$4[rsp]
  008b0	f3 0f 5c 4c 24
	68		 subss	 xmm1, DWORD PTR sx$7[rsp]
  008b6	f3 0f 59 c1	 mulss	 xmm0, xmm1
  008ba	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR y0$5[rsp]
  008c0	f3 0f 5c 4c 24
	6c		 subss	 xmm1, DWORD PTR sy$8[rsp]
  008c6	f3 0f 10 54 24
	60		 movss	 xmm2, DWORD PTR y0$5[rsp]
  008cc	f3 0f 5c 54 24
	6c		 subss	 xmm2, DWORD PTR sy$8[rsp]
  008d2	f3 0f 59 ca	 mulss	 xmm1, xmm2
  008d6	f3 0f 58 c1	 addss	 xmm0, xmm1
  008da	f3 0f 11 84 24
	20 01 00 00	 movss	 DWORD PTR dist2$41[rsp], xmm0

; 4652 :                   if (dist2 < min_dist*min_dist)

  008e3	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  008e9	f3 0f 59 44 24
	54		 mulss	 xmm0, DWORD PTR min_dist$2[rsp]
  008ef	0f 2f 84 24 20
	01 00 00	 comiss	 xmm0, DWORD PTR dist2$41[rsp]
  008f7	76 18		 jbe	 SHORT $LN29@stbtt_GetG

; 4653 :                      min_dist = (float) STBTT_sqrt(dist2);

  008f9	f3 0f 5a 84 24
	20 01 00 00	 cvtss2sd xmm0, DWORD PTR dist2$41[rsp]
  00902	e8 00 00 00 00	 call	 sqrt
  00907	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0090b	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN29@stbtt_GetG:

; 4654 : 
; 4655 :                   // coarse culling against bbox
; 4656 :                   //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
; 4657 :                   //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
; 4658 :                   dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];

  00911	f3 0f 10 84 24
	24 01 00 00	 movss	 xmm0, DWORD PTR x1$42[rsp]
  0091a	f3 0f 5c 44 24
	5c		 subss	 xmm0, DWORD PTR x0$4[rsp]
  00920	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR y0$5[rsp]
  00926	f3 0f 5c 4c 24
	6c		 subss	 xmm1, DWORD PTR sy$8[rsp]
  0092c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00930	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR y1$43[rsp]
  00939	f3 0f 5c 4c 24
	60		 subss	 xmm1, DWORD PTR y0$5[rsp]
  0093f	f3 0f 10 54 24
	5c		 movss	 xmm2, DWORD PTR x0$4[rsp]
  00945	f3 0f 5c 54 24
	68		 subss	 xmm2, DWORD PTR sx$7[rsp]
  0094b	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0094f	f3 0f 5c c1	 subss	 xmm0, xmm1
  00953	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00957	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  0095e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00962	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00967	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  0096f	f3 0f 59 04 81	 mulss	 xmm0, DWORD PTR [rcx+rax*4]
  00974	f3 0f 11 84 24
	30 01 00 00	 movss	 DWORD PTR dist$45[rsp], xmm0

; 4659 :                   STBTT_assert(i != 0);

  0097d	83 7c 24 50 00	 cmp	 DWORD PTR i$1[rsp], 0
  00982	75 1b		 jne	 SHORT $LN55@stbtt_GetG
  00984	41 b8 33 12 00
	00		 mov	 r8d, 4659		; 00001233H
  0098a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG44013
  00991	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG44014
  00998	e8 00 00 00 00	 call	 _wassert
  0099d	33 c0		 xor	 eax, eax
$LN55@stbtt_GetG:

; 4660 :                   if (dist < min_dist) {

  0099f	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  009a5	0f 2f 84 24 30
	01 00 00	 comiss	 xmm0, DWORD PTR dist$45[rsp]
  009ad	0f 86 f1 00 00
	00		 jbe	 $LN30@stbtt_GetG

; 4661 :                      // check position along line
; 4662 :                      // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
; 4663 :                      // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
; 4664 :                      float dx = x1-x0, dy = y1-y0;

  009b3	f3 0f 10 84 24
	24 01 00 00	 movss	 xmm0, DWORD PTR x1$42[rsp]
  009bc	f3 0f 5c 44 24
	5c		 subss	 xmm0, DWORD PTR x0$4[rsp]
  009c2	f3 0f 11 84 24
	00 01 00 00	 movss	 DWORD PTR dx$35[rsp], xmm0
  009cb	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR y1$43[rsp]
  009d4	f3 0f 5c 44 24
	60		 subss	 xmm0, DWORD PTR y0$5[rsp]
  009da	f3 0f 11 84 24
	04 01 00 00	 movss	 DWORD PTR dy$36[rsp], xmm0

; 4665 :                      float px = x0-sx, py = y0-sy;

  009e3	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  009e9	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  009ef	f3 0f 11 84 24
	94 01 00 00	 movss	 DWORD PTR px$57[rsp], xmm0
  009f8	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y0$5[rsp]
  009fe	f3 0f 5c 44 24
	6c		 subss	 xmm0, DWORD PTR sy$8[rsp]
  00a04	f3 0f 11 84 24
	98 01 00 00	 movss	 DWORD PTR py$58[rsp], xmm0

; 4666 :                      // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
; 4667 :                      // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
; 4668 :                      float t = -(px*dx + py*dy) / (dx*dx + dy*dy);

  00a0d	f3 0f 10 84 24
	94 01 00 00	 movss	 xmm0, DWORD PTR px$57[rsp]
  00a16	f3 0f 59 84 24
	00 01 00 00	 mulss	 xmm0, DWORD PTR dx$35[rsp]
  00a1f	f3 0f 10 8c 24
	98 01 00 00	 movss	 xmm1, DWORD PTR py$58[rsp]
  00a28	f3 0f 59 8c 24
	04 01 00 00	 mulss	 xmm1, DWORD PTR dy$36[rsp]
  00a31	f3 0f 58 c1	 addss	 xmm0, xmm1
  00a35	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00a3c	f3 0f 10 8c 24
	00 01 00 00	 movss	 xmm1, DWORD PTR dx$35[rsp]
  00a45	f3 0f 59 8c 24
	00 01 00 00	 mulss	 xmm1, DWORD PTR dx$35[rsp]
  00a4e	f3 0f 10 94 24
	04 01 00 00	 movss	 xmm2, DWORD PTR dy$36[rsp]
  00a57	f3 0f 59 94 24
	04 01 00 00	 mulss	 xmm2, DWORD PTR dy$36[rsp]
  00a60	f3 0f 58 ca	 addss	 xmm1, xmm2
  00a64	f3 0f 5e c1	 divss	 xmm0, xmm1
  00a68	f3 0f 11 84 24
	2c 01 00 00	 movss	 DWORD PTR t$44[rsp], xmm0

; 4669 :                      if (t >= 0.0f && t <= 1.0f)

  00a71	f3 0f 10 84 24
	2c 01 00 00	 movss	 xmm0, DWORD PTR t$44[rsp]
  00a7a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00a81	72 21		 jb	 SHORT $LN31@stbtt_GetG
  00a83	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a8b	0f 2f 84 24 2c
	01 00 00	 comiss	 xmm0, DWORD PTR t$44[rsp]
  00a93	72 0f		 jb	 SHORT $LN31@stbtt_GetG

; 4670 :                         min_dist = dist;

  00a95	f3 0f 10 84 24
	30 01 00 00	 movss	 xmm0, DWORD PTR dist$45[rsp]
  00a9e	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN31@stbtt_GetG:
$LN30@stbtt_GetG:

; 4671 :                   }

  00aa4	e9 93 0d 00 00	 jmp	 $LN28@stbtt_GetG
$LN27@stbtt_GetG:

; 4672 :                } else if (verts[i].type == STBTT_vcurve) {

  00aa9	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00aae	48 6b c0 0e	 imul	 rax, rax, 14
  00ab2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00aba	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  00abf	83 f8 03	 cmp	 eax, 3
  00ac2	0f 85 74 0d 00
	00		 jne	 $LN32@stbtt_GetG

; 4673 :                   float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;

  00ac8	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00acc	ff c8		 dec	 eax
  00ace	48 98		 cdqe
  00ad0	48 6b c0 0e	 imul	 rax, rax, 14
  00ad4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00adc	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00ae0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00ae4	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  00aed	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR x2$16[rsp], xmm0
  00af6	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00afa	ff c8		 dec	 eax
  00afc	48 98		 cdqe
  00afe	48 6b c0 0e	 imul	 rax, rax, 14
  00b02	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00b0a	0f bf 44 01 02	 movsx	 eax, WORD PTR [rcx+rax+2]
  00b0f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b13	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  00b19	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR y2$17[rsp], xmm0

; 4674 :                   float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;

  00b22	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b27	48 6b c0 0e	 imul	 rax, rax, 14
  00b2b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00b33	0f bf 44 01 04	 movsx	 eax, WORD PTR [rcx+rax+4]
  00b38	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b3c	f3 0f 59 84 24
	8c 00 00 00	 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  00b45	f3 0f 11 44 24
	70		 movss	 DWORD PTR x1$9[rsp], xmm0
  00b4b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b50	48 6b c0 0e	 imul	 rax, rax, 14
  00b54	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  00b5c	0f bf 44 01 06	 movsx	 eax, WORD PTR [rcx+rax+6]
  00b61	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b65	f3 0f 59 44 24
	78		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  00b6b	f3 0f 11 44 24
	74		 movss	 DWORD PTR y1$10[rsp], xmm0

; 4675 :                   float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);

  00b71	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00b77	0f 2f 44 24 5c	 comiss	 xmm0, DWORD PTR x0$4[rsp]
  00b7c	76 11		 jbe	 SHORT $LN56@stbtt_GetG
  00b7e	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  00b84	f3 0f 11 84 24
	34 01 00 00	 movss	 DWORD PTR tv438[rsp], xmm0
  00b8d	eb 0f		 jmp	 SHORT $LN57@stbtt_GetG
$LN56@stbtt_GetG:
  00b8f	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00b95	f3 0f 11 84 24
	34 01 00 00	 movss	 DWORD PTR tv438[rsp], xmm0
$LN57@stbtt_GetG:
  00b9e	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x2$16[rsp]
  00ba7	0f 2f 84 24 34
	01 00 00	 comiss	 xmm0, DWORD PTR tv438[rsp]
  00baf	76 41		 jbe	 SHORT $LN60@stbtt_GetG
  00bb1	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00bb7	0f 2f 44 24 5c	 comiss	 xmm0, DWORD PTR x0$4[rsp]
  00bbc	76 11		 jbe	 SHORT $LN58@stbtt_GetG
  00bbe	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  00bc4	f3 0f 11 84 24
	38 01 00 00	 movss	 DWORD PTR tv441[rsp], xmm0
  00bcd	eb 0f		 jmp	 SHORT $LN59@stbtt_GetG
$LN58@stbtt_GetG:
  00bcf	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00bd5	f3 0f 11 84 24
	38 01 00 00	 movss	 DWORD PTR tv441[rsp], xmm0
$LN59@stbtt_GetG:
  00bde	f3 0f 10 84 24
	38 01 00 00	 movss	 xmm0, DWORD PTR tv441[rsp]
  00be7	f3 0f 11 84 24
	3c 01 00 00	 movss	 DWORD PTR tv442[rsp], xmm0
  00bf0	eb 12		 jmp	 SHORT $LN61@stbtt_GetG
$LN60@stbtt_GetG:
  00bf2	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x2$16[rsp]
  00bfb	f3 0f 11 84 24
	3c 01 00 00	 movss	 DWORD PTR tv442[rsp], xmm0
$LN61@stbtt_GetG:
  00c04	f3 0f 10 84 24
	3c 01 00 00	 movss	 xmm0, DWORD PTR tv442[rsp]
  00c0d	f3 0f 11 84 24
	9c 01 00 00	 movss	 DWORD PTR box_x0$59[rsp], xmm0

; 4676 :                   float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);

  00c16	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00c1c	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR y0$5[rsp]
  00c21	76 11		 jbe	 SHORT $LN62@stbtt_GetG
  00c23	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y0$5[rsp]
  00c29	f3 0f 11 84 24
	40 01 00 00	 movss	 DWORD PTR tv444[rsp], xmm0
  00c32	eb 0f		 jmp	 SHORT $LN63@stbtt_GetG
$LN62@stbtt_GetG:
  00c34	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00c3a	f3 0f 11 84 24
	40 01 00 00	 movss	 DWORD PTR tv444[rsp], xmm0
$LN63@stbtt_GetG:
  00c43	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y2$17[rsp]
  00c4c	0f 2f 84 24 40
	01 00 00	 comiss	 xmm0, DWORD PTR tv444[rsp]
  00c54	76 41		 jbe	 SHORT $LN66@stbtt_GetG
  00c56	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00c5c	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR y0$5[rsp]
  00c61	76 11		 jbe	 SHORT $LN64@stbtt_GetG
  00c63	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y0$5[rsp]
  00c69	f3 0f 11 84 24
	44 01 00 00	 movss	 DWORD PTR tv447[rsp], xmm0
  00c72	eb 0f		 jmp	 SHORT $LN65@stbtt_GetG
$LN64@stbtt_GetG:
  00c74	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00c7a	f3 0f 11 84 24
	44 01 00 00	 movss	 DWORD PTR tv447[rsp], xmm0
$LN65@stbtt_GetG:
  00c83	f3 0f 10 84 24
	44 01 00 00	 movss	 xmm0, DWORD PTR tv447[rsp]
  00c8c	f3 0f 11 84 24
	48 01 00 00	 movss	 DWORD PTR tv480[rsp], xmm0
  00c95	eb 12		 jmp	 SHORT $LN67@stbtt_GetG
$LN66@stbtt_GetG:
  00c97	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y2$17[rsp]
  00ca0	f3 0f 11 84 24
	48 01 00 00	 movss	 DWORD PTR tv480[rsp], xmm0
$LN67@stbtt_GetG:
  00ca9	f3 0f 10 84 24
	48 01 00 00	 movss	 xmm0, DWORD PTR tv480[rsp]
  00cb2	f3 0f 11 84 24
	a4 01 00 00	 movss	 DWORD PTR box_y0$61[rsp], xmm0

; 4677 :                   float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);

  00cbb	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00cc1	0f 2f 44 24 5c	 comiss	 xmm0, DWORD PTR x0$4[rsp]
  00cc6	76 11		 jbe	 SHORT $LN68@stbtt_GetG
  00cc8	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00cce	f3 0f 11 84 24
	4c 01 00 00	 movss	 DWORD PTR tv482[rsp], xmm0
  00cd7	eb 0f		 jmp	 SHORT $LN69@stbtt_GetG
$LN68@stbtt_GetG:
  00cd9	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  00cdf	f3 0f 11 84 24
	4c 01 00 00	 movss	 DWORD PTR tv482[rsp], xmm0
$LN69@stbtt_GetG:
  00ce8	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x2$16[rsp]
  00cf1	0f 2f 84 24 4c
	01 00 00	 comiss	 xmm0, DWORD PTR tv482[rsp]
  00cf9	76 14		 jbe	 SHORT $LN72@stbtt_GetG
  00cfb	f3 0f 10 84 24
	9c 00 00 00	 movss	 xmm0, DWORD PTR x2$16[rsp]
  00d04	f3 0f 11 84 24
	54 01 00 00	 movss	 DWORD PTR tv486[rsp], xmm0
  00d0d	eb 3f		 jmp	 SHORT $LN73@stbtt_GetG
$LN72@stbtt_GetG:
  00d0f	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00d15	0f 2f 44 24 5c	 comiss	 xmm0, DWORD PTR x0$4[rsp]
  00d1a	76 11		 jbe	 SHORT $LN70@stbtt_GetG
  00d1c	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00d22	f3 0f 11 84 24
	50 01 00 00	 movss	 DWORD PTR tv485[rsp], xmm0
  00d2b	eb 0f		 jmp	 SHORT $LN71@stbtt_GetG
$LN70@stbtt_GetG:
  00d2d	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  00d33	f3 0f 11 84 24
	50 01 00 00	 movss	 DWORD PTR tv485[rsp], xmm0
$LN71@stbtt_GetG:
  00d3c	f3 0f 10 84 24
	50 01 00 00	 movss	 xmm0, DWORD PTR tv485[rsp]
  00d45	f3 0f 11 84 24
	54 01 00 00	 movss	 DWORD PTR tv486[rsp], xmm0
$LN73@stbtt_GetG:
  00d4e	f3 0f 10 84 24
	54 01 00 00	 movss	 xmm0, DWORD PTR tv486[rsp]
  00d57	f3 0f 11 84 24
	a0 01 00 00	 movss	 DWORD PTR box_x1$60[rsp], xmm0

; 4678 :                   float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);

  00d60	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00d66	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR y0$5[rsp]
  00d6b	76 11		 jbe	 SHORT $LN74@stbtt_GetG
  00d6d	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00d73	f3 0f 11 84 24
	58 01 00 00	 movss	 DWORD PTR tv488[rsp], xmm0
  00d7c	eb 0f		 jmp	 SHORT $LN75@stbtt_GetG
$LN74@stbtt_GetG:
  00d7e	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y0$5[rsp]
  00d84	f3 0f 11 84 24
	58 01 00 00	 movss	 DWORD PTR tv488[rsp], xmm0
$LN75@stbtt_GetG:
  00d8d	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y2$17[rsp]
  00d96	0f 2f 84 24 58
	01 00 00	 comiss	 xmm0, DWORD PTR tv488[rsp]
  00d9e	76 14		 jbe	 SHORT $LN78@stbtt_GetG
  00da0	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR y2$17[rsp]
  00da9	f3 0f 11 84 24
	60 01 00 00	 movss	 DWORD PTR tv492[rsp], xmm0
  00db2	eb 3f		 jmp	 SHORT $LN79@stbtt_GetG
$LN78@stbtt_GetG:
  00db4	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00dba	0f 2f 44 24 60	 comiss	 xmm0, DWORD PTR y0$5[rsp]
  00dbf	76 11		 jbe	 SHORT $LN76@stbtt_GetG
  00dc1	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00dc7	f3 0f 11 84 24
	5c 01 00 00	 movss	 DWORD PTR tv491[rsp], xmm0
  00dd0	eb 0f		 jmp	 SHORT $LN77@stbtt_GetG
$LN76@stbtt_GetG:
  00dd2	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y0$5[rsp]
  00dd8	f3 0f 11 84 24
	5c 01 00 00	 movss	 DWORD PTR tv491[rsp], xmm0
$LN77@stbtt_GetG:
  00de1	f3 0f 10 84 24
	5c 01 00 00	 movss	 xmm0, DWORD PTR tv491[rsp]
  00dea	f3 0f 11 84 24
	60 01 00 00	 movss	 DWORD PTR tv492[rsp], xmm0
$LN79@stbtt_GetG:
  00df3	f3 0f 10 84 24
	60 01 00 00	 movss	 xmm0, DWORD PTR tv492[rsp]
  00dfc	f3 0f 11 84 24
	a8 01 00 00	 movss	 DWORD PTR box_y1$62[rsp], xmm0

; 4679 :                   // coarse culling against bbox to avoid computing cubic unnecessarily
; 4680 :                   if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {

  00e05	f3 0f 10 84 24
	9c 01 00 00	 movss	 xmm0, DWORD PTR box_x0$59[rsp]
  00e0e	f3 0f 5c 44 24
	54		 subss	 xmm0, DWORD PTR min_dist$2[rsp]
  00e14	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR sx$7[rsp]
  00e1a	0f 2f c8	 comiss	 xmm1, xmm0
  00e1d	0f 86 19 0a 00
	00		 jbe	 $LN33@stbtt_GetG
  00e23	f3 0f 10 84 24
	a0 01 00 00	 movss	 xmm0, DWORD PTR box_x1$60[rsp]
  00e2c	f3 0f 58 44 24
	54		 addss	 xmm0, DWORD PTR min_dist$2[rsp]
  00e32	0f 2f 44 24 68	 comiss	 xmm0, DWORD PTR sx$7[rsp]
  00e37	0f 86 ff 09 00
	00		 jbe	 $LN33@stbtt_GetG
  00e3d	f3 0f 10 84 24
	a4 01 00 00	 movss	 xmm0, DWORD PTR box_y0$61[rsp]
  00e46	f3 0f 5c 44 24
	54		 subss	 xmm0, DWORD PTR min_dist$2[rsp]
  00e4c	f3 0f 10 4c 24
	6c		 movss	 xmm1, DWORD PTR sy$8[rsp]
  00e52	0f 2f c8	 comiss	 xmm1, xmm0
  00e55	0f 86 e1 09 00
	00		 jbe	 $LN33@stbtt_GetG
  00e5b	f3 0f 10 84 24
	a8 01 00 00	 movss	 xmm0, DWORD PTR box_y1$62[rsp]
  00e64	f3 0f 58 44 24
	54		 addss	 xmm0, DWORD PTR min_dist$2[rsp]
  00e6a	0f 2f 44 24 6c	 comiss	 xmm0, DWORD PTR sy$8[rsp]
  00e6f	0f 86 c7 09 00
	00		 jbe	 $LN33@stbtt_GetG

; 4681 :                      int num=0;

  00e75	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR num$13[rsp], 0

; 4682 :                      float ax = x1-x0, ay = y1-y0;

  00e80	f3 0f 10 44 24
	70		 movss	 xmm0, DWORD PTR x1$9[rsp]
  00e86	f3 0f 5c 44 24
	5c		 subss	 xmm0, DWORD PTR x0$4[rsp]
  00e8c	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR ax$14[rsp], xmm0
  00e95	f3 0f 10 44 24
	74		 movss	 xmm0, DWORD PTR y1$10[rsp]
  00e9b	f3 0f 5c 44 24
	60		 subss	 xmm0, DWORD PTR y0$5[rsp]
  00ea1	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR ay$15[rsp], xmm0

; 4683 :                      float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;

  00eaa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00eb2	f3 0f 59 44 24
	70		 mulss	 xmm0, DWORD PTR x1$9[rsp]
  00eb8	f3 0f 10 4c 24
	5c		 movss	 xmm1, DWORD PTR x0$4[rsp]
  00ebe	f3 0f 5c c8	 subss	 xmm1, xmm0
  00ec2	0f 28 c1	 movaps	 xmm0, xmm1
  00ec5	f3 0f 58 84 24
	9c 00 00 00	 addss	 xmm0, DWORD PTR x2$16[rsp]
  00ece	f3 0f 11 84 24
	e0 00 00 00	 movss	 DWORD PTR bx$29[rsp], xmm0
  00ed7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00edf	f3 0f 59 44 24
	74		 mulss	 xmm0, DWORD PTR y1$10[rsp]
  00ee5	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR y0$5[rsp]
  00eeb	f3 0f 5c c8	 subss	 xmm1, xmm0
  00eef	0f 28 c1	 movaps	 xmm0, xmm1
  00ef2	f3 0f 58 84 24
	a0 00 00 00	 addss	 xmm0, DWORD PTR y2$17[rsp]
  00efb	f3 0f 11 84 24
	e4 00 00 00	 movss	 DWORD PTR by$30[rsp], xmm0

; 4684 :                      float mx = x0 - sx, my = y0 - sy;

  00f04	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  00f0a	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  00f10	f3 0f 11 84 24
	e8 00 00 00	 movss	 DWORD PTR mx$31[rsp], xmm0
  00f19	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR y0$5[rsp]
  00f1f	f3 0f 5c 44 24
	6c		 subss	 xmm0, DWORD PTR sy$8[rsp]
  00f25	f3 0f 11 84 24
	ec 00 00 00	 movss	 DWORD PTR my$32[rsp], xmm0

; 4685 :                      float res[3] = {0.f,0.f,0.f};

  00f2e	0f 57 c0	 xorps	 xmm0, xmm0
  00f31	f3 0f 11 84 24
	d0 01 00 00	 movss	 DWORD PTR res$69[rsp], xmm0
  00f3a	0f 57 c0	 xorps	 xmm0, xmm0
  00f3d	f3 0f 11 84 24
	d4 01 00 00	 movss	 DWORD PTR res$69[rsp+4], xmm0
  00f46	0f 57 c0	 xorps	 xmm0, xmm0
  00f49	f3 0f 11 84 24
	d8 01 00 00	 movss	 DWORD PTR res$69[rsp+8], xmm0

; 4686 :                      float px,py,t,it,dist2;
; 4687 :                      float a_inv = precompute[i];

  00f52	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00f57	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  00f5f	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  00f64	f3 0f 11 84 24
	f0 00 00 00	 movss	 DWORD PTR a_inv$33[rsp], xmm0

; 4688 :                      if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula

  00f6d	f3 0f 5a 84 24
	f0 00 00 00	 cvtss2sd xmm0, DWORD PTR a_inv$33[rsp]
  00f76	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00f7e	0f 8a 4d 02 00
	00		 jp	 $LN34@stbtt_GetG
  00f84	0f 85 47 02 00
	00		 jne	 $LN34@stbtt_GetG

; 4689 :                         float a = 3*(ax*bx + ay*by);

  00f8a	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR ax$14[rsp]
  00f93	f3 0f 59 84 24
	e0 00 00 00	 mulss	 xmm0, DWORD PTR bx$29[rsp]
  00f9c	f3 0f 10 8c 24
	98 00 00 00	 movss	 xmm1, DWORD PTR ay$15[rsp]
  00fa5	f3 0f 59 8c 24
	e4 00 00 00	 mulss	 xmm1, DWORD PTR by$30[rsp]
  00fae	f3 0f 58 c1	 addss	 xmm0, xmm1
  00fb2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40400000
  00fba	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00fbe	0f 28 c1	 movaps	 xmm0, xmm1
  00fc1	f3 0f 11 84 24
	dc 00 00 00	 movss	 DWORD PTR a$28[rsp], xmm0

; 4690 :                         float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);

  00fca	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR ax$14[rsp]
  00fd3	f3 0f 59 84 24
	94 00 00 00	 mulss	 xmm0, DWORD PTR ax$14[rsp]
  00fdc	f3 0f 10 8c 24
	98 00 00 00	 movss	 xmm1, DWORD PTR ay$15[rsp]
  00fe5	f3 0f 59 8c 24
	98 00 00 00	 mulss	 xmm1, DWORD PTR ay$15[rsp]
  00fee	f3 0f 58 c1	 addss	 xmm0, xmm1
  00ff2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  00ffa	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00ffe	0f 28 c1	 movaps	 xmm0, xmm1
  01001	f3 0f 10 8c 24
	e8 00 00 00	 movss	 xmm1, DWORD PTR mx$31[rsp]
  0100a	f3 0f 59 8c 24
	e0 00 00 00	 mulss	 xmm1, DWORD PTR bx$29[rsp]
  01013	f3 0f 10 94 24
	ec 00 00 00	 movss	 xmm2, DWORD PTR my$32[rsp]
  0101c	f3 0f 59 94 24
	e4 00 00 00	 mulss	 xmm2, DWORD PTR by$30[rsp]
  01025	f3 0f 58 ca	 addss	 xmm1, xmm2
  01029	f3 0f 58 c1	 addss	 xmm0, xmm1
  0102d	f3 0f 11 84 24
	b4 00 00 00	 movss	 DWORD PTR b$20[rsp], xmm0

; 4691 :                         float c = mx*ax+my*ay;

  01036	f3 0f 10 84 24
	e8 00 00 00	 movss	 xmm0, DWORD PTR mx$31[rsp]
  0103f	f3 0f 59 84 24
	94 00 00 00	 mulss	 xmm0, DWORD PTR ax$14[rsp]
  01048	f3 0f 10 8c 24
	ec 00 00 00	 movss	 xmm1, DWORD PTR my$32[rsp]
  01051	f3 0f 59 8c 24
	98 00 00 00	 mulss	 xmm1, DWORD PTR ay$15[rsp]
  0105a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0105e	f3 0f 11 84 24
	64 01 00 00	 movss	 DWORD PTR c$46[rsp], xmm0

; 4692 :                         if (a == 0.0) { // if a is 0, it's linear

  01067	f3 0f 5a 84 24
	dc 00 00 00	 cvtss2sd xmm0, DWORD PTR a$28[rsp]
  01070	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  01078	7a 56		 jp	 SHORT $LN36@stbtt_GetG
  0107a	75 54		 jne	 SHORT $LN36@stbtt_GetG

; 4693 :                            if (b != 0.0) {

  0107c	f3 0f 5a 84 24
	b4 00 00 00	 cvtss2sd xmm0, DWORD PTR b$20[rsp]
  01085	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0108d	7a 02		 jp	 SHORT $LN80@stbtt_GetG
  0108f	74 3a		 je	 SHORT $LN38@stbtt_GetG
$LN80@stbtt_GetG:

; 4694 :                               res[num++] = -c/b;

  01091	f3 0f 10 84 24
	64 01 00 00	 movss	 xmm0, DWORD PTR c$46[rsp]
  0109a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  010a1	f3 0f 5e 84 24
	b4 00 00 00	 divss	 xmm0, DWORD PTR b$20[rsp]
  010aa	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR num$13[rsp]
  010b2	f3 0f 11 84 84
	d0 01 00 00	 movss	 DWORD PTR res$69[rsp+rax*4], xmm0
  010bb	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$13[rsp]
  010c2	ff c0		 inc	 eax
  010c4	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$13[rsp], eax
$LN38@stbtt_GetG:

; 4695 :                            }
; 4696 :                         } else {

  010cb	e9 fc 00 00 00	 jmp	 $LN37@stbtt_GetG
$LN36@stbtt_GetG:

; 4697 :                            float discriminant = b*b - 4*a*c;

  010d0	f3 0f 10 84 24
	b4 00 00 00	 movss	 xmm0, DWORD PTR b$20[rsp]
  010d9	f3 0f 59 84 24
	b4 00 00 00	 mulss	 xmm0, DWORD PTR b$20[rsp]
  010e2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  010ea	f3 0f 59 8c 24
	dc 00 00 00	 mulss	 xmm1, DWORD PTR a$28[rsp]
  010f3	f3 0f 59 8c 24
	64 01 00 00	 mulss	 xmm1, DWORD PTR c$46[rsp]
  010fc	f3 0f 5c c1	 subss	 xmm0, xmm1
  01100	f3 0f 11 84 24
	68 01 00 00	 movss	 DWORD PTR discriminant$47[rsp], xmm0

; 4698 :                            if (discriminant < 0)

  01109	0f 57 c0	 xorps	 xmm0, xmm0
  0110c	0f 2f 84 24 68
	01 00 00	 comiss	 xmm0, DWORD PTR discriminant$47[rsp]
  01114	76 10		 jbe	 SHORT $LN39@stbtt_GetG

; 4699 :                               num = 0;

  01116	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR num$13[rsp], 0
  01121	e9 a6 00 00 00	 jmp	 $LN40@stbtt_GetG
$LN39@stbtt_GetG:

; 4700 :                            else {
; 4701 :                               float root = (float) STBTT_sqrt(discriminant);

  01126	f3 0f 5a 84 24
	68 01 00 00	 cvtss2sd xmm0, DWORD PTR discriminant$47[rsp]
  0112f	e8 00 00 00 00	 call	 sqrt
  01134	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  01138	f3 0f 11 84 24
	6c 01 00 00	 movss	 DWORD PTR root$48[rsp], xmm0

; 4702 :                               res[0] = (-b - root)/(2*a);

  01141	f3 0f 10 84 24
	b4 00 00 00	 movss	 xmm0, DWORD PTR b$20[rsp]
  0114a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  01151	f3 0f 5c 84 24
	6c 01 00 00	 subss	 xmm0, DWORD PTR root$48[rsp]
  0115a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  01162	f3 0f 59 8c 24
	dc 00 00 00	 mulss	 xmm1, DWORD PTR a$28[rsp]
  0116b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0116f	b8 04 00 00 00	 mov	 eax, 4
  01174	48 6b c0 00	 imul	 rax, rax, 0
  01178	f3 0f 11 84 04
	d0 01 00 00	 movss	 DWORD PTR res$69[rsp+rax], xmm0

; 4703 :                               res[1] = (-b + root)/(2*a);

  01181	f3 0f 10 84 24
	b4 00 00 00	 movss	 xmm0, DWORD PTR b$20[rsp]
  0118a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  01191	f3 0f 58 84 24
	6c 01 00 00	 addss	 xmm0, DWORD PTR root$48[rsp]
  0119a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  011a2	f3 0f 59 8c 24
	dc 00 00 00	 mulss	 xmm1, DWORD PTR a$28[rsp]
  011ab	f3 0f 5e c1	 divss	 xmm0, xmm1
  011af	b8 04 00 00 00	 mov	 eax, 4
  011b4	48 6b c0 01	 imul	 rax, rax, 1
  011b8	f3 0f 11 84 04
	d0 01 00 00	 movss	 DWORD PTR res$69[rsp+rax], xmm0

; 4704 :                               num = 2; // don't bother distinguishing 1-solution case, as code below will still work

  011c1	c7 84 24 90 00
	00 00 02 00 00
	00		 mov	 DWORD PTR num$13[rsp], 2
$LN40@stbtt_GetG:
$LN37@stbtt_GetG:

; 4705 :                            }
; 4706 :                         }
; 4707 :                      } else {

  011cc	e9 27 01 00 00	 jmp	 $LN35@stbtt_GetG
$LN34@stbtt_GetG:

; 4708 :                         float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point

  011d1	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR ax$14[rsp]
  011da	f3 0f 59 84 24
	e0 00 00 00	 mulss	 xmm0, DWORD PTR bx$29[rsp]
  011e3	f3 0f 10 8c 24
	98 00 00 00	 movss	 xmm1, DWORD PTR ay$15[rsp]
  011ec	f3 0f 59 8c 24
	e4 00 00 00	 mulss	 xmm1, DWORD PTR by$30[rsp]
  011f5	f3 0f 58 c1	 addss	 xmm0, xmm1
  011f9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40400000
  01201	f3 0f 59 c8	 mulss	 xmm1, xmm0
  01205	0f 28 c1	 movaps	 xmm0, xmm1
  01208	f3 0f 59 84 24
	f0 00 00 00	 mulss	 xmm0, DWORD PTR a_inv$33[rsp]
  01211	f3 0f 11 84 24
	b4 01 00 00	 movss	 DWORD PTR b$65[rsp], xmm0

; 4709 :                         float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;

  0121a	f3 0f 10 84 24
	94 00 00 00	 movss	 xmm0, DWORD PTR ax$14[rsp]
  01223	f3 0f 59 84 24
	94 00 00 00	 mulss	 xmm0, DWORD PTR ax$14[rsp]
  0122c	f3 0f 10 8c 24
	98 00 00 00	 movss	 xmm1, DWORD PTR ay$15[rsp]
  01235	f3 0f 59 8c 24
	98 00 00 00	 mulss	 xmm1, DWORD PTR ay$15[rsp]
  0123e	f3 0f 58 c1	 addss	 xmm0, xmm1
  01242	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  0124a	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0124e	0f 28 c1	 movaps	 xmm0, xmm1
  01251	f3 0f 10 8c 24
	e8 00 00 00	 movss	 xmm1, DWORD PTR mx$31[rsp]
  0125a	f3 0f 59 8c 24
	e0 00 00 00	 mulss	 xmm1, DWORD PTR bx$29[rsp]
  01263	f3 0f 10 94 24
	ec 00 00 00	 movss	 xmm2, DWORD PTR my$32[rsp]
  0126c	f3 0f 59 94 24
	e4 00 00 00	 mulss	 xmm2, DWORD PTR by$30[rsp]
  01275	f3 0f 58 ca	 addss	 xmm1, xmm2
  01279	f3 0f 58 c1	 addss	 xmm0, xmm1
  0127d	f3 0f 59 84 24
	f0 00 00 00	 mulss	 xmm0, DWORD PTR a_inv$33[rsp]
  01286	f3 0f 11 84 24
	b0 01 00 00	 movss	 DWORD PTR c$64[rsp], xmm0

; 4710 :                         float d = (mx*ax+my*ay) * a_inv;

  0128f	f3 0f 10 84 24
	e8 00 00 00	 movss	 xmm0, DWORD PTR mx$31[rsp]
  01298	f3 0f 59 84 24
	94 00 00 00	 mulss	 xmm0, DWORD PTR ax$14[rsp]
  012a1	f3 0f 10 8c 24
	ec 00 00 00	 movss	 xmm1, DWORD PTR my$32[rsp]
  012aa	f3 0f 59 8c 24
	98 00 00 00	 mulss	 xmm1, DWORD PTR ay$15[rsp]
  012b3	f3 0f 58 c1	 addss	 xmm0, xmm1
  012b7	f3 0f 59 84 24
	f0 00 00 00	 mulss	 xmm0, DWORD PTR a_inv$33[rsp]
  012c0	f3 0f 11 84 24
	ac 01 00 00	 movss	 DWORD PTR d$63[rsp], xmm0

; 4711 :                         num = stbtt__solve_cubic(b, c, d, res);

  012c9	4c 8d 8c 24 d0
	01 00 00	 lea	 r9, QWORD PTR res$69[rsp]
  012d1	f3 0f 10 94 24
	ac 01 00 00	 movss	 xmm2, DWORD PTR d$63[rsp]
  012da	f3 0f 10 8c 24
	b0 01 00 00	 movss	 xmm1, DWORD PTR c$64[rsp]
  012e3	f3 0f 10 84 24
	b4 01 00 00	 movss	 xmm0, DWORD PTR b$65[rsp]
  012ec	e8 00 00 00 00	 call	 ?stbtt__solve_cubic@@YAHMMMPEAM@Z ; stbtt__solve_cubic
  012f1	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$13[rsp], eax
$LN35@stbtt_GetG:

; 4712 :                      }
; 4713 :                      dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);

  012f8	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR x0$4[rsp]
  012fe	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  01304	f3 0f 10 4c 24
	5c		 movss	 xmm1, DWORD PTR x0$4[rsp]
  0130a	f3 0f 5c 4c 24
	68		 subss	 xmm1, DWORD PTR sx$7[rsp]
  01310	f3 0f 59 c1	 mulss	 xmm0, xmm1
  01314	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR y0$5[rsp]
  0131a	f3 0f 5c 4c 24
	6c		 subss	 xmm1, DWORD PTR sy$8[rsp]
  01320	f3 0f 10 54 24
	60		 movss	 xmm2, DWORD PTR y0$5[rsp]
  01326	f3 0f 5c 54 24
	6c		 subss	 xmm2, DWORD PTR sy$8[rsp]
  0132c	f3 0f 59 ca	 mulss	 xmm1, xmm2
  01330	f3 0f 58 c1	 addss	 xmm0, xmm1
  01334	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR dist2$12[rsp], xmm0

; 4714 :                      if (dist2 < min_dist*min_dist)

  0133d	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  01343	f3 0f 59 44 24
	54		 mulss	 xmm0, DWORD PTR min_dist$2[rsp]
  01349	0f 2f 84 24 88
	00 00 00	 comiss	 xmm0, DWORD PTR dist2$12[rsp]
  01351	76 18		 jbe	 SHORT $LN41@stbtt_GetG

; 4715 :                         min_dist = (float) STBTT_sqrt(dist2);

  01353	f3 0f 5a 84 24
	88 00 00 00	 cvtss2sd xmm0, DWORD PTR dist2$12[rsp]
  0135c	e8 00 00 00 00	 call	 sqrt
  01361	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  01365	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN41@stbtt_GetG:

; 4716 : 
; 4717 :                      if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {

  0136b	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR num$13[rsp], 1
  01373	0f 8c 8d 01 00
	00		 jl	 $LN42@stbtt_GetG
  01379	b8 04 00 00 00	 mov	 eax, 4
  0137e	48 6b c0 00	 imul	 rax, rax, 0
  01382	f3 0f 10 84 04
	d0 01 00 00	 movss	 xmm0, DWORD PTR res$69[rsp+rax]
  0138b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  01392	0f 82 6e 01 00
	00		 jb	 $LN42@stbtt_GetG
  01398	b8 04 00 00 00	 mov	 eax, 4
  0139d	48 6b c0 00	 imul	 rax, rax, 0
  013a1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  013a9	0f 2f 84 04 d0
	01 00 00	 comiss	 xmm0, DWORD PTR res$69[rsp+rax]
  013b1	0f 82 4f 01 00
	00		 jb	 $LN42@stbtt_GetG

; 4718 :                         t = res[0], it = 1.0f - t;

  013b7	b8 04 00 00 00	 mov	 eax, 4
  013bc	48 6b c0 00	 imul	 rax, rax, 0
  013c0	f3 0f 10 84 04
	d0 01 00 00	 movss	 xmm0, DWORD PTR res$69[rsp+rax]
  013c9	f3 0f 11 44 24
	58		 movss	 DWORD PTR t$3[rsp], xmm0
  013cf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  013d7	f3 0f 5c 44 24
	58		 subss	 xmm0, DWORD PTR t$3[rsp]
  013dd	f3 0f 11 44 24
	64		 movss	 DWORD PTR it$6[rsp], xmm0

; 4719 :                         px = it*it*x0 + 2*t*it*x1 + t*t*x2;

  013e3	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR it$6[rsp]
  013e9	f3 0f 59 44 24
	64		 mulss	 xmm0, DWORD PTR it$6[rsp]
  013ef	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR x0$4[rsp]
  013f5	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  013fd	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  01403	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR it$6[rsp]
  01409	f3 0f 59 4c 24
	70		 mulss	 xmm1, DWORD PTR x1$9[rsp]
  0140f	f3 0f 58 c1	 addss	 xmm0, xmm1
  01413	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR t$3[rsp]
  01419	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  0141f	f3 0f 59 8c 24
	9c 00 00 00	 mulss	 xmm1, DWORD PTR x2$16[rsp]
  01428	f3 0f 58 c1	 addss	 xmm0, xmm1
  0142c	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR px$18[rsp], xmm0

; 4720 :                         py = it*it*y0 + 2*t*it*y1 + t*t*y2;

  01435	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR it$6[rsp]
  0143b	f3 0f 59 44 24
	64		 mulss	 xmm0, DWORD PTR it$6[rsp]
  01441	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR y0$5[rsp]
  01447	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  0144f	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  01455	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR it$6[rsp]
  0145b	f3 0f 59 4c 24
	74		 mulss	 xmm1, DWORD PTR y1$10[rsp]
  01461	f3 0f 58 c1	 addss	 xmm0, xmm1
  01465	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR t$3[rsp]
  0146b	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  01471	f3 0f 59 8c 24
	a0 00 00 00	 mulss	 xmm1, DWORD PTR y2$17[rsp]
  0147a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0147e	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR py$19[rsp], xmm0

; 4721 :                         dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);

  01487	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR px$18[rsp]
  01490	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  01496	f3 0f 10 8c 24
	a4 00 00 00	 movss	 xmm1, DWORD PTR px$18[rsp]
  0149f	f3 0f 5c 4c 24
	68		 subss	 xmm1, DWORD PTR sx$7[rsp]
  014a5	f3 0f 59 c1	 mulss	 xmm0, xmm1
  014a9	f3 0f 10 8c 24
	a8 00 00 00	 movss	 xmm1, DWORD PTR py$19[rsp]
  014b2	f3 0f 5c 4c 24
	6c		 subss	 xmm1, DWORD PTR sy$8[rsp]
  014b8	f3 0f 10 94 24
	a8 00 00 00	 movss	 xmm2, DWORD PTR py$19[rsp]
  014c1	f3 0f 5c 54 24
	6c		 subss	 xmm2, DWORD PTR sy$8[rsp]
  014c7	f3 0f 59 ca	 mulss	 xmm1, xmm2
  014cb	f3 0f 58 c1	 addss	 xmm0, xmm1
  014cf	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR dist2$12[rsp], xmm0

; 4722 :                         if (dist2 < min_dist * min_dist)

  014d8	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  014de	f3 0f 59 44 24
	54		 mulss	 xmm0, DWORD PTR min_dist$2[rsp]
  014e4	0f 2f 84 24 88
	00 00 00	 comiss	 xmm0, DWORD PTR dist2$12[rsp]
  014ec	76 18		 jbe	 SHORT $LN43@stbtt_GetG

; 4723 :                            min_dist = (float) STBTT_sqrt(dist2);

  014ee	f3 0f 5a 84 24
	88 00 00 00	 cvtss2sd xmm0, DWORD PTR dist2$12[rsp]
  014f7	e8 00 00 00 00	 call	 sqrt
  014fc	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  01500	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN43@stbtt_GetG:
$LN42@stbtt_GetG:

; 4724 :                      }
; 4725 :                      if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {

  01506	83 bc 24 90 00
	00 00 02	 cmp	 DWORD PTR num$13[rsp], 2
  0150e	0f 8c 8d 01 00
	00		 jl	 $LN44@stbtt_GetG
  01514	b8 04 00 00 00	 mov	 eax, 4
  01519	48 6b c0 01	 imul	 rax, rax, 1
  0151d	f3 0f 10 84 04
	d0 01 00 00	 movss	 xmm0, DWORD PTR res$69[rsp+rax]
  01526	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0152d	0f 82 6e 01 00
	00		 jb	 $LN44@stbtt_GetG
  01533	b8 04 00 00 00	 mov	 eax, 4
  01538	48 6b c0 01	 imul	 rax, rax, 1
  0153c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01544	0f 2f 84 04 d0
	01 00 00	 comiss	 xmm0, DWORD PTR res$69[rsp+rax]
  0154c	0f 82 4f 01 00
	00		 jb	 $LN44@stbtt_GetG

; 4726 :                         t = res[1], it = 1.0f - t;

  01552	b8 04 00 00 00	 mov	 eax, 4
  01557	48 6b c0 01	 imul	 rax, rax, 1
  0155b	f3 0f 10 84 04
	d0 01 00 00	 movss	 xmm0, DWORD PTR res$69[rsp+rax]
  01564	f3 0f 11 44 24
	58		 movss	 DWORD PTR t$3[rsp], xmm0
  0156a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01572	f3 0f 5c 44 24
	58		 subss	 xmm0, DWORD PTR t$3[rsp]
  01578	f3 0f 11 44 24
	64		 movss	 DWORD PTR it$6[rsp], xmm0

; 4727 :                         px = it*it*x0 + 2*t*it*x1 + t*t*x2;

  0157e	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR it$6[rsp]
  01584	f3 0f 59 44 24
	64		 mulss	 xmm0, DWORD PTR it$6[rsp]
  0158a	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR x0$4[rsp]
  01590	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  01598	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  0159e	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR it$6[rsp]
  015a4	f3 0f 59 4c 24
	70		 mulss	 xmm1, DWORD PTR x1$9[rsp]
  015aa	f3 0f 58 c1	 addss	 xmm0, xmm1
  015ae	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR t$3[rsp]
  015b4	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  015ba	f3 0f 59 8c 24
	9c 00 00 00	 mulss	 xmm1, DWORD PTR x2$16[rsp]
  015c3	f3 0f 58 c1	 addss	 xmm0, xmm1
  015c7	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR px$18[rsp], xmm0

; 4728 :                         py = it*it*y0 + 2*t*it*y1 + t*t*y2;

  015d0	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR it$6[rsp]
  015d6	f3 0f 59 44 24
	64		 mulss	 xmm0, DWORD PTR it$6[rsp]
  015dc	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR y0$5[rsp]
  015e2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  015ea	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  015f0	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR it$6[rsp]
  015f6	f3 0f 59 4c 24
	74		 mulss	 xmm1, DWORD PTR y1$10[rsp]
  015fc	f3 0f 58 c1	 addss	 xmm0, xmm1
  01600	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR t$3[rsp]
  01606	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  0160c	f3 0f 59 8c 24
	a0 00 00 00	 mulss	 xmm1, DWORD PTR y2$17[rsp]
  01615	f3 0f 58 c1	 addss	 xmm0, xmm1
  01619	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR py$19[rsp], xmm0

; 4729 :                         dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);

  01622	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR px$18[rsp]
  0162b	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  01631	f3 0f 10 8c 24
	a4 00 00 00	 movss	 xmm1, DWORD PTR px$18[rsp]
  0163a	f3 0f 5c 4c 24
	68		 subss	 xmm1, DWORD PTR sx$7[rsp]
  01640	f3 0f 59 c1	 mulss	 xmm0, xmm1
  01644	f3 0f 10 8c 24
	a8 00 00 00	 movss	 xmm1, DWORD PTR py$19[rsp]
  0164d	f3 0f 5c 4c 24
	6c		 subss	 xmm1, DWORD PTR sy$8[rsp]
  01653	f3 0f 10 94 24
	a8 00 00 00	 movss	 xmm2, DWORD PTR py$19[rsp]
  0165c	f3 0f 5c 54 24
	6c		 subss	 xmm2, DWORD PTR sy$8[rsp]
  01662	f3 0f 59 ca	 mulss	 xmm1, xmm2
  01666	f3 0f 58 c1	 addss	 xmm0, xmm1
  0166a	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR dist2$12[rsp], xmm0

; 4730 :                         if (dist2 < min_dist * min_dist)

  01673	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  01679	f3 0f 59 44 24
	54		 mulss	 xmm0, DWORD PTR min_dist$2[rsp]
  0167f	0f 2f 84 24 88
	00 00 00	 comiss	 xmm0, DWORD PTR dist2$12[rsp]
  01687	76 18		 jbe	 SHORT $LN45@stbtt_GetG

; 4731 :                            min_dist = (float) STBTT_sqrt(dist2);

  01689	f3 0f 5a 84 24
	88 00 00 00	 cvtss2sd xmm0, DWORD PTR dist2$12[rsp]
  01692	e8 00 00 00 00	 call	 sqrt
  01697	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0169b	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN45@stbtt_GetG:
$LN44@stbtt_GetG:

; 4732 :                      }
; 4733 :                      if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {

  016a1	83 bc 24 90 00
	00 00 03	 cmp	 DWORD PTR num$13[rsp], 3
  016a9	0f 8c 8d 01 00
	00		 jl	 $LN46@stbtt_GetG
  016af	b8 04 00 00 00	 mov	 eax, 4
  016b4	48 6b c0 02	 imul	 rax, rax, 2
  016b8	f3 0f 10 84 04
	d0 01 00 00	 movss	 xmm0, DWORD PTR res$69[rsp+rax]
  016c1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  016c8	0f 82 6e 01 00
	00		 jb	 $LN46@stbtt_GetG
  016ce	b8 04 00 00 00	 mov	 eax, 4
  016d3	48 6b c0 02	 imul	 rax, rax, 2
  016d7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  016df	0f 2f 84 04 d0
	01 00 00	 comiss	 xmm0, DWORD PTR res$69[rsp+rax]
  016e7	0f 82 4f 01 00
	00		 jb	 $LN46@stbtt_GetG

; 4734 :                         t = res[2], it = 1.0f - t;

  016ed	b8 04 00 00 00	 mov	 eax, 4
  016f2	48 6b c0 02	 imul	 rax, rax, 2
  016f6	f3 0f 10 84 04
	d0 01 00 00	 movss	 xmm0, DWORD PTR res$69[rsp+rax]
  016ff	f3 0f 11 44 24
	58		 movss	 DWORD PTR t$3[rsp], xmm0
  01705	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0170d	f3 0f 5c 44 24
	58		 subss	 xmm0, DWORD PTR t$3[rsp]
  01713	f3 0f 11 44 24
	64		 movss	 DWORD PTR it$6[rsp], xmm0

; 4735 :                         px = it*it*x0 + 2*t*it*x1 + t*t*x2;

  01719	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR it$6[rsp]
  0171f	f3 0f 59 44 24
	64		 mulss	 xmm0, DWORD PTR it$6[rsp]
  01725	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR x0$4[rsp]
  0172b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  01733	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  01739	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR it$6[rsp]
  0173f	f3 0f 59 4c 24
	70		 mulss	 xmm1, DWORD PTR x1$9[rsp]
  01745	f3 0f 58 c1	 addss	 xmm0, xmm1
  01749	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR t$3[rsp]
  0174f	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  01755	f3 0f 59 8c 24
	9c 00 00 00	 mulss	 xmm1, DWORD PTR x2$16[rsp]
  0175e	f3 0f 58 c1	 addss	 xmm0, xmm1
  01762	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR px$18[rsp], xmm0

; 4736 :                         py = it*it*y0 + 2*t*it*y1 + t*t*y2;

  0176b	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR it$6[rsp]
  01771	f3 0f 59 44 24
	64		 mulss	 xmm0, DWORD PTR it$6[rsp]
  01777	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR y0$5[rsp]
  0177d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  01785	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  0178b	f3 0f 59 4c 24
	64		 mulss	 xmm1, DWORD PTR it$6[rsp]
  01791	f3 0f 59 4c 24
	74		 mulss	 xmm1, DWORD PTR y1$10[rsp]
  01797	f3 0f 58 c1	 addss	 xmm0, xmm1
  0179b	f3 0f 10 4c 24
	58		 movss	 xmm1, DWORD PTR t$3[rsp]
  017a1	f3 0f 59 4c 24
	58		 mulss	 xmm1, DWORD PTR t$3[rsp]
  017a7	f3 0f 59 8c 24
	a0 00 00 00	 mulss	 xmm1, DWORD PTR y2$17[rsp]
  017b0	f3 0f 58 c1	 addss	 xmm0, xmm1
  017b4	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR py$19[rsp], xmm0

; 4737 :                         dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);

  017bd	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR px$18[rsp]
  017c6	f3 0f 5c 44 24
	68		 subss	 xmm0, DWORD PTR sx$7[rsp]
  017cc	f3 0f 10 8c 24
	a4 00 00 00	 movss	 xmm1, DWORD PTR px$18[rsp]
  017d5	f3 0f 5c 4c 24
	68		 subss	 xmm1, DWORD PTR sx$7[rsp]
  017db	f3 0f 59 c1	 mulss	 xmm0, xmm1
  017df	f3 0f 10 8c 24
	a8 00 00 00	 movss	 xmm1, DWORD PTR py$19[rsp]
  017e8	f3 0f 5c 4c 24
	6c		 subss	 xmm1, DWORD PTR sy$8[rsp]
  017ee	f3 0f 10 94 24
	a8 00 00 00	 movss	 xmm2, DWORD PTR py$19[rsp]
  017f7	f3 0f 5c 54 24
	6c		 subss	 xmm2, DWORD PTR sy$8[rsp]
  017fd	f3 0f 59 ca	 mulss	 xmm1, xmm2
  01801	f3 0f 58 c1	 addss	 xmm0, xmm1
  01805	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR dist2$12[rsp], xmm0

; 4738 :                         if (dist2 < min_dist * min_dist)

  0180e	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  01814	f3 0f 59 44 24
	54		 mulss	 xmm0, DWORD PTR min_dist$2[rsp]
  0181a	0f 2f 84 24 88
	00 00 00	 comiss	 xmm0, DWORD PTR dist2$12[rsp]
  01822	76 18		 jbe	 SHORT $LN47@stbtt_GetG

; 4739 :                            min_dist = (float) STBTT_sqrt(dist2);

  01824	f3 0f 5a 84 24
	88 00 00 00	 cvtss2sd xmm0, DWORD PTR dist2$12[rsp]
  0182d	e8 00 00 00 00	 call	 sqrt
  01832	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  01836	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN47@stbtt_GetG:
$LN46@stbtt_GetG:
$LN33@stbtt_GetG:
$LN32@stbtt_GetG:
$LN28@stbtt_GetG:

; 4740 :                      }
; 4741 :                   }
; 4742 :                }
; 4743 :             }

  0183c	e9 5a ef ff ff	 jmp	 $LN11@stbtt_GetG
$LN12@stbtt_GetG:

; 4744 :             if (winding == 0)

  01841	83 bc 24 b8 01
	00 00 00	 cmp	 DWORD PTR winding$66[rsp], 0
  01849	75 13		 jne	 SHORT $LN48@stbtt_GetG

; 4745 :                min_dist = -min_dist;  // if outside the shape, value is negative

  0184b	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR min_dist$2[rsp]
  01851	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  01858	f3 0f 11 44 24
	54		 movss	 DWORD PTR min_dist$2[rsp], xmm0
$LN48@stbtt_GetG:

; 4746 :             val = onedge_value + pixel_dist_scale * min_dist;

  0185e	0f b6 84 24 20
	02 00 00	 movzx	 eax, BYTE PTR onedge_value$[rsp]
  01866	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0186a	f3 0f 10 8c 24
	28 02 00 00	 movss	 xmm1, DWORD PTR pixel_dist_scale$[rsp]
  01873	f3 0f 59 4c 24
	54		 mulss	 xmm1, DWORD PTR min_dist$2[rsp]
  01879	f3 0f 58 c1	 addss	 xmm0, xmm1
  0187d	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR val$23[rsp], xmm0

; 4747 :             if (val < 0)

  01886	0f 57 c0	 xorps	 xmm0, xmm0
  01889	0f 2f 84 24 c8
	00 00 00	 comiss	 xmm0, DWORD PTR val$23[rsp]
  01891	76 0e		 jbe	 SHORT $LN49@stbtt_GetG

; 4748 :                val = 0;

  01893	0f 57 c0	 xorps	 xmm0, xmm0
  01896	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR val$23[rsp], xmm0
  0189f	eb 23		 jmp	 SHORT $LN50@stbtt_GetG
$LN49@stbtt_GetG:

; 4749 :             else if (val > 255)

  018a1	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR val$23[rsp]
  018aa	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  018b1	76 11		 jbe	 SHORT $LN51@stbtt_GetG

; 4750 :                val = 255;

  018b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  018bb	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR val$23[rsp], xmm0
$LN51@stbtt_GetG:
$LN50@stbtt_GetG:

; 4751 :             data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;

  018c4	f3 0f 2c 84 24
	c8 00 00 00	 cvttss2si eax, DWORD PTR val$23[rsp]
  018cd	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iy0$[rsp]
  018d4	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR y$24[rsp]
  018db	2b d1		 sub	 edx, ecx
  018dd	8b ca		 mov	 ecx, edx
  018df	0f af 8c 24 08
	01 00 00	 imul	 ecx, DWORD PTR w$[rsp]
  018e7	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR ix0$[rsp]
  018ee	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR x$25[rsp]
  018f6	44 2b c2	 sub	 r8d, edx
  018f9	41 8b d0	 mov	 edx, r8d
  018fc	03 ca		 add	 ecx, edx
  018fe	48 63 c9	 movsxd	 rcx, ecx
  01901	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  01909	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4752 :          }

  0190c	e9 c5 ed ff ff	 jmp	 $LN8@stbtt_GetG
$LN9@stbtt_GetG:

; 4753 :       }

  01911	e9 8c ed ff ff	 jmp	 $LN5@stbtt_GetG
$LN6@stbtt_GetG:

; 4754 :       STBTT_free(precompute, info->userdata);

  01916	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR precompute$34[rsp]
  0191e	e8 00 00 00 00	 call	 free

; 4755 :       STBTT_free(verts, info->userdata);

  01923	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR verts$11[rsp]
  0192b	e8 00 00 00 00	 call	 free

; 4756 :    }
; 4757 :    return data;

  01930	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR data$[rsp]
$LN1@stbtt_GetG:

; 4758 : }

  01938	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01940	48 33 cc	 xor	 rcx, rsp
  01943	e8 00 00 00 00	 call	 __security_check_cookie
  01948	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  0194f	c3		 ret	 0
stbtt_GetGlyphSDF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
bitmap$ = 48
userdata$ = 56
stbtt_FreeSDF PROC

; 4766 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4767 :    STBTT_free(bitmap, userdata);

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitmap$[rsp]
  00013	e8 00 00 00 00	 call	 free

; 4768 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
stbtt_FreeSDF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv65 = 96
winding_count$ = 100
scale$ = 104
winding_lengths$ = 112
windings$ = 120
result$ = 144
flatness_in_pixels$ = 152
vertices$ = 160
num_verts$ = 168
scale_x$ = 176
scale_y$ = 184
shift_x$ = 192
shift_y$ = 200
x_off$ = 208
y_off$ = 216
invert$ = 224
userdata$ = 232
stbtt_Rasterize PROC

; 3696 : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3697 :    float scale            = scale_x > scale_y ? scale_y : scale_x;

  0001c	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  00025	0f 2f 84 24 b8
	00 00 00	 comiss	 xmm0, DWORD PTR scale_y$[rsp]
  0002d	76 11		 jbe	 SHORT $LN4@stbtt_Rast
  0002f	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00038	f3 0f 11 44 24
	60		 movss	 DWORD PTR tv65[rsp], xmm0
  0003e	eb 0f		 jmp	 SHORT $LN5@stbtt_Rast
$LN4@stbtt_Rast:
  00040	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  00049	f3 0f 11 44 24
	60		 movss	 DWORD PTR tv65[rsp], xmm0
$LN5@stbtt_Rast:
  0004f	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR tv65[rsp]
  00055	f3 0f 11 44 24
	68		 movss	 DWORD PTR scale$[rsp], xmm0

; 3698 :    int winding_count      = 0;

  0005b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR winding_count$[rsp], 0

; 3699 :    int *winding_lengths   = NULL;

  00063	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR winding_lengths$[rsp], 0

; 3700 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

  0006c	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR flatness_in_pixels$[rsp]
  00075	f3 0f 5e 44 24
	68		 divss	 xmm0, DWORD PTR scale$[rsp]
  0007b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR userdata$[rsp]
  00083	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00088	48 8d 44 24 64	 lea	 rax, QWORD PTR winding_count$[rsp]
  0008d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00092	4c 8d 4c 24 70	 lea	 r9, QWORD PTR winding_lengths$[rsp]
  00097	0f 28 d0	 movaps	 xmm2, xmm0
  0009a	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR num_verts$[rsp]
  000a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR vertices$[rsp]
  000a9	e8 00 00 00 00	 call	 ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
  000ae	48 89 44 24 78	 mov	 QWORD PTR windings$[rsp], rax

; 3701 :    if (windings) {

  000b3	48 83 7c 24 78
	00		 cmp	 QWORD PTR windings$[rsp], 0
  000b9	0f 84 9a 00 00
	00		 je	 $LN2@stbtt_Rast

; 3702 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

  000bf	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR userdata$[rsp]
  000c7	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  000cc	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR invert$[rsp]
  000d3	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  000d7	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR y_off$[rsp]
  000de	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  000e2	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR x_off$[rsp]
  000e9	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000ed	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  000f6	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  000fc	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  00105	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0010b	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00114	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0011a	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  00123	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00129	44 8b 4c 24 64	 mov	 r9d, DWORD PTR winding_count$[rsp]
  0012e	4c 8b 44 24 70	 mov	 r8, QWORD PTR winding_lengths$[rsp]
  00133	48 8b 54 24 78	 mov	 rdx, QWORD PTR windings$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00140	e8 00 00 00 00	 call	 ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize

; 3703 :       STBTT_free(winding_lengths, userdata);

  00145	48 8b 4c 24 70	 mov	 rcx, QWORD PTR winding_lengths$[rsp]
  0014a	e8 00 00 00 00	 call	 free

; 3704 :       STBTT_free(windings, userdata);

  0014f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR windings$[rsp]
  00154	e8 00 00 00 00	 call	 free
$LN2@stbtt_Rast:

; 3705 :    }
; 3706 : }

  00159	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00160	c3		 ret	 0
stbtt_Rasterize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
x0$ = 48
y0$ = 52
y1$ = 56
x1$ = 60
font$ = 80
glyph$ = 88
scale_x$ = 96
scale_y$ = 104
shift_x$ = 112
shift_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetGlyphBitmapBoxSubpixel PROC

; 2722 : {

$LN13:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2723 :    int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning

  00019	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR x0$[rsp], 0
  00021	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR y0$[rsp], 0

; 2724 :    if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {

  00029	48 8d 44 24 38	 lea	 rax, QWORD PTR y1$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00033	48 8d 44 24 3c	 lea	 rax, QWORD PTR x1$[rsp]
  00038	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003d	4c 8d 4c 24 34	 lea	 r9, QWORD PTR y0$[rsp]
  00042	4c 8d 44 24 30	 lea	 r8, QWORD PTR x0$[rsp]
  00047	8b 54 24 58	 mov	 edx, DWORD PTR glyph$[rsp]
  0004b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR font$[rsp]
  00050	e8 00 00 00 00	 call	 stbtt_GetGlyphBox
  00055	85 c0		 test	 eax, eax
  00057	75 69		 jne	 SHORT $LN2@stbtt_GetG

; 2725 :       // e.g. space character
; 2726 :       if (ix0) *ix0 = 0;

  00059	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ix0$[rsp], 0
  00062	74 0e		 je	 SHORT $LN4@stbtt_GetG
  00064	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ix0$[rsp]
  0006c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@stbtt_GetG:

; 2727 :       if (iy0) *iy0 = 0;

  00072	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR iy0$[rsp], 0
  0007b	74 0e		 je	 SHORT $LN5@stbtt_GetG
  0007d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR iy0$[rsp]
  00085	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN5@stbtt_GetG:

; 2728 :       if (ix1) *ix1 = 0;

  0008b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR ix1$[rsp], 0
  00094	74 0e		 je	 SHORT $LN6@stbtt_GetG
  00096	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ix1$[rsp]
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN6@stbtt_GetG:

; 2729 :       if (iy1) *iy1 = 0;

  000a4	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR iy1$[rsp], 0
  000ad	74 0e		 je	 SHORT $LN7@stbtt_GetG
  000af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR iy1$[rsp]
  000b7	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN7@stbtt_GetG:

; 2730 :    } else {

  000bd	e9 d8 00 00 00	 jmp	 $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2731 :       // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
; 2732 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

  000c2	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ix0$[rsp], 0
  000cb	74 29		 je	 SHORT $LN8@stbtt_GetG
  000cd	f3 0f 2a 44 24
	30		 cvtsi2ss xmm0, DWORD PTR x0$[rsp]
  000d3	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  000d9	f3 0f 58 44 24
	70		 addss	 xmm0, DWORD PTR shift_x$[rsp]
  000df	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000e3	e8 00 00 00 00	 call	 floor
  000e8	f2 0f 2c c0	 cvttsd2si eax, xmm0
  000ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ix0$[rsp]
  000f4	89 01		 mov	 DWORD PTR [rcx], eax
$LN8@stbtt_GetG:

; 2733 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  000f6	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR iy0$[rsp], 0
  000ff	74 2d		 je	 SHORT $LN9@stbtt_GetG
  00101	8b 44 24 38	 mov	 eax, DWORD PTR y1$[rsp]
  00105	f7 d8		 neg	 eax
  00107	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0010b	f3 0f 59 44 24
	68		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  00111	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR shift_y$[rsp]
  00117	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0011b	e8 00 00 00 00	 call	 floor
  00120	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00124	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR iy0$[rsp]
  0012c	89 01		 mov	 DWORD PTR [rcx], eax
$LN9@stbtt_GetG:

; 2734 :       if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);

  0012e	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR ix1$[rsp], 0
  00137	74 29		 je	 SHORT $LN10@stbtt_GetG
  00139	f3 0f 2a 44 24
	3c		 cvtsi2ss xmm0, DWORD PTR x1$[rsp]
  0013f	f3 0f 59 44 24
	60		 mulss	 xmm0, DWORD PTR scale_x$[rsp]
  00145	f3 0f 58 44 24
	70		 addss	 xmm0, DWORD PTR shift_x$[rsp]
  0014b	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0014f	e8 00 00 00 00	 call	 ceil
  00154	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00158	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ix1$[rsp]
  00160	89 01		 mov	 DWORD PTR [rcx], eax
$LN10@stbtt_GetG:

; 2735 :       if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);

  00162	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR iy1$[rsp], 0
  0016b	74 2d		 je	 SHORT $LN11@stbtt_GetG
  0016d	8b 44 24 34	 mov	 eax, DWORD PTR y0$[rsp]
  00171	f7 d8		 neg	 eax
  00173	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00177	f3 0f 59 44 24
	68		 mulss	 xmm0, DWORD PTR scale_y$[rsp]
  0017d	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR shift_y$[rsp]
  00183	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00187	e8 00 00 00 00	 call	 ceil
  0018c	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00190	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iy1$[rsp]
  00198	89 01		 mov	 DWORD PTR [rcx], eax
$LN11@stbtt_GetG:
$LN3@stbtt_GetG:

; 2736 :    }
; 2737 : }

  0019a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019e	c3		 ret	 0
stbtt_GetGlyphBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
font$ = 96
glyph$ = 104
scale_x$ = 112
scale_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetGlyphBitmapBox PROC

; 2740 : {

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2741 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

  00019	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR iy1$[rsp]
  00021	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00026	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ix1$[rsp]
  0002e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00033	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR iy0$[rsp]
  0003b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00040	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ix0$[rsp]
  00048	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004d	0f 57 c0	 xorps	 xmm0, xmm0
  00050	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0005f	f3 0f 10 5c 24
	78		 movss	 xmm3, DWORD PTR scale_y$[rsp]
  00065	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR scale_x$[rsp]
  0006b	8b 54 24 68	 mov	 edx, DWORD PTR glyph$[rsp]
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR font$[rsp]
  00074	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 2742 : }

  00079	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007d	c3		 ret	 0
stbtt_GetGlyphBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
output$ = 104
out_w$ = 112
out_h$ = 120
out_stride$ = 128
scale_x$ = 136
scale_y$ = 144
shift_x$ = 152
shift_y$ = 160
prefilter_x$ = 168
prefilter_y$ = 176
sub_x$ = 184
sub_y$ = 192
glyph$ = 200
stbtt_MakeGlyphBitmapSubpixelPrefilter PROC

; 4185 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4186 :    stbtt_MakeGlyphBitmapSubpixel(info,

  00018	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR prefilter_y$[rsp]
  0001f	ff c8		 dec	 eax
  00021	8b 4c 24 78	 mov	 ecx, DWORD PTR out_h$[rsp]
  00025	2b c8		 sub	 ecx, eax
  00027	8b c1		 mov	 eax, ecx
  00029	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR prefilter_x$[rsp]
  00030	ff c9		 dec	 ecx
  00032	8b 54 24 70	 mov	 edx, DWORD PTR out_w$[rsp]
  00036	2b d1		 sub	 edx, ecx
  00038	8b ca		 mov	 ecx, edx
  0003a	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  00041	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  00045	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  0004e	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  00054	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  0005d	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00063	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0006c	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00072	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  0007b	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00081	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR out_stride$[rsp]
  00088	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0008c	44 8b c8	 mov	 r9d, eax
  0008f	44 8b c1	 mov	 r8d, ecx
  00092	48 8b 54 24 68	 mov	 rdx, QWORD PTR output$[rsp]
  00097	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  0009c	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmapSubpixel

; 4187 :                                  output,
; 4188 :                                  out_w - (prefilter_x - 1),
; 4189 :                                  out_h - (prefilter_y - 1),
; 4190 :                                  out_stride,
; 4191 :                                  scale_x,
; 4192 :                                  scale_y,
; 4193 :                                  shift_x,
; 4194 :                                  shift_y,
; 4195 :                                  glyph);
; 4196 : 
; 4197 :    if (prefilter_x > 1)

  000a1	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR prefilter_x$[rsp], 1
  000a9	7e 26		 jle	 SHORT $LN2@stbtt_Make

; 4198 :       stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

  000ab	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR prefilter_x$[rsp]
  000b2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b6	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR out_stride$[rsp]
  000be	44 8b 44 24 78	 mov	 r8d, DWORD PTR out_h$[rsp]
  000c3	8b 54 24 70	 mov	 edx, DWORD PTR out_w$[rsp]
  000c7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR output$[rsp]
  000cc	e8 00 00 00 00	 call	 ?stbtt__h_prefilter@@YAXPEAEHHHI@Z ; stbtt__h_prefilter
$LN2@stbtt_Make:

; 4199 : 
; 4200 :    if (prefilter_y > 1)

  000d1	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR prefilter_y$[rsp], 1
  000d9	7e 26		 jle	 SHORT $LN3@stbtt_Make

; 4201 :       stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

  000db	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR prefilter_y$[rsp]
  000e2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e6	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR out_stride$[rsp]
  000ee	44 8b 44 24 78	 mov	 r8d, DWORD PTR out_h$[rsp]
  000f3	8b 54 24 70	 mov	 edx, DWORD PTR out_w$[rsp]
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR output$[rsp]
  000fc	e8 00 00 00 00	 call	 ?stbtt__v_prefilter@@YAXPEAEHHHI@Z ; stbtt__v_prefilter
$LN3@stbtt_Make:

; 4202 : 
; 4203 :    *sub_x = stbtt__oversample_shift(prefilter_x);

  00101	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR prefilter_x$[rsp]
  00108	e8 00 00 00 00	 call	 ?stbtt__oversample_shift@@YAMH@Z ; stbtt__oversample_shift
  0010d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR sub_x$[rsp]
  00115	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4204 :    *sub_y = stbtt__oversample_shift(prefilter_y);

  00119	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR prefilter_y$[rsp]
  00120	e8 00 00 00 00	 call	 ?stbtt__oversample_shift@@YAMH@Z ; stbtt__oversample_shift
  00125	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sub_y$[rsp]
  0012d	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4205 : }

  00131	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00135	c3		 ret	 0
stbtt_MakeGlyphBitmapSubpixelPrefilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
iy0$ = 96
ix0$ = 100
num_verts$ = 104
vertices$ = 112
gbm$ = 120
info$ = 160
output$ = 168
out_w$ = 176
out_h$ = 184
out_stride$ = 192
scale_x$ = 200
scale_y$ = 208
shift_x$ = 216
shift_y$ = 224
glyph$ = 232
stbtt_MakeGlyphBitmapSubpixel PROC

; 3759 : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3760 :    int ix0,iy0;
; 3761 :    stbtt_vertex *vertices;
; 3762 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

  0001b	4c 8d 44 24 70	 lea	 r8, QWORD PTR vertices$[rsp]
  00020	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  00027	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0002f	e8 00 00 00 00	 call	 stbtt_GetGlyphShape
  00034	89 44 24 68	 mov	 DWORD PTR num_verts$[rsp], eax

; 3763 :    stbtt__bitmap gbm;
; 3764 : 
; 3765 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);

  00038	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00041	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0004a	48 8d 44 24 60	 lea	 rax, QWORD PTR iy0$[rsp]
  0004f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00054	48 8d 44 24 64	 lea	 rax, QWORD PTR ix0$[rsp]
  00059	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0005e	f3 0f 10 84 24
	e0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  00067	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0006d	f3 0f 10 84 24
	d8 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  00076	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0007c	f3 0f 10 9c 24
	d0 00 00 00	 movss	 xmm3, DWORD PTR scale_y$[rsp]
  00085	f3 0f 10 94 24
	c8 00 00 00	 movss	 xmm2, DWORD PTR scale_x$[rsp]
  0008e	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  00095	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0009d	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 3766 :    gbm.pixels = output;

  000a2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR output$[rsp]
  000aa	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR gbm$[rsp+16], rax

; 3767 :    gbm.w = out_w;

  000b2	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR out_w$[rsp]
  000b9	89 44 24 78	 mov	 DWORD PTR gbm$[rsp], eax

; 3768 :    gbm.h = out_h;

  000bd	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR out_h$[rsp]
  000c4	89 44 24 7c	 mov	 DWORD PTR gbm$[rsp+4], eax

; 3769 :    gbm.stride = out_stride;

  000c8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR out_stride$[rsp]
  000cf	89 84 24 80 00
	00 00		 mov	 DWORD PTR gbm$[rsp+8], eax

; 3770 : 
; 3771 :    if (gbm.w && gbm.h)

  000d6	83 7c 24 78 00	 cmp	 DWORD PTR gbm$[rsp], 0
  000db	0f 84 8b 00 00
	00		 je	 $LN2@stbtt_Make
  000e1	83 7c 24 7c 00	 cmp	 DWORD PTR gbm$[rsp+4], 0
  000e6	0f 84 80 00 00
	00		 je	 $LN2@stbtt_Make

; 3772 :       stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

  000ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f7	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  000fc	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR [rsp+80], 1
  00104	8b 44 24 60	 mov	 eax, DWORD PTR iy0$[rsp]
  00108	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0010c	8b 44 24 64	 mov	 eax, DWORD PTR ix0$[rsp]
  00110	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00114	f3 0f 10 84 24
	e0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  0011d	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00123	f3 0f 10 84 24
	d8 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  0012c	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00132	f3 0f 10 84 24
	d0 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0013b	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00141	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  0014a	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00150	44 8b 4c 24 68	 mov	 r9d, DWORD PTR num_verts$[rsp]
  00155	4c 8b 44 24 70	 mov	 r8, QWORD PTR vertices$[rsp]
  0015a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3eb33333
  00162	48 8d 4c 24 78	 lea	 rcx, QWORD PTR gbm$[rsp]
  00167	e8 00 00 00 00	 call	 stbtt_Rasterize
$LN2@stbtt_Make:

; 3773 : 
; 3774 :    STBTT_free(vertices, info->userdata);

  0016c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR vertices$[rsp]
  00171	e8 00 00 00 00	 call	 free

; 3775 : }

  00176	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0017d	c3		 ret	 0
stbtt_MakeGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
output$ = 104
out_w$ = 112
out_h$ = 120
out_stride$ = 128
scale_x$ = 136
scale_y$ = 144
glyph$ = 152
stbtt_MakeGlyphBitmap PROC

; 3778 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3779 :    stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);

  00018	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR glyph$[rsp]
  0001f	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  0002c	0f 57 c0	 xorps	 xmm0, xmm0
  0002f	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00035	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0003e	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00044	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  0004d	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00053	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR out_stride$[rsp]
  0005a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005e	44 8b 4c 24 78	 mov	 r9d, DWORD PTR out_h$[rsp]
  00063	44 8b 44 24 70	 mov	 r8d, DWORD PTR out_w$[rsp]
  00068	48 8b 54 24 68	 mov	 rdx, QWORD PTR output$[rsp]
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00072	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmapSubpixel

; 3780 : }

  00077	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007b	c3		 ret	 0
stbtt_MakeGlyphBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
iy0$ = 96
ix0$ = 100
ix1$ = 104
iy1$ = 108
num_verts$ = 112
vertices$ = 120
gbm$ = 128
info$ = 176
scale_x$ = 184
scale_y$ = 192
shift_x$ = 200
shift_y$ = 208
glyph$ = 216
width$ = 224
height$ = 232
xoff$ = 240
yoff$ = 248
stbtt_GetGlyphBitmapSubpixel PROC

; 3714 : {

$LN12:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 3715 :    int ix0,iy0,ix1,iy1;
; 3716 :    stbtt__bitmap gbm;
; 3717 :    stbtt_vertex *vertices;
; 3718 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

  0001e	4c 8d 44 24 78	 lea	 r8, QWORD PTR vertices$[rsp]
  00023	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  0002a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00032	e8 00 00 00 00	 call	 stbtt_GetGlyphShape
  00037	89 44 24 70	 mov	 DWORD PTR num_verts$[rsp], eax

; 3719 : 
; 3720 :    if (scale_x == 0) scale_x = scale_y;

  0003b	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  00044	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0004b	7a 14		 jp	 SHORT $LN2@stbtt_GetG
  0004d	75 12		 jne	 SHORT $LN2@stbtt_GetG
  0004f	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00058	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR scale_x$[rsp], xmm0
$LN2@stbtt_GetG:

; 3721 :    if (scale_y == 0) {

  00061	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0006a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00071	7a 39		 jp	 SHORT $LN3@stbtt_GetG
  00073	75 37		 jne	 SHORT $LN3@stbtt_GetG

; 3722 :       if (scale_x == 0) {

  00075	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  0007e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00085	7a 13		 jp	 SHORT $LN4@stbtt_GetG
  00087	75 11		 jne	 SHORT $LN4@stbtt_GetG

; 3723 :          STBTT_free(vertices, info->userdata);

  00089	48 8b 4c 24 78	 mov	 rcx, QWORD PTR vertices$[rsp]
  0008e	e8 00 00 00 00	 call	 free

; 3724 :          return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	e9 09 02 00 00	 jmp	 $LN1@stbtt_GetG
$LN4@stbtt_GetG:

; 3725 :       }
; 3726 :       scale_y = scale_x;

  0009a	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  000a3	f3 0f 11 84 24
	c0 00 00 00	 movss	 DWORD PTR scale_y$[rsp], xmm0
$LN3@stbtt_GetG:

; 3727 :    }
; 3728 : 
; 3729 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

  000ac	48 8d 44 24 6c	 lea	 rax, QWORD PTR iy1$[rsp]
  000b1	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000b6	48 8d 44 24 68	 lea	 rax, QWORD PTR ix1$[rsp]
  000bb	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000c0	48 8d 44 24 60	 lea	 rax, QWORD PTR iy0$[rsp]
  000c5	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000ca	48 8d 44 24 64	 lea	 rax, QWORD PTR ix0$[rsp]
  000cf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000d4	f3 0f 10 84 24
	d0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  000dd	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  000e3	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  000ec	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000f2	f3 0f 10 9c 24
	c0 00 00 00	 movss	 xmm3, DWORD PTR scale_y$[rsp]
  000fb	f3 0f 10 94 24
	b8 00 00 00	 movss	 xmm2, DWORD PTR scale_x$[rsp]
  00104	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR glyph$[rsp]
  0010b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00113	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 3730 : 
; 3731 :    // now we get the size
; 3732 :    gbm.w = (ix1 - ix0);

  00118	8b 44 24 64	 mov	 eax, DWORD PTR ix0$[rsp]
  0011c	8b 4c 24 68	 mov	 ecx, DWORD PTR ix1$[rsp]
  00120	2b c8		 sub	 ecx, eax
  00122	8b c1		 mov	 eax, ecx
  00124	89 84 24 80 00
	00 00		 mov	 DWORD PTR gbm$[rsp], eax

; 3733 :    gbm.h = (iy1 - iy0);

  0012b	8b 44 24 60	 mov	 eax, DWORD PTR iy0$[rsp]
  0012f	8b 4c 24 6c	 mov	 ecx, DWORD PTR iy1$[rsp]
  00133	2b c8		 sub	 ecx, eax
  00135	8b c1		 mov	 eax, ecx
  00137	89 84 24 84 00
	00 00		 mov	 DWORD PTR gbm$[rsp+4], eax

; 3734 :    gbm.pixels = NULL; // in case we error

  0013e	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR gbm$[rsp+16], 0

; 3735 : 
; 3736 :    if (width ) *width  = gbm.w;

  0014a	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR width$[rsp], 0
  00153	74 11		 je	 SHORT $LN5@stbtt_GetG
  00155	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR width$[rsp]
  0015d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR gbm$[rsp]
  00164	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbtt_GetG:

; 3737 :    if (height) *height = gbm.h;

  00166	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR height$[rsp], 0
  0016f	74 11		 je	 SHORT $LN6@stbtt_GetG
  00171	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR height$[rsp]
  00179	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR gbm$[rsp+4]
  00180	89 08		 mov	 DWORD PTR [rax], ecx
$LN6@stbtt_GetG:

; 3738 :    if (xoff  ) *xoff   = ix0;

  00182	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR xoff$[rsp], 0
  0018b	74 0e		 je	 SHORT $LN7@stbtt_GetG
  0018d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR xoff$[rsp]
  00195	8b 4c 24 64	 mov	 ecx, DWORD PTR ix0$[rsp]
  00199	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@stbtt_GetG:

; 3739 :    if (yoff  ) *yoff   = iy0;

  0019b	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR yoff$[rsp], 0
  001a4	74 0e		 je	 SHORT $LN8@stbtt_GetG
  001a6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR yoff$[rsp]
  001ae	8b 4c 24 60	 mov	 ecx, DWORD PTR iy0$[rsp]
  001b2	89 08		 mov	 DWORD PTR [rax], ecx
$LN8@stbtt_GetG:

; 3740 : 
; 3741 :    if (gbm.w && gbm.h) {

  001b4	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR gbm$[rsp], 0
  001bc	0f 84 cf 00 00
	00		 je	 $LN9@stbtt_GetG
  001c2	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR gbm$[rsp+4], 0
  001ca	0f 84 c1 00 00
	00		 je	 $LN9@stbtt_GetG

; 3742 :       gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);

  001d0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR gbm$[rsp]
  001d7	0f af 84 24 84
	00 00 00	 imul	 eax, DWORD PTR gbm$[rsp+4]
  001df	48 98		 cdqe
  001e1	48 8b c8	 mov	 rcx, rax
  001e4	e8 00 00 00 00	 call	 malloc
  001e9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR gbm$[rsp+16], rax

; 3743 :       if (gbm.pixels) {

  001f1	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR gbm$[rsp+16], 0
  001fa	0f 84 91 00 00
	00		 je	 $LN10@stbtt_GetG

; 3744 :          gbm.stride = gbm.w;

  00200	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR gbm$[rsp]
  00207	89 84 24 88 00
	00 00		 mov	 DWORD PTR gbm$[rsp+8], eax

; 3745 : 
; 3746 :          stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);

  0020e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00216	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00219	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0021e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR [rsp+80], 1
  00226	8b 44 24 60	 mov	 eax, DWORD PTR iy0$[rsp]
  0022a	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0022e	8b 44 24 64	 mov	 eax, DWORD PTR ix0$[rsp]
  00232	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00236	f3 0f 10 84 24
	d0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  0023f	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00245	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  0024e	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00254	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0025d	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00263	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  0026c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00272	44 8b 4c 24 70	 mov	 r9d, DWORD PTR num_verts$[rsp]
  00277	4c 8b 44 24 78	 mov	 r8, QWORD PTR vertices$[rsp]
  0027c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3eb33333
  00284	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR gbm$[rsp]
  0028c	e8 00 00 00 00	 call	 stbtt_Rasterize
$LN10@stbtt_GetG:
$LN9@stbtt_GetG:

; 3747 :       }
; 3748 :    }
; 3749 :    STBTT_free(vertices, info->userdata);

  00291	48 8b 4c 24 78	 mov	 rcx, QWORD PTR vertices$[rsp]
  00296	e8 00 00 00 00	 call	 free

; 3750 :    return gbm.pixels;

  0029b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR gbm$[rsp+16]
$LN1@stbtt_GetG:

; 3751 : }

  002a3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002aa	c3		 ret	 0
stbtt_GetGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
scale_x$ = 104
scale_y$ = 112
glyph$ = 120
width$ = 128
height$ = 136
xoff$ = 144
yoff$ = 152
stbtt_GetGlyphBitmap PROC

; 3754 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3755 :    return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);

  0001a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR yoff$[rsp]
  00022	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00027	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR xoff$[rsp]
  0002f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00034	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR height$[rsp]
  0003c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00041	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR width$[rsp]
  00049	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004e	8b 44 24 78	 mov	 eax, DWORD PTR glyph$[rsp]
  00052	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0005f	0f 57 db	 xorps	 xmm3, xmm3
  00062	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR scale_y$[rsp]
  00068	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR scale_x$[rsp]
  0006e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00073	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapSubpixel

; 3756 : }

  00078	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007c	c3		 ret	 0
stbtt_GetGlyphBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
font$ = 96
codepoint$ = 104
scale_x$ = 112
scale_y$ = 120
shift_x$ = 128
shift_y$ = 136
ix0$ = 144
iy0$ = 152
ix1$ = 160
iy1$ = 168
stbtt_GetCodepointBitmapBoxSubpixel PROC

; 2745 : {

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2746 :    stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);

  00019	8b 54 24 68	 mov	 edx, DWORD PTR codepoint$[rsp]
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR font$[rsp]
  00022	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00027	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR iy1$[rsp]
  0002f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00034	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR ix1$[rsp]
  0003c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00041	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iy0$[rsp]
  00049	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0004e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ix0$[rsp]
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  00064	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0006a	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  00073	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00079	f3 0f 10 5c 24
	78		 movss	 xmm3, DWORD PTR scale_y$[rsp]
  0007f	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR scale_x$[rsp]
  00085	8b d0		 mov	 edx, eax
  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR font$[rsp]
  0008c	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 2747 : }

  00091	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00095	c3		 ret	 0
stbtt_GetCodepointBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
font$ = 96
codepoint$ = 104
scale_x$ = 112
scale_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetCodepointBitmapBox PROC

; 2750 : {

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2751 :    stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);

  00019	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR iy1$[rsp]
  00021	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00026	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ix1$[rsp]
  0002e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00033	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR iy0$[rsp]
  0003b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00040	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ix0$[rsp]
  00048	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004d	0f 57 c0	 xorps	 xmm0, xmm0
  00050	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0005f	f3 0f 10 5c 24
	78		 movss	 xmm3, DWORD PTR scale_y$[rsp]
  00065	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR scale_x$[rsp]
  0006b	8b 54 24 68	 mov	 edx, DWORD PTR codepoint$[rsp]
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR font$[rsp]
  00074	e8 00 00 00 00	 call	 stbtt_GetCodepointBitmapBoxSubpixel

; 2752 : }

  00079	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007d	c3		 ret	 0
stbtt_GetCodepointBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 128
output$ = 136
out_w$ = 144
out_h$ = 152
out_stride$ = 160
scale_x$ = 168
scale_y$ = 176
shift_x$ = 184
shift_y$ = 192
oversample_x$ = 200
oversample_y$ = 208
sub_x$ = 216
sub_y$ = 224
codepoint$ = 232
stbtt_MakeCodepointBitmapSubpixelPrefilter PROC

; 3788 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3789 :    stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));

  00018	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR codepoint$[rsp]
  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00027	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  0002c	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00030	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR sub_y$[rsp]
  00038	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  0003d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR sub_x$[rsp]
  00045	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0004a	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR oversample_y$[rsp]
  00051	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00055	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR oversample_x$[rsp]
  0005c	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00060	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  00069	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  0006f	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  00078	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  0007e	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00087	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0008d	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  00096	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0009c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR out_stride$[rsp]
  000a3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a7	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR out_h$[rsp]
  000af	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR out_w$[rsp]
  000b7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR output$[rsp]
  000bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000c7	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmapSubpixelPrefilter

; 3790 : }

  000cc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000d0	c3		 ret	 0
stbtt_MakeCodepointBitmapSubpixelPrefilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
output$ = 104
out_w$ = 112
out_h$ = 120
out_stride$ = 128
scale_x$ = 136
scale_y$ = 144
shift_x$ = 152
shift_y$ = 160
codepoint$ = 168
stbtt_MakeCodepointBitmapSubpixel PROC

; 3793 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3794 :    stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));

  00018	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR codepoint$[rsp]
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00024	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00029	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0002d	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  00036	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  0003c	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR shift_x$[rsp]
  00045	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  0004b	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  00054	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0005a	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  00063	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00069	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR out_stride$[rsp]
  00070	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00074	44 8b 4c 24 78	 mov	 r9d, DWORD PTR out_h$[rsp]
  00079	44 8b 44 24 70	 mov	 r8d, DWORD PTR out_w$[rsp]
  0007e	48 8b 54 24 68	 mov	 rdx, QWORD PTR output$[rsp]
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00088	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmapSubpixel

; 3795 : }

  0008d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00091	c3		 ret	 0
stbtt_MakeCodepointBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
output$ = 104
out_w$ = 112
out_h$ = 120
out_stride$ = 128
scale_x$ = 136
scale_y$ = 144
codepoint$ = 152
stbtt_MakeCodepointBitmap PROC

; 3803 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3804 :    stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);

  00018	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR codepoint$[rsp]
  0001f	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  0002c	0f 57 c0	 xorps	 xmm0, xmm0
  0002f	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00035	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR scale_y$[rsp]
  0003e	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00044	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR scale_x$[rsp]
  0004d	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00053	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR out_stride$[rsp]
  0005a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005e	44 8b 4c 24 78	 mov	 r9d, DWORD PTR out_h$[rsp]
  00063	44 8b 44 24 70	 mov	 r8d, DWORD PTR out_w$[rsp]
  00068	48 8b 54 24 68	 mov	 rdx, QWORD PTR output$[rsp]
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00072	e8 00 00 00 00	 call	 stbtt_MakeCodepointBitmapSubpixel

; 3805 : }

  00077	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007b	c3		 ret	 0
stbtt_MakeCodepointBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
scale_x$ = 104
scale_y$ = 112
shift_x$ = 120
shift_y$ = 128
codepoint$ = 136
width$ = 144
height$ = 152
xoff$ = 160
yoff$ = 168
stbtt_GetCodepointBitmapSubpixel PROC

; 3783 : {

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3784 :    return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);

  0001b	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR codepoint$[rsp]
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00027	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  0002c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR yoff$[rsp]
  00034	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00039	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR xoff$[rsp]
  00041	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00046	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR height$[rsp]
  0004e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00053	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR width$[rsp]
  0005b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00060	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00064	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  0006d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00073	f3 0f 10 5c 24
	78		 movss	 xmm3, DWORD PTR shift_x$[rsp]
  00079	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR scale_y$[rsp]
  0007f	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR scale_x$[rsp]
  00085	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  0008a	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapSubpixel

; 3785 : }

  0008f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00093	c3		 ret	 0
stbtt_GetCodepointBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 96
scale_x$ = 104
scale_y$ = 112
codepoint$ = 120
width$ = 128
height$ = 136
xoff$ = 144
yoff$ = 152
stbtt_GetCodepointBitmap PROC

; 3798 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3799 :    return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);

  0001a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR yoff$[rsp]
  00022	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00027	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR xoff$[rsp]
  0002f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00034	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR height$[rsp]
  0003c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00041	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR width$[rsp]
  00049	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004e	8b 44 24 78	 mov	 eax, DWORD PTR codepoint$[rsp]
  00052	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0005f	0f 57 db	 xorps	 xmm3, xmm3
  00062	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR scale_y$[rsp]
  00068	f3 0f 10 4c 24
	68		 movss	 xmm1, DWORD PTR scale_x$[rsp]
  0006e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00073	e8 00 00 00 00	 call	 stbtt_GetCodepointBitmapSubpixel

; 3800 : }

  00078	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007c	c3		 ret	 0
stbtt_GetCodepointBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
bitmap$ = 48
userdata$ = 56
stbtt_FreeBitmap PROC

; 3709 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3710 :    STBTT_free(bitmap, userdata);

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitmap$[rsp]
  00013	e8 00 00 00 00	 call	 free

; 3711 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
stbtt_FreeBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
svg_doc$ = 32
data$ = 40
tv73 = 48
info$ = 80
gl$ = 88
svg$ = 96
stbtt_GetGlyphSVG PROC

; 2695 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2696 :    stbtt_uint8 *data = info->data;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  00017	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001b	48 89 44 24 28	 mov	 QWORD PTR data$[rsp], rax

; 2697 :    stbtt_uint8 *svg_doc;
; 2698 : 
; 2699 :    if (info->svg == 0)

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  00025	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  00029	75 04		 jne	 SHORT $LN2@stbtt_GetG

; 2700 :       return 0;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 6e		 jmp	 SHORT $LN1@stbtt_GetG
$LN2@stbtt_GetG:

; 2701 : 
; 2702 :    svg_doc = stbtt_FindSVGDoc(info, gl);

  0002f	8b 54 24 58	 mov	 edx, DWORD PTR gl$[rsp]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00038	e8 00 00 00 00	 call	 stbtt_FindSVGDoc
  0003d	48 89 44 24 20	 mov	 QWORD PTR svg_doc$[rsp], rax

; 2703 :    if (svg_doc != NULL) {

  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR svg_doc$[rsp], 0
  00048	74 51		 je	 SHORT $LN3@stbtt_GetG

; 2704 :       *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);

  0004a	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  0004f	48 63 40 34	 movsxd	 rax, DWORD PTR [rax+52]
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR data$[rsp]
  00058	48 03 c8	 add	 rcx, rax
  0005b	48 8b c1	 mov	 rax, rcx
  0005e	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR svg_doc$[rsp]
  00068	48 83 c1 04	 add	 rcx, 4
  0006c	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00071	8b c0		 mov	 eax, eax
  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv73[rsp]
  00078	48 03 c8	 add	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR svg$[rsp]
  00083	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2705 :       return ttULONG(svg_doc + 8);

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR svg_doc$[rsp]
  0008b	48 83 c0 08	 add	 rax, 8
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00097	eb 04		 jmp	 SHORT $LN1@stbtt_GetG

; 2706 :    } else {

  00099	eb 02		 jmp	 SHORT $LN4@stbtt_GetG
$LN3@stbtt_GetG:

; 2707 :       return 0;

  0009b	33 c0		 xor	 eax, eax
$LN4@stbtt_GetG:
$LN1@stbtt_GetG:

; 2708 :    }
; 2709 : }

  0009d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a1	c3		 ret	 0
stbtt_GetGlyphSVG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
unicode_codepoint$ = 56
svg$ = 64
stbtt_GetCodepointSVG PROC

; 2712 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2713 :    return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);

  00012	8b 54 24 38	 mov	 edx, DWORD PTR unicode_codepoint$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0001b	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00020	4c 8b 44 24 40	 mov	 r8, QWORD PTR svg$[rsp]
  00025	8b d0		 mov	 edx, eax
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0002c	e8 00 00 00 00	 call	 stbtt_GetGlyphSVG

; 2714 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
stbtt_GetCodepointSVG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 32
numEntries$ = 36
svg_doc$1 = 40
svg_doc_list$ = 48
data$ = 56
svg_docs$ = 64
info$ = 96
gl$ = 104
stbtt_FindSVGDoc PROC

; 2678 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2679 :    int i;
; 2680 :    stbtt_uint8 *data = info->data;

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00012	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00016	48 89 44 24 38	 mov	 QWORD PTR data$[rsp], rax

; 2681 :    stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);

  0001b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR info$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbtt__get_svg@@YAHPEAUstbtt_fontinfo@@@Z ; stbtt__get_svg
  00025	48 98		 cdqe
  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0002c	48 03 c8	 add	 rcx, rax
  0002f	48 8b c1	 mov	 rax, rcx
  00032	48 89 44 24 30	 mov	 QWORD PTR svg_doc_list$[rsp], rax

; 2682 : 
; 2683 :    int numEntries = ttUSHORT(svg_doc_list);

  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR svg_doc_list$[rsp]
  0003c	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00041	0f b7 c0	 movzx	 eax, ax
  00044	89 44 24 24	 mov	 DWORD PTR numEntries$[rsp], eax

; 2684 :    stbtt_uint8 *svg_docs = svg_doc_list + 2;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR svg_doc_list$[rsp]
  0004d	48 83 c0 02	 add	 rax, 2
  00051	48 89 44 24 40	 mov	 QWORD PTR svg_docs$[rsp], rax

; 2685 : 
; 2686 :    for(i=0; i<numEntries; i++) {

  00056	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0005e	eb 0a		 jmp	 SHORT $LN4@stbtt_Find
$LN2@stbtt_Find:
  00060	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00064	ff c0		 inc	 eax
  00066	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Find:
  0006a	8b 44 24 24	 mov	 eax, DWORD PTR numEntries$[rsp]
  0006e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00072	7d 4d		 jge	 SHORT $LN3@stbtt_Find

; 2687 :       stbtt_uint8 *svg_doc = svg_docs + (12 * i);

  00074	6b 44 24 20 0c	 imul	 eax, DWORD PTR i$[rsp], 12
  00079	48 98		 cdqe
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR svg_docs$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 28	 mov	 QWORD PTR svg_doc$1[rsp], rax

; 2688 :       if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))

  0008b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR svg_doc$1[rsp]
  00090	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00095	0f b7 c0	 movzx	 eax, ax
  00098	39 44 24 68	 cmp	 DWORD PTR gl$[rsp], eax
  0009c	7c 21		 jl	 SHORT $LN5@stbtt_Find
  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR svg_doc$1[rsp]
  000a3	48 83 c0 02	 add	 rax, 2
  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000af	0f b7 c0	 movzx	 eax, ax
  000b2	39 44 24 68	 cmp	 DWORD PTR gl$[rsp], eax
  000b6	7f 07		 jg	 SHORT $LN5@stbtt_Find

; 2689 :          return svg_doc;

  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR svg_doc$1[rsp]
  000bd	eb 04		 jmp	 SHORT $LN1@stbtt_Find
$LN5@stbtt_Find:

; 2690 :    }

  000bf	eb 9f		 jmp	 SHORT $LN2@stbtt_Find
$LN3@stbtt_Find:

; 2691 :    return 0;

  000c1	33 c0		 xor	 eax, eax
$LN1@stbtt_Find:

; 2692 : }

  000c3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c7	c3		 ret	 0
stbtt_FindSVGDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
v$ = 56
stbtt_FreeShape PROC

; 2673 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2674 :    STBTT_free(v, info->userdata);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  00013	e8 00 00 00 00	 call	 free

; 2675 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
stbtt_FreeShape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
glyph_index$ = 56
pvertices$ = 64
stbtt_GetGlyphShape PROC

; 2298 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2299 :    if (!info->cff.size)

  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00017	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  0001b	75 17		 jne	 SHORT $LN2@stbtt_GetG

; 2300 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR pvertices$[rsp]
  00022	8b 54 24 38	 mov	 edx, DWORD PTR glyph_index$[rsp]
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0002b	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
  00030	eb 15		 jmp	 SHORT $LN1@stbtt_GetG
  00032	eb 13		 jmp	 SHORT $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2301 :    else
; 2302 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

  00034	4c 8b 44 24 40	 mov	 r8, QWORD PTR pvertices$[rsp]
  00039	8b 54 24 38	 mov	 edx, DWORD PTR glyph_index$[rsp]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeT2
$LN3@stbtt_GetG:
$LN1@stbtt_GetG:

; 2303 : }

  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
stbtt_GetGlyphShape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
unicode_codepoint$ = 56
vertices$ = 64
stbtt_GetCodepointShape PROC

; 1590 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1591 :    return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);

  00012	8b 54 24 38	 mov	 edx, DWORD PTR unicode_codepoint$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0001b	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00020	4c 8b 44 24 40	 mov	 r8, QWORD PTR vertices$[rsp]
  00025	8b d0		 mov	 edx, eax
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0002c	e8 00 00 00 00	 call	 stbtt_GetGlyphShape

; 1592 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
stbtt_GetCodepointShape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
numberOfContours$ = 48
tv75 = 52
g$ = 56
tv87 = 60
info$ = 80
glyph_index$ = 88
stbtt_IsGlyphEmpty PROC

; 1647 : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1648 :    stbtt_int16 numberOfContours;
; 1649 :    int g;
; 1650 :    if (info->cff.size)

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  00012	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00016	74 42		 je	 SHORT $LN2@stbtt_IsGl

; 1651 :       return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;

  00018	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00021	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002a	45 33 c9	 xor	 r9d, r9d
  0002d	45 33 c0	 xor	 r8d, r8d
  00030	8b 54 24 58	 mov	 edx, DWORD PTR glyph_index$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ; stbtt__GetGlyphInfoT2
  0003e	85 c0		 test	 eax, eax
  00040	75 0a		 jne	 SHORT $LN5@stbtt_IsGl
  00042	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0004a	eb 08		 jmp	 SHORT $LN6@stbtt_IsGl
$LN5@stbtt_IsGl:
  0004c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN6@stbtt_IsGl:
  00054	8b 44 24 34	 mov	 eax, DWORD PTR tv75[rsp]
  00058	eb 5a		 jmp	 SHORT $LN1@stbtt_IsGl
$LN2@stbtt_IsGl:

; 1652 :    g = stbtt__GetGlyfOffset(info, glyph_index);

  0005a	8b 54 24 58	 mov	 edx, DWORD PTR glyph_index$[rsp]
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
  00068	89 44 24 38	 mov	 DWORD PTR g$[rsp], eax

; 1653 :    if (g < 0) return 1;

  0006c	83 7c 24 38 00	 cmp	 DWORD PTR g$[rsp], 0
  00071	7d 07		 jge	 SHORT $LN3@stbtt_IsGl
  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	eb 3a		 jmp	 SHORT $LN1@stbtt_IsGl
$LN3@stbtt_IsGl:

; 1654 :    numberOfContours = ttSHORT(info->data + g);

  0007a	48 63 44 24 38	 movsxd	 rax, DWORD PTR g$[rsp]
  0007f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00084	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00090	66 89 44 24 30	 mov	 WORD PTR numberOfContours$[rsp], ax

; 1655 :    return numberOfContours == 0;

  00095	0f bf 44 24 30	 movsx	 eax, WORD PTR numberOfContours$[rsp]
  0009a	85 c0		 test	 eax, eax
  0009c	75 0a		 jne	 SHORT $LN7@stbtt_IsGl
  0009e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  000a6	eb 08		 jmp	 SHORT $LN8@stbtt_IsGl
$LN7@stbtt_IsGl:
  000a8	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN8@stbtt_IsGl:
  000b0	8b 44 24 3c	 mov	 eax, DWORD PTR tv87[rsp]
$LN1@stbtt_IsGl:

; 1656 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
stbtt_IsGlyphEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
k$ = 32
length$ = 36
data$ = 40
info$ = 64
table$ = 72
table_length$ = 80
stbtt_GetKerningTable PROC

; 2333 : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2334 :    stbtt_uint8 *data = info->data + info->kern;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00018	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00021	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00025	48 89 44 24 28	 mov	 QWORD PTR data$[rsp], rax

; 2335 :    int k, length;
; 2336 : 
; 2337 :    // we only look at the first table. it must be 'horizontal' and format 0.
; 2338 :    if (!info->kern)

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0002f	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00033	75 07		 jne	 SHORT $LN5@stbtt_GetK

; 2339 :       return 0;

  00035	33 c0		 xor	 eax, eax
  00037	e9 1c 01 00 00	 jmp	 $LN1@stbtt_GetK
$LN5@stbtt_GetK:

; 2340 :    if (ttUSHORT(data+2) < 1) // number of tables, need at least 1

  0003c	48 8b 44 24 28	 mov	 rax, QWORD PTR data$[rsp]
  00041	48 83 c0 02	 add	 rax, 2
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0004d	0f b7 c0	 movzx	 eax, ax
  00050	83 f8 01	 cmp	 eax, 1
  00053	7d 07		 jge	 SHORT $LN6@stbtt_GetK

; 2341 :       return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 fc 00 00 00	 jmp	 $LN1@stbtt_GetK
$LN6@stbtt_GetK:

; 2342 :    if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR data$[rsp]
  00061	48 83 c0 08	 add	 rax, 8
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0006d	0f b7 c0	 movzx	 eax, ax
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 07		 je	 SHORT $LN7@stbtt_GetK

; 2343 :       return 0;

  00075	33 c0		 xor	 eax, eax
  00077	e9 dc 00 00 00	 jmp	 $LN1@stbtt_GetK
$LN7@stbtt_GetK:

; 2344 : 
; 2345 :    length = ttUSHORT(data+10);

  0007c	48 8b 44 24 28	 mov	 rax, QWORD PTR data$[rsp]
  00081	48 83 c0 0a	 add	 rax, 10
  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0008d	0f b7 c0	 movzx	 eax, ax
  00090	89 44 24 24	 mov	 DWORD PTR length$[rsp], eax

; 2346 :    if (table_length < length)

  00094	8b 44 24 24	 mov	 eax, DWORD PTR length$[rsp]
  00098	39 44 24 50	 cmp	 DWORD PTR table_length$[rsp], eax
  0009c	7d 08		 jge	 SHORT $LN8@stbtt_GetK

; 2347 :       length = table_length;

  0009e	8b 44 24 50	 mov	 eax, DWORD PTR table_length$[rsp]
  000a2	89 44 24 24	 mov	 DWORD PTR length$[rsp], eax
$LN8@stbtt_GetK:

; 2348 : 
; 2349 :    for (k = 0; k < length; k++)

  000a6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000ae	eb 0a		 jmp	 SHORT $LN4@stbtt_GetK
$LN2@stbtt_GetK:
  000b0	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  000b4	ff c0		 inc	 eax
  000b6	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbtt_GetK:
  000ba	8b 44 24 24	 mov	 eax, DWORD PTR length$[rsp]
  000be	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  000c2	0f 8d 8c 00 00
	00		 jge	 $LN3@stbtt_GetK

; 2350 :    {
; 2351 :       table[k].glyph1 = ttUSHORT(data+18+(k*6));

  000c8	6b 44 24 20 06	 imul	 eax, DWORD PTR k$[rsp], 6
  000cd	48 98		 cdqe
  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR data$[rsp]
  000d4	48 8d 44 01 12	 lea	 rax, QWORD PTR [rcx+rax+18]
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000e1	0f b7 c0	 movzx	 eax, ax
  000e4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  000e9	48 6b c9 0c	 imul	 rcx, rcx, 12
  000ed	48 8b 54 24 48	 mov	 rdx, QWORD PTR table$[rsp]
  000f2	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2352 :       table[k].glyph2 = ttUSHORT(data+20+(k*6));

  000f5	6b 44 24 20 06	 imul	 eax, DWORD PTR k$[rsp], 6
  000fa	48 98		 cdqe
  000fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR data$[rsp]
  00101	48 8d 44 01 14	 lea	 rax, QWORD PTR [rcx+rax+20]
  00106	48 8b c8	 mov	 rcx, rax
  00109	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0010e	0f b7 c0	 movzx	 eax, ax
  00111	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00116	48 6b c9 0c	 imul	 rcx, rcx, 12
  0011a	48 8b 54 24 48	 mov	 rdx, QWORD PTR table$[rsp]
  0011f	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 2353 :       table[k].advance = ttSHORT(data+22+(k*6));

  00123	6b 44 24 20 06	 imul	 eax, DWORD PTR k$[rsp], 6
  00128	48 98		 cdqe
  0012a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR data$[rsp]
  0012f	48 8d 44 01 16	 lea	 rax, QWORD PTR [rcx+rax+22]
  00134	48 8b c8	 mov	 rcx, rax
  00137	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0013c	98		 cwde
  0013d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00142	48 6b c9 0c	 imul	 rcx, rcx, 12
  00146	48 8b 54 24 48	 mov	 rdx, QWORD PTR table$[rsp]
  0014b	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax

; 2354 :    }

  0014f	e9 5c ff ff ff	 jmp	 $LN2@stbtt_GetK
$LN3@stbtt_GetK:

; 2355 : 
; 2356 :    return length;

  00154	8b 44 24 24	 mov	 eax, DWORD PTR length$[rsp]
$LN1@stbtt_GetK:

; 2357 : }

  00158	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015c	c3		 ret	 0
stbtt_GetKerningTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
data$ = 32
info$ = 64
stbtt_GetKerningTableLength PROC

; 2318 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2319 :    stbtt_uint8 *data = info->data + info->kern;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0000e	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00017	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0001b	48 89 44 24 20	 mov	 QWORD PTR data$[rsp], rax

; 2320 : 
; 2321 :    // we only look at the first table. it must be 'horizontal' and format 0.
; 2322 :    if (!info->kern)

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00025	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00029	75 04		 jne	 SHORT $LN2@stbtt_GetK

; 2323 :       return 0;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 4e		 jmp	 SHORT $LN1@stbtt_GetK
$LN2@stbtt_GetK:

; 2324 :    if (ttUSHORT(data+2) < 1) // number of tables, need at least 1

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00034	48 83 c0 02	 add	 rax, 2
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00040	0f b7 c0	 movzx	 eax, ax
  00043	83 f8 01	 cmp	 eax, 1
  00046	7d 04		 jge	 SHORT $LN3@stbtt_GetK

; 2325 :       return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 31		 jmp	 SHORT $LN1@stbtt_GetK
$LN3@stbtt_GetK:

; 2326 :    if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  00051	48 83 c0 08	 add	 rax, 8
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0005d	0f b7 c0	 movzx	 eax, ax
  00060	83 f8 01	 cmp	 eax, 1
  00063	74 04		 je	 SHORT $LN4@stbtt_GetK

; 2327 :       return 0;

  00065	33 c0		 xor	 eax, eax
  00067	eb 14		 jmp	 SHORT $LN1@stbtt_GetK
$LN4@stbtt_GetK:

; 2328 : 
; 2329 :    return ttUSHORT(data+10);

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR data$[rsp]
  0006e	48 83 c0 0a	 add	 rax, 10
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0007a	0f b7 c0	 movzx	 eax, ax
$LN1@stbtt_GetK:

; 2330 : }

  0007d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00081	c3		 ret	 0
stbtt_GetKerningTableLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
g$1 = 48
info$ = 80
glyph_index$ = 88
x0$ = 96
y0$ = 104
x1$ = 112
y1$ = 120
stbtt_GetGlyphBox PROC

; 1626 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1627 :    if (info->cff.size) {

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  0001c	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00020	74 31		 je	 SHORT $LN2@stbtt_GetG

; 1628 :       stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);

  00022	48 8b 44 24 78	 mov	 rax, QWORD PTR y1$[rsp]
  00027	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR x1$[rsp]
  00031	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00036	4c 8b 4c 24 68	 mov	 r9, QWORD PTR y0$[rsp]
  0003b	4c 8b 44 24 60	 mov	 r8, QWORD PTR x0$[rsp]
  00040	8b 54 24 58	 mov	 edx, DWORD PTR glyph_index$[rsp]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00049	e8 00 00 00 00	 call	 ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ; stbtt__GetGlyphInfoT2

; 1629 :    } else {

  0004e	e9 cc 00 00 00	 jmp	 $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 1630 :       int g = stbtt__GetGlyfOffset(info, glyph_index);

  00053	8b 54 24 58	 mov	 edx, DWORD PTR glyph_index$[rsp]
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  0005c	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
  00061	89 44 24 30	 mov	 DWORD PTR g$1[rsp], eax

; 1631 :       if (g < 0) return 0;

  00065	83 7c 24 30 00	 cmp	 DWORD PTR g$1[rsp], 0
  0006a	7d 07		 jge	 SHORT $LN4@stbtt_GetG
  0006c	33 c0		 xor	 eax, eax
  0006e	e9 b1 00 00 00	 jmp	 $LN1@stbtt_GetG
$LN4@stbtt_GetG:

; 1632 : 
; 1633 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

  00073	48 83 7c 24 60
	00		 cmp	 QWORD PTR x0$[rsp], 0
  00079	74 23		 je	 SHORT $LN5@stbtt_GetG
  0007b	48 63 44 24 30	 movsxd	 rax, DWORD PTR g$1[rsp]
  00080	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00085	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00089	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00096	98		 cwde
  00097	48 8b 4c 24 60	 mov	 rcx, QWORD PTR x0$[rsp]
  0009c	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbtt_GetG:

; 1634 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

  0009e	48 83 7c 24 68
	00		 cmp	 QWORD PTR y0$[rsp], 0
  000a4	74 23		 je	 SHORT $LN6@stbtt_GetG
  000a6	48 63 44 24 30	 movsxd	 rax, DWORD PTR g$1[rsp]
  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  000b0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b4	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  000c1	98		 cwde
  000c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR y0$[rsp]
  000c7	89 01		 mov	 DWORD PTR [rcx], eax
$LN6@stbtt_GetG:

; 1635 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

  000c9	48 83 7c 24 70
	00		 cmp	 QWORD PTR x1$[rsp], 0
  000cf	74 23		 je	 SHORT $LN7@stbtt_GetG
  000d1	48 63 44 24 30	 movsxd	 rax, DWORD PTR g$1[rsp]
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  000db	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000df	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  000e4	48 8b c8	 mov	 rcx, rax
  000e7	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  000ec	98		 cwde
  000ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR x1$[rsp]
  000f2	89 01		 mov	 DWORD PTR [rcx], eax
$LN7@stbtt_GetG:

; 1636 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

  000f4	48 83 7c 24 78
	00		 cmp	 QWORD PTR y1$[rsp], 0
  000fa	74 23		 je	 SHORT $LN8@stbtt_GetG
  000fc	48 63 44 24 30	 movsxd	 rax, DWORD PTR g$1[rsp]
  00101	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00106	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0010a	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00117	98		 cwde
  00118	48 8b 4c 24 78	 mov	 rcx, QWORD PTR y1$[rsp]
  0011d	89 01		 mov	 DWORD PTR [rcx], eax
$LN8@stbtt_GetG:
$LN3@stbtt_GetG:

; 1637 :    }
; 1638 :    return 1;

  0011f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_GetG:

; 1639 : }

  00124	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00128	c3		 ret	 0
stbtt_GetGlyphBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
xAdvance$ = 32
info$ = 64
g1$ = 72
g2$ = 80
stbtt_GetGlyphKernAdvance PROC

; 2611 : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2612 :    int xAdvance = 0;

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR xAdvance$[rsp], 0

; 2613 : 
; 2614 :    if (info->gpos)

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0001f	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00023	74 21		 je	 SHORT $LN2@stbtt_GetG

; 2615 :       xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);

  00025	44 8b 44 24 50	 mov	 r8d, DWORD PTR g2$[rsp]
  0002a	8b 54 24 48	 mov	 edx, DWORD PTR g1$[rsp]
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00033	e8 00 00 00 00	 call	 ?stbtt__GetGlyphGPOSInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z ; stbtt__GetGlyphGPOSInfoAdvance
  00038	8b 4c 24 20	 mov	 ecx, DWORD PTR xAdvance$[rsp]
  0003c	03 c8		 add	 ecx, eax
  0003e	8b c1		 mov	 eax, ecx
  00040	89 44 24 20	 mov	 DWORD PTR xAdvance$[rsp], eax
  00044	eb 2a		 jmp	 SHORT $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2616 :    else if (info->kern)

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0004b	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0004f	74 1f		 je	 SHORT $LN4@stbtt_GetG

; 2617 :       xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

  00051	44 8b 44 24 50	 mov	 r8d, DWORD PTR g2$[rsp]
  00056	8b 54 24 48	 mov	 edx, DWORD PTR g1$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0005f	e8 00 00 00 00	 call	 ?stbtt__GetGlyphKernInfoAdvance@@YAHPEBUstbtt_fontinfo@@HH@Z ; stbtt__GetGlyphKernInfoAdvance
  00064	8b 4c 24 20	 mov	 ecx, DWORD PTR xAdvance$[rsp]
  00068	03 c8		 add	 ecx, eax
  0006a	8b c1		 mov	 eax, ecx
  0006c	89 44 24 20	 mov	 DWORD PTR xAdvance$[rsp], eax
$LN4@stbtt_GetG:
$LN3@stbtt_GetG:

; 2618 : 
; 2619 :    return xAdvance;

  00070	8b 44 24 20	 mov	 eax, DWORD PTR xAdvance$[rsp]

; 2620 : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
stbtt_GetGlyphKernAdvance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
numOfLongHorMetrics$ = 32
info$ = 64
glyph_index$ = 72
advanceWidth$ = 80
leftSideBearing$ = 88
stbtt_GetGlyphHMetrics PROC

; 2306 : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2307 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0001c	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00020	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00025	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00029	48 8d 44 01 22	 lea	 rax, QWORD PTR [rcx+rax+34]
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00036	66 89 44 24 20	 mov	 WORD PTR numOfLongHorMetrics$[rsp], ax

; 2308 :    if (glyph_index < numOfLongHorMetrics) {

  0003b	0f b7 44 24 20	 movzx	 eax, WORD PTR numOfLongHorMetrics$[rsp]
  00040	39 44 24 48	 cmp	 DWORD PTR glyph_index$[rsp], eax
  00044	0f 8d 81 00 00
	00		 jge	 $LN2@stbtt_GetG

; 2309 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

  0004a	48 83 7c 24 50
	00		 cmp	 QWORD PTR advanceWidth$[rsp], 0
  00050	74 35		 je	 SHORT $LN4@stbtt_GetG
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00057	48 63 40 28	 movsxd	 rax, DWORD PTR [rax+40]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00060	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00064	48 03 c8	 add	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx
  0006a	8b 4c 24 48	 mov	 ecx, DWORD PTR glyph_index$[rsp]
  0006e	c1 e1 02	 shl	 ecx, 2
  00071	48 63 c9	 movsxd	 rcx, ecx
  00074	48 03 c1	 add	 rax, rcx
  00077	48 8b c8	 mov	 rcx, rax
  0007a	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0007f	98		 cwde
  00080	48 8b 4c 24 50	 mov	 rcx, QWORD PTR advanceWidth$[rsp]
  00085	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbtt_GetG:

; 2310 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);

  00087	48 83 7c 24 58
	00		 cmp	 QWORD PTR leftSideBearing$[rsp], 0
  0008d	74 37		 je	 SHORT $LN5@stbtt_GetG
  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00094	48 63 40 28	 movsxd	 rax, DWORD PTR [rax+40]
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0009d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a1	48 03 c8	 add	 rcx, rax
  000a4	48 8b c1	 mov	 rax, rcx
  000a7	8b 4c 24 48	 mov	 ecx, DWORD PTR glyph_index$[rsp]
  000ab	c1 e1 02	 shl	 ecx, 2
  000ae	48 63 c9	 movsxd	 rcx, ecx
  000b1	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  000be	98		 cwde
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR leftSideBearing$[rsp]
  000c4	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbtt_GetG:

; 2311 :    } else {

  000c6	e9 95 00 00 00	 jmp	 $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 2312 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

  000cb	48 83 7c 24 50
	00		 cmp	 QWORD PTR advanceWidth$[rsp], 0
  000d1	74 3a		 je	 SHORT $LN6@stbtt_GetG
  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  000d8	48 63 40 28	 movsxd	 rax, DWORD PTR [rax+40]
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000e1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000e5	48 03 c8	 add	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	0f b7 4c 24 20	 movzx	 ecx, WORD PTR numOfLongHorMetrics$[rsp]
  000f0	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [rcx*4-4]
  000f7	48 63 c9	 movsxd	 rcx, ecx
  000fa	48 03 c1	 add	 rax, rcx
  000fd	48 8b c8	 mov	 rcx, rax
  00100	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00105	98		 cwde
  00106	48 8b 4c 24 50	 mov	 rcx, QWORD PTR advanceWidth$[rsp]
  0010b	89 01		 mov	 DWORD PTR [rcx], eax
$LN6@stbtt_GetG:

; 2313 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));

  0010d	48 83 7c 24 58
	00		 cmp	 QWORD PTR leftSideBearing$[rsp], 0
  00113	74 4b		 je	 SHORT $LN7@stbtt_GetG
  00115	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0011a	48 63 40 28	 movsxd	 rax, DWORD PTR [rax+40]
  0011e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00123	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00127	48 03 c8	 add	 rcx, rax
  0012a	48 8b c1	 mov	 rax, rcx
  0012d	0f b7 4c 24 20	 movzx	 ecx, WORD PTR numOfLongHorMetrics$[rsp]
  00132	c1 e1 02	 shl	 ecx, 2
  00135	48 63 c9	 movsxd	 rcx, ecx
  00138	48 03 c1	 add	 rax, rcx
  0013b	0f b7 4c 24 20	 movzx	 ecx, WORD PTR numOfLongHorMetrics$[rsp]
  00140	8b 54 24 48	 mov	 edx, DWORD PTR glyph_index$[rsp]
  00144	2b d1		 sub	 edx, ecx
  00146	8b ca		 mov	 ecx, edx
  00148	d1 e1		 shl	 ecx, 1
  0014a	48 63 c9	 movsxd	 rcx, ecx
  0014d	48 03 c1	 add	 rax, rcx
  00150	48 8b c8	 mov	 rcx, rax
  00153	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00158	98		 cwde
  00159	48 8b 4c 24 58	 mov	 rcx, QWORD PTR leftSideBearing$[rsp]
  0015e	89 01		 mov	 DWORD PTR [rcx], eax
$LN7@stbtt_GetG:
$LN3@stbtt_GetG:

; 2314 :    }
; 2315 : }

  00160	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00164	c3		 ret	 0
stbtt_GetGlyphHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 64
codepoint$ = 72
x0$ = 80
y0$ = 88
x1$ = 96
y1$ = 104
stbtt_GetCodepointBox PROC

; 1642 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1643 :    return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);

  00017	8b 54 24 48	 mov	 edx, DWORD PTR codepoint$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00020	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00025	48 8b 4c 24 68	 mov	 rcx, QWORD PTR y1$[rsp]
  0002a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR x1$[rsp]
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	4c 8b 4c 24 58	 mov	 r9, QWORD PTR y0$[rsp]
  0003e	4c 8b 44 24 50	 mov	 r8, QWORD PTR x0$[rsp]
  00043	8b d0		 mov	 edx, eax
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0004a	e8 00 00 00 00	 call	 stbtt_GetGlyphBox

; 1644 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
stbtt_GetCodepointBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv69 = 32
info$ = 64
ch1$ = 72
ch2$ = 80
stbtt_GetCodepointKernAdvance PROC

; 2623 : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2624 :    if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00017	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0001b	75 0f		 jne	 SHORT $LN2@stbtt_GetC
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00022	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00026	75 04		 jne	 SHORT $LN2@stbtt_GetC

; 2625 :       return 0;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 33		 jmp	 SHORT $LN1@stbtt_GetC
$LN2@stbtt_GetC:

; 2626 :    return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));

  0002c	8b 54 24 50	 mov	 edx, DWORD PTR ch2$[rsp]
  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00035	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  0003a	89 44 24 20	 mov	 DWORD PTR tv69[rsp], eax
  0003e	8b 54 24 48	 mov	 edx, DWORD PTR ch1$[rsp]
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00047	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  0004c	8b 4c 24 20	 mov	 ecx, DWORD PTR tv69[rsp]
  00050	44 8b c1	 mov	 r8d, ecx
  00053	8b d0		 mov	 edx, eax
  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0005a	e8 00 00 00 00	 call	 stbtt_GetGlyphKernAdvance
$LN1@stbtt_GetC:

; 2627 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
stbtt_GetCodepointKernAdvance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
codepoint$ = 56
advanceWidth$ = 64
leftSideBearing$ = 72
stbtt_GetCodepointHMetrics PROC

; 2630 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2631 :    stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);

  00017	8b 54 24 38	 mov	 edx, DWORD PTR codepoint$[rsp]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00020	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00025	4c 8b 4c 24 48	 mov	 r9, QWORD PTR leftSideBearing$[rsp]
  0002a	4c 8b 44 24 40	 mov	 r8, QWORD PTR advanceWidth$[rsp]
  0002f	8b d0		 mov	 edx, eax
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00036	e8 00 00 00 00	 call	 stbtt_GetGlyphHMetrics

; 2632 : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
stbtt_GetCodepointHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
x0$ = 56
y0$ = 64
x1$ = 72
y1$ = 80
stbtt_GetFontBoundingBox PROC

; 2653 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2654 :    *x0 = ttSHORT(info->data + info->head + 36);

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  0001d	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00026	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002a	48 8d 44 01 24	 lea	 rax, QWORD PTR [rcx+rax+36]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00037	98		 cwde
  00038	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x0$[rsp]
  0003d	89 01		 mov	 DWORD PTR [rcx], eax

; 2655 :    *y0 = ttSHORT(info->data + info->head + 38);

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00044	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0004d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00051	48 8d 44 01 26	 lea	 rax, QWORD PTR [rcx+rax+38]
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0005e	98		 cwde
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR y0$[rsp]
  00064	89 01		 mov	 DWORD PTR [rcx], eax

; 2656 :    *x1 = ttSHORT(info->data + info->head + 40);

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  0006b	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00074	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00078	48 8d 44 01 28	 lea	 rax, QWORD PTR [rcx+rax+40]
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00085	98		 cwde
  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x1$[rsp]
  0008b	89 01		 mov	 DWORD PTR [rcx], eax

; 2657 :    *y1 = ttSHORT(info->data + info->head + 42);

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00092	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0009b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0009f	48 8d 44 01 2a	 lea	 rax, QWORD PTR [rcx+rax+42]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  000ac	98		 cwde
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y1$[rsp]
  000b2	89 01		 mov	 DWORD PTR [rcx], eax

; 2658 : }

  000b4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b8	c3		 ret	 0
stbtt_GetFontBoundingBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tab$ = 32
info$ = 64
typoAscent$ = 72
typoDescent$ = 80
typoLineGap$ = 88
stbtt_GetFontVMetricsOS2 PROC

; 2642 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2643 :    int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");

  00018	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG42392
  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00024	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  0002c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00030	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  00035	89 44 24 20	 mov	 DWORD PTR tab$[rsp], eax

; 2644 :    if (!tab)

  00039	83 7c 24 20 00	 cmp	 DWORD PTR tab$[rsp], 0
  0003e	75 07		 jne	 SHORT $LN2@stbtt_GetF

; 2645 :       return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 86 00 00 00	 jmp	 $LN1@stbtt_GetF
$LN2@stbtt_GetF:

; 2646 :    if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);

  00047	48 83 7c 24 48
	00		 cmp	 QWORD PTR typoAscent$[rsp], 0
  0004d	74 23		 je	 SHORT $LN3@stbtt_GetF
  0004f	48 63 44 24 20	 movsxd	 rax, DWORD PTR tab$[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00059	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005d	48 8d 44 01 44	 lea	 rax, QWORD PTR [rcx+rax+68]
  00062	48 8b c8	 mov	 rcx, rax
  00065	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0006a	98		 cwde
  0006b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR typoAscent$[rsp]
  00070	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbtt_GetF:

; 2647 :    if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);

  00072	48 83 7c 24 50
	00		 cmp	 QWORD PTR typoDescent$[rsp], 0
  00078	74 23		 je	 SHORT $LN4@stbtt_GetF
  0007a	48 63 44 24 20	 movsxd	 rax, DWORD PTR tab$[rsp]
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00084	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00088	48 8d 44 01 46	 lea	 rax, QWORD PTR [rcx+rax+70]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00095	98		 cwde
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR typoDescent$[rsp]
  0009b	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbtt_GetF:

; 2648 :    if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);

  0009d	48 83 7c 24 58
	00		 cmp	 QWORD PTR typoLineGap$[rsp], 0
  000a3	74 23		 je	 SHORT $LN5@stbtt_GetF
  000a5	48 63 44 24 20	 movsxd	 rax, DWORD PTR tab$[rsp]
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  000af	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b3	48 8d 44 01 48	 lea	 rax, QWORD PTR [rcx+rax+72]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  000c0	98		 cwde
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR typoLineGap$[rsp]
  000c6	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbtt_GetF:

; 2649 :    return 1;

  000c8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_GetF:

; 2650 : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
stbtt_GetFontVMetricsOS2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
ascent$ = 56
descent$ = 64
lineGap$ = 72
stbtt_GetFontVMetrics PROC

; 2635 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2636 :    if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);

  00018	48 83 7c 24 38
	00		 cmp	 QWORD PTR ascent$[rsp], 0
  0001e	74 27		 je	 SHORT $LN2@stbtt_GetF
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00025	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0002e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00032	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0003f	98		 cwde
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ascent$[rsp]
  00045	89 01		 mov	 DWORD PTR [rcx], eax
$LN2@stbtt_GetF:

; 2637 :    if (descent) *descent = ttSHORT(info->data+info->hhea + 6);

  00047	48 83 7c 24 40
	00		 cmp	 QWORD PTR descent$[rsp], 0
  0004d	74 27		 je	 SHORT $LN3@stbtt_GetF
  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00054	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0005d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00061	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0006e	98		 cwde
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR descent$[rsp]
  00074	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbtt_GetF:

; 2638 :    if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);

  00076	48 83 7c 24 48
	00		 cmp	 QWORD PTR lineGap$[rsp], 0
  0007c	74 27		 je	 SHORT $LN4@stbtt_GetF
  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR info$[rsp]
  00083	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  0008c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00090	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0009d	98		 cwde
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lineGap$[rsp]
  000a3	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbtt_GetF:

; 2639 : }

  000a5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a9	c3		 ret	 0
stbtt_GetFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
unitsPerEm$ = 32
info$ = 64
pixels$ = 72
stbtt_ScaleForMappingEmToPixels PROC

; 2667 : {

$LN3:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2668 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00014	48 63 40 1c	 movsxd	 rax, DWORD PTR [rax+28]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0001d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00021	48 8d 44 01 12	 lea	 rax, QWORD PTR [rcx+rax+18]
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0002e	0f b7 c0	 movzx	 eax, ax
  00031	89 44 24 20	 mov	 DWORD PTR unitsPerEm$[rsp], eax

; 2669 :    return pixels / unitsPerEm;

  00035	f3 0f 2a 44 24
	20		 cvtsi2ss xmm0, DWORD PTR unitsPerEm$[rsp]
  0003b	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR pixels$[rsp]
  00041	f3 0f 5e c8	 divss	 xmm1, xmm0
  00045	0f 28 c1	 movaps	 xmm0, xmm1

; 2670 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
stbtt_ScaleForMappingEmToPixels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv71 = 32
fheight$ = 36
info$ = 64
height$ = 72
stbtt_ScaleForPixelHeight PROC

; 2661 : {

$LN3:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2662 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR info$[rsp]
  00014	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  0001d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00021	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0002e	98		 cwde
  0002f	89 44 24 20	 mov	 DWORD PTR tv71[rsp], eax
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR info$[rsp]
  00038	48 63 49 24	 movsxd	 rcx, DWORD PTR [rcx+36]
  0003c	48 8b 54 24 40	 mov	 rdx, QWORD PTR info$[rsp]
  00041	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00045	48 8d 4c 0a 06	 lea	 rcx, QWORD PTR [rdx+rcx+6]
  0004a	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  0004f	98		 cwde
  00050	8b 4c 24 20	 mov	 ecx, DWORD PTR tv71[rsp]
  00054	2b c8		 sub	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	89 44 24 24	 mov	 DWORD PTR fheight$[rsp], eax

; 2663 :    return (float) height / fheight;

  0005c	f3 0f 2a 44 24
	24		 cvtsi2ss xmm0, DWORD PTR fheight$[rsp]
  00062	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR height$[rsp]
  00068	f3 0f 5e c8	 divss	 xmm1, xmm0
  0006c	0f 28 c1	 movaps	 xmm0, xmm1

; 2664 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
stbtt_ScaleForPixelHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
index_map$ = 32
format$ = 36
item$1 = 40
search$2 = 44
data$ = 48
searchRange$3 = 56
segcount$4 = 60
entrySelector$5 = 64
rangeShift$6 = 68
offset$7 = 72
start$8 = 76
mid$9 = 80
low$10 = 84
end$11 = 88
last$12 = 92
first$13 = 96
endCount$14 = 100
high$15 = 104
start_char$16 = 108
start_glyph$17 = 112
bytes$18 = 116
count$19 = 120
ngroups$20 = 124
end_char$21 = 128
info$ = 160
unicode_codepoint$ = 168
stbtt_FindGlyphIndex PROC

; 1497 : {

$LN33:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1498 :    stbtt_uint8 *data = info->data;

  00010	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 1499 :    stbtt_uint32 index_map = info->index_map;

  00021	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00029	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0002c	89 44 24 20	 mov	 DWORD PTR index_map$[rsp], eax

; 1500 : 
; 1501 :    stbtt_uint16 format = ttUSHORT(data + index_map + 0);

  00030	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 8b c1	 mov	 rax, rcx
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00047	66 89 44 24 24	 mov	 WORD PTR format$[rsp], ax

; 1502 :    if (format == 0) { // apple byte encoding

  0004c	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  00051	85 c0		 test	 eax, eax
  00053	75 5a		 jne	 SHORT $LN6@stbtt_Find

; 1503 :       stbtt_int32 bytes = ttUSHORT(data + index_map + 2);

  00055	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00059	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0005e	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00063	48 8b c8	 mov	 rcx, rax
  00066	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0006b	0f b7 c0	 movzx	 eax, ax
  0006e	89 44 24 74	 mov	 DWORD PTR bytes$18[rsp], eax

; 1504 :       if (unicode_codepoint < bytes-6)

  00072	8b 44 24 74	 mov	 eax, DWORD PTR bytes$18[rsp]
  00076	83 e8 06	 sub	 eax, 6
  00079	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00080	7d 21		 jge	 SHORT $LN8@stbtt_Find

; 1505 :          return ttBYTE(data + index_map + 6 + unicode_codepoint);

  00082	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0008b	48 03 c8	 add	 rcx, rax
  0008e	48 8b c1	 mov	 rax, rcx
  00091	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR unicode_codepoint$[rsp]
  00099	0f b6 44 08 06	 movzx	 eax, BYTE PTR [rax+rcx+6]
  0009e	e9 57 05 00 00	 jmp	 $LN1@stbtt_Find
$LN8@stbtt_Find:

; 1506 :       return 0;

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 50 05 00 00	 jmp	 $LN1@stbtt_Find
  000aa	e9 28 05 00 00	 jmp	 $LN7@stbtt_Find
$LN6@stbtt_Find:

; 1507 :    } else if (format == 6) {

  000af	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  000b4	83 f8 06	 cmp	 eax, 6
  000b7	0f 85 9f 00 00
	00		 jne	 $LN9@stbtt_Find

; 1508 :       stbtt_uint32 first = ttUSHORT(data + index_map + 6);

  000bd	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  000c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000c6	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000d3	0f b7 c0	 movzx	 eax, ax
  000d6	89 44 24 60	 mov	 DWORD PTR first$13[rsp], eax

; 1509 :       stbtt_uint32 count = ttUSHORT(data + index_map + 8);

  000da	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000e3	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000e8	48 8b c8	 mov	 rcx, rax
  000eb	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  000f0	0f b7 c0	 movzx	 eax, ax
  000f3	89 44 24 78	 mov	 DWORD PTR count$19[rsp], eax

; 1510 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

  000f7	8b 44 24 60	 mov	 eax, DWORD PTR first$13[rsp]
  000fb	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00102	72 4c		 jb	 SHORT $LN11@stbtt_Find
  00104	8b 44 24 78	 mov	 eax, DWORD PTR count$19[rsp]
  00108	8b 4c 24 60	 mov	 ecx, DWORD PTR first$13[rsp]
  0010c	03 c8		 add	 ecx, eax
  0010e	8b c1		 mov	 eax, ecx
  00110	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00117	73 37		 jae	 SHORT $LN11@stbtt_Find

; 1511 :          return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);

  00119	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  0011d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00122	48 03 c8	 add	 rcx, rax
  00125	48 8b c1	 mov	 rax, rcx
  00128	8b 4c 24 60	 mov	 ecx, DWORD PTR first$13[rsp]
  0012c	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR unicode_codepoint$[rsp]
  00133	2b d1		 sub	 edx, ecx
  00135	8b ca		 mov	 ecx, edx
  00137	d1 e1		 shl	 ecx, 1
  00139	8b c9		 mov	 ecx, ecx
  0013b	48 8d 44 08 0a	 lea	 rax, QWORD PTR [rax+rcx+10]
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00148	0f b7 c0	 movzx	 eax, ax
  0014b	e9 aa 04 00 00	 jmp	 $LN1@stbtt_Find
$LN11@stbtt_Find:

; 1512 :       return 0;

  00150	33 c0		 xor	 eax, eax
  00152	e9 a3 04 00 00	 jmp	 $LN1@stbtt_Find
  00157	e9 7b 04 00 00	 jmp	 $LN10@stbtt_Find
$LN9@stbtt_Find:

; 1513 :    } else if (format == 2) {

  0015c	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  00161	83 f8 02	 cmp	 eax, 2
  00164	75 2d		 jne	 SHORT $LN12@stbtt_Find

; 1514 :       STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean

  00166	33 c0		 xor	 eax, eax
  00168	85 c0		 test	 eax, eax
  0016a	75 1b		 jne	 SHORT $LN31@stbtt_Find
  0016c	41 b8 ea 05 00
	00		 mov	 r8d, 1514		; 000005eaH
  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41591
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41592
  00180	e8 00 00 00 00	 call	 _wassert
  00185	33 c0		 xor	 eax, eax
$LN31@stbtt_Find:

; 1515 :       return 0;

  00187	33 c0		 xor	 eax, eax
  00189	e9 6c 04 00 00	 jmp	 $LN1@stbtt_Find
  0018e	e9 44 04 00 00	 jmp	 $LN13@stbtt_Find
$LN12@stbtt_Find:

; 1516 :    } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges

  00193	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  00198	83 f8 04	 cmp	 eax, 4
  0019b	0f 85 ee 02 00
	00		 jne	 $LN14@stbtt_Find

; 1517 :       stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;

  001a1	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  001a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  001aa	48 8d 44 01 06	 lea	 rax, QWORD PTR [rcx+rax+6]
  001af	48 8b c8	 mov	 rcx, rax
  001b2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001b7	0f b7 c0	 movzx	 eax, ax
  001ba	d1 f8		 sar	 eax, 1
  001bc	66 89 44 24 3c	 mov	 WORD PTR segcount$4[rsp], ax

; 1518 :       stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;

  001c1	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  001c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  001ca	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001d7	0f b7 c0	 movzx	 eax, ax
  001da	d1 f8		 sar	 eax, 1
  001dc	66 89 44 24 38	 mov	 WORD PTR searchRange$3[rsp], ax

; 1519 :       stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);

  001e1	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  001e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  001ea	48 8d 44 01 0a	 lea	 rax, QWORD PTR [rcx+rax+10]
  001ef	48 8b c8	 mov	 rcx, rax
  001f2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  001f7	66 89 44 24 40	 mov	 WORD PTR entrySelector$5[rsp], ax

; 1520 :       stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

  001fc	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00200	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00205	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  0020a	48 8b c8	 mov	 rcx, rax
  0020d	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00212	0f b7 c0	 movzx	 eax, ax
  00215	d1 f8		 sar	 eax, 1
  00217	66 89 44 24 44	 mov	 WORD PTR rangeShift$6[rsp], ax

; 1521 : 
; 1522 :       // do a binary search of the segments
; 1523 :       stbtt_uint32 endCount = index_map + 14;

  0021c	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00220	83 c0 0e	 add	 eax, 14
  00223	89 44 24 64	 mov	 DWORD PTR endCount$14[rsp], eax

; 1524 :       stbtt_uint32 search = endCount;

  00227	8b 44 24 64	 mov	 eax, DWORD PTR endCount$14[rsp]
  0022b	89 44 24 2c	 mov	 DWORD PTR search$2[rsp], eax

; 1525 : 
; 1526 :       if (unicode_codepoint > 0xffff)

  0022f	81 bc 24 a8 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR unicode_codepoint$[rsp], 65535 ; 0000ffffH
  0023a	7e 07		 jle	 SHORT $LN16@stbtt_Find

; 1527 :          return 0;

  0023c	33 c0		 xor	 eax, eax
  0023e	e9 b7 03 00 00	 jmp	 $LN1@stbtt_Find
$LN16@stbtt_Find:

; 1528 : 
; 1529 :       // they lie from endCount .. endCount + segCount
; 1530 :       // but searchRange is the nearest power of two, so...
; 1531 :       if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))

  00243	8b 44 24 2c	 mov	 eax, DWORD PTR search$2[rsp]
  00247	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0024c	48 03 c8	 add	 rcx, rax
  0024f	48 8b c1	 mov	 rax, rcx
  00252	0f b7 4c 24 44	 movzx	 ecx, WORD PTR rangeShift$6[rsp]
  00257	d1 e1		 shl	 ecx, 1
  00259	48 63 c9	 movsxd	 rcx, ecx
  0025c	48 03 c1	 add	 rax, rcx
  0025f	48 8b c8	 mov	 rcx, rax
  00262	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00267	0f b7 c0	 movzx	 eax, ax
  0026a	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00271	7c 10		 jl	 SHORT $LN17@stbtt_Find

; 1532 :          search += rangeShift*2;

  00273	0f b7 44 24 44	 movzx	 eax, WORD PTR rangeShift$6[rsp]
  00278	8b 4c 24 2c	 mov	 ecx, DWORD PTR search$2[rsp]
  0027c	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  0027f	89 44 24 2c	 mov	 DWORD PTR search$2[rsp], eax
$LN17@stbtt_Find:

; 1533 : 
; 1534 :       // now decrement to bias correctly to find smallest
; 1535 :       search -= 2;

  00283	8b 44 24 2c	 mov	 eax, DWORD PTR search$2[rsp]
  00287	83 e8 02	 sub	 eax, 2
  0028a	89 44 24 2c	 mov	 DWORD PTR search$2[rsp], eax
$LN2@stbtt_Find:

; 1536 :       while (entrySelector) {

  0028e	0f b7 44 24 40	 movzx	 eax, WORD PTR entrySelector$5[rsp]
  00293	85 c0		 test	 eax, eax
  00295	74 63		 je	 SHORT $LN3@stbtt_Find

; 1537 :          stbtt_uint16 end;
; 1538 :          searchRange >>= 1;

  00297	0f b7 44 24 38	 movzx	 eax, WORD PTR searchRange$3[rsp]
  0029c	66 d1 e8	 shr	 ax, 1
  0029f	66 89 44 24 38	 mov	 WORD PTR searchRange$3[rsp], ax

; 1539 :          end = ttUSHORT(data + search + searchRange*2);

  002a4	8b 44 24 2c	 mov	 eax, DWORD PTR search$2[rsp]
  002a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  002ad	48 03 c8	 add	 rcx, rax
  002b0	48 8b c1	 mov	 rax, rcx
  002b3	0f b7 4c 24 38	 movzx	 ecx, WORD PTR searchRange$3[rsp]
  002b8	d1 e1		 shl	 ecx, 1
  002ba	48 63 c9	 movsxd	 rcx, ecx
  002bd	48 03 c1	 add	 rax, rcx
  002c0	48 8b c8	 mov	 rcx, rax
  002c3	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  002c8	66 89 44 24 58	 mov	 WORD PTR end$11[rsp], ax

; 1540 :          if (unicode_codepoint > end)

  002cd	0f b7 44 24 58	 movzx	 eax, WORD PTR end$11[rsp]
  002d2	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  002d9	7e 10		 jle	 SHORT $LN18@stbtt_Find

; 1541 :             search += searchRange*2;

  002db	0f b7 44 24 38	 movzx	 eax, WORD PTR searchRange$3[rsp]
  002e0	8b 4c 24 2c	 mov	 ecx, DWORD PTR search$2[rsp]
  002e4	8d 04 41	 lea	 eax, DWORD PTR [rcx+rax*2]
  002e7	89 44 24 2c	 mov	 DWORD PTR search$2[rsp], eax
$LN18@stbtt_Find:

; 1542 :          --entrySelector;

  002eb	0f b7 44 24 40	 movzx	 eax, WORD PTR entrySelector$5[rsp]
  002f0	66 ff c8	 dec	 ax
  002f3	66 89 44 24 40	 mov	 WORD PTR entrySelector$5[rsp], ax

; 1543 :       }

  002f8	eb 94		 jmp	 SHORT $LN2@stbtt_Find
$LN3@stbtt_Find:

; 1544 :       search += 2;

  002fa	8b 44 24 2c	 mov	 eax, DWORD PTR search$2[rsp]
  002fe	83 c0 02	 add	 eax, 2
  00301	89 44 24 2c	 mov	 DWORD PTR search$2[rsp], eax

; 1545 : 
; 1546 :       {
; 1547 :          stbtt_uint16 offset, start, last;
; 1548 :          stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

  00305	8b 44 24 64	 mov	 eax, DWORD PTR endCount$14[rsp]
  00309	8b 4c 24 2c	 mov	 ecx, DWORD PTR search$2[rsp]
  0030d	2b c8		 sub	 ecx, eax
  0030f	8b c1		 mov	 eax, ecx
  00311	d1 e8		 shr	 eax, 1
  00313	66 89 44 24 28	 mov	 WORD PTR item$1[rsp], ax

; 1549 : 
; 1550 :          start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);

  00318	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  0031c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00321	48 03 c8	 add	 rcx, rax
  00324	48 8b c1	 mov	 rax, rcx
  00327	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR segcount$4[rsp]
  0032c	d1 e1		 shl	 ecx, 1
  0032e	48 63 c9	 movsxd	 rcx, ecx
  00331	48 8d 44 08 0e	 lea	 rax, QWORD PTR [rax+rcx+14]
  00336	0f b7 4c 24 28	 movzx	 ecx, WORD PTR item$1[rsp]
  0033b	d1 e1		 shl	 ecx, 1
  0033d	48 63 c9	 movsxd	 rcx, ecx
  00340	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00345	48 8b c8	 mov	 rcx, rax
  00348	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  0034d	66 89 44 24 4c	 mov	 WORD PTR start$8[rsp], ax

; 1551 :          last = ttUSHORT(data + endCount + 2*item);

  00352	8b 44 24 64	 mov	 eax, DWORD PTR endCount$14[rsp]
  00356	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0035b	48 03 c8	 add	 rcx, rax
  0035e	48 8b c1	 mov	 rax, rcx
  00361	0f b7 4c 24 28	 movzx	 ecx, WORD PTR item$1[rsp]
  00366	d1 e1		 shl	 ecx, 1
  00368	48 63 c9	 movsxd	 rcx, ecx
  0036b	48 03 c1	 add	 rax, rcx
  0036e	48 8b c8	 mov	 rcx, rax
  00371	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00376	66 89 44 24 5c	 mov	 WORD PTR last$12[rsp], ax

; 1552 :          if (unicode_codepoint < start || unicode_codepoint > last)

  0037b	0f b7 44 24 4c	 movzx	 eax, WORD PTR start$8[rsp]
  00380	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00387	7c 0e		 jl	 SHORT $LN20@stbtt_Find
  00389	0f b7 44 24 5c	 movzx	 eax, WORD PTR last$12[rsp]
  0038e	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00395	7e 07		 jle	 SHORT $LN19@stbtt_Find
$LN20@stbtt_Find:

; 1553 :             return 0;

  00397	33 c0		 xor	 eax, eax
  00399	e9 5c 02 00 00	 jmp	 $LN1@stbtt_Find
$LN19@stbtt_Find:

; 1554 : 
; 1555 :          offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);

  0039e	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  003a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  003a7	48 03 c8	 add	 rcx, rax
  003aa	48 8b c1	 mov	 rax, rcx
  003ad	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR segcount$4[rsp]
  003b2	6b c9 06	 imul	 ecx, ecx, 6
  003b5	48 63 c9	 movsxd	 rcx, ecx
  003b8	48 8d 44 08 0e	 lea	 rax, QWORD PTR [rax+rcx+14]
  003bd	0f b7 4c 24 28	 movzx	 ecx, WORD PTR item$1[rsp]
  003c2	d1 e1		 shl	 ecx, 1
  003c4	48 63 c9	 movsxd	 rcx, ecx
  003c7	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  003cc	48 8b c8	 mov	 rcx, rax
  003cf	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  003d4	66 89 44 24 48	 mov	 WORD PTR offset$7[rsp], ax

; 1556 :          if (offset == 0)

  003d9	0f b7 44 24 48	 movzx	 eax, WORD PTR offset$7[rsp]
  003de	85 c0		 test	 eax, eax
  003e0	75 4a		 jne	 SHORT $LN21@stbtt_Find

; 1557 :             return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

  003e2	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  003e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  003eb	48 03 c8	 add	 rcx, rax
  003ee	48 8b c1	 mov	 rax, rcx
  003f1	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR segcount$4[rsp]
  003f6	c1 e1 02	 shl	 ecx, 2
  003f9	48 63 c9	 movsxd	 rcx, ecx
  003fc	48 8d 44 08 0e	 lea	 rax, QWORD PTR [rax+rcx+14]
  00401	0f b7 4c 24 28	 movzx	 ecx, WORD PTR item$1[rsp]
  00406	d1 e1		 shl	 ecx, 1
  00408	48 63 c9	 movsxd	 rcx, ecx
  0040b	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00410	48 8b c8	 mov	 rcx, rax
  00413	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPEAE@Z	; ttSHORT
  00418	98		 cwde
  00419	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR unicode_codepoint$[rsp]
  00420	03 c8		 add	 ecx, eax
  00422	8b c1		 mov	 eax, ecx
  00424	0f b7 c0	 movzx	 eax, ax
  00427	e9 ce 01 00 00	 jmp	 $LN1@stbtt_Find
$LN21@stbtt_Find:

; 1558 : 
; 1559 :          return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);

  0042c	0f b7 44 24 48	 movzx	 eax, WORD PTR offset$7[rsp]
  00431	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00436	48 03 c8	 add	 rcx, rax
  00439	48 8b c1	 mov	 rax, rcx
  0043c	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR start$8[rsp]
  00441	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR unicode_codepoint$[rsp]
  00448	2b d1		 sub	 edx, ecx
  0044a	8b ca		 mov	 ecx, edx
  0044c	d1 e1		 shl	 ecx, 1
  0044e	48 63 c9	 movsxd	 rcx, ecx
  00451	48 03 c1	 add	 rax, rcx
  00454	8b 4c 24 20	 mov	 ecx, DWORD PTR index_map$[rsp]
  00458	48 03 c1	 add	 rax, rcx
  0045b	0f b7 4c 24 3c	 movzx	 ecx, WORD PTR segcount$4[rsp]
  00460	6b c9 06	 imul	 ecx, ecx, 6
  00463	48 63 c9	 movsxd	 rcx, ecx
  00466	48 8d 44 08 0e	 lea	 rax, QWORD PTR [rax+rcx+14]
  0046b	0f b7 4c 24 28	 movzx	 ecx, WORD PTR item$1[rsp]
  00470	d1 e1		 shl	 ecx, 1
  00472	48 63 c9	 movsxd	 rcx, ecx
  00475	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  0047a	48 8b c8	 mov	 rcx, rax
  0047d	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPEAE@Z	; ttUSHORT
  00482	0f b7 c0	 movzx	 eax, ax
  00485	e9 70 01 00 00	 jmp	 $LN1@stbtt_Find
  0048a	e9 48 01 00 00	 jmp	 $LN15@stbtt_Find
$LN14@stbtt_Find:

; 1560 :       }
; 1561 :    } else if (format == 12 || format == 13) {

  0048f	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  00494	83 f8 0c	 cmp	 eax, 12
  00497	74 0e		 je	 SHORT $LN23@stbtt_Find
  00499	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  0049e	83 f8 0d	 cmp	 eax, 13
  004a1	0f 85 30 01 00
	00		 jne	 $LN22@stbtt_Find
$LN23@stbtt_Find:

; 1562 :       stbtt_uint32 ngroups = ttULONG(data+index_map+12);

  004a7	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  004ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  004b0	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  004b5	48 8b c8	 mov	 rcx, rax
  004b8	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  004bd	89 44 24 7c	 mov	 DWORD PTR ngroups$20[rsp], eax

; 1563 :       stbtt_int32 low,high;
; 1564 :       low = 0; high = (stbtt_int32)ngroups;

  004c1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR low$10[rsp], 0
  004c9	8b 44 24 7c	 mov	 eax, DWORD PTR ngroups$20[rsp]
  004cd	89 44 24 68	 mov	 DWORD PTR high$15[rsp], eax
$LN4@stbtt_Find:

; 1565 :       // Binary search the right group.
; 1566 :       while (low < high) {

  004d1	8b 44 24 68	 mov	 eax, DWORD PTR high$15[rsp]
  004d5	39 44 24 54	 cmp	 DWORD PTR low$10[rsp], eax
  004d9	0f 8d f4 00 00
	00		 jge	 $LN5@stbtt_Find

; 1567 :          stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high

  004df	8b 44 24 54	 mov	 eax, DWORD PTR low$10[rsp]
  004e3	8b 4c 24 68	 mov	 ecx, DWORD PTR high$15[rsp]
  004e7	2b c8		 sub	 ecx, eax
  004e9	8b c1		 mov	 eax, ecx
  004eb	d1 f8		 sar	 eax, 1
  004ed	8b 4c 24 54	 mov	 ecx, DWORD PTR low$10[rsp]
  004f1	03 c8		 add	 ecx, eax
  004f3	8b c1		 mov	 eax, ecx
  004f5	89 44 24 50	 mov	 DWORD PTR mid$9[rsp], eax

; 1568 :          stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);

  004f9	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  004fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00502	48 03 c8	 add	 rcx, rax
  00505	48 8b c1	 mov	 rax, rcx
  00508	6b 4c 24 50 0c	 imul	 ecx, DWORD PTR mid$9[rsp], 12
  0050d	48 63 c9	 movsxd	 rcx, ecx
  00510	48 8d 44 08 10	 lea	 rax, QWORD PTR [rax+rcx+16]
  00515	48 8b c8	 mov	 rcx, rax
  00518	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  0051d	89 44 24 6c	 mov	 DWORD PTR start_char$16[rsp], eax

; 1569 :          stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);

  00521	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00525	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0052a	48 03 c8	 add	 rcx, rax
  0052d	48 8b c1	 mov	 rax, rcx
  00530	6b 4c 24 50 0c	 imul	 ecx, DWORD PTR mid$9[rsp], 12
  00535	48 63 c9	 movsxd	 rcx, ecx
  00538	48 8d 44 08 14	 lea	 rax, QWORD PTR [rax+rcx+20]
  0053d	48 8b c8	 mov	 rcx, rax
  00540	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  00545	89 84 24 80 00
	00 00		 mov	 DWORD PTR end_char$21[rsp], eax

; 1570 :          if ((stbtt_uint32) unicode_codepoint < start_char)

  0054c	8b 44 24 6c	 mov	 eax, DWORD PTR start_char$16[rsp]
  00550	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00557	73 0a		 jae	 SHORT $LN24@stbtt_Find

; 1571 :             high = mid;

  00559	8b 44 24 50	 mov	 eax, DWORD PTR mid$9[rsp]
  0055d	89 44 24 68	 mov	 DWORD PTR high$15[rsp], eax
  00561	eb 6b		 jmp	 SHORT $LN25@stbtt_Find
$LN24@stbtt_Find:

; 1572 :          else if ((stbtt_uint32) unicode_codepoint > end_char)

  00563	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR end_char$21[rsp]
  0056a	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR unicode_codepoint$[rsp], eax
  00571	76 0c		 jbe	 SHORT $LN26@stbtt_Find

; 1573 :             low = mid+1;

  00573	8b 44 24 50	 mov	 eax, DWORD PTR mid$9[rsp]
  00577	ff c0		 inc	 eax
  00579	89 44 24 54	 mov	 DWORD PTR low$10[rsp], eax
  0057d	eb 4f		 jmp	 SHORT $LN27@stbtt_Find
$LN26@stbtt_Find:

; 1574 :          else {
; 1575 :             stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);

  0057f	8b 44 24 20	 mov	 eax, DWORD PTR index_map$[rsp]
  00583	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00588	48 03 c8	 add	 rcx, rax
  0058b	48 8b c1	 mov	 rax, rcx
  0058e	6b 4c 24 50 0c	 imul	 ecx, DWORD PTR mid$9[rsp], 12
  00593	48 63 c9	 movsxd	 rcx, ecx
  00596	48 8d 44 08 18	 lea	 rax, QWORD PTR [rax+rcx+24]
  0059b	48 8b c8	 mov	 rcx, rax
  0059e	e8 00 00 00 00	 call	 ?ttULONG@@YAIPEAE@Z	; ttULONG
  005a3	89 44 24 70	 mov	 DWORD PTR start_glyph$17[rsp], eax

; 1576 :             if (format == 12)

  005a7	0f b7 44 24 24	 movzx	 eax, WORD PTR format$[rsp]
  005ac	83 f8 0c	 cmp	 eax, 12
  005af	75 17		 jne	 SHORT $LN28@stbtt_Find

; 1577 :                return start_glyph + unicode_codepoint-start_char;

  005b1	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR unicode_codepoint$[rsp]
  005b8	8b 4c 24 70	 mov	 ecx, DWORD PTR start_glyph$17[rsp]
  005bc	03 c8		 add	 ecx, eax
  005be	8b c1		 mov	 eax, ecx
  005c0	2b 44 24 6c	 sub	 eax, DWORD PTR start_char$16[rsp]
  005c4	eb 34		 jmp	 SHORT $LN1@stbtt_Find
  005c6	eb 06		 jmp	 SHORT $LN29@stbtt_Find
$LN28@stbtt_Find:

; 1578 :             else // format == 13
; 1579 :                return start_glyph;

  005c8	8b 44 24 70	 mov	 eax, DWORD PTR start_glyph$17[rsp]
  005cc	eb 2c		 jmp	 SHORT $LN1@stbtt_Find
$LN29@stbtt_Find:
$LN27@stbtt_Find:
$LN25@stbtt_Find:

; 1580 :          }
; 1581 :       }

  005ce	e9 fe fe ff ff	 jmp	 $LN4@stbtt_Find
$LN5@stbtt_Find:

; 1582 :       return 0; // not found

  005d3	33 c0		 xor	 eax, eax
  005d5	eb 23		 jmp	 SHORT $LN1@stbtt_Find
$LN22@stbtt_Find:
$LN15@stbtt_Find:
$LN13@stbtt_Find:
$LN10@stbtt_Find:
$LN7@stbtt_Find:

; 1583 :    }
; 1584 :    // @TODO
; 1585 :    STBTT_assert(0);

  005d7	33 c0		 xor	 eax, eax
  005d9	85 c0		 test	 eax, eax
  005db	75 1b		 jne	 SHORT $LN32@stbtt_Find
  005dd	41 b8 31 06 00
	00		 mov	 r8d, 1585		; 00000631H
  005e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG41609
  005ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG41610
  005f1	e8 00 00 00 00	 call	 _wassert
  005f6	33 c0		 xor	 eax, eax
$LN32@stbtt_Find:

; 1586 :    return 0;

  005f8	33 c0		 xor	 eax, eax
$LN1@stbtt_Find:

; 1587 : }

  005fa	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00601	c3		 ret	 0
stbtt_FindGlyphIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
info$ = 48
data$ = 56
offset$ = 64
stbtt_InitFont PROC

; 4953 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4954 :    return stbtt_InitFont_internal(info, (unsigned char *) data, offset);

  00013	44 8b 44 24 40	 mov	 r8d, DWORD PTR offset$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR data$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00022	e8 00 00 00 00	 call	 ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ; stbtt_InitFont_internal

; 4955 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
stbtt_InitFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
data$ = 48
index$ = 56
stbtt_GetFontOffsetForIndex PROC

; 4943 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4944 :    return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);

  0000d	8b 54 24 38	 mov	 edx, DWORD PTR index$[rsp]
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00016	e8 00 00 00 00	 call	 ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ; stbtt_GetFontOffsetForIndex_internal

; 4945 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
stbtt_GetFontOffsetForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
data$ = 48
stbtt_GetNumberOfFonts PROC

; 4948 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4949 :    return stbtt_GetNumberOfFonts_internal((unsigned char *) data);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbtt_GetNumberOfFonts_internal@@YAHPEAE@Z ; stbtt_GetNumberOfFonts_internal

; 4950 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
stbtt_GetNumberOfFonts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
r$1 = 80
i$ = 88
j$ = 92
scale$2 = 96
pad$3 = 100
glyph$4 = 104
bc$5 = 112
fh$6 = 120
missing_glyph$ = 124
k$ = 128
return_value$ = 132
tv80 = 136
tv176 = 140
x0$7 = 144
recip_h$8 = 148
sub_x$9 = 152
y0$10 = 156
recip_v$11 = 160
sub_y$12 = 164
codepoint$13 = 168
advance$14 = 172
old_h_over$ = 176
old_v_over$ = 180
lsb$15 = 184
y1$16 = 188
x1$17 = 192
spc$ = 240
info$ = 248
ranges$ = 256
num_ranges$ = 264
rects$ = 272
stbtt_PackFontRangesRenderIntoRects PROC

; 4209 : {

$LN22:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 4210 :    int i,j,k, missing_glyph = -1, return_value = 1;

  0001d	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR missing_glyph$[rsp], -1
  00025	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR return_value$[rsp], 1

; 4211 : 
; 4212 :    // save current values
; 4213 :    int old_h_over = spc->h_oversample;

  00030	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00038	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0003b	89 84 24 b0 00
	00 00		 mov	 DWORD PTR old_h_over$[rsp], eax

; 4214 :    int old_v_over = spc->v_oversample;

  00042	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0004a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0004d	89 84 24 b4 00
	00 00		 mov	 DWORD PTR old_v_over$[rsp], eax

; 4215 : 
; 4216 :    k = 0;

  00054	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0

; 4217 :    for (i=0; i < num_ranges; ++i) {

  0005f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00067	eb 0a		 jmp	 SHORT $LN4@stbtt_Pack
$LN2@stbtt_Pack:
  00069	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  0006d	ff c0		 inc	 eax
  0006f	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Pack:
  00073	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR num_ranges$[rsp]
  0007a	39 44 24 58	 cmp	 DWORD PTR i$[rsp], eax
  0007e	0f 8d 3c 07 00
	00		 jge	 $LN3@stbtt_Pack

; 4218 :       float fh = ranges[i].font_size;

  00084	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00089	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0008d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00095	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  0009a	f3 0f 11 44 24
	78		 movss	 DWORD PTR fh$6[rsp], xmm0

; 4219 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  000a0	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR fh$6[rsp]
  000a6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000ad	76 1e		 jbe	 SHORT $LN18@stbtt_Pack
  000af	f3 0f 10 4c 24
	78		 movss	 xmm1, DWORD PTR fh$6[rsp]
  000b5	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000bd	e8 00 00 00 00	 call	 stbtt_ScaleForPixelHeight
  000c2	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR tv80[rsp], xmm0
  000cb	eb 26		 jmp	 SHORT $LN19@stbtt_Pack
$LN18@stbtt_Pack:
  000cd	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR fh$6[rsp]
  000d3	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000da	0f 28 c8	 movaps	 xmm1, xmm0
  000dd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000e5	e8 00 00 00 00	 call	 stbtt_ScaleForMappingEmToPixels
  000ea	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR tv80[rsp], xmm0
$LN19@stbtt_Pack:
  000f3	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR tv80[rsp]
  000fc	f3 0f 11 44 24
	60		 movss	 DWORD PTR scale$2[rsp], xmm0

; 4220 :       float recip_h,recip_v,sub_x,sub_y;
; 4221 :       spc->h_oversample = ranges[i].h_oversample;

  00102	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00107	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0010b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00113	0f b6 44 01 20	 movzx	 eax, BYTE PTR [rcx+rax+32]
  00118	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00120	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 4222 :       spc->v_oversample = ranges[i].v_oversample;

  00123	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00128	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0012c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00134	0f b6 44 01 21	 movzx	 eax, BYTE PTR [rcx+rax+33]
  00139	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00141	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 4223 :       recip_h = 1.0f / spc->h_oversample;

  00144	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0014c	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0014f	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00154	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0015c	f3 0f 5e c8	 divss	 xmm1, xmm0
  00160	0f 28 c1	 movaps	 xmm0, xmm1
  00163	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR recip_h$8[rsp], xmm0

; 4224 :       recip_v = 1.0f / spc->v_oversample;

  0016c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00174	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00177	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  0017c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00184	f3 0f 5e c8	 divss	 xmm1, xmm0
  00188	0f 28 c1	 movaps	 xmm0, xmm1
  0018b	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR recip_v$11[rsp], xmm0

; 4225 :       sub_x = stbtt__oversample_shift(spc->h_oversample);

  00194	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0019c	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  0019f	e8 00 00 00 00	 call	 ?stbtt__oversample_shift@@YAMH@Z ; stbtt__oversample_shift
  001a4	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR sub_x$9[rsp], xmm0

; 4226 :       sub_y = stbtt__oversample_shift(spc->v_oversample);

  001ad	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  001b5	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001b8	e8 00 00 00 00	 call	 ?stbtt__oversample_shift@@YAMH@Z ; stbtt__oversample_shift
  001bd	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR sub_y$12[rsp], xmm0

; 4227 :       for (j=0; j < ranges[i].num_chars; ++j) {

  001c6	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001ce	eb 0a		 jmp	 SHORT $LN7@stbtt_Pack
$LN5@stbtt_Pack:
  001d0	8b 44 24 5c	 mov	 eax, DWORD PTR j$[rsp]
  001d4	ff c0		 inc	 eax
  001d6	89 44 24 5c	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbtt_Pack:
  001da	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  001df	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  001e3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  001eb	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  001ef	39 44 24 5c	 cmp	 DWORD PTR j$[rsp], eax
  001f3	0f 8d c2 05 00
	00		 jge	 $LN6@stbtt_Pack

; 4228 :          stbrp_rect *r = &rects[k];

  001f9	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  00201	48 6b c0 18	 imul	 rax, rax, 24
  00205	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR rects$[rsp]
  0020d	48 03 c8	 add	 rcx, rax
  00210	48 8b c1	 mov	 rax, rcx
  00213	48 89 44 24 50	 mov	 QWORD PTR r$1[rsp], rax

; 4229 :          if (r->was_packed && r->w != 0 && r->h != 0) {

  00218	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0021d	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00221	0f 84 df 04 00
	00		 je	 $LN8@stbtt_Pack
  00227	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0022c	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00230	0f 84 d0 04 00
	00		 je	 $LN8@stbtt_Pack
  00236	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0023b	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0023f	0f 84 c1 04 00
	00		 je	 $LN8@stbtt_Pack

; 4230 :             stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];

  00245	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  0024a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0024e	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR j$[rsp]
  00253	48 6b c9 1c	 imul	 rcx, rcx, 28
  00257	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  0025f	48 03 4c 02 18	 add	 rcx, QWORD PTR [rdx+rax+24]
  00264	48 8b c1	 mov	 rax, rcx
  00267	48 89 44 24 70	 mov	 QWORD PTR bc$5[rsp], rax

; 4231 :             int advance, lsb, x0,y0,x1,y1;
; 4232 :             int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

  0026c	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00271	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00275	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  0027d	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00283	75 22		 jne	 SHORT $LN20@stbtt_Pack
  00285	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  0028a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0028e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00296	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0029a	03 44 24 5c	 add	 eax, DWORD PTR j$[rsp]
  0029e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  002a5	eb 25		 jmp	 SHORT $LN21@stbtt_Pack
$LN20@stbtt_Pack:
  002a7	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  002ac	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  002b0	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR j$[rsp]
  002b5	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  002bd	48 8b 44 02 08	 mov	 rax, QWORD PTR [rdx+rax+8]
  002c2	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  002c5	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
$LN21@stbtt_Pack:
  002cc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv176[rsp]
  002d3	89 84 24 a8 00
	00 00		 mov	 DWORD PTR codepoint$13[rsp], eax

; 4233 :             int glyph = stbtt_FindGlyphIndex(info, codepoint);

  002da	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR codepoint$13[rsp]
  002e1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  002e9	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  002ee	89 44 24 68	 mov	 DWORD PTR glyph$4[rsp], eax

; 4234 :             stbrp_coord pad = (stbrp_coord) spc->padding;

  002f2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  002fa	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  002fd	89 44 24 64	 mov	 DWORD PTR pad$3[rsp], eax

; 4235 : 
; 4236 :             // pad on left and top
; 4237 :             r->x += pad;

  00301	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00306	8b 00		 mov	 eax, DWORD PTR [rax]
  00308	03 44 24 64	 add	 eax, DWORD PTR pad$3[rsp]
  0030c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00311	89 01		 mov	 DWORD PTR [rcx], eax

; 4238 :             r->y += pad;

  00313	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00318	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0031b	03 44 24 64	 add	 eax, DWORD PTR pad$3[rsp]
  0031f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00324	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 4239 :             r->w -= pad;

  00327	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0032c	8b 4c 24 64	 mov	 ecx, DWORD PTR pad$3[rsp]
  00330	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00333	2b c1		 sub	 eax, ecx
  00335	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  0033a	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 4240 :             r->h -= pad;

  0033d	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00342	8b 4c 24 64	 mov	 ecx, DWORD PTR pad$3[rsp]
  00346	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00349	2b c1		 sub	 eax, ecx
  0034b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00350	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4241 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);

  00353	4c 8d 8c 24 b8
	00 00 00	 lea	 r9, QWORD PTR lsb$15[rsp]
  0035b	4c 8d 84 24 ac
	00 00 00	 lea	 r8, QWORD PTR advance$14[rsp]
  00363	8b 54 24 68	 mov	 edx, DWORD PTR glyph$4[rsp]
  00367	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0036f	e8 00 00 00 00	 call	 stbtt_GetGlyphHMetrics

; 4242 :             stbtt_GetGlyphBitmapBox(info, glyph,

  00374	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0037c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0037f	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00384	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR scale$2[rsp]
  0038a	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0038e	0f 28 c1	 movaps	 xmm0, xmm1
  00391	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00399	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0039c	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  003a1	f3 0f 10 54 24
	60		 movss	 xmm2, DWORD PTR scale$2[rsp]
  003a7	f3 0f 59 d1	 mulss	 xmm2, xmm1
  003ab	0f 28 ca	 movaps	 xmm1, xmm2
  003ae	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR y1$16[rsp]
  003b6	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003bb	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR x1$17[rsp]
  003c3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003c8	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR y0$10[rsp]
  003d0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d5	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR x0$7[rsp]
  003dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e2	0f 28 d8	 movaps	 xmm3, xmm0
  003e5	0f 28 d1	 movaps	 xmm2, xmm1
  003e8	8b 54 24 68	 mov	 edx, DWORD PTR glyph$4[rsp]
  003ec	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  003f4	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBox

; 4243 :                                     scale * spc->h_oversample,
; 4244 :                                     scale * spc->v_oversample,
; 4245 :                                     &x0,&y0,&x1,&y1);
; 4246 :             stbtt_MakeGlyphBitmapSubpixel(info,

  003f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00401	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00404	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00409	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR scale$2[rsp]
  0040f	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00413	0f 28 c1	 movaps	 xmm0, xmm1
  00416	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0041e	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00421	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  00426	f3 0f 10 54 24
	60		 movss	 xmm2, DWORD PTR scale$2[rsp]
  0042c	f3 0f 59 d1	 mulss	 xmm2, xmm1
  00430	0f 28 ca	 movaps	 xmm1, xmm2
  00433	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00438	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00440	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00443	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00446	2b c1		 sub	 eax, ecx
  00448	ff c0		 inc	 eax
  0044a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  0044f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR spc$[rsp]
  00457	8b 52 24	 mov	 edx, DWORD PTR [rdx+36]
  0045a	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0045d	2b ca		 sub	 ecx, edx
  0045f	ff c1		 inc	 ecx
  00461	48 8b 54 24 50	 mov	 rdx, QWORD PTR r$1[rsp]
  00466	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  00469	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR spc$[rsp]
  00471	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  00475	4c 03 c2	 add	 r8, rdx
  00478	49 8b d0	 mov	 rdx, r8
  0047b	4c 8b 44 24 50	 mov	 r8, QWORD PTR r$1[rsp]
  00480	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR spc$[rsp]
  00488	45 8b 40 04	 mov	 r8d, DWORD PTR [r8+4]
  0048c	45 0f af 41 18	 imul	 r8d, DWORD PTR [r9+24]
  00491	4d 63 c0	 movsxd	 r8, r8d
  00494	49 03 d0	 add	 rdx, r8
  00497	44 8b 44 24 68	 mov	 r8d, DWORD PTR glyph$4[rsp]
  0049c	44 89 44 24 48	 mov	 DWORD PTR [rsp+72], r8d
  004a1	0f 57 d2	 xorps	 xmm2, xmm2
  004a4	f3 0f 11 54 24
	40		 movss	 DWORD PTR [rsp+64], xmm2
  004aa	0f 57 d2	 xorps	 xmm2, xmm2
  004ad	f3 0f 11 54 24
	38		 movss	 DWORD PTR [rsp+56], xmm2
  004b3	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  004b9	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  004bf	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR spc$[rsp]
  004c7	45 8b 40 18	 mov	 r8d, DWORD PTR [r8+24]
  004cb	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  004d0	44 8b c8	 mov	 r9d, eax
  004d3	44 8b c1	 mov	 r8d, ecx
  004d6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  004de	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmapSubpixel

; 4247 :                                           spc->pixels + r->x + r->y*spc->stride_in_bytes,
; 4248 :                                           r->w - spc->h_oversample+1,
; 4249 :                                           r->h - spc->v_oversample+1,
; 4250 :                                           spc->stride_in_bytes,
; 4251 :                                           scale * spc->h_oversample,
; 4252 :                                           scale * spc->v_oversample,
; 4253 :                                           0,0,
; 4254 :                                           glyph);
; 4255 : 
; 4256 :             if (spc->h_oversample > 1)

  004e3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  004eb	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  004ef	76 68		 jbe	 SHORT $LN10@stbtt_Pack

; 4257 :                stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

  004f1	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  004f6	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  004f9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00501	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00505	48 03 c8	 add	 rcx, rax
  00508	48 8b c1	 mov	 rax, rcx
  0050b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00510	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR spc$[rsp]
  00518	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0051b	0f af 4a 18	 imul	 ecx, DWORD PTR [rdx+24]
  0051f	48 63 c9	 movsxd	 rcx, ecx
  00522	48 03 c1	 add	 rax, rcx
  00525	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  0052d	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  00530	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00534	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  0053c	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  00540	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00545	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  00549	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  0054e	8b 51 0c	 mov	 edx, DWORD PTR [rcx+12]
  00551	48 8b c8	 mov	 rcx, rax
  00554	e8 00 00 00 00	 call	 ?stbtt__h_prefilter@@YAXPEAEHHHI@Z ; stbtt__h_prefilter
$LN10@stbtt_Pack:

; 4258 :                                   r->w, r->h, spc->stride_in_bytes,
; 4259 :                                   spc->h_oversample);
; 4260 : 
; 4261 :             if (spc->v_oversample > 1)

  00559	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00561	83 78 28 01	 cmp	 DWORD PTR [rax+40], 1
  00565	76 68		 jbe	 SHORT $LN11@stbtt_Pack

; 4262 :                stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

  00567	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0056c	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0056f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00577	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0057b	48 03 c8	 add	 rcx, rax
  0057e	48 8b c1	 mov	 rax, rcx
  00581	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00586	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR spc$[rsp]
  0058e	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00591	0f af 4a 18	 imul	 ecx, DWORD PTR [rdx+24]
  00595	48 63 c9	 movsxd	 rcx, ecx
  00598	48 03 c1	 add	 rax, rcx
  0059b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  005a3	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  005a6	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  005aa	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  005b2	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  005b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  005bb	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  005bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  005c4	8b 51 0c	 mov	 edx, DWORD PTR [rcx+12]
  005c7	48 8b c8	 mov	 rcx, rax
  005ca	e8 00 00 00 00	 call	 ?stbtt__v_prefilter@@YAXPEAEHHHI@Z ; stbtt__v_prefilter
$LN11@stbtt_Pack:

; 4263 :                                   r->w, r->h, spc->stride_in_bytes,
; 4264 :                                   spc->v_oversample);
; 4265 : 
; 4266 :             bc->x0       = (stbtt_int16)  r->x;

  005cf	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  005d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  005d9	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  005dc	66 89 08	 mov	 WORD PTR [rax], cx

; 4267 :             bc->y0       = (stbtt_int16)  r->y;

  005df	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  005e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  005e9	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  005ed	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 4268 :             bc->x1       = (stbtt_int16) (r->x + r->w);

  005f1	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  005f6	8b 00		 mov	 eax, DWORD PTR [rax]
  005f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  005fd	03 41 0c	 add	 eax, DWORD PTR [rcx+12]
  00600	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bc$5[rsp]
  00605	66 89 41 04	 mov	 WORD PTR [rcx+4], ax

; 4269 :             bc->y1       = (stbtt_int16) (r->y + r->h);

  00609	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0060e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00611	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$1[rsp]
  00616	03 41 10	 add	 eax, DWORD PTR [rcx+16]
  00619	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bc$5[rsp]
  0061e	66 89 41 06	 mov	 WORD PTR [rcx+6], ax

; 4270 :             bc->xadvance =                scale * advance;

  00622	f3 0f 2a 84 24
	ac 00 00 00	 cvtsi2ss xmm0, DWORD PTR advance$14[rsp]
  0062b	f3 0f 10 4c 24
	60		 movss	 xmm1, DWORD PTR scale$2[rsp]
  00631	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00635	0f 28 c1	 movaps	 xmm0, xmm1
  00638	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  0063d	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 4271 :             bc->xoff     =       (float)  x0 * recip_h + sub_x;

  00642	f3 0f 2a 84 24
	90 00 00 00	 cvtsi2ss xmm0, DWORD PTR x0$7[rsp]
  0064b	f3 0f 59 84 24
	94 00 00 00	 mulss	 xmm0, DWORD PTR recip_h$8[rsp]
  00654	f3 0f 58 84 24
	98 00 00 00	 addss	 xmm0, DWORD PTR sub_x$9[rsp]
  0065d	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  00662	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 4272 :             bc->yoff     =       (float)  y0 * recip_v + sub_y;

  00667	f3 0f 2a 84 24
	9c 00 00 00	 cvtsi2ss xmm0, DWORD PTR y0$10[rsp]
  00670	f3 0f 59 84 24
	a0 00 00 00	 mulss	 xmm0, DWORD PTR recip_v$11[rsp]
  00679	f3 0f 58 84 24
	a4 00 00 00	 addss	 xmm0, DWORD PTR sub_y$12[rsp]
  00682	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  00687	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 4273 :             bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;

  0068c	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00691	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00694	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR x0$7[rsp]
  0069b	03 c8		 add	 ecx, eax
  0069d	8b c1		 mov	 eax, ecx
  0069f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  006a3	f3 0f 59 84 24
	94 00 00 00	 mulss	 xmm0, DWORD PTR recip_h$8[rsp]
  006ac	f3 0f 58 84 24
	98 00 00 00	 addss	 xmm0, DWORD PTR sub_x$9[rsp]
  006b5	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  006ba	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 4274 :             bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;

  006bf	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  006c4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  006c7	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR y0$10[rsp]
  006ce	03 c8		 add	 ecx, eax
  006d0	8b c1		 mov	 eax, ecx
  006d2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  006d6	f3 0f 59 84 24
	a0 00 00 00	 mulss	 xmm0, DWORD PTR recip_v$11[rsp]
  006df	f3 0f 58 84 24
	a4 00 00 00	 addss	 xmm0, DWORD PTR sub_y$12[rsp]
  006e8	48 8b 44 24 70	 mov	 rax, QWORD PTR bc$5[rsp]
  006ed	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 4275 : 
; 4276 :             if (glyph == 0)

  006f2	83 7c 24 68 00	 cmp	 DWORD PTR glyph$4[rsp], 0
  006f7	75 08		 jne	 SHORT $LN12@stbtt_Pack

; 4277 :                missing_glyph = j;

  006f9	8b 44 24 5c	 mov	 eax, DWORD PTR j$[rsp]
  006fd	89 44 24 7c	 mov	 DWORD PTR missing_glyph$[rsp], eax
$LN12@stbtt_Pack:
  00701	e9 a0 00 00 00	 jmp	 $LN9@stbtt_Pack
$LN8@stbtt_Pack:

; 4278 :          } else if (spc->skip_missing) {

  00706	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0070e	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00712	74 10		 je	 SHORT $LN13@stbtt_Pack

; 4279 :             return_value = 0;

  00714	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR return_value$[rsp], 0
  0071f	e9 82 00 00 00	 jmp	 $LN14@stbtt_Pack
$LN13@stbtt_Pack:

; 4280 :          } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {

  00724	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00729	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0072d	74 6c		 je	 SHORT $LN15@stbtt_Pack
  0072f	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  00734	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00738	75 61		 jne	 SHORT $LN15@stbtt_Pack
  0073a	48 8b 44 24 50	 mov	 rax, QWORD PTR r$1[rsp]
  0073f	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00743	75 56		 jne	 SHORT $LN15@stbtt_Pack
  00745	83 7c 24 7c 00	 cmp	 DWORD PTR missing_glyph$[rsp], 0
  0074a	7c 4f		 jl	 SHORT $LN15@stbtt_Pack

; 4281 :             ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];

  0074c	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00751	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00755	48 63 4c 24 7c	 movsxd	 rcx, DWORD PTR missing_glyph$[rsp]
  0075a	48 6b c9 1c	 imul	 rcx, rcx, 28
  0075e	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  00766	48 8b 44 02 18	 mov	 rax, QWORD PTR [rdx+rax+24]
  0076b	48 63 54 24 58	 movsxd	 rdx, DWORD PTR i$[rsp]
  00770	48 6b d2 28	 imul	 rdx, rdx, 40		; 00000028H
  00774	4c 63 44 24 5c	 movsxd	 r8, DWORD PTR j$[rsp]
  00779	4d 6b c0 1c	 imul	 r8, r8, 28
  0077d	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR ranges$[rsp]
  00785	49 8b 54 11 18	 mov	 rdx, QWORD PTR [r9+rdx+24]
  0078a	4a 8d 3c 02	 lea	 rdi, QWORD PTR [rdx+r8]
  0078e	48 8d 34 08	 lea	 rsi, QWORD PTR [rax+rcx]
  00792	b9 1c 00 00 00	 mov	 ecx, 28
  00797	f3 a4		 rep movsb

; 4282 :          } else {

  00799	eb 0b		 jmp	 SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:

; 4283 :             return_value = 0; // if any fail, report failure

  0079b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR return_value$[rsp], 0
$LN16@stbtt_Pack:
$LN14@stbtt_Pack:
$LN9@stbtt_Pack:

; 4284 :          }
; 4285 : 
; 4286 :          ++k;

  007a6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  007ad	ff c0		 inc	 eax
  007af	89 84 24 80 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 4287 :       }

  007b6	e9 15 fa ff ff	 jmp	 $LN5@stbtt_Pack
$LN6@stbtt_Pack:

; 4288 :    }

  007bb	e9 a9 f8 ff ff	 jmp	 $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 4289 : 
; 4290 :    // restore original values
; 4291 :    spc->h_oversample = old_h_over;

  007c0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  007c8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR old_h_over$[rsp]
  007cf	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 4292 :    spc->v_oversample = old_v_over;

  007d2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  007da	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR old_v_over$[rsp]
  007e1	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 4293 : 
; 4294 :    return return_value;

  007e4	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR return_value$[rsp]

; 4295 : }

  007eb	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  007f2	5f		 pop	 rdi
  007f3	5e		 pop	 rsi
  007f4	c3		 ret	 0
stbtt_PackFontRangesRenderIntoRects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
spc$ = 48
rects$ = 56
num_rects$ = 64
stbtt_PackFontRangesPackRects PROC

; 4298 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4299 :    stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);

  00013	44 8b 44 24 40	 mov	 r8d, DWORD PTR num_rects$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR rects$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR spc$[rsp]
  00022	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00026	e8 00 00 00 00	 call	 ?stbrp_pack_rects@@YAXPEAUstbrp_context@@PEAUstbrp_rect@@H@Z ; stbrp_pack_rects

; 4300 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
stbtt_PackFontRangesPackRects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 80
k$ = 84
j$ = 88
fh$1 = 92
glyph$2 = 96
tv78 = 100
tv144 = 104
scale$3 = 108
missing_glyph_added$ = 112
codepoint$4 = 116
x0$5 = 120
x1$6 = 124
y0$7 = 128
y1$8 = 132
spc$ = 160
info$ = 168
ranges$ = 176
num_ranges$ = 184
rects$ = 192
stbtt_PackFontRangesGatherRects PROC

; 4150 : {

$LN17:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4151 :    int i,j,k;
; 4152 :    int missing_glyph_added = 0;

  0001b	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR missing_glyph_added$[rsp], 0

; 4153 : 
; 4154 :    k=0;

  00023	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 4155 :    for (i=0; i < num_ranges; ++i) {

  0002b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00033	eb 0a		 jmp	 SHORT $LN4@stbtt_Pack
$LN2@stbtt_Pack:
  00035	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00039	ff c0		 inc	 eax
  0003b	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Pack:
  0003f	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR num_ranges$[rsp]
  00046	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  0004a	0f 8d e4 02 00
	00		 jge	 $LN3@stbtt_Pack

; 4156 :       float fh = ranges[i].font_size;

  00050	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00055	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00059	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00061	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  00066	f3 0f 11 44 24
	5c		 movss	 DWORD PTR fh$1[rsp], xmm0

; 4157 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  0006c	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR fh$1[rsp]
  00072	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00079	76 1b		 jbe	 SHORT $LN13@stbtt_Pack
  0007b	f3 0f 10 4c 24
	5c		 movss	 xmm1, DWORD PTR fh$1[rsp]
  00081	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00089	e8 00 00 00 00	 call	 stbtt_ScaleForPixelHeight
  0008e	f3 0f 11 44 24
	64		 movss	 DWORD PTR tv78[rsp], xmm0
  00094	eb 23		 jmp	 SHORT $LN14@stbtt_Pack
$LN13@stbtt_Pack:
  00096	f3 0f 10 44 24
	5c		 movss	 xmm0, DWORD PTR fh$1[rsp]
  0009c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000a3	0f 28 c8	 movaps	 xmm1, xmm0
  000a6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000ae	e8 00 00 00 00	 call	 stbtt_ScaleForMappingEmToPixels
  000b3	f3 0f 11 44 24
	64		 movss	 DWORD PTR tv78[rsp], xmm0
$LN14@stbtt_Pack:
  000b9	f3 0f 10 44 24
	64		 movss	 xmm0, DWORD PTR tv78[rsp]
  000bf	f3 0f 11 44 24
	6c		 movss	 DWORD PTR scale$3[rsp], xmm0

; 4158 :       ranges[i].h_oversample = (unsigned char) spc->h_oversample;

  000c5	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000ca	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  000d6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR spc$[rsp]
  000de	0f b6 52 24	 movzx	 edx, BYTE PTR [rdx+36]
  000e2	88 54 01 20	 mov	 BYTE PTR [rcx+rax+32], dl

; 4159 :       ranges[i].v_oversample = (unsigned char) spc->v_oversample;

  000e6	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000eb	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000ef	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  000f7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR spc$[rsp]
  000ff	0f b6 52 28	 movzx	 edx, BYTE PTR [rdx+40]
  00103	88 54 01 21	 mov	 BYTE PTR [rcx+rax+33], dl

; 4160 :       for (j=0; j < ranges[i].num_chars; ++j) {

  00107	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0010f	eb 0a		 jmp	 SHORT $LN7@stbtt_Pack
$LN5@stbtt_Pack:
  00111	8b 44 24 58	 mov	 eax, DWORD PTR j$[rsp]
  00115	ff c0		 inc	 eax
  00117	89 44 24 58	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbtt_Pack:
  0011b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00120	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00124	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  0012c	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  00130	39 44 24 58	 cmp	 DWORD PTR j$[rsp], eax
  00134	0f 8d f5 01 00
	00		 jge	 $LN6@stbtt_Pack

; 4161 :          int x0,y0,x1,y1;
; 4162 :          int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

  0013a	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0013f	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00143	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  0014b	48 83 7c 01 08
	00		 cmp	 QWORD PTR [rcx+rax+8], 0
  00151	75 1f		 jne	 SHORT $LN15@stbtt_Pack
  00153	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00158	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0015c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00164	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00168	03 44 24 58	 add	 eax, DWORD PTR j$[rsp]
  0016c	89 44 24 68	 mov	 DWORD PTR tv144[rsp], eax
  00170	eb 22		 jmp	 SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:
  00172	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00177	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0017b	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR j$[rsp]
  00180	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  00188	48 8b 44 02 08	 mov	 rax, QWORD PTR [rdx+rax+8]
  0018d	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00190	89 44 24 68	 mov	 DWORD PTR tv144[rsp], eax
$LN16@stbtt_Pack:
  00194	8b 44 24 68	 mov	 eax, DWORD PTR tv144[rsp]
  00198	89 44 24 74	 mov	 DWORD PTR codepoint$4[rsp], eax

; 4163 :          int glyph = stbtt_FindGlyphIndex(info, codepoint);

  0019c	8b 54 24 74	 mov	 edx, DWORD PTR codepoint$4[rsp]
  001a0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  001a8	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  001ad	89 44 24 60	 mov	 DWORD PTR glyph$2[rsp], eax

; 4164 :          if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {

  001b1	83 7c 24 60 00	 cmp	 DWORD PTR glyph$2[rsp], 0
  001b6	75 4c		 jne	 SHORT $LN8@stbtt_Pack
  001b8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  001c0	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  001c4	75 07		 jne	 SHORT $LN10@stbtt_Pack
  001c6	83 7c 24 70 00	 cmp	 DWORD PTR missing_glyph_added$[rsp], 0
  001cb	74 37		 je	 SHORT $LN8@stbtt_Pack
$LN10@stbtt_Pack:

; 4165 :             rects[k].w = rects[k].h = 0;

  001cd	48 63 44 24 54	 movsxd	 rax, DWORD PTR k$[rsp]
  001d2	48 6b c0 18	 imul	 rax, rax, 24
  001d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR rects$[rsp]
  001de	c7 44 01 10 00
	00 00 00	 mov	 DWORD PTR [rcx+rax+16], 0
  001e6	48 63 44 24 54	 movsxd	 rax, DWORD PTR k$[rsp]
  001eb	48 6b c0 18	 imul	 rax, rax, 24
  001ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR rects$[rsp]
  001f7	c7 44 01 0c 00
	00 00 00	 mov	 DWORD PTR [rcx+rax+12], 0

; 4166 :          } else {

  001ff	e9 1c 01 00 00	 jmp	 $LN9@stbtt_Pack
$LN8@stbtt_Pack:

; 4167 :             stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,

  00204	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  0020c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0020f	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00214	f3 0f 10 4c 24
	6c		 movss	 xmm1, DWORD PTR scale$3[rsp]
  0021a	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0021e	0f 28 c1	 movaps	 xmm0, xmm1
  00221	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00229	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0022c	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  00231	f3 0f 10 54 24
	6c		 movss	 xmm2, DWORD PTR scale$3[rsp]
  00237	f3 0f 59 d1	 mulss	 xmm2, xmm1
  0023b	0f 28 ca	 movaps	 xmm1, xmm2
  0023e	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR y1$8[rsp]
  00246	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0024b	48 8d 44 24 7c	 lea	 rax, QWORD PTR x1$6[rsp]
  00250	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00255	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR y0$7[rsp]
  0025d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00262	48 8d 44 24 78	 lea	 rax, QWORD PTR x0$5[rsp]
  00267	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0026c	0f 57 d2	 xorps	 xmm2, xmm2
  0026f	f3 0f 11 54 24
	28		 movss	 DWORD PTR [rsp+40], xmm2
  00275	0f 57 d2	 xorps	 xmm2, xmm2
  00278	f3 0f 11 54 24
	20		 movss	 DWORD PTR [rsp+32], xmm2
  0027e	0f 28 d8	 movaps	 xmm3, xmm0
  00281	0f 28 d1	 movaps	 xmm2, xmm1
  00284	8b 54 24 60	 mov	 edx, DWORD PTR glyph$2[rsp]
  00288	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00290	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 4168 :                                             scale * spc->h_oversample,
; 4169 :                                             scale * spc->v_oversample,
; 4170 :                                             0,0,
; 4171 :                                             &x0,&y0,&x1,&y1);
; 4172 :             rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);

  00295	8b 44 24 78	 mov	 eax, DWORD PTR x0$5[rsp]
  00299	8b 4c 24 7c	 mov	 ecx, DWORD PTR x1$6[rsp]
  0029d	2b c8		 sub	 ecx, eax
  0029f	8b c1		 mov	 eax, ecx
  002a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  002a9	03 41 1c	 add	 eax, DWORD PTR [rcx+28]
  002ac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  002b4	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  002b7	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002bb	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR k$[rsp]
  002c0	48 6b c9 18	 imul	 rcx, rcx, 24
  002c4	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR rects$[rsp]
  002cc	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax

; 4173 :             rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);

  002d0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR y0$7[rsp]
  002d7	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR y1$8[rsp]
  002de	2b c8		 sub	 ecx, eax
  002e0	8b c1		 mov	 eax, ecx
  002e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  002ea	03 41 1c	 add	 eax, DWORD PTR [rcx+28]
  002ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  002f5	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  002f8	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002fc	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR k$[rsp]
  00301	48 6b c9 18	 imul	 rcx, rcx, 24
  00305	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR rects$[rsp]
  0030d	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax

; 4174 :             if (glyph == 0)

  00311	83 7c 24 60 00	 cmp	 DWORD PTR glyph$2[rsp], 0
  00316	75 08		 jne	 SHORT $LN11@stbtt_Pack

; 4175 :                missing_glyph_added = 1;

  00318	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR missing_glyph_added$[rsp], 1
$LN11@stbtt_Pack:
$LN9@stbtt_Pack:

; 4176 :          }
; 4177 :          ++k;

  00320	8b 44 24 54	 mov	 eax, DWORD PTR k$[rsp]
  00324	ff c0		 inc	 eax
  00326	89 44 24 54	 mov	 DWORD PTR k$[rsp], eax

; 4178 :       }

  0032a	e9 e2 fd ff ff	 jmp	 $LN5@stbtt_Pack
$LN6@stbtt_Pack:

; 4179 :    }

  0032f	e9 01 fd ff ff	 jmp	 $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 4180 : 
; 4181 :    return k;

  00334	8b 44 24 54	 mov	 eax, DWORD PTR k$[rsp]

; 4182 : }

  00338	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0033f	c3		 ret	 0
stbtt_PackFontRangesGatherRects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
x$1 = 32
y$2 = 36
ipw$ = 40
iph$ = 44
b$ = 48
chardata$ = 80
pw$ = 88
ph$ = 96
char_index$ = 104
xpos$ = 112
ypos$ = 120
q$ = 128
align_to_integer$ = 136
stbtt_GetPackedQuad PROC

; 4364 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4365 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

  00017	f3 0f 2a 44 24
	58		 cvtsi2ss xmm0, DWORD PTR pw$[rsp]
  0001d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00025	f3 0f 5e c8	 divss	 xmm1, xmm0
  00029	0f 28 c1	 movaps	 xmm0, xmm1
  0002c	f3 0f 11 44 24
	28		 movss	 DWORD PTR ipw$[rsp], xmm0
  00032	f3 0f 2a 44 24
	60		 cvtsi2ss xmm0, DWORD PTR ph$[rsp]
  00038	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00040	f3 0f 5e c8	 divss	 xmm1, xmm0
  00044	0f 28 c1	 movaps	 xmm0, xmm1
  00047	f3 0f 11 44 24
	2c		 movss	 DWORD PTR iph$[rsp], xmm0

; 4366 :    const stbtt_packedchar *b = chardata + char_index;

  0004d	48 63 44 24 68	 movsxd	 rax, DWORD PTR char_index$[rsp]
  00052	48 6b c0 1c	 imul	 rax, rax, 28
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chardata$[rsp]
  0005b	48 03 c8	 add	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax

; 4367 : 
; 4368 :    if (align_to_integer) {

  00066	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR align_to_integer$[rsp], 0
  0006e	0f 84 d9 00 00
	00		 je	 $LN2@stbtt_GetP

; 4369 :       float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);

  00074	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  0007e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00082	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [rcx+8]
  00087	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0008f	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00093	e8 00 00 00 00	 call	 floor
  00098	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0009c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000a0	f3 0f 11 44 24
	20		 movss	 DWORD PTR x$1[rsp], xmm0

; 4370 :       float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);

  000a6	48 8b 44 24 78	 mov	 rax, QWORD PTR ypos$[rsp]
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  000b0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  000b4	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [rcx+12]
  000b9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000c1	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000c5	e8 00 00 00 00	 call	 floor
  000ca	f2 0f 2c c0	 cvttsd2si eax, xmm0
  000ce	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000d2	f3 0f 11 44 24
	24		 movss	 DWORD PTR y$2[rsp], xmm0

; 4371 :       q->x0 = x;

  000d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  000e0	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR x$1[rsp]
  000e6	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4372 :       q->y0 = y;

  000ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  000f2	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR y$2[rsp]
  000f8	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 4373 :       q->x1 = x + b->xoff2 - b->xoff;

  000fd	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00102	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR x$1[rsp]
  00108	f3 0f 58 40 14	 addss	 xmm0, DWORD PTR [rax+20]
  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00112	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [rax+8]
  00117	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  0011f	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 4374 :       q->y1 = y + b->yoff2 - b->yoff;

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00129	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR y$2[rsp]
  0012f	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [rax+24]
  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00139	f3 0f 5c 40 0c	 subss	 xmm0, DWORD PTR [rax+12]
  0013e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00146	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 4375 :    } else {

  0014b	eb 7f		 jmp	 SHORT $LN3@stbtt_GetP
$LN2@stbtt_GetP:

; 4376 :       q->x0 = *xpos + b->xoff;

  0014d	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  00152	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00157	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0015b	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [rcx+8]
  00160	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00168	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4377 :       q->y0 = *ypos + b->yoff;

  0016c	48 8b 44 24 78	 mov	 rax, QWORD PTR ypos$[rsp]
  00171	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00176	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0017a	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [rcx+12]
  0017f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00187	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 4378 :       q->x1 = *xpos + b->xoff2;

  0018c	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  00191	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00196	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0019a	f3 0f 58 41 14	 addss	 xmm0, DWORD PTR [rcx+20]
  0019f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  001a7	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 4379 :       q->y1 = *ypos + b->yoff2;

  001ac	48 8b 44 24 78	 mov	 rax, QWORD PTR ypos$[rsp]
  001b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  001b6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  001ba	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [rcx+24]
  001bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  001c7	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
$LN3@stbtt_GetP:

; 4380 :    }
; 4381 : 
; 4382 :    q->s0 = b->x0 * ipw;

  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  001d1	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001d4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001d8	f3 0f 59 44 24
	28		 mulss	 xmm0, DWORD PTR ipw$[rsp]
  001de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  001e6	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 4383 :    q->t0 = b->y0 * iph;

  001eb	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  001f0	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  001f4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f8	f3 0f 59 44 24
	2c		 mulss	 xmm0, DWORD PTR iph$[rsp]
  001fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00206	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 4384 :    q->s1 = b->x1 * ipw;

  0020b	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00210	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  00214	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00218	f3 0f 59 44 24
	28		 mulss	 xmm0, DWORD PTR ipw$[rsp]
  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00226	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 4385 :    q->t1 = b->y1 * iph;

  0022b	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  00230	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00234	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00238	f3 0f 59 44 24
	2c		 mulss	 xmm0, DWORD PTR iph$[rsp]
  0023e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00246	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0

; 4386 : 
; 4387 :    *xpos += b->xadvance;

  0024b	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  00250	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00255	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00259	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [rcx+16]
  0025e	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  00263	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4388 : }

  00267	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0026b	c3		 ret	 0
stbtt_GetPackedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
spc$ = 8
skip$ = 16
stbtt_PackSetSkipMissingCodepoints PROC

; 4006 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 4007 :    spc->skip_missing = skip;

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR spc$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR skip$[rsp]
  00012	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 4008 : }

  00015	c3		 ret	 0
stbtt_PackSetSkipMissingCodepoints ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
spc$ = 48
h_oversample$ = 56
v_oversample$ = 64
stbtt_PackSetOversampling PROC

; 3996 : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3997 :    STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);

  00012	83 7c 24 38 08	 cmp	 DWORD PTR h_oversample$[rsp], 8
  00017	76 1b		 jbe	 SHORT $LN5@stbtt_Pack
  00019	41 b8 9d 0f 00
	00		 mov	 r8d, 3997		; 00000f9dH
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG43425
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG43426
  0002d	e8 00 00 00 00	 call	 _wassert
  00032	33 c0		 xor	 eax, eax
$LN5@stbtt_Pack:

; 3998 :    STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);

  00034	83 7c 24 40 08	 cmp	 DWORD PTR v_oversample$[rsp], 8
  00039	76 1b		 jbe	 SHORT $LN6@stbtt_Pack
  0003b	41 b8 9e 0f 00
	00		 mov	 r8d, 3998		; 00000f9eH
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG43427
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG43428
  0004f	e8 00 00 00 00	 call	 _wassert
  00054	33 c0		 xor	 eax, eax
$LN6@stbtt_Pack:

; 3999 :    if (h_oversample <= STBTT_MAX_OVERSAMPLE)

  00056	83 7c 24 38 08	 cmp	 DWORD PTR h_oversample$[rsp], 8
  0005b	77 0c		 ja	 SHORT $LN2@stbtt_Pack

; 4000 :       spc->h_oversample = h_oversample;

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR spc$[rsp]
  00062	8b 4c 24 38	 mov	 ecx, DWORD PTR h_oversample$[rsp]
  00066	89 48 24	 mov	 DWORD PTR [rax+36], ecx
$LN2@stbtt_Pack:

; 4001 :    if (v_oversample <= STBTT_MAX_OVERSAMPLE)

  00069	83 7c 24 40 08	 cmp	 DWORD PTR v_oversample$[rsp], 8
  0006e	77 0c		 ja	 SHORT $LN3@stbtt_Pack

; 4002 :       spc->v_oversample = v_oversample;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR spc$[rsp]
  00075	8b 4c 24 40	 mov	 ecx, DWORD PTR v_oversample$[rsp]
  00079	89 48 28	 mov	 DWORD PTR [rax+40], ecx
$LN3@stbtt_Pack:

; 4003 : }

  0007c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00080	c3		 ret	 0
stbtt_PackSetOversampling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
i$ = 48
j$ = 52
n$ = 56
return_value$ = 60
rects$ = 64
info$ = 80
spc$ = 256
fontdata$ = 264
font_index$ = 272
ranges$ = 280
num_ranges$ = 288
stbtt_PackFontRanges PROC

; 4303 : {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 4304 :    stbtt_fontinfo info;
; 4305 :    int i,j,n, return_value = 1;

  0001b	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR return_value$[rsp], 1

; 4306 :    //stbrp_context *context = (stbrp_context *) spc->pack_info;
; 4307 :    stbrp_rect    *rects;
; 4308 : 
; 4309 :    // flag all characters as NOT packed
; 4310 :    for (i=0; i < num_ranges; ++i)

  00023	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 0a		 jmp	 SHORT $LN4@stbtt_Pack
$LN2@stbtt_Pack:
  0002d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00031	ff c0		 inc	 eax
  00033	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbtt_Pack:
  00037	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR num_ranges$[rsp]
  0003e	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00042	0f 8d d4 00 00
	00		 jge	 $LN3@stbtt_Pack

; 4311 :       for (j=0; j < ranges[i].num_chars; ++j)

  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00050	eb 0a		 jmp	 SHORT $LN7@stbtt_Pack
$LN5@stbtt_Pack:
  00052	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00056	ff c0		 inc	 eax
  00058	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbtt_Pack:
  0005c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00061	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00065	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  0006d	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  00071	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  00075	0f 8d 9c 00 00
	00		 jge	 $LN6@stbtt_Pack

; 4312 :          ranges[i].chardata_for_range[j].x0 =

  0007b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00084	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  00089	48 6b c9 1c	 imul	 rcx, rcx, 28
  0008d	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  00095	48 8b 44 02 18	 mov	 rax, QWORD PTR [rdx+rax+24]
  0009a	33 d2		 xor	 edx, edx
  0009c	66 89 54 08 06	 mov	 WORD PTR [rax+rcx+6], dx
  000a1	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000a6	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000aa	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000af	48 6b c9 1c	 imul	 rcx, rcx, 28
  000b3	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  000bb	48 8b 44 02 18	 mov	 rax, QWORD PTR [rdx+rax+24]
  000c0	33 d2		 xor	 edx, edx
  000c2	66 89 54 08 04	 mov	 WORD PTR [rax+rcx+4], dx
  000c7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000cc	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000d0	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000d5	48 6b c9 1c	 imul	 rcx, rcx, 28
  000d9	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  000e1	48 8b 44 02 18	 mov	 rax, QWORD PTR [rdx+rax+24]
  000e6	33 d2		 xor	 edx, edx
  000e8	66 89 54 08 02	 mov	 WORD PTR [rax+rcx+2], dx
  000ed	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000f2	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000f6	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  000fb	48 6b c9 1c	 imul	 rcx, rcx, 28
  000ff	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR ranges$[rsp]
  00107	48 8b 44 02 18	 mov	 rax, QWORD PTR [rdx+rax+24]
  0010c	33 d2		 xor	 edx, edx
  0010e	66 89 14 08	 mov	 WORD PTR [rax+rcx], dx
  00112	e9 3b ff ff ff	 jmp	 $LN5@stbtt_Pack
$LN6@stbtt_Pack:
  00117	e9 11 ff ff ff	 jmp	 $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 4313 :          ranges[i].chardata_for_range[j].y0 =
; 4314 :          ranges[i].chardata_for_range[j].x1 =
; 4315 :          ranges[i].chardata_for_range[j].y1 = 0;
; 4316 : 
; 4317 :    n = 0;

  0011c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 4318 :    for (i=0; i < num_ranges; ++i)

  00124	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012c	eb 0a		 jmp	 SHORT $LN10@stbtt_Pack
$LN8@stbtt_Pack:
  0012e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00132	ff c0		 inc	 eax
  00134	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbtt_Pack:
  00138	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR num_ranges$[rsp]
  0013f	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00143	7d 23		 jge	 SHORT $LN9@stbtt_Pack

; 4319 :       n += ranges[i].num_chars;

  00145	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0014a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0014e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ranges$[rsp]
  00156	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  0015a	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  0015e	03 c8		 add	 ecx, eax
  00160	8b c1		 mov	 eax, ecx
  00162	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  00166	eb c6		 jmp	 SHORT $LN8@stbtt_Pack
$LN9@stbtt_Pack:

; 4320 : 
; 4321 :    rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);

  00168	48 63 44 24 38	 movsxd	 rax, DWORD PTR n$[rsp]
  0016d	48 6b c0 18	 imul	 rax, rax, 24
  00171	48 8b c8	 mov	 rcx, rax
  00174	e8 00 00 00 00	 call	 malloc
  00179	48 89 44 24 40	 mov	 QWORD PTR rects$[rsp], rax

; 4322 :    if (rects == NULL)

  0017e	48 83 7c 24 40
	00		 cmp	 QWORD PTR rects$[rsp], 0
  00184	75 07		 jne	 SHORT $LN11@stbtt_Pack

; 4323 :       return 0;

  00186	33 c0		 xor	 eax, eax
  00188	e9 be 00 00 00	 jmp	 $LN1@stbtt_Pack
$LN11@stbtt_Pack:

; 4324 : 
; 4325 :    info.userdata = spc->user_allocator_context;

  0018d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR spc$[rsp]
  00195	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00198	48 89 44 24 50	 mov	 QWORD PTR info$[rsp], rax

; 4326 :    stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

  0019d	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR font_index$[rsp]
  001a4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR fontdata$[rsp]
  001ac	e8 00 00 00 00	 call	 stbtt_GetFontOffsetForIndex
  001b1	44 8b c0	 mov	 r8d, eax
  001b4	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR fontdata$[rsp]
  001bc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR info$[rsp]
  001c1	e8 00 00 00 00	 call	 stbtt_InitFont

; 4327 : 
; 4328 :    n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

  001c6	48 8b 44 24 40	 mov	 rax, QWORD PTR rects$[rsp]
  001cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d0	44 8b 8c 24 20
	01 00 00	 mov	 r9d, DWORD PTR num_ranges$[rsp]
  001d8	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR ranges$[rsp]
  001e0	48 8d 54 24 50	 lea	 rdx, QWORD PTR info$[rsp]
  001e5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  001ed	e8 00 00 00 00	 call	 stbtt_PackFontRangesGatherRects
  001f2	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 4329 : 
; 4330 :    stbtt_PackFontRangesPackRects(spc, rects, n);

  001f6	44 8b 44 24 38	 mov	 r8d, DWORD PTR n$[rsp]
  001fb	48 8b 54 24 40	 mov	 rdx, QWORD PTR rects$[rsp]
  00200	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00208	e8 00 00 00 00	 call	 stbtt_PackFontRangesPackRects

; 4331 : 
; 4332 :    return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

  0020d	48 8b 44 24 40	 mov	 rax, QWORD PTR rects$[rsp]
  00212	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00217	44 8b 8c 24 20
	01 00 00	 mov	 r9d, DWORD PTR num_ranges$[rsp]
  0021f	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR ranges$[rsp]
  00227	48 8d 54 24 50	 lea	 rdx, QWORD PTR info$[rsp]
  0022c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR spc$[rsp]
  00234	e8 00 00 00 00	 call	 stbtt_PackFontRangesRenderIntoRects
  00239	89 44 24 3c	 mov	 DWORD PTR return_value$[rsp], eax

; 4333 : 
; 4334 :    STBTT_free(rects, spc->user_allocator_context);

  0023d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rects$[rsp]
  00242	e8 00 00 00 00	 call	 free

; 4335 :    return return_value;

  00247	8b 44 24 3c	 mov	 eax, DWORD PTR return_value$[rsp]
$LN1@stbtt_Pack:

; 4336 : }

  0024b	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00252	c3		 ret	 0
stbtt_PackFontRanges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
range$ = 48
spc$ = 112
fontdata$ = 120
font_index$ = 128
font_size$ = 136
first_unicode_codepoint_in_range$ = 144
num_chars_in_range$ = 152
chardata_for_range$ = 160
stbtt_PackFontRange PROC

; 4340 : {

$LN3:
  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4341 :    stbtt_pack_range range;
; 4342 :    range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR first_unicode_codepoint_in_range$[rsp]
  00020	89 44 24 34	 mov	 DWORD PTR range$[rsp+4], eax

; 4343 :    range.array_of_unicode_codepoints = NULL;

  00024	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR range$[rsp+8], 0

; 4344 :    range.num_chars                   = num_chars_in_range;

  0002d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR num_chars_in_range$[rsp]
  00034	89 44 24 40	 mov	 DWORD PTR range$[rsp+16], eax

; 4345 :    range.chardata_for_range          = chardata_for_range;

  00038	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chardata_for_range$[rsp]
  00040	48 89 44 24 48	 mov	 QWORD PTR range$[rsp+24], rax

; 4346 :    range.font_size                   = font_size;

  00045	f3 0f 10 84 24
	88 00 00 00	 movss	 xmm0, DWORD PTR font_size$[rsp]
  0004e	f3 0f 11 44 24
	30		 movss	 DWORD PTR range$[rsp], xmm0

; 4347 :    return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);

  00054	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0005c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR range$[rsp]
  00061	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR font_index$[rsp]
  00069	48 8b 54 24 78	 mov	 rdx, QWORD PTR fontdata$[rsp]
  0006e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spc$[rsp]
  00073	e8 00 00 00 00	 call	 stbtt_PackFontRanges

; 4348 : }

  00078	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0007c	c3		 ret	 0
stbtt_PackFontRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
spc$ = 48
stbtt_PackEnd PROC

; 3990 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3991 :    STBTT_free(spc->nodes    , spc->user_allocator_context);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR spc$[rsp]
  0000e	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00012	e8 00 00 00 00	 call	 free

; 3992 :    STBTT_free(spc->pack_info, spc->user_allocator_context);

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR spc$[rsp]
  0001c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00020	e8 00 00 00 00	 call	 free

; 3993 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
stbtt_PackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
tv91 = 48
num_nodes$ = 52
nodes$ = 56
context$ = 64
tv138 = 72
spc$ = 96
pixels$ = 104
pw$ = 112
ph$ = 120
stride_in_bytes$ = 128
padding$ = 136
alloc_context$ = 144
stbtt_PackBegin PROC

; 3958 : {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3959 :    stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);

  00019	b9 14 00 00 00	 mov	 ecx, 20
  0001e	e8 00 00 00 00	 call	 malloc
  00023	48 89 44 24 40	 mov	 QWORD PTR context$[rsp], rax

; 3960 :    int            num_nodes = pw - padding;

  00028	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR padding$[rsp]
  0002f	8b 4c 24 70	 mov	 ecx, DWORD PTR pw$[rsp]
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 34	 mov	 DWORD PTR num_nodes$[rsp], eax

; 3961 :    stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

  0003b	48 63 44 24 34	 movsxd	 rax, DWORD PTR num_nodes$[rsp]
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 malloc
  00048	48 89 44 24 38	 mov	 QWORD PTR nodes$[rsp], rax

; 3962 : 
; 3963 :    if (context == NULL || nodes == NULL) {

  0004d	48 83 7c 24 40
	00		 cmp	 QWORD PTR context$[rsp], 0
  00053	74 08		 je	 SHORT $LN3@stbtt_Pack
  00055	48 83 7c 24 38
	00		 cmp	 QWORD PTR nodes$[rsp], 0
  0005b	75 2b		 jne	 SHORT $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 3964 :       if (context != NULL) STBTT_free(context, alloc_context);

  0005d	48 83 7c 24 40
	00		 cmp	 QWORD PTR context$[rsp], 0
  00063	74 0a		 je	 SHORT $LN4@stbtt_Pack
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR context$[rsp]
  0006a	e8 00 00 00 00	 call	 free
$LN4@stbtt_Pack:

; 3965 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

  0006f	48 83 7c 24 38
	00		 cmp	 QWORD PTR nodes$[rsp], 0
  00075	74 0a		 je	 SHORT $LN5@stbtt_Pack
  00077	48 8b 4c 24 38	 mov	 rcx, QWORD PTR nodes$[rsp]
  0007c	e8 00 00 00 00	 call	 free
$LN5@stbtt_Pack:

; 3966 :       return 0;

  00081	33 c0		 xor	 eax, eax
  00083	e9 15 01 00 00	 jmp	 $LN1@stbtt_Pack
$LN2@stbtt_Pack:

; 3967 :    }
; 3968 : 
; 3969 :    spc->user_allocator_context = alloc_context;

  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  0008d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR alloc_context$[rsp]
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3970 :    spc->width = pw;

  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  0009d	8b 4c 24 70	 mov	 ecx, DWORD PTR pw$[rsp]
  000a1	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 3971 :    spc->height = ph;

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  000a9	8b 4c 24 78	 mov	 ecx, DWORD PTR ph$[rsp]
  000ad	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 3972 :    spc->pixels = pixels;

  000b0	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  000b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixels$[rsp]
  000ba	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 3973 :    spc->pack_info = context;

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR context$[rsp]
  000c8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3974 :    spc->nodes = nodes;

  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  000d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR nodes$[rsp]
  000d6	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 3975 :    spc->padding = padding;

  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  000df	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR padding$[rsp]
  000e6	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 3976 :    spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;

  000e9	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR stride_in_bytes$[rsp], 0
  000f1	74 0d		 je	 SHORT $LN8@stbtt_Pack
  000f3	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR stride_in_bytes$[rsp]
  000fa	89 44 24 30	 mov	 DWORD PTR tv91[rsp], eax
  000fe	eb 08		 jmp	 SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:
  00100	8b 44 24 70	 mov	 eax, DWORD PTR pw$[rsp]
  00104	89 44 24 30	 mov	 DWORD PTR tv91[rsp], eax
$LN9@stbtt_Pack:
  00108	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  0010d	8b 4c 24 30	 mov	 ecx, DWORD PTR tv91[rsp]
  00111	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 3977 :    spc->h_oversample = 1;

  00114	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  00119	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [rax+36], 1

; 3978 :    spc->v_oversample = 1;

  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  00125	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [rax+40], 1

; 3979 :    spc->skip_missing = 0;

  0012c	48 8b 44 24 60	 mov	 rax, QWORD PTR spc$[rsp]
  00131	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 3980 : 
; 3981 :    stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

  00138	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR padding$[rsp]
  0013f	8b 4c 24 78	 mov	 ecx, DWORD PTR ph$[rsp]
  00143	2b c8		 sub	 ecx, eax
  00145	8b c1		 mov	 eax, ecx
  00147	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR padding$[rsp]
  0014e	8b 54 24 70	 mov	 edx, DWORD PTR pw$[rsp]
  00152	2b d1		 sub	 edx, ecx
  00154	8b ca		 mov	 ecx, edx
  00156	8b 54 24 34	 mov	 edx, DWORD PTR num_nodes$[rsp]
  0015a	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0015e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR nodes$[rsp]
  00163	44 8b c0	 mov	 r8d, eax
  00166	8b d1		 mov	 edx, ecx
  00168	48 8b 4c 24 40	 mov	 rcx, QWORD PTR context$[rsp]
  0016d	e8 00 00 00 00	 call	 ?stbrp_init_target@@YAXPEAUstbrp_context@@HHPEAUstbrp_node@@H@Z ; stbrp_init_target

; 3982 : 
; 3983 :    if (pixels)

  00172	48 83 7c 24 68
	00		 cmp	 QWORD PTR pixels$[rsp], 0
  00178	74 1e		 je	 SHORT $LN6@stbtt_Pack

; 3984 :       STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

  0017a	8b 44 24 70	 mov	 eax, DWORD PTR pw$[rsp]
  0017e	0f af 44 24 78	 imul	 eax, DWORD PTR ph$[rsp]
  00183	48 98		 cdqe
  00185	48 89 44 24 48	 mov	 QWORD PTR tv138[rsp], rax
  0018a	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pixels$[rsp]
  0018f	33 c0		 xor	 eax, eax
  00191	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv138[rsp]
  00196	f3 aa		 rep stosb
$LN6@stbtt_Pack:

; 3985 : 
; 3986 :    return 1;

  00198	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_Pack:

; 3987 : }

  0019d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001a1	5f		 pop	 rdi
  001a2	c3		 ret	 0
stbtt_PackBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
scale$ = 32
tv78 = 36
i_ascent$ = 40
i_descent$ = 44
i_lineGap$ = 48
info$ = 64
fontdata$ = 240
index$ = 248
size$ = 256
ascent$ = 264
descent$ = 272
lineGap$ = 280
stbtt_GetScaledFontVMetrics PROC

; 4351 : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 4352 :    int i_ascent, i_descent, i_lineGap;
; 4353 :    float scale;
; 4354 :    stbtt_fontinfo info;
; 4355 :    stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));

  0001b	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR index$[rsp]
  00022	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fontdata$[rsp]
  0002a	e8 00 00 00 00	 call	 stbtt_GetFontOffsetForIndex
  0002f	44 8b c0	 mov	 r8d, eax
  00032	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR fontdata$[rsp]
  0003a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  0003f	e8 00 00 00 00	 call	 stbtt_InitFont

; 4356 :    scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);

  00044	f3 0f 10 84 24
	00 01 00 00	 movss	 xmm0, DWORD PTR size$[rsp]
  0004d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00054	76 1b		 jbe	 SHORT $LN3@stbtt_GetS
  00056	f3 0f 10 8c 24
	00 01 00 00	 movss	 xmm1, DWORD PTR size$[rsp]
  0005f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  00064	e8 00 00 00 00	 call	 stbtt_ScaleForPixelHeight
  00069	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv78[rsp], xmm0
  0006f	eb 23		 jmp	 SHORT $LN4@stbtt_GetS
$LN3@stbtt_GetS:
  00071	f3 0f 10 84 24
	00 01 00 00	 movss	 xmm0, DWORD PTR size$[rsp]
  0007a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00081	0f 28 c8	 movaps	 xmm1, xmm0
  00084	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  00089	e8 00 00 00 00	 call	 stbtt_ScaleForMappingEmToPixels
  0008e	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv78[rsp], xmm0
$LN4@stbtt_GetS:
  00094	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR tv78[rsp]
  0009a	f3 0f 11 44 24
	20		 movss	 DWORD PTR scale$[rsp], xmm0

; 4357 :    stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);

  000a0	4c 8d 4c 24 30	 lea	 r9, QWORD PTR i_lineGap$[rsp]
  000a5	4c 8d 44 24 2c	 lea	 r8, QWORD PTR i_descent$[rsp]
  000aa	48 8d 54 24 28	 lea	 rdx, QWORD PTR i_ascent$[rsp]
  000af	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  000b4	e8 00 00 00 00	 call	 stbtt_GetFontVMetrics

; 4358 :    *ascent  = (float) i_ascent  * scale;

  000b9	f3 0f 2a 44 24
	28		 cvtsi2ss xmm0, DWORD PTR i_ascent$[rsp]
  000bf	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR scale$[rsp]
  000c5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR ascent$[rsp]
  000cd	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4359 :    *descent = (float) i_descent * scale;

  000d1	f3 0f 2a 44 24
	2c		 cvtsi2ss xmm0, DWORD PTR i_descent$[rsp]
  000d7	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR scale$[rsp]
  000dd	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR descent$[rsp]
  000e5	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4360 :    *lineGap = (float) i_lineGap * scale;

  000e9	f3 0f 2a 44 24
	30		 cvtsi2ss xmm0, DWORD PTR i_lineGap$[rsp]
  000ef	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR scale$[rsp]
  000f5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR lineGap$[rsp]
  000fd	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 4361 : }

  00101	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00108	c3		 ret	 0
stbtt_GetScaledFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
d3d_bias$ = 32
tv65 = 36
round_x$ = 40
round_y$ = 44
ipw$ = 48
iph$ = 52
b$ = 56
chardata$ = 80
pw$ = 88
ph$ = 96
char_index$ = 104
xpos$ = 112
ypos$ = 120
q$ = 128
opengl_fillrule$ = 136
stbtt_GetBakedQuad PROC

; 3860 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3861 :    float d3d_bias = opengl_fillrule ? 0 : -0.5f;

  00017	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR opengl_fillrule$[rsp], 0
  0001f	74 0b		 je	 SHORT $LN3@stbtt_GetB
  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv65[rsp], xmm0
  0002a	eb 0e		 jmp	 SHORT $LN4@stbtt_GetB
$LN3@stbtt_GetB:
  0002c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf000000
  00034	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv65[rsp], xmm0
$LN4@stbtt_GetB:
  0003a	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR tv65[rsp]
  00040	f3 0f 11 44 24
	20		 movss	 DWORD PTR d3d_bias$[rsp], xmm0

; 3862 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

  00046	f3 0f 2a 44 24
	58		 cvtsi2ss xmm0, DWORD PTR pw$[rsp]
  0004c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00054	f3 0f 5e c8	 divss	 xmm1, xmm0
  00058	0f 28 c1	 movaps	 xmm0, xmm1
  0005b	f3 0f 11 44 24
	30		 movss	 DWORD PTR ipw$[rsp], xmm0
  00061	f3 0f 2a 44 24
	60		 cvtsi2ss xmm0, DWORD PTR ph$[rsp]
  00067	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0006f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00073	0f 28 c1	 movaps	 xmm0, xmm1
  00076	f3 0f 11 44 24
	34		 movss	 DWORD PTR iph$[rsp], xmm0

; 3863 :    const stbtt_bakedchar *b = chardata + char_index;

  0007c	48 63 44 24 68	 movsxd	 rax, DWORD PTR char_index$[rsp]
  00081	48 6b c0 14	 imul	 rax, rax, 20
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR chardata$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax

; 3864 :    int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);

  00095	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  0009a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  0009f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  000a3	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [rcx+8]
  000a8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000b0	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000b4	e8 00 00 00 00	 call	 floor
  000b9	f2 0f 2c c0	 cvttsd2si eax, xmm0
  000bd	89 44 24 28	 mov	 DWORD PTR round_x$[rsp], eax

; 3865 :    int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

  000c1	48 8b 44 24 78	 mov	 rax, QWORD PTR ypos$[rsp]
  000c6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  000cb	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  000cf	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [rcx+12]
  000d4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000dc	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000e0	e8 00 00 00 00	 call	 floor
  000e5	f2 0f 2c c0	 cvttsd2si eax, xmm0
  000e9	89 44 24 2c	 mov	 DWORD PTR round_y$[rsp], eax

; 3866 : 
; 3867 :    q->x0 = round_x + d3d_bias;

  000ed	f3 0f 2a 44 24
	28		 cvtsi2ss xmm0, DWORD PTR round_x$[rsp]
  000f3	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR d3d_bias$[rsp]
  000f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00101	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 3868 :    q->y0 = round_y + d3d_bias;

  00105	f3 0f 2a 44 24
	2c		 cvtsi2ss xmm0, DWORD PTR round_y$[rsp]
  0010b	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR d3d_bias$[rsp]
  00111	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  00119	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 3869 :    q->x1 = round_x + b->x1 - b->x0 + d3d_bias;

  0011e	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00123	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  00127	8b 4c 24 28	 mov	 ecx, DWORD PTR round_x$[rsp]
  0012b	03 c8		 add	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  00134	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  00137	2b c1		 sub	 eax, ecx
  00139	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0013d	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR d3d_bias$[rsp]
  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  0014b	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 3870 :    q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

  00150	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00155	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00159	8b 4c 24 2c	 mov	 ecx, DWORD PTR round_y$[rsp]
  0015d	03 c8		 add	 ecx, eax
  0015f	8b c1		 mov	 eax, ecx
  00161	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  00166	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  0016a	2b c1		 sub	 eax, ecx
  0016c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00170	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR d3d_bias$[rsp]
  00176	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  0017e	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 3871 : 
; 3872 :    q->s0 = b->x0 * ipw;

  00183	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00188	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0018b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0018f	f3 0f 59 44 24
	30		 mulss	 xmm0, DWORD PTR ipw$[rsp]
  00195	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  0019d	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 3873 :    q->t0 = b->y0 * iph;

  001a2	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  001a7	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  001ab	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001af	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR iph$[rsp]
  001b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  001bd	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 3874 :    q->s1 = b->x1 * ipw;

  001c2	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  001c7	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  001cb	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001cf	f3 0f 59 44 24
	30		 mulss	 xmm0, DWORD PTR ipw$[rsp]
  001d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  001dd	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0

; 3875 :    q->t1 = b->y1 * iph;

  001e2	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  001e7	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  001eb	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001ef	f3 0f 59 44 24
	34		 mulss	 xmm0, DWORD PTR iph$[rsp]
  001f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR q$[rsp]
  001fd	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0

; 3876 : 
; 3877 :    *xpos += b->xadvance;

  00202	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  00207	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$[rsp]
  0020c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00210	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [rcx+16]
  00215	48 8b 44 24 70	 mov	 rax, QWORD PTR xpos$[rsp]
  0021a	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 3878 : }

  0021e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00222	c3		 ret	 0
stbtt_GetBakedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\stb_truetype.h
_TEXT	SEGMENT
data$ = 96
offset$ = 104
pixel_height$ = 112
pixels$ = 120
pw$ = 128
ph$ = 136
first_char$ = 144
num_chars$ = 152
chardata$ = 160
stbtt_BakeFontBitmap PROC

; 4938 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000b	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4939 :    return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);

  00018	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR chardata$[rsp]
  00020	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00025	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR num_chars$[rsp]
  0002c	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00030	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR first_char$[rsp]
  00037	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0003b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR ph$[rsp]
  00042	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00046	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR pw$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 4c 24 78	 mov	 r9, QWORD PTR pixels$[rsp]
  00056	f3 0f 10 54 24
	70		 movss	 xmm2, DWORD PTR pixel_height$[rsp]
  0005c	8b 54 24 68	 mov	 edx, DWORD PTR offset$[rsp]
  00060	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00065	e8 00 00 00 00	 call	 ?stbtt_BakeFontBitmap_internal@@YAHPEAEHM0HHHHPEAUstbtt_bakedchar@@@Z ; stbtt_BakeFontBitmap_internal

; 4940 : }

  0006a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006e	c3		 ret	 0
stbtt_BakeFontBitmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons.h
_TEXT	SEGMENT
Result$ = 0
A$ = 32
B$ = 40
??U@YA?AW4ui_type@@W40@0@Z PROC				; operator|

; 114  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 115  :     ui_type Result = (ui_type)((int)A | (int)B);

  0000c	8b 44 24 28	 mov	 eax, DWORD PTR B$[rsp]
  00010	8b 4c 24 20	 mov	 ecx, DWORD PTR A$[rsp]
  00014	0b c8		 or	 ecx, eax
  00016	8b c1		 mov	 eax, ecx
  00018	89 04 24	 mov	 DWORD PTR Result$[rsp], eax

; 116  :     return(Result);

  0001b	8b 04 24	 mov	 eax, DWORD PTR Result$[rsp]

; 117  : }

  0001e	48 83 c4 18	 add	 rsp, 24
  00022	c3		 ret	 0
??U@YA?AW4ui_type@@W40@0@Z ENDP				; operator|
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
$T8 = 144
$T9 = 160
$T10 = 176
$T11 = 192
$T12 = 208
$T13 = 224
$T14 = 240
$T15 = 256
$T16 = 272
$T17 = 288
$T18 = 304
$T19 = 320
$T20 = 336
F$ = 400
S$ = 416
U$ = 432
$T21 = 448
$T22 = 464
$T23 = 480
$T24 = 496
$T25 = 512
$T26 = 528
__$ArrayPad$ = 592
Result$ = 640
Eye$ = 648
Center$ = 656
Up$ = 664
?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z PROC		; Mat4LookAt

; 695  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 696  :     v3 F = V3Normalize(Center - Eye);

  0002f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00034	48 8b f8	 mov	 rdi, rax
  00037	48 8b b4 24 88
	02 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  0003f	b9 0c 00 00 00	 mov	 ecx, 12
  00044	f3 a4		 rep movsb
  00046	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0004b	48 8b f8	 mov	 rdi, rax
  0004e	48 8b b4 24 90
	02 00 00	 mov	 rsi, QWORD PTR Center$[rsp]
  00056	b9 0c 00 00 00	 mov	 ecx, 12
  0005b	f3 a4		 rep movsb
  0005d	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00062	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00067	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  0006f	e8 00 00 00 00	 call	 ??G@YA?ATv3@@T0@0@Z	; operator-
  00074	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  0007c	48 8b f9	 mov	 rdi, rcx
  0007f	48 8b f0	 mov	 rsi, rax
  00082	b9 0c 00 00 00	 mov	 ecx, 12
  00087	f3 a4		 rep movsb
  00089	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  0008e	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00096	48 8b f8	 mov	 rdi, rax
  00099	48 8b f1	 mov	 rsi, rcx
  0009c	b9 0c 00 00 00	 mov	 ecx, 12
  000a1	f3 a4		 rep movsb
  000a3	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  000a8	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  000b0	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  000b5	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  000bd	48 8b f9	 mov	 rdi, rcx
  000c0	48 8b f0	 mov	 rsi, rax
  000c3	b9 0c 00 00 00	 mov	 ecx, 12
  000c8	f3 a4		 rep movsb
  000ca	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR F$[rsp]
  000d2	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  000da	48 8b f8	 mov	 rdi, rax
  000dd	48 8b f1	 mov	 rsi, rcx
  000e0	b9 0c 00 00 00	 mov	 ecx, 12
  000e5	f3 a4		 rep movsb

; 697  :     v3 S = V3Normalize(V3Cross(F, Up));

  000e7	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  000ec	48 8b f8	 mov	 rdi, rax
  000ef	48 8b b4 24 98
	02 00 00	 mov	 rsi, QWORD PTR Up$[rsp]
  000f7	b9 0c 00 00 00	 mov	 ecx, 12
  000fc	f3 a4		 rep movsb
  000fe	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  00103	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR F$[rsp]
  0010b	48 8b f8	 mov	 rdi, rax
  0010e	48 8b f1	 mov	 rsi, rcx
  00111	b9 0c 00 00 00	 mov	 ecx, 12
  00116	f3 a4		 rep movsb
  00118	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T4[rsp]
  0011d	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T5[rsp]
  00122	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  0012a	e8 00 00 00 00	 call	 ?V3Cross@@YA?ATv3@@T1@0@Z ; V3Cross
  0012f	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  00137	48 8b f9	 mov	 rdi, rcx
  0013a	48 8b f0	 mov	 rsi, rax
  0013d	b9 0c 00 00 00	 mov	 ecx, 12
  00142	f3 a4		 rep movsb
  00144	48 8d 44 24 70	 lea	 rax, QWORD PTR $T6[rsp]
  00149	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  00151	48 8b f8	 mov	 rdi, rax
  00154	48 8b f1	 mov	 rsi, rcx
  00157	b9 0c 00 00 00	 mov	 ecx, 12
  0015c	f3 a4		 rep movsb
  0015e	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T6[rsp]
  00163	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  0016b	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  00170	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  00178	48 8b f9	 mov	 rdi, rcx
  0017b	48 8b f0	 mov	 rsi, rax
  0017e	b9 0c 00 00 00	 mov	 ecx, 12
  00183	f3 a4		 rep movsb
  00185	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR S$[rsp]
  0018d	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  00195	48 8b f8	 mov	 rdi, rax
  00198	48 8b f1	 mov	 rsi, rcx
  0019b	b9 0c 00 00 00	 mov	 ecx, 12
  001a0	f3 a4		 rep movsb

; 698  :     v3 U = V3Cross(S, F);

  001a2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  001aa	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR F$[rsp]
  001b2	48 8b f8	 mov	 rdi, rax
  001b5	48 8b f1	 mov	 rsi, rcx
  001b8	b9 0c 00 00 00	 mov	 ecx, 12
  001bd	f3 a4		 rep movsb
  001bf	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  001c7	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR S$[rsp]
  001cf	48 8b f8	 mov	 rdi, rax
  001d2	48 8b f1	 mov	 rsi, rcx
  001d5	b9 0c 00 00 00	 mov	 ecx, 12
  001da	f3 a4		 rep movsb
  001dc	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR $T7[rsp]
  001e4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  001ec	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  001f4	e8 00 00 00 00	 call	 ?V3Cross@@YA?ATv3@@T1@0@Z ; V3Cross
  001f9	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00201	48 8b f9	 mov	 rdi, rcx
  00204	48 8b f0	 mov	 rsi, rax
  00207	b9 0c 00 00 00	 mov	 ecx, 12
  0020c	f3 a4		 rep movsb
  0020e	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR U$[rsp]
  00216	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  0021e	48 8b f8	 mov	 rdi, rax
  00221	48 8b f1	 mov	 rsi, rcx
  00224	b9 0c 00 00 00	 mov	 ecx, 12
  00229	f3 a4		 rep movsb

; 699  :     
; 700  :     *Result = Mat4Identity();

  0022b	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  00233	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  00238	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  00240	48 8b f9	 mov	 rdi, rcx
  00243	48 8b f0	 mov	 rsi, rax
  00246	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0024b	f3 a4		 rep movsb
  0024d	48 8d 84 24 10
	02 00 00	 lea	 rax, QWORD PTR $T26[rsp]
  00255	48 8b bc 24 80
	02 00 00	 mov	 rdi, QWORD PTR Result$[rsp]
  0025d	48 8b f0	 mov	 rsi, rax
  00260	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00265	f3 a4		 rep movsb

; 701  :     Result->m[0][0] = S.x;

  00267	b8 10 00 00 00	 mov	 eax, 16
  0026c	48 6b c0 00	 imul	 rax, rax, 0
  00270	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00278	48 03 c8	 add	 rcx, rax
  0027b	48 8b c1	 mov	 rax, rcx
  0027e	b9 04 00 00 00	 mov	 ecx, 4
  00283	48 6b c9 00	 imul	 rcx, rcx, 0
  00287	f3 0f 10 84 24
	a0 01 00 00	 movss	 xmm0, DWORD PTR S$[rsp]
  00290	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 702  :     Result->m[1][0] = S.y;

  00295	b8 10 00 00 00	 mov	 eax, 16
  0029a	48 6b c0 01	 imul	 rax, rax, 1
  0029e	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  002a6	48 03 c8	 add	 rcx, rax
  002a9	48 8b c1	 mov	 rax, rcx
  002ac	b9 04 00 00 00	 mov	 ecx, 4
  002b1	48 6b c9 00	 imul	 rcx, rcx, 0
  002b5	f3 0f 10 84 24
	a4 01 00 00	 movss	 xmm0, DWORD PTR S$[rsp+4]
  002be	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 703  :     Result->m[2][0] = S.z;

  002c3	b8 10 00 00 00	 mov	 eax, 16
  002c8	48 6b c0 02	 imul	 rax, rax, 2
  002cc	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  002d4	48 03 c8	 add	 rcx, rax
  002d7	48 8b c1	 mov	 rax, rcx
  002da	b9 04 00 00 00	 mov	 ecx, 4
  002df	48 6b c9 00	 imul	 rcx, rcx, 0
  002e3	f3 0f 10 84 24
	a8 01 00 00	 movss	 xmm0, DWORD PTR S$[rsp+8]
  002ec	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 704  :     Result->m[0][1] = U.x;

  002f1	b8 10 00 00 00	 mov	 eax, 16
  002f6	48 6b c0 00	 imul	 rax, rax, 0
  002fa	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00302	48 03 c8	 add	 rcx, rax
  00305	48 8b c1	 mov	 rax, rcx
  00308	b9 04 00 00 00	 mov	 ecx, 4
  0030d	48 6b c9 01	 imul	 rcx, rcx, 1
  00311	f3 0f 10 84 24
	b0 01 00 00	 movss	 xmm0, DWORD PTR U$[rsp]
  0031a	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 705  :     Result->m[1][1] = U.y;

  0031f	b8 10 00 00 00	 mov	 eax, 16
  00324	48 6b c0 01	 imul	 rax, rax, 1
  00328	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00330	48 03 c8	 add	 rcx, rax
  00333	48 8b c1	 mov	 rax, rcx
  00336	b9 04 00 00 00	 mov	 ecx, 4
  0033b	48 6b c9 01	 imul	 rcx, rcx, 1
  0033f	f3 0f 10 84 24
	b4 01 00 00	 movss	 xmm0, DWORD PTR U$[rsp+4]
  00348	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 706  :     Result->m[2][1] = U.z;

  0034d	b8 10 00 00 00	 mov	 eax, 16
  00352	48 6b c0 02	 imul	 rax, rax, 2
  00356	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  0035e	48 03 c8	 add	 rcx, rax
  00361	48 8b c1	 mov	 rax, rcx
  00364	b9 04 00 00 00	 mov	 ecx, 4
  00369	48 6b c9 01	 imul	 rcx, rcx, 1
  0036d	f3 0f 10 84 24
	b8 01 00 00	 movss	 xmm0, DWORD PTR U$[rsp+8]
  00376	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 707  :     Result->m[0][2] = -F.x;

  0037b	f3 0f 10 84 24
	90 01 00 00	 movss	 xmm0, DWORD PTR F$[rsp]
  00384	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0038b	b8 10 00 00 00	 mov	 eax, 16
  00390	48 6b c0 00	 imul	 rax, rax, 0
  00394	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  0039c	48 03 c8	 add	 rcx, rax
  0039f	48 8b c1	 mov	 rax, rcx
  003a2	b9 04 00 00 00	 mov	 ecx, 4
  003a7	48 6b c9 02	 imul	 rcx, rcx, 2
  003ab	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 708  :     Result->m[1][2] = -F.y;

  003b0	f3 0f 10 84 24
	94 01 00 00	 movss	 xmm0, DWORD PTR F$[rsp+4]
  003b9	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003c0	b8 10 00 00 00	 mov	 eax, 16
  003c5	48 6b c0 01	 imul	 rax, rax, 1
  003c9	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  003d1	48 03 c8	 add	 rcx, rax
  003d4	48 8b c1	 mov	 rax, rcx
  003d7	b9 04 00 00 00	 mov	 ecx, 4
  003dc	48 6b c9 02	 imul	 rcx, rcx, 2
  003e0	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 709  :     Result->m[2][2] = -F.z;

  003e5	f3 0f 10 84 24
	98 01 00 00	 movss	 xmm0, DWORD PTR F$[rsp+8]
  003ee	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003f5	b8 10 00 00 00	 mov	 eax, 16
  003fa	48 6b c0 02	 imul	 rax, rax, 2
  003fe	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00406	48 03 c8	 add	 rcx, rax
  00409	48 8b c1	 mov	 rax, rcx
  0040c	b9 04 00 00 00	 mov	 ecx, 4
  00411	48 6b c9 02	 imul	 rcx, rcx, 2
  00415	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 710  :     Result->m[3][0] = -V3MultiplyDot(S, Eye);

  0041a	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  00422	48 8b f8	 mov	 rdi, rax
  00425	48 8b b4 24 88
	02 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  0042d	b9 0c 00 00 00	 mov	 ecx, 12
  00432	f3 a4		 rep movsb
  00434	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  0043c	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR S$[rsp]
  00444	48 8b f8	 mov	 rdi, rax
  00447	48 8b f1	 mov	 rsi, rcx
  0044a	b9 0c 00 00 00	 mov	 ecx, 12
  0044f	f3 a4		 rep movsb
  00451	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  00459	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00461	e8 00 00 00 00	 call	 ?V3MultiplyDot@@YAMTv3@@0@Z ; V3MultiplyDot
  00466	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0046d	b8 10 00 00 00	 mov	 eax, 16
  00472	48 6b c0 03	 imul	 rax, rax, 3
  00476	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  0047e	48 03 c8	 add	 rcx, rax
  00481	48 8b c1	 mov	 rax, rcx
  00484	b9 04 00 00 00	 mov	 ecx, 4
  00489	48 6b c9 00	 imul	 rcx, rcx, 0
  0048d	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 711  :     Result->m[3][1] = -V3MultiplyDot(U, Eye);

  00492	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  0049a	48 8b f8	 mov	 rdi, rax
  0049d	48 8b b4 24 88
	02 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  004a5	b9 0c 00 00 00	 mov	 ecx, 12
  004aa	f3 a4		 rep movsb
  004ac	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  004b4	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR U$[rsp]
  004bc	48 8b f8	 mov	 rdi, rax
  004bf	48 8b f1	 mov	 rsi, rcx
  004c2	b9 0c 00 00 00	 mov	 ecx, 12
  004c7	f3 a4		 rep movsb
  004c9	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T11[rsp]
  004d1	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  004d9	e8 00 00 00 00	 call	 ?V3MultiplyDot@@YAMTv3@@0@Z ; V3MultiplyDot
  004de	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  004e5	b8 10 00 00 00	 mov	 eax, 16
  004ea	48 6b c0 03	 imul	 rax, rax, 3
  004ee	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  004f6	48 03 c8	 add	 rcx, rax
  004f9	48 8b c1	 mov	 rax, rcx
  004fc	b9 04 00 00 00	 mov	 ecx, 4
  00501	48 6b c9 01	 imul	 rcx, rcx, 1
  00505	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 712  :     Result->m[3][2] = V3MultiplyDot(F, Eye);

  0050a	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T13[rsp]
  00512	48 8b f8	 mov	 rdi, rax
  00515	48 8b b4 24 88
	02 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  0051d	b9 0c 00 00 00	 mov	 ecx, 12
  00522	f3 a4		 rep movsb
  00524	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T14[rsp]
  0052c	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR F$[rsp]
  00534	48 8b f8	 mov	 rdi, rax
  00537	48 8b f1	 mov	 rsi, rcx
  0053a	b9 0c 00 00 00	 mov	 ecx, 12
  0053f	f3 a4		 rep movsb
  00541	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  00549	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  00551	e8 00 00 00 00	 call	 ?V3MultiplyDot@@YAMTv3@@0@Z ; V3MultiplyDot
  00556	b8 10 00 00 00	 mov	 eax, 16
  0055b	48 6b c0 03	 imul	 rax, rax, 3
  0055f	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00567	48 03 c8	 add	 rcx, rax
  0056a	48 8b c1	 mov	 rax, rcx
  0056d	b9 04 00 00 00	 mov	 ecx, 4
  00572	48 6b c9 02	 imul	 rcx, rcx, 2
  00576	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 713  : }

  0057b	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00583	48 33 cc	 xor	 rcx, rsp
  00586	e8 00 00 00 00	 call	 __security_check_cookie
  0058b	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  00592	5f		 pop	 rdi
  00593	5e		 pop	 rsi
  00594	c3		 ret	 0
?Mat4LookAt@@YAXPEATmat4@@Tv3@@11@Z ENDP		; Mat4LookAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
Result$ = 96
$T2 = 160
__$ArrayPad$ = 224
Mat4$ = 272
Left$ = 280
Right$ = 288
Top$ = 296
Bottom$ = 304
Near$ = 312
Far$ = 320
?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z PROC		; CreateOrthographic

; 681  : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	56		 push	 rsi
  00018	57		 push	 rdi
  00019	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 682  :     mat4 Result = Mat4Identity();

  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00037	e8 00 00 00 00	 call	 ?Mat4Identity@@YA?ATmat4@@XZ ; Mat4Identity
  0003c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  00044	48 8b f9	 mov	 rdi, rcx
  00047	48 8b f0	 mov	 rsi, rax
  0004a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0004f	f3 a4		 rep movsb
  00051	48 8d 44 24 60	 lea	 rax, QWORD PTR Result$[rsp]
  00056	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  0005e	48 8b f8	 mov	 rdi, rax
  00061	48 8b f1	 mov	 rsi, rcx
  00064	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00069	f3 a4		 rep movsb

; 683  :     Result.m[0][0] = 2.0f / (Right - Left);

  0006b	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR Right$[rsp]
  00074	f3 0f 5c 84 24
	18 01 00 00	 subss	 xmm0, DWORD PTR Left$[rsp]
  0007d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  00085	f3 0f 5e c8	 divss	 xmm1, xmm0
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	b8 10 00 00 00	 mov	 eax, 16
  00091	48 6b c0 00	 imul	 rax, rax, 0
  00095	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0009a	b9 04 00 00 00	 mov	 ecx, 4
  0009f	48 6b c9 00	 imul	 rcx, rcx, 0
  000a3	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 684  :     Result.m[1][1] = 2.0f / (Top - Bottom);

  000a8	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR Top$[rsp]
  000b1	f3 0f 5c 84 24
	30 01 00 00	 subss	 xmm0, DWORD PTR Bottom$[rsp]
  000ba	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  000c2	f3 0f 5e c8	 divss	 xmm1, xmm0
  000c6	0f 28 c1	 movaps	 xmm0, xmm1
  000c9	b8 10 00 00 00	 mov	 eax, 16
  000ce	48 6b c0 01	 imul	 rax, rax, 1
  000d2	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000d7	b9 04 00 00 00	 mov	 ecx, 4
  000dc	48 6b c9 01	 imul	 rcx, rcx, 1
  000e0	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 685  :     Result.m[2][2] = -2.0f / (Far - Near);

  000e5	f3 0f 10 84 24
	40 01 00 00	 movss	 xmm0, DWORD PTR Far$[rsp]
  000ee	f3 0f 5c 84 24
	38 01 00 00	 subss	 xmm0, DWORD PTR Near$[rsp]
  000f7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@c0000000
  000ff	f3 0f 5e c8	 divss	 xmm1, xmm0
  00103	0f 28 c1	 movaps	 xmm0, xmm1
  00106	b8 10 00 00 00	 mov	 eax, 16
  0010b	48 6b c0 02	 imul	 rax, rax, 2
  0010f	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00114	b9 04 00 00 00	 mov	 ecx, 4
  00119	48 6b c9 02	 imul	 rcx, rcx, 2
  0011d	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 686  :     Result.m[3][0] = -(Right + Left) / (Right - Left);

  00122	f3 0f 10 84 24
	20 01 00 00	 movss	 xmm0, DWORD PTR Right$[rsp]
  0012b	f3 0f 58 84 24
	18 01 00 00	 addss	 xmm0, DWORD PTR Left$[rsp]
  00134	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0013b	f3 0f 10 8c 24
	20 01 00 00	 movss	 xmm1, DWORD PTR Right$[rsp]
  00144	f3 0f 5c 8c 24
	18 01 00 00	 subss	 xmm1, DWORD PTR Left$[rsp]
  0014d	f3 0f 5e c1	 divss	 xmm0, xmm1
  00151	b8 10 00 00 00	 mov	 eax, 16
  00156	48 6b c0 03	 imul	 rax, rax, 3
  0015a	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0015f	b9 04 00 00 00	 mov	 ecx, 4
  00164	48 6b c9 00	 imul	 rcx, rcx, 0
  00168	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 687  :     Result.m[3][1] = -(Top + Bottom) / (Top - Bottom);

  0016d	f3 0f 10 84 24
	28 01 00 00	 movss	 xmm0, DWORD PTR Top$[rsp]
  00176	f3 0f 58 84 24
	30 01 00 00	 addss	 xmm0, DWORD PTR Bottom$[rsp]
  0017f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00186	f3 0f 10 8c 24
	28 01 00 00	 movss	 xmm1, DWORD PTR Top$[rsp]
  0018f	f3 0f 5c 8c 24
	30 01 00 00	 subss	 xmm1, DWORD PTR Bottom$[rsp]
  00198	f3 0f 5e c1	 divss	 xmm0, xmm1
  0019c	b8 10 00 00 00	 mov	 eax, 16
  001a1	48 6b c0 03	 imul	 rax, rax, 3
  001a5	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  001aa	b9 04 00 00 00	 mov	 ecx, 4
  001af	48 6b c9 01	 imul	 rcx, rcx, 1
  001b3	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 688  :     Result.m[3][2] = -(Far + Near) / (Far - Near);

  001b8	f3 0f 10 84 24
	40 01 00 00	 movss	 xmm0, DWORD PTR Far$[rsp]
  001c1	f3 0f 58 84 24
	38 01 00 00	 addss	 xmm0, DWORD PTR Near$[rsp]
  001ca	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001d1	f3 0f 10 8c 24
	40 01 00 00	 movss	 xmm1, DWORD PTR Far$[rsp]
  001da	f3 0f 5c 8c 24
	38 01 00 00	 subss	 xmm1, DWORD PTR Near$[rsp]
  001e3	f3 0f 5e c1	 divss	 xmm0, xmm1
  001e7	b8 10 00 00 00	 mov	 eax, 16
  001ec	48 6b c0 03	 imul	 rax, rax, 3
  001f0	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  001f5	b9 04 00 00 00	 mov	 ecx, 4
  001fa	48 6b c9 02	 imul	 rcx, rcx, 2
  001fe	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 689  :     
; 690  :     *Mat4 = Result;

  00203	48 8d 44 24 60	 lea	 rax, QWORD PTR Result$[rsp]
  00208	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR Mat4$[rsp]
  00210	48 8b f0	 mov	 rsi, rax
  00213	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00218	f3 a4		 rep movsb

; 691  : }

  0021a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00222	48 33 cc	 xor	 rcx, rsp
  00225	e8 00 00 00 00	 call	 __security_check_cookie
  0022a	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00231	5f		 pop	 rdi
  00232	5e		 pop	 rsi
  00233	c3		 ret	 0
?CreateOrthographic@@YAXPEATmat4@@MMMMMM@Z ENDP		; CreateOrthographic
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
TanHalfFOV$ = 32
Result$ = 48
__$ArrayPad$ = 112
Mat4$ = 160
Aspect$ = 168
FOV$ = 176
Near$ = 184
Far$ = 192
?CreatePerspective@@YAXPEATmat4@@MMMM@Z PROC		; CreatePerspective

; 661  : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	56		 push	 rsi
  00018	57		 push	 rdi
  00019	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 662  :     Assert(Abs(Aspect - EPSILON) > 0.0f);

  0002f	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR Aspect$[rsp]
  00038	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@34000000
  00040	e8 00 00 00 00	 call	 ?Abs@@YAMM@Z		; Abs
  00045	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0004c	77 0b		 ja	 SHORT $LN2@CreatePers
  0004e	c7 04 25 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ds:0, 0
$LN2@CreatePers:

; 663  :     
; 664  :     f32 TanHalfFOV = Tan(FOV / 2.0f);

  00059	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR FOV$[rsp]
  00062	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0006a	e8 00 00 00 00	 call	 ?Tan@@YAMM@Z		; Tan
  0006f	f3 0f 11 44 24
	20		 movss	 DWORD PTR TanHalfFOV$[rsp], xmm0

; 665  :     
; 666  :     mat4 Result = {0};

  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 44 24
	30		 movss	 DWORD PTR Result$[rsp], xmm0
  0007e	48 8d 44 24 34	 lea	 rax, QWORD PTR Result$[rsp+4]
  00083	48 8b f8	 mov	 rdi, rax
  00086	33 c0		 xor	 eax, eax
  00088	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0008d	f3 aa		 rep stosb

; 667  :     Result.m[0][0] = 1.0f / (Aspect * TanHalfFOV);

  0008f	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR Aspect$[rsp]
  00098	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR TanHalfFOV$[rsp]
  0009e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  000a6	f3 0f 5e c8	 divss	 xmm1, xmm0
  000aa	0f 28 c1	 movaps	 xmm0, xmm1
  000ad	b8 10 00 00 00	 mov	 eax, 16
  000b2	48 6b c0 00	 imul	 rax, rax, 0
  000b6	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000bb	b9 04 00 00 00	 mov	 ecx, 4
  000c0	48 6b c9 00	 imul	 rcx, rcx, 0
  000c4	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 668  :     Result.m[1][1] = 1.0f / (TanHalfFOV);

  000c9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d1	f3 0f 5e 44 24
	20		 divss	 xmm0, DWORD PTR TanHalfFOV$[rsp]
  000d7	b8 10 00 00 00	 mov	 eax, 16
  000dc	48 6b c0 01	 imul	 rax, rax, 1
  000e0	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	48 6b c9 01	 imul	 rcx, rcx, 1
  000ee	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 669  :     Result.m[2][2] = Far / (Far - Near);

  000f3	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR Far$[rsp]
  000fc	f3 0f 5c 84 24
	b8 00 00 00	 subss	 xmm0, DWORD PTR Near$[rsp]
  00105	f3 0f 10 8c 24
	c0 00 00 00	 movss	 xmm1, DWORD PTR Far$[rsp]
  0010e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00112	0f 28 c1	 movaps	 xmm0, xmm1
  00115	b8 10 00 00 00	 mov	 eax, 16
  0011a	48 6b c0 02	 imul	 rax, rax, 2
  0011e	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00123	b9 04 00 00 00	 mov	 ecx, 4
  00128	48 6b c9 02	 imul	 rcx, rcx, 2
  0012c	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 670  :     Result.m[2][3] = 1.0f;

  00131	b8 10 00 00 00	 mov	 eax, 16
  00136	48 6b c0 02	 imul	 rax, rax, 2
  0013a	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0013f	b9 04 00 00 00	 mov	 ecx, 4
  00144	48 6b c9 03	 imul	 rcx, rcx, 3
  00148	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00150	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 671  :     Result.m[3][2] = -(Far*Near) / (Far - Near);

  00155	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR Far$[rsp]
  0015e	f3 0f 59 84 24
	b8 00 00 00	 mulss	 xmm0, DWORD PTR Near$[rsp]
  00167	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0016e	f3 0f 10 8c 24
	c0 00 00 00	 movss	 xmm1, DWORD PTR Far$[rsp]
  00177	f3 0f 5c 8c 24
	b8 00 00 00	 subss	 xmm1, DWORD PTR Near$[rsp]
  00180	f3 0f 5e c1	 divss	 xmm0, xmm1
  00184	b8 10 00 00 00	 mov	 eax, 16
  00189	48 6b c0 03	 imul	 rax, rax, 3
  0018d	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00192	b9 04 00 00 00	 mov	 ecx, 4
  00197	48 6b c9 02	 imul	 rcx, rcx, 2
  0019b	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 672  :     
; 673  :     *Mat4 = Result;

  001a0	48 8d 44 24 30	 lea	 rax, QWORD PTR Result$[rsp]
  001a5	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR Mat4$[rsp]
  001ad	48 8b f0	 mov	 rsi, rax
  001b0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001b5	f3 a4		 rep movsb

; 674  : }

  001b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bc	48 33 cc	 xor	 rcx, rsp
  001bf	e8 00 00 00 00	 call	 __security_check_cookie
  001c4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001cb	5f		 pop	 rdi
  001cc	5e		 pop	 rsi
  001cd	c3		 ret	 0
?CreatePerspective@@YAXPEATmat4@@MMMM@Z ENDP		; CreatePerspective
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
$T8 = 144
$T9 = 160
__$ArrayPad$ = 176
Result$ = 224
Scale$ = 232
?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z PROC			; ScaleMat4

; 653  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 654  :     Result->e[0] = Result->e[0] * Scale.x;

  00025	b8 10 00 00 00	 mov	 eax, 16
  0002a	48 6b c0 00	 imul	 rax, rax, 0
  0002e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00033	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  0003b	48 8b f9	 mov	 rdi, rcx
  0003e	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f3 a4		 rep movsb
  00049	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Scale$[rsp]
  00051	f3 0f 10 10	 movss	 xmm2, DWORD PTR [rax]
  00055	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0005a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  0005f	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00064	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0006c	48 8b f9	 mov	 rdi, rcx
  0006f	48 8b f0	 mov	 rsi, rax
  00072	b9 10 00 00 00	 mov	 ecx, 16
  00077	f3 a4		 rep movsb
  00079	b8 10 00 00 00	 mov	 eax, 16
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  0008a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  00092	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00096	48 8b f2	 mov	 rsi, rdx
  00099	b9 10 00 00 00	 mov	 ecx, 16
  0009e	f3 a4		 rep movsb

; 655  :     Result->e[1] = Result->e[1] * Scale.y;

  000a0	b8 10 00 00 00	 mov	 eax, 16
  000a5	48 6b c0 01	 imul	 rax, rax, 1
  000a9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  000ae	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  000b6	48 8b f9	 mov	 rdi, rcx
  000b9	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000bd	b9 10 00 00 00	 mov	 ecx, 16
  000c2	f3 a4		 rep movsb
  000c4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Scale$[rsp]
  000cc	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [rax+4]
  000d1	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  000d6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T5[rsp]
  000db	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  000e0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  000e8	48 8b f9	 mov	 rdi, rcx
  000eb	48 8b f0	 mov	 rsi, rax
  000ee	b9 10 00 00 00	 mov	 ecx, 16
  000f3	f3 a4		 rep movsb
  000f5	b8 10 00 00 00	 mov	 eax, 16
  000fa	48 6b c0 01	 imul	 rax, rax, 1
  000fe	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00106	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  0010e	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00112	48 8b f2	 mov	 rsi, rdx
  00115	b9 10 00 00 00	 mov	 ecx, 16
  0011a	f3 a4		 rep movsb

; 656  :     Result->e[2] = Result->e[2] * Scale.z;

  0011c	b8 10 00 00 00	 mov	 eax, 16
  00121	48 6b c0 02	 imul	 rax, rax, 2
  00125	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0012a	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  00132	48 8b f9	 mov	 rdi, rcx
  00135	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00139	b9 10 00 00 00	 mov	 ecx, 16
  0013e	f3 a4		 rep movsb
  00140	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Scale$[rsp]
  00148	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [rax+8]
  0014d	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  00152	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T6[rsp]
  00157	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  0015c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00164	48 8b f9	 mov	 rdi, rcx
  00167	48 8b f0	 mov	 rsi, rax
  0016a	b9 10 00 00 00	 mov	 ecx, 16
  0016f	f3 a4		 rep movsb
  00171	b8 10 00 00 00	 mov	 eax, 16
  00176	48 6b c0 02	 imul	 rax, rax, 2
  0017a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00182	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  0018a	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  0018e	48 8b f2	 mov	 rsi, rdx
  00191	b9 10 00 00 00	 mov	 ecx, 16
  00196	f3 a4		 rep movsb

; 657  : }

  00198	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a0	48 33 cc	 xor	 rcx, rsp
  001a3	e8 00 00 00 00	 call	 __security_check_cookie
  001a8	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001af	5f		 pop	 rdi
  001b0	5e		 pop	 rsi
  001b1	c3		 ret	 0
?ScaleMat4@@YAXPEATmat4@@Tv3@@@Z ENDP			; ScaleMat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
S$ = 32
C$ = 36
tv230 = 40
tv242 = 48
tv254 = 56
tv278 = 64
tv322 = 72
tv334 = 80
tv358 = 88
tv370 = 96
tv382 = 104
$T1 = 112
$T2 = 128
$T3 = 144
$T4 = 160
$T5 = 176
$T6 = 192
$T7 = 208
$T8 = 224
$T9 = 240
$T10 = 256
$T11 = 272
$T12 = 288
$T13 = 304
$T14 = 320
$T15 = 336
$T16 = 352
$T17 = 368
$T18 = 384
$T19 = 400
$T20 = 416
$T21 = 432
$T22 = 448
$T23 = 464
$T24 = 480
$T25 = 496
$T26 = 512
$T27 = 528
$T28 = 544
$T29 = 560
$T30 = 576
$T31 = 592
$T32 = 608
$T33 = 624
$T34 = 640
$T35 = 656
$T36 = 672
$T37 = 688
$T38 = 704
$T39 = 720
$T40 = 736
Axis$ = 752
Temp$ = 768
Second$ = 784
First$ = 800
Third$ = 816
Rotate$ = 832
$T41 = 896
$T42 = 912
$T43 = 928
$T44 = 944
$T45 = 960
$T46 = 976
$T47 = 992
$T48 = 1008
$T49 = 1024
$T50 = 1040
$T51 = 1056
$T52 = 1072
$T53 = 1088
$T54 = 1104
$T55 = 1120
$T56 = 1136
$T57 = 1152
Result$ = 1168
__$ArrayPad$ = 1232
OutResult$ = 1280
Angle$ = 1288
RawAxis$ = 1296
?RotateMat4@@YAXPEATmat4@@MTv3@@@Z PROC			; RotateMat4

; 607  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec e8 04
	00 00		 sub	 rsp, 1256		; 000004e8H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 608  :     f32 C = Cos(Angle);

  0002b	f3 0f 10 84 24
	08 05 00 00	 movss	 xmm0, DWORD PTR Angle$[rsp]
  00034	e8 00 00 00 00	 call	 ?Cos@@YAMM@Z		; Cos
  00039	f3 0f 11 44 24
	24		 movss	 DWORD PTR C$[rsp], xmm0

; 609  :     f32 S = Sin(Angle);

  0003f	f3 0f 10 84 24
	08 05 00 00	 movss	 xmm0, DWORD PTR Angle$[rsp]
  00048	e8 00 00 00 00	 call	 ?Sin@@YAMM@Z		; Sin
  0004d	f3 0f 11 44 24
	20		 movss	 DWORD PTR S$[rsp], xmm0

; 610  :     
; 611  :     v3 Axis = V3Normalize(RawAxis);

  00053	48 8d 44 24 70	 lea	 rax, QWORD PTR $T1[rsp]
  00058	48 8b f8	 mov	 rdi, rax
  0005b	48 8b b4 24 10
	05 00 00	 mov	 rsi, QWORD PTR RawAxis$[rsp]
  00063	b9 0c 00 00 00	 mov	 ecx, 12
  00068	f3 a4		 rep movsb
  0006a	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T1[rsp]
  0006f	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  00077	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  0007c	48 8d 8c 24 80
	03 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  00084	48 8b f9	 mov	 rdi, rcx
  00087	48 8b f0	 mov	 rsi, rax
  0008a	b9 0c 00 00 00	 mov	 ecx, 12
  0008f	f3 a4		 rep movsb
  00091	48 8d 84 24 f0
	02 00 00	 lea	 rax, QWORD PTR Axis$[rsp]
  00099	48 8d 8c 24 80
	03 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  000a1	48 8b f8	 mov	 rdi, rax
  000a4	48 8b f1	 mov	 rsi, rcx
  000a7	b9 0c 00 00 00	 mov	 ecx, 12
  000ac	f3 a4		 rep movsb

; 612  :     v3 Temp = Axis * (1.0f - C);

  000ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b6	f3 0f 5c 44 24
	24		 subss	 xmm0, DWORD PTR C$[rsp]
  000bc	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T2[rsp]
  000c4	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR Axis$[rsp]
  000cc	48 8b f8	 mov	 rdi, rax
  000cf	48 8b f1	 mov	 rsi, rcx
  000d2	b9 0c 00 00 00	 mov	 ecx, 12
  000d7	f3 a4		 rep movsb
  000d9	0f 28 d0	 movaps	 xmm2, xmm0
  000dc	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T2[rsp]
  000e4	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  000ec	e8 00 00 00 00	 call	 ??D@YA?ATv3@@T0@M@Z	; operator*
  000f1	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  000f9	48 8b f9	 mov	 rdi, rcx
  000fc	48 8b f0	 mov	 rsi, rax
  000ff	b9 0c 00 00 00	 mov	 ecx, 12
  00104	f3 a4		 rep movsb
  00106	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR Temp$[rsp]
  0010e	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  00116	48 8b f8	 mov	 rdi, rax
  00119	48 8b f1	 mov	 rsi, rcx
  0011c	b9 0c 00 00 00	 mov	 ecx, 12
  00121	f3 a4		 rep movsb

; 613  :     
; 614  :     mat4 Rotate = {0};

  00123	0f 57 c0	 xorps	 xmm0, xmm0
  00126	f3 0f 11 84 24
	40 03 00 00	 movss	 DWORD PTR Rotate$[rsp], xmm0
  0012f	48 8d 84 24 44
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+4]
  00137	48 8b f8	 mov	 rdi, rax
  0013a	33 c0		 xor	 eax, eax
  0013c	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00141	f3 aa		 rep stosb

; 615  :     Rotate.m[0][0] = C + Temp.e[0]*Axis.e[0];

  00143	b8 04 00 00 00	 mov	 eax, 4
  00148	48 6b c0 00	 imul	 rax, rax, 0
  0014c	b9 04 00 00 00	 mov	 ecx, 4
  00151	48 6b c9 00	 imul	 rcx, rcx, 0
  00155	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  0015e	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  00167	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR C$[rsp]
  0016d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00171	0f 28 c1	 movaps	 xmm0, xmm1
  00174	b8 10 00 00 00	 mov	 eax, 16
  00179	48 6b c0 00	 imul	 rax, rax, 0
  0017d	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00185	b9 04 00 00 00	 mov	 ecx, 4
  0018a	48 6b c9 00	 imul	 rcx, rcx, 0
  0018e	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 616  :     Rotate.m[0][1] = Temp.e[0]*Axis.e[1] + S*Axis.e[2];

  00193	b8 04 00 00 00	 mov	 eax, 4
  00198	48 6b c0 00	 imul	 rax, rax, 0
  0019c	b9 04 00 00 00	 mov	 ecx, 4
  001a1	48 6b c9 01	 imul	 rcx, rcx, 1
  001a5	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  001ae	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  001b7	b8 04 00 00 00	 mov	 eax, 4
  001bc	48 6b c0 02	 imul	 rax, rax, 2
  001c0	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR S$[rsp]
  001c6	f3 0f 59 8c 04
	f0 02 00 00	 mulss	 xmm1, DWORD PTR Axis$[rsp+rax]
  001cf	f3 0f 58 c1	 addss	 xmm0, xmm1
  001d3	b8 10 00 00 00	 mov	 eax, 16
  001d8	48 6b c0 00	 imul	 rax, rax, 0
  001dc	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  001e4	b9 04 00 00 00	 mov	 ecx, 4
  001e9	48 6b c9 01	 imul	 rcx, rcx, 1
  001ed	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 617  :     Rotate.m[0][2] = Temp.e[0]*Axis.e[2] - S*Axis.e[1];

  001f2	b8 04 00 00 00	 mov	 eax, 4
  001f7	48 6b c0 00	 imul	 rax, rax, 0
  001fb	b9 04 00 00 00	 mov	 ecx, 4
  00200	48 6b c9 02	 imul	 rcx, rcx, 2
  00204	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  0020d	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  00216	b8 04 00 00 00	 mov	 eax, 4
  0021b	48 6b c0 01	 imul	 rax, rax, 1
  0021f	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR S$[rsp]
  00225	f3 0f 59 8c 04
	f0 02 00 00	 mulss	 xmm1, DWORD PTR Axis$[rsp+rax]
  0022e	f3 0f 5c c1	 subss	 xmm0, xmm1
  00232	b8 10 00 00 00	 mov	 eax, 16
  00237	48 6b c0 00	 imul	 rax, rax, 0
  0023b	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00243	b9 04 00 00 00	 mov	 ecx, 4
  00248	48 6b c9 02	 imul	 rcx, rcx, 2
  0024c	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 618  :     
; 619  :     Rotate.m[1][0] = Temp.e[1]*Axis.e[0] - S*Axis.e[2];

  00251	b8 04 00 00 00	 mov	 eax, 4
  00256	48 6b c0 01	 imul	 rax, rax, 1
  0025a	b9 04 00 00 00	 mov	 ecx, 4
  0025f	48 6b c9 00	 imul	 rcx, rcx, 0
  00263	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  0026c	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  00275	b8 04 00 00 00	 mov	 eax, 4
  0027a	48 6b c0 02	 imul	 rax, rax, 2
  0027e	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR S$[rsp]
  00284	f3 0f 59 8c 04
	f0 02 00 00	 mulss	 xmm1, DWORD PTR Axis$[rsp+rax]
  0028d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00291	b8 10 00 00 00	 mov	 eax, 16
  00296	48 6b c0 01	 imul	 rax, rax, 1
  0029a	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  002a2	b9 04 00 00 00	 mov	 ecx, 4
  002a7	48 6b c9 00	 imul	 rcx, rcx, 0
  002ab	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 620  :     Rotate.m[1][1] = C + Temp.e[1]*Axis.e[1];

  002b0	b8 04 00 00 00	 mov	 eax, 4
  002b5	48 6b c0 01	 imul	 rax, rax, 1
  002b9	b9 04 00 00 00	 mov	 ecx, 4
  002be	48 6b c9 01	 imul	 rcx, rcx, 1
  002c2	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  002cb	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  002d4	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR C$[rsp]
  002da	f3 0f 58 c8	 addss	 xmm1, xmm0
  002de	0f 28 c1	 movaps	 xmm0, xmm1
  002e1	b8 10 00 00 00	 mov	 eax, 16
  002e6	48 6b c0 01	 imul	 rax, rax, 1
  002ea	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  002f2	b9 04 00 00 00	 mov	 ecx, 4
  002f7	48 6b c9 01	 imul	 rcx, rcx, 1
  002fb	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 621  :     Rotate.m[1][2] = Temp.e[1]*Axis.e[2] + S*Axis.e[0];

  00300	b8 04 00 00 00	 mov	 eax, 4
  00305	48 6b c0 01	 imul	 rax, rax, 1
  00309	b9 04 00 00 00	 mov	 ecx, 4
  0030e	48 6b c9 02	 imul	 rcx, rcx, 2
  00312	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  0031b	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  00324	b8 04 00 00 00	 mov	 eax, 4
  00329	48 6b c0 00	 imul	 rax, rax, 0
  0032d	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR S$[rsp]
  00333	f3 0f 59 8c 04
	f0 02 00 00	 mulss	 xmm1, DWORD PTR Axis$[rsp+rax]
  0033c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00340	b8 10 00 00 00	 mov	 eax, 16
  00345	48 6b c0 01	 imul	 rax, rax, 1
  00349	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00351	b9 04 00 00 00	 mov	 ecx, 4
  00356	48 6b c9 02	 imul	 rcx, rcx, 2
  0035a	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 622  :     
; 623  :     Rotate.m[2][0] = Temp.e[2]*Axis.e[0] + S*Axis.e[1];

  0035f	b8 04 00 00 00	 mov	 eax, 4
  00364	48 6b c0 02	 imul	 rax, rax, 2
  00368	b9 04 00 00 00	 mov	 ecx, 4
  0036d	48 6b c9 00	 imul	 rcx, rcx, 0
  00371	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  0037a	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  00383	b8 04 00 00 00	 mov	 eax, 4
  00388	48 6b c0 01	 imul	 rax, rax, 1
  0038c	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR S$[rsp]
  00392	f3 0f 59 8c 04
	f0 02 00 00	 mulss	 xmm1, DWORD PTR Axis$[rsp+rax]
  0039b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0039f	b8 10 00 00 00	 mov	 eax, 16
  003a4	48 6b c0 02	 imul	 rax, rax, 2
  003a8	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  003b0	b9 04 00 00 00	 mov	 ecx, 4
  003b5	48 6b c9 00	 imul	 rcx, rcx, 0
  003b9	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 624  :     Rotate.m[2][1] = Temp.e[2]*Axis.e[1] - S*Axis.e[0];

  003be	b8 04 00 00 00	 mov	 eax, 4
  003c3	48 6b c0 02	 imul	 rax, rax, 2
  003c7	b9 04 00 00 00	 mov	 ecx, 4
  003cc	48 6b c9 01	 imul	 rcx, rcx, 1
  003d0	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  003d9	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  003e2	b8 04 00 00 00	 mov	 eax, 4
  003e7	48 6b c0 00	 imul	 rax, rax, 0
  003eb	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR S$[rsp]
  003f1	f3 0f 59 8c 04
	f0 02 00 00	 mulss	 xmm1, DWORD PTR Axis$[rsp+rax]
  003fa	f3 0f 5c c1	 subss	 xmm0, xmm1
  003fe	b8 10 00 00 00	 mov	 eax, 16
  00403	48 6b c0 02	 imul	 rax, rax, 2
  00407	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  0040f	b9 04 00 00 00	 mov	 ecx, 4
  00414	48 6b c9 01	 imul	 rcx, rcx, 1
  00418	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 625  :     Rotate.m[2][2] = C + Temp.e[2]*Axis.e[2];

  0041d	b8 04 00 00 00	 mov	 eax, 4
  00422	48 6b c0 02	 imul	 rax, rax, 2
  00426	b9 04 00 00 00	 mov	 ecx, 4
  0042b	48 6b c9 02	 imul	 rcx, rcx, 2
  0042f	f3 0f 10 84 04
	00 03 00 00	 movss	 xmm0, DWORD PTR Temp$[rsp+rax]
  00438	f3 0f 59 84 0c
	f0 02 00 00	 mulss	 xmm0, DWORD PTR Axis$[rsp+rcx]
  00441	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR C$[rsp]
  00447	f3 0f 58 c8	 addss	 xmm1, xmm0
  0044b	0f 28 c1	 movaps	 xmm0, xmm1
  0044e	b8 10 00 00 00	 mov	 eax, 16
  00453	48 6b c0 02	 imul	 rax, rax, 2
  00457	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  0045f	b9 04 00 00 00	 mov	 ecx, 4
  00464	48 6b c9 02	 imul	 rcx, rcx, 2
  00468	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 626  :     
; 627  :     v4 First, Second, Third;
; 628  :     
; 629  :     mat4 Result = {0};

  0046d	0f 57 c0	 xorps	 xmm0, xmm0
  00470	f3 0f 11 84 24
	90 04 00 00	 movss	 DWORD PTR Result$[rsp], xmm0
  00479	48 8d 84 24 94
	04 00 00	 lea	 rax, QWORD PTR Result$[rsp+4]
  00481	48 8b f8	 mov	 rdi, rax
  00484	33 c0		 xor	 eax, eax
  00486	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0048b	f3 aa		 rep stosb

; 630  :     
; 631  :     First = OutResult->e[0] * Rotate.m[0][0];

  0048d	b8 10 00 00 00	 mov	 eax, 16
  00492	48 6b c0 00	 imul	 rax, rax, 0
  00496	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  0049e	b9 04 00 00 00	 mov	 ecx, 4
  004a3	48 6b c9 00	 imul	 rcx, rcx, 0
  004a7	48 89 4c 24 28	 mov	 QWORD PTR tv230[rsp], rcx
  004ac	ba 10 00 00 00	 mov	 edx, 16
  004b1	48 6b d2 00	 imul	 rdx, rdx, 0
  004b5	48 8d bc 24 20
	01 00 00	 lea	 rdi, QWORD PTR $T12[rsp]
  004bd	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  004c5	48 03 f2	 add	 rsi, rdx
  004c8	b9 10 00 00 00	 mov	 ecx, 16
  004cd	f3 a4		 rep movsb
  004cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv230[rsp]
  004d4	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  004d9	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR $T12[rsp]
  004e1	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  004e9	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  004ee	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR $T57[rsp]
  004f6	48 8b f9	 mov	 rdi, rcx
  004f9	48 8b f0	 mov	 rsi, rax
  004fc	b9 10 00 00 00	 mov	 ecx, 16
  00501	f3 a4		 rep movsb
  00503	48 8d 84 24 20
	03 00 00	 lea	 rax, QWORD PTR First$[rsp]
  0050b	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR $T57[rsp]
  00513	48 8b f8	 mov	 rdi, rax
  00516	48 8b f1	 mov	 rsi, rcx
  00519	b9 10 00 00 00	 mov	 ecx, 16
  0051e	f3 a4		 rep movsb

; 632  :     Second = OutResult->e[1] * Rotate.m[0][1];

  00520	b8 10 00 00 00	 mov	 eax, 16
  00525	48 6b c0 00	 imul	 rax, rax, 0
  00529	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00531	b9 04 00 00 00	 mov	 ecx, 4
  00536	48 6b c9 01	 imul	 rcx, rcx, 1
  0053a	48 89 4c 24 30	 mov	 QWORD PTR tv242[rsp], rcx
  0053f	ba 10 00 00 00	 mov	 edx, 16
  00544	48 6b d2 01	 imul	 rdx, rdx, 1
  00548	48 8d bc 24 40
	01 00 00	 lea	 rdi, QWORD PTR $T14[rsp]
  00550	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  00558	48 03 f2	 add	 rsi, rdx
  0055b	b9 10 00 00 00	 mov	 ecx, 16
  00560	f3 a4		 rep movsb
  00562	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv242[rsp]
  00567	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  0056c	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR $T14[rsp]
  00574	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  0057c	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00581	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  00589	48 8b f9	 mov	 rdi, rcx
  0058c	48 8b f0	 mov	 rsi, rax
  0058f	b9 10 00 00 00	 mov	 ecx, 16
  00594	f3 a4		 rep movsb
  00596	48 8d 84 24 10
	03 00 00	 lea	 rax, QWORD PTR Second$[rsp]
  0059e	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  005a6	48 8b f8	 mov	 rdi, rax
  005a9	48 8b f1	 mov	 rsi, rcx
  005ac	b9 10 00 00 00	 mov	 ecx, 16
  005b1	f3 a4		 rep movsb

; 633  :     Third = OutResult->e[2] * Rotate.m[0][2];

  005b3	b8 10 00 00 00	 mov	 eax, 16
  005b8	48 6b c0 00	 imul	 rax, rax, 0
  005bc	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  005c4	b9 04 00 00 00	 mov	 ecx, 4
  005c9	48 6b c9 02	 imul	 rcx, rcx, 2
  005cd	48 89 4c 24 38	 mov	 QWORD PTR tv254[rsp], rcx
  005d2	ba 10 00 00 00	 mov	 edx, 16
  005d7	48 6b d2 02	 imul	 rdx, rdx, 2
  005db	48 8d bc 24 60
	01 00 00	 lea	 rdi, QWORD PTR $T16[rsp]
  005e3	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  005eb	48 03 f2	 add	 rsi, rdx
  005ee	b9 10 00 00 00	 mov	 ecx, 16
  005f3	f3 a4		 rep movsb
  005f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv254[rsp]
  005fa	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  005ff	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR $T16[rsp]
  00607	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  0060f	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00614	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR $T44[rsp]
  0061c	48 8b f9	 mov	 rdi, rcx
  0061f	48 8b f0	 mov	 rsi, rax
  00622	b9 10 00 00 00	 mov	 ecx, 16
  00627	f3 a4		 rep movsb
  00629	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR Third$[rsp]
  00631	48 8d 8c 24 b0
	03 00 00	 lea	 rcx, QWORD PTR $T44[rsp]
  00639	48 8b f8	 mov	 rdi, rax
  0063c	48 8b f1	 mov	 rsi, rcx
  0063f	b9 10 00 00 00	 mov	 ecx, 16
  00644	f3 a4		 rep movsb

; 634  :     Result.e[0] = First + Second + Third;

  00646	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR $T18[rsp]
  0064e	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR Second$[rsp]
  00656	48 8b f8	 mov	 rdi, rax
  00659	48 8b f1	 mov	 rsi, rcx
  0065c	b9 10 00 00 00	 mov	 ecx, 16
  00661	f3 a4		 rep movsb
  00663	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR $T19[rsp]
  0066b	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR First$[rsp]
  00673	48 8b f8	 mov	 rdi, rax
  00676	48 8b f1	 mov	 rsi, rcx
  00679	b9 10 00 00 00	 mov	 ecx, 16
  0067e	f3 a4		 rep movsb
  00680	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR $T18[rsp]
  00688	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR $T19[rsp]
  00690	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR $T29[rsp]
  00698	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  0069d	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR $T45[rsp]
  006a5	48 8b f9	 mov	 rdi, rcx
  006a8	48 8b f0	 mov	 rsi, rax
  006ab	b9 10 00 00 00	 mov	 ecx, 16
  006b0	f3 a4		 rep movsb
  006b2	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR $T21[rsp]
  006ba	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR Third$[rsp]
  006c2	48 8b f8	 mov	 rdi, rax
  006c5	48 8b f1	 mov	 rsi, rcx
  006c8	b9 10 00 00 00	 mov	 ecx, 16
  006cd	f3 a4		 rep movsb
  006cf	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR $T22[rsp]
  006d7	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR $T45[rsp]
  006df	48 8b f8	 mov	 rdi, rax
  006e2	48 8b f1	 mov	 rsi, rcx
  006e5	b9 10 00 00 00	 mov	 ecx, 16
  006ea	f3 a4		 rep movsb
  006ec	4c 8d 84 24 b0
	01 00 00	 lea	 r8, QWORD PTR $T21[rsp]
  006f4	48 8d 94 24 c0
	01 00 00	 lea	 rdx, QWORD PTR $T22[rsp]
  006fc	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00704	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  00709	48 8d 8c 24 d0
	03 00 00	 lea	 rcx, QWORD PTR $T46[rsp]
  00711	48 8b f9	 mov	 rdi, rcx
  00714	48 8b f0	 mov	 rsi, rax
  00717	b9 10 00 00 00	 mov	 ecx, 16
  0071c	f3 a4		 rep movsb
  0071e	b8 10 00 00 00	 mov	 eax, 16
  00723	48 6b c0 00	 imul	 rax, rax, 0
  00727	48 8d 8c 24 d0
	03 00 00	 lea	 rcx, QWORD PTR $T46[rsp]
  0072f	48 8d bc 04 90
	04 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  00737	48 8b f1	 mov	 rsi, rcx
  0073a	b9 10 00 00 00	 mov	 ecx, 16
  0073f	f3 a4		 rep movsb

; 635  :     
; 636  :     First = OutResult->e[0] * Rotate.m[1][0];

  00741	b8 10 00 00 00	 mov	 eax, 16
  00746	48 6b c0 01	 imul	 rax, rax, 1
  0074a	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00752	b9 04 00 00 00	 mov	 ecx, 4
  00757	48 6b c9 00	 imul	 rcx, rcx, 0
  0075b	48 89 4c 24 40	 mov	 QWORD PTR tv278[rsp], rcx
  00760	ba 10 00 00 00	 mov	 edx, 16
  00765	48 6b d2 00	 imul	 rdx, rdx, 0
  00769	48 8d bc 24 90
	00 00 00	 lea	 rdi, QWORD PTR $T3[rsp]
  00771	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  00779	48 03 f2	 add	 rsi, rdx
  0077c	b9 10 00 00 00	 mov	 ecx, 16
  00781	f3 a4		 rep movsb
  00783	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv278[rsp]
  00788	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  0078d	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T3[rsp]
  00795	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0079d	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  007a2	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR $T47[rsp]
  007aa	48 8b f9	 mov	 rdi, rcx
  007ad	48 8b f0	 mov	 rsi, rax
  007b0	b9 10 00 00 00	 mov	 ecx, 16
  007b5	f3 a4		 rep movsb
  007b7	48 8d 84 24 20
	03 00 00	 lea	 rax, QWORD PTR First$[rsp]
  007bf	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR $T47[rsp]
  007c7	48 8b f8	 mov	 rdi, rax
  007ca	48 8b f1	 mov	 rsi, rcx
  007cd	b9 10 00 00 00	 mov	 ecx, 16
  007d2	f3 a4		 rep movsb

; 637  :     Second = OutResult->e[1] * Rotate.m[1][1];

  007d4	b8 10 00 00 00	 mov	 eax, 16
  007d9	48 6b c0 01	 imul	 rax, rax, 1
  007dd	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  007e5	b9 04 00 00 00	 mov	 ecx, 4
  007ea	48 6b c9 01	 imul	 rcx, rcx, 1
  007ee	48 89 4c 24 48	 mov	 QWORD PTR tv322[rsp], rcx
  007f3	ba 10 00 00 00	 mov	 edx, 16
  007f8	48 6b d2 01	 imul	 rdx, rdx, 1
  007fc	48 8d bc 24 b0
	00 00 00	 lea	 rdi, QWORD PTR $T5[rsp]
  00804	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  0080c	48 03 f2	 add	 rsi, rdx
  0080f	b9 10 00 00 00	 mov	 ecx, 16
  00814	f3 a4		 rep movsb
  00816	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv322[rsp]
  0081b	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  00820	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR $T5[rsp]
  00828	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  00830	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00835	48 8d 8c 24 30
	04 00 00	 lea	 rcx, QWORD PTR $T52[rsp]
  0083d	48 8b f9	 mov	 rdi, rcx
  00840	48 8b f0	 mov	 rsi, rax
  00843	b9 10 00 00 00	 mov	 ecx, 16
  00848	f3 a4		 rep movsb
  0084a	48 8d 84 24 10
	03 00 00	 lea	 rax, QWORD PTR Second$[rsp]
  00852	48 8d 8c 24 30
	04 00 00	 lea	 rcx, QWORD PTR $T52[rsp]
  0085a	48 8b f8	 mov	 rdi, rax
  0085d	48 8b f1	 mov	 rsi, rcx
  00860	b9 10 00 00 00	 mov	 ecx, 16
  00865	f3 a4		 rep movsb

; 638  :     Third = OutResult->e[2] * Rotate.m[1][2];

  00867	b8 10 00 00 00	 mov	 eax, 16
  0086c	48 6b c0 01	 imul	 rax, rax, 1
  00870	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00878	b9 04 00 00 00	 mov	 ecx, 4
  0087d	48 6b c9 02	 imul	 rcx, rcx, 2
  00881	48 89 4c 24 50	 mov	 QWORD PTR tv334[rsp], rcx
  00886	ba 10 00 00 00	 mov	 edx, 16
  0088b	48 6b d2 02	 imul	 rdx, rdx, 2
  0088f	48 8d bc 24 d0
	00 00 00	 lea	 rdi, QWORD PTR $T7[rsp]
  00897	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  0089f	48 03 f2	 add	 rsi, rdx
  008a2	b9 10 00 00 00	 mov	 ecx, 16
  008a7	f3 a4		 rep movsb
  008a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv334[rsp]
  008ae	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  008b3	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  008bb	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  008c3	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  008c8	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR $T55[rsp]
  008d0	48 8b f9	 mov	 rdi, rcx
  008d3	48 8b f0	 mov	 rsi, rax
  008d6	b9 10 00 00 00	 mov	 ecx, 16
  008db	f3 a4		 rep movsb
  008dd	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR Third$[rsp]
  008e5	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR $T55[rsp]
  008ed	48 8b f8	 mov	 rdi, rax
  008f0	48 8b f1	 mov	 rsi, rcx
  008f3	b9 10 00 00 00	 mov	 ecx, 16
  008f8	f3 a4		 rep movsb

; 639  :     Result.e[1] = First + Second + Third;

  008fa	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  00902	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR Second$[rsp]
  0090a	48 8b f8	 mov	 rdi, rax
  0090d	48 8b f1	 mov	 rsi, rcx
  00910	b9 10 00 00 00	 mov	 ecx, 16
  00915	f3 a4		 rep movsb
  00917	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  0091f	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR First$[rsp]
  00927	48 8b f8	 mov	 rdi, rax
  0092a	48 8b f1	 mov	 rsi, rcx
  0092d	b9 10 00 00 00	 mov	 ecx, 16
  00932	f3 a4		 rep movsb
  00934	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR $T8[rsp]
  0093c	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  00944	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  0094c	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  00951	48 8d 8c 24 00
	04 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  00959	48 8b f9	 mov	 rdi, rcx
  0095c	48 8b f0	 mov	 rsi, rax
  0095f	b9 10 00 00 00	 mov	 ecx, 16
  00964	f3 a4		 rep movsb
  00966	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  0096e	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR Third$[rsp]
  00976	48 8b f8	 mov	 rdi, rax
  00979	48 8b f1	 mov	 rsi, rcx
  0097c	b9 10 00 00 00	 mov	 ecx, 16
  00981	f3 a4		 rep movsb
  00983	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  0098b	48 8d 8c 24 00
	04 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  00993	48 8b f8	 mov	 rdi, rax
  00996	48 8b f1	 mov	 rsi, rcx
  00999	b9 10 00 00 00	 mov	 ecx, 16
  0099e	f3 a4		 rep movsb
  009a0	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR $T10[rsp]
  009a8	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR $T11[rsp]
  009b0	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  009b8	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  009bd	48 8d 8c 24 20
	04 00 00	 lea	 rcx, QWORD PTR $T51[rsp]
  009c5	48 8b f9	 mov	 rdi, rcx
  009c8	48 8b f0	 mov	 rsi, rax
  009cb	b9 10 00 00 00	 mov	 ecx, 16
  009d0	f3 a4		 rep movsb
  009d2	b8 10 00 00 00	 mov	 eax, 16
  009d7	48 6b c0 01	 imul	 rax, rax, 1
  009db	48 8d 8c 24 20
	04 00 00	 lea	 rcx, QWORD PTR $T51[rsp]
  009e3	48 8d bc 04 90
	04 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  009eb	48 8b f1	 mov	 rsi, rcx
  009ee	b9 10 00 00 00	 mov	 ecx, 16
  009f3	f3 a4		 rep movsb

; 640  :     
; 641  :     First = OutResult->e[0] * Rotate.m[2][0];

  009f5	b8 10 00 00 00	 mov	 eax, 16
  009fa	48 6b c0 02	 imul	 rax, rax, 2
  009fe	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00a06	b9 04 00 00 00	 mov	 ecx, 4
  00a0b	48 6b c9 00	 imul	 rcx, rcx, 0
  00a0f	48 89 4c 24 58	 mov	 QWORD PTR tv358[rsp], rcx
  00a14	ba 10 00 00 00	 mov	 edx, 16
  00a19	48 6b d2 00	 imul	 rdx, rdx, 0
  00a1d	48 8d bc 24 c0
	00 00 00	 lea	 rdi, QWORD PTR $T6[rsp]
  00a25	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  00a2d	48 03 f2	 add	 rsi, rdx
  00a30	b9 10 00 00 00	 mov	 ecx, 16
  00a35	f3 a4		 rep movsb
  00a37	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv358[rsp]
  00a3c	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  00a41	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR $T6[rsp]
  00a49	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  00a51	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00a56	48 8d 8c 24 50
	04 00 00	 lea	 rcx, QWORD PTR $T54[rsp]
  00a5e	48 8b f9	 mov	 rdi, rcx
  00a61	48 8b f0	 mov	 rsi, rax
  00a64	b9 10 00 00 00	 mov	 ecx, 16
  00a69	f3 a4		 rep movsb
  00a6b	48 8d 84 24 20
	03 00 00	 lea	 rax, QWORD PTR First$[rsp]
  00a73	48 8d 8c 24 50
	04 00 00	 lea	 rcx, QWORD PTR $T54[rsp]
  00a7b	48 8b f8	 mov	 rdi, rax
  00a7e	48 8b f1	 mov	 rsi, rcx
  00a81	b9 10 00 00 00	 mov	 ecx, 16
  00a86	f3 a4		 rep movsb

; 642  :     Second = OutResult->e[1] * Rotate.m[2][1];

  00a88	b8 10 00 00 00	 mov	 eax, 16
  00a8d	48 6b c0 02	 imul	 rax, rax, 2
  00a91	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00a99	b9 04 00 00 00	 mov	 ecx, 4
  00a9e	48 6b c9 01	 imul	 rcx, rcx, 1
  00aa2	48 89 4c 24 60	 mov	 QWORD PTR tv370[rsp], rcx
  00aa7	ba 10 00 00 00	 mov	 edx, 16
  00aac	48 6b d2 01	 imul	 rdx, rdx, 1
  00ab0	48 8d bc 24 30
	01 00 00	 lea	 rdi, QWORD PTR $T13[rsp]
  00ab8	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  00ac0	48 03 f2	 add	 rsi, rdx
  00ac3	b9 10 00 00 00	 mov	 ecx, 16
  00ac8	f3 a4		 rep movsb
  00aca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv370[rsp]
  00acf	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  00ad4	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  00adc	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR $T37[rsp]
  00ae4	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00ae9	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  00af1	48 8b f9	 mov	 rdi, rcx
  00af4	48 8b f0	 mov	 rsi, rax
  00af7	b9 10 00 00 00	 mov	 ecx, 16
  00afc	f3 a4		 rep movsb
  00afe	48 8d 84 24 10
	03 00 00	 lea	 rax, QWORD PTR Second$[rsp]
  00b06	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  00b0e	48 8b f8	 mov	 rdi, rax
  00b11	48 8b f1	 mov	 rsi, rcx
  00b14	b9 10 00 00 00	 mov	 ecx, 16
  00b19	f3 a4		 rep movsb

; 643  :     Third = OutResult->e[2] * Rotate.m[2][2];

  00b1b	b8 10 00 00 00	 mov	 eax, 16
  00b20	48 6b c0 02	 imul	 rax, rax, 2
  00b24	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR Rotate$[rsp+rax]
  00b2c	b9 04 00 00 00	 mov	 ecx, 4
  00b31	48 6b c9 02	 imul	 rcx, rcx, 2
  00b35	48 89 4c 24 68	 mov	 QWORD PTR tv382[rsp], rcx
  00b3a	ba 10 00 00 00	 mov	 edx, 16
  00b3f	48 6b d2 02	 imul	 rdx, rdx, 2
  00b43	48 8d bc 24 50
	01 00 00	 lea	 rdi, QWORD PTR $T15[rsp]
  00b4b	48 8b b4 24 00
	05 00 00	 mov	 rsi, QWORD PTR OutResult$[rsp]
  00b53	48 03 f2	 add	 rsi, rdx
  00b56	b9 10 00 00 00	 mov	 ecx, 16
  00b5b	f3 a4		 rep movsb
  00b5d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv382[rsp]
  00b62	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  00b67	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR $T15[rsp]
  00b6f	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  00b77	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00b7c	48 8d 8c 24 10
	04 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  00b84	48 8b f9	 mov	 rdi, rcx
  00b87	48 8b f0	 mov	 rsi, rax
  00b8a	b9 10 00 00 00	 mov	 ecx, 16
  00b8f	f3 a4		 rep movsb
  00b91	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR Third$[rsp]
  00b99	48 8d 8c 24 10
	04 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  00ba1	48 8b f8	 mov	 rdi, rax
  00ba4	48 8b f1	 mov	 rsi, rcx
  00ba7	b9 10 00 00 00	 mov	 ecx, 16
  00bac	f3 a4		 rep movsb

; 644  :     Result.e[2] = First + Second + Third;

  00bae	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR $T17[rsp]
  00bb6	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR Second$[rsp]
  00bbe	48 8b f8	 mov	 rdi, rax
  00bc1	48 8b f1	 mov	 rsi, rcx
  00bc4	b9 10 00 00 00	 mov	 ecx, 16
  00bc9	f3 a4		 rep movsb
  00bcb	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR $T20[rsp]
  00bd3	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR First$[rsp]
  00bdb	48 8b f8	 mov	 rdi, rax
  00bde	48 8b f1	 mov	 rsi, rcx
  00be1	b9 10 00 00 00	 mov	 ecx, 16
  00be6	f3 a4		 rep movsb
  00be8	4c 8d 84 24 70
	01 00 00	 lea	 r8, QWORD PTR $T17[rsp]
  00bf0	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR $T20[rsp]
  00bf8	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00c00	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  00c05	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR $T53[rsp]
  00c0d	48 8b f9	 mov	 rdi, rcx
  00c10	48 8b f0	 mov	 rsi, rax
  00c13	b9 10 00 00 00	 mov	 ecx, 16
  00c18	f3 a4		 rep movsb
  00c1a	48 8d 84 24 d0
	01 00 00	 lea	 rax, QWORD PTR $T23[rsp]
  00c22	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR Third$[rsp]
  00c2a	48 8b f8	 mov	 rdi, rax
  00c2d	48 8b f1	 mov	 rsi, rcx
  00c30	b9 10 00 00 00	 mov	 ecx, 16
  00c35	f3 a4		 rep movsb
  00c37	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  00c3f	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR $T53[rsp]
  00c47	48 8b f8	 mov	 rdi, rax
  00c4a	48 8b f1	 mov	 rsi, rcx
  00c4d	b9 10 00 00 00	 mov	 ecx, 16
  00c52	f3 a4		 rep movsb
  00c54	4c 8d 84 24 d0
	01 00 00	 lea	 r8, QWORD PTR $T23[rsp]
  00c5c	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  00c64	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  00c6c	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  00c71	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR $T56[rsp]
  00c79	48 8b f9	 mov	 rdi, rcx
  00c7c	48 8b f0	 mov	 rsi, rax
  00c7f	b9 10 00 00 00	 mov	 ecx, 16
  00c84	f3 a4		 rep movsb
  00c86	b8 10 00 00 00	 mov	 eax, 16
  00c8b	48 6b c0 02	 imul	 rax, rax, 2
  00c8f	48 8d 8c 24 70
	04 00 00	 lea	 rcx, QWORD PTR $T56[rsp]
  00c97	48 8d bc 04 90
	04 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  00c9f	48 8b f1	 mov	 rsi, rcx
  00ca2	b9 10 00 00 00	 mov	 ecx, 16
  00ca7	f3 a4		 rep movsb

; 645  :     
; 646  :     Result.e[3] = OutResult->e[3];

  00ca9	b8 10 00 00 00	 mov	 eax, 16
  00cae	48 6b c0 03	 imul	 rax, rax, 3
  00cb2	b9 10 00 00 00	 mov	 ecx, 16
  00cb7	48 6b c9 03	 imul	 rcx, rcx, 3
  00cbb	48 8b 94 24 00
	05 00 00	 mov	 rdx, QWORD PTR OutResult$[rsp]
  00cc3	48 8d bc 0c 90
	04 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rcx]
  00ccb	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00ccf	b9 10 00 00 00	 mov	 ecx, 16
  00cd4	f3 a4		 rep movsb

; 647  :     
; 648  :     *OutResult = Result;

  00cd6	48 8d 84 24 90
	04 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  00cde	48 8b bc 24 00
	05 00 00	 mov	 rdi, QWORD PTR OutResult$[rsp]
  00ce6	48 8b f0	 mov	 rsi, rax
  00ce9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00cee	f3 a4		 rep movsb

; 649  : }

  00cf0	48 8b 8c 24 d0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00cf8	48 33 cc	 xor	 rcx, rsp
  00cfb	e8 00 00 00 00	 call	 __security_check_cookie
  00d00	48 81 c4 e8 04
	00 00		 add	 rsp, 1256		; 000004e8H
  00d07	5f		 pop	 rdi
  00d08	5e		 pop	 rsi
  00d09	c3		 ret	 0
?RotateMat4@@YAXPEATmat4@@MTv3@@@Z ENDP			; RotateMat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
$T8 = 144
$T9 = 160
$T10 = 176
$T11 = 192
$T12 = 208
$T13 = 224
$T14 = 240
$T15 = 256
Final$ = 272
$T16 = 288
$T17 = 304
$T18 = 320
Second$ = 336
First$ = 352
$T19 = 368
Third$ = 384
$T20 = 400
$T21 = 416
__$ArrayPad$ = 432
Result$ = 480
Translation$ = 488
?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z PROC		; TranslateMat4

; 593  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 594  :     v4 First = Result->e[0] * Translation.x;

  00025	b8 10 00 00 00	 mov	 eax, 16
  0002a	48 6b c0 00	 imul	 rax, rax, 0
  0002e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00033	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  0003b	48 8b f9	 mov	 rdi, rcx
  0003e	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f3 a4		 rep movsb
  00049	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Translation$[rsp]
  00051	f3 0f 10 10	 movss	 xmm2, DWORD PTR [rax]
  00055	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0005a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00062	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00067	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0006f	48 8b f9	 mov	 rdi, rcx
  00072	48 8b f0	 mov	 rsi, rax
  00075	b9 10 00 00 00	 mov	 ecx, 16
  0007a	f3 a4		 rep movsb
  0007c	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR First$[rsp]
  00084	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	48 8b f1	 mov	 rsi, rcx
  00092	b9 10 00 00 00	 mov	 ecx, 16
  00097	f3 a4		 rep movsb

; 595  :     v4 Second = Result->e[1] * Translation.y;

  00099	b8 10 00 00 00	 mov	 eax, 16
  0009e	48 6b c0 01	 imul	 rax, rax, 1
  000a2	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  000a7	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  000af	48 8b f9	 mov	 rdi, rcx
  000b2	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000b6	b9 10 00 00 00	 mov	 ecx, 16
  000bb	f3 a4		 rep movsb
  000bd	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Translation$[rsp]
  000c5	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [rax+4]
  000ca	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  000cf	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  000d7	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  000dc	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  000e4	48 8b f9	 mov	 rdi, rcx
  000e7	48 8b f0	 mov	 rsi, rax
  000ea	b9 10 00 00 00	 mov	 ecx, 16
  000ef	f3 a4		 rep movsb
  000f1	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR Second$[rsp]
  000f9	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  00101	48 8b f8	 mov	 rdi, rax
  00104	48 8b f1	 mov	 rsi, rcx
  00107	b9 10 00 00 00	 mov	 ecx, 16
  0010c	f3 a4		 rep movsb

; 596  :     v4 Third = Result->e[2] * Translation.z;

  0010e	b8 10 00 00 00	 mov	 eax, 16
  00113	48 6b c0 02	 imul	 rax, rax, 2
  00117	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0011c	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  00124	48 8b f9	 mov	 rdi, rcx
  00127	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0012b	b9 10 00 00 00	 mov	 ecx, 16
  00130	f3 a4		 rep movsb
  00132	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR Translation$[rsp]
  0013a	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [rax+8]
  0013f	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  00144	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  0014c	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@M@Z	; operator*
  00151	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00159	48 8b f9	 mov	 rdi, rcx
  0015c	48 8b f0	 mov	 rsi, rax
  0015f	b9 10 00 00 00	 mov	 ecx, 16
  00164	f3 a4		 rep movsb
  00166	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR Third$[rsp]
  0016e	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00176	48 8b f8	 mov	 rdi, rax
  00179	48 8b f1	 mov	 rsi, rcx
  0017c	b9 10 00 00 00	 mov	 ecx, 16
  00181	f3 a4		 rep movsb

; 597  :     
; 598  :     v4 Final = First +Second;

  00183	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  00188	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR Second$[rsp]
  00190	48 8b f8	 mov	 rdi, rax
  00193	48 8b f1	 mov	 rsi, rcx
  00196	b9 10 00 00 00	 mov	 ecx, 16
  0019b	f3 a4		 rep movsb
  0019d	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  001a2	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR First$[rsp]
  001aa	48 8b f8	 mov	 rdi, rax
  001ad	48 8b f1	 mov	 rsi, rcx
  001b0	b9 10 00 00 00	 mov	 ecx, 16
  001b5	f3 a4		 rep movsb
  001b7	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T4[rsp]
  001bc	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T5[rsp]
  001c1	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  001c9	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  001ce	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  001d6	48 8b f9	 mov	 rdi, rcx
  001d9	48 8b f0	 mov	 rsi, rax
  001dc	b9 10 00 00 00	 mov	 ecx, 16
  001e1	f3 a4		 rep movsb
  001e3	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR Final$[rsp]
  001eb	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  001f3	48 8b f8	 mov	 rdi, rax
  001f6	48 8b f1	 mov	 rsi, rcx
  001f9	b9 10 00 00 00	 mov	 ecx, 16
  001fe	f3 a4		 rep movsb

; 599  :     Final = Final + Third;

  00200	48 8d 44 24 70	 lea	 rax, QWORD PTR $T6[rsp]
  00205	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR Third$[rsp]
  0020d	48 8b f8	 mov	 rdi, rax
  00210	48 8b f1	 mov	 rsi, rcx
  00213	b9 10 00 00 00	 mov	 ecx, 16
  00218	f3 a4		 rep movsb
  0021a	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  00222	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR Final$[rsp]
  0022a	48 8b f8	 mov	 rdi, rax
  0022d	48 8b f1	 mov	 rsi, rcx
  00230	b9 10 00 00 00	 mov	 ecx, 16
  00235	f3 a4		 rep movsb
  00237	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T6[rsp]
  0023c	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  00244	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  0024c	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  00251	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  00259	48 8b f9	 mov	 rdi, rcx
  0025c	48 8b f0	 mov	 rsi, rax
  0025f	b9 10 00 00 00	 mov	 ecx, 16
  00264	f3 a4		 rep movsb
  00266	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR Final$[rsp]
  0026e	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  00276	48 8b f8	 mov	 rdi, rax
  00279	48 8b f1	 mov	 rsi, rcx
  0027c	b9 10 00 00 00	 mov	 ecx, 16
  00281	f3 a4		 rep movsb

; 600  :     Final = Final + Result->e[3];

  00283	b8 10 00 00 00	 mov	 eax, 16
  00288	48 6b c0 03	 imul	 rax, rax, 3
  0028c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00294	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR Result$[rsp]
  0029c	48 8b f9	 mov	 rdi, rcx
  0029f	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  002a3	b9 10 00 00 00	 mov	 ecx, 16
  002a8	f3 a4		 rep movsb
  002aa	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  002b2	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR Final$[rsp]
  002ba	48 8b f8	 mov	 rdi, rax
  002bd	48 8b f1	 mov	 rsi, rcx
  002c0	b9 10 00 00 00	 mov	 ecx, 16
  002c5	f3 a4		 rep movsb
  002c7	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR $T8[rsp]
  002cf	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  002d7	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  002df	e8 00 00 00 00	 call	 ??H@YA?ATv4@@T0@0@Z	; operator+
  002e4	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  002ec	48 8b f9	 mov	 rdi, rcx
  002ef	48 8b f0	 mov	 rsi, rax
  002f2	b9 10 00 00 00	 mov	 ecx, 16
  002f7	f3 a4		 rep movsb
  002f9	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR Final$[rsp]
  00301	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00309	48 8b f8	 mov	 rdi, rax
  0030c	48 8b f1	 mov	 rsi, rcx
  0030f	b9 10 00 00 00	 mov	 ecx, 16
  00314	f3 a4		 rep movsb

; 601  :     
; 602  :     Result->e[3] = Final;

  00316	b8 10 00 00 00	 mov	 eax, 16
  0031b	48 6b c0 03	 imul	 rax, rax, 3
  0031f	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR Result$[rsp]
  00327	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR Final$[rsp]
  0032f	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00333	48 8b f2	 mov	 rsi, rdx
  00336	b9 10 00 00 00	 mov	 ecx, 16
  0033b	f3 a4		 rep movsb

; 603  : }

  0033d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00345	48 33 cc	 xor	 rcx, rsp
  00348	e8 00 00 00 00	 call	 __security_check_cookie
  0034d	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00354	5f		 pop	 rdi
  00355	5e		 pop	 rsi
  00356	c3		 ret	 0
?TranslateMat4@@YAXPEATmat4@@Tv3@@@Z ENDP		; TranslateMat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??D@YA?ATv4@@Tmat4@@T0@@Z PROC				; operator*

; 579  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 580  :     v4 Result =
; 581  :     {
; 582  :         B.x*A.m[0][0] + B.y*A.m[0][1] + B.z*A.m[0][2] + B.w*A.m[0][3],

  00024	b8 10 00 00 00	 mov	 eax, 16
  00029	48 6b c0 00	 imul	 rax, rax, 0
  0002d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	48 6b c9 00	 imul	 rcx, rcx, 0
  00041	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00046	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  0004a	f3 0f 59 04 08	 mulss	 xmm0, DWORD PTR [rax+rcx]
  0004f	b8 10 00 00 00	 mov	 eax, 16
  00054	48 6b c0 00	 imul	 rax, rax, 0
  00058	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0005d	48 03 c8	 add	 rcx, rax
  00060	48 8b c1	 mov	 rax, rcx
  00063	b9 04 00 00 00	 mov	 ecx, 4
  00068	48 6b c9 01	 imul	 rcx, rcx, 1
  0006c	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00071	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  00076	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0007b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0007f	b8 10 00 00 00	 mov	 eax, 16
  00084	48 6b c0 00	 imul	 rax, rax, 0
  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0008d	48 03 c8	 add	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	b9 04 00 00 00	 mov	 ecx, 4
  00098	48 6b c9 02	 imul	 rcx, rcx, 2
  0009c	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  000a1	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [rdx+8]
  000a6	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  000ab	f3 0f 58 c1	 addss	 xmm0, xmm1
  000af	b8 10 00 00 00	 mov	 eax, 16
  000b4	48 6b c0 00	 imul	 rax, rax, 0
  000b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  000bd	48 03 c8	 add	 rcx, rax
  000c0	48 8b c1	 mov	 rax, rcx
  000c3	b9 04 00 00 00	 mov	 ecx, 4
  000c8	48 6b c9 03	 imul	 rcx, rcx, 3
  000cc	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  000d1	f3 0f 10 4a 0c	 movss	 xmm1, DWORD PTR [rdx+12]
  000d6	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  000db	f3 0f 58 c1	 addss	 xmm0, xmm1
  000df	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 583  :         B.x*A.m[1][0] + B.y*A.m[1][1] + B.z*A.m[1][2] + B.w*A.m[1][3],

  000e4	b8 10 00 00 00	 mov	 eax, 16
  000e9	48 6b c0 01	 imul	 rax, rax, 1
  000ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  000f2	48 03 c8	 add	 rcx, rax
  000f5	48 8b c1	 mov	 rax, rcx
  000f8	b9 04 00 00 00	 mov	 ecx, 4
  000fd	48 6b c9 00	 imul	 rcx, rcx, 0
  00101	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00106	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  0010a	f3 0f 59 04 08	 mulss	 xmm0, DWORD PTR [rax+rcx]
  0010f	b8 10 00 00 00	 mov	 eax, 16
  00114	48 6b c0 01	 imul	 rax, rax, 1
  00118	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0011d	48 03 c8	 add	 rcx, rax
  00120	48 8b c1	 mov	 rax, rcx
  00123	b9 04 00 00 00	 mov	 ecx, 4
  00128	48 6b c9 01	 imul	 rcx, rcx, 1
  0012c	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00131	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  00136	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0013b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0013f	b8 10 00 00 00	 mov	 eax, 16
  00144	48 6b c0 01	 imul	 rax, rax, 1
  00148	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0014d	48 03 c8	 add	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	b9 04 00 00 00	 mov	 ecx, 4
  00158	48 6b c9 02	 imul	 rcx, rcx, 2
  0015c	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00161	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [rdx+8]
  00166	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0016b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0016f	b8 10 00 00 00	 mov	 eax, 16
  00174	48 6b c0 01	 imul	 rax, rax, 1
  00178	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0017d	48 03 c8	 add	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	b9 04 00 00 00	 mov	 ecx, 4
  00188	48 6b c9 03	 imul	 rcx, rcx, 3
  0018c	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00191	f3 0f 10 4a 0c	 movss	 xmm1, DWORD PTR [rdx+12]
  00196	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0019b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0019f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 584  :         B.x*A.m[2][0] + B.y*A.m[2][1] + B.z*A.m[2][2] + B.w*A.m[2][3],

  001a5	b8 10 00 00 00	 mov	 eax, 16
  001aa	48 6b c0 02	 imul	 rax, rax, 2
  001ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  001b3	48 03 c8	 add	 rcx, rax
  001b6	48 8b c1	 mov	 rax, rcx
  001b9	b9 04 00 00 00	 mov	 ecx, 4
  001be	48 6b c9 00	 imul	 rcx, rcx, 0
  001c2	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  001c7	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  001cb	f3 0f 59 04 08	 mulss	 xmm0, DWORD PTR [rax+rcx]
  001d0	b8 10 00 00 00	 mov	 eax, 16
  001d5	48 6b c0 02	 imul	 rax, rax, 2
  001d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  001de	48 03 c8	 add	 rcx, rax
  001e1	48 8b c1	 mov	 rax, rcx
  001e4	b9 04 00 00 00	 mov	 ecx, 4
  001e9	48 6b c9 01	 imul	 rcx, rcx, 1
  001ed	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  001f2	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  001f7	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  001fc	f3 0f 58 c1	 addss	 xmm0, xmm1
  00200	b8 10 00 00 00	 mov	 eax, 16
  00205	48 6b c0 02	 imul	 rax, rax, 2
  00209	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0020e	48 03 c8	 add	 rcx, rax
  00211	48 8b c1	 mov	 rax, rcx
  00214	b9 04 00 00 00	 mov	 ecx, 4
  00219	48 6b c9 02	 imul	 rcx, rcx, 2
  0021d	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00222	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [rdx+8]
  00227	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0022c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00230	b8 10 00 00 00	 mov	 eax, 16
  00235	48 6b c0 02	 imul	 rax, rax, 2
  00239	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0023e	48 03 c8	 add	 rcx, rax
  00241	48 8b c1	 mov	 rax, rcx
  00244	b9 04 00 00 00	 mov	 ecx, 4
  00249	48 6b c9 03	 imul	 rcx, rcx, 3
  0024d	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00252	f3 0f 10 4a 0c	 movss	 xmm1, DWORD PTR [rdx+12]
  00257	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0025c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00260	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 585  :         B.x*A.m[3][0] + B.y*A.m[3][1] + B.z*A.m[3][2] + B.w*A.m[3][3]

  00266	b8 10 00 00 00	 mov	 eax, 16
  0026b	48 6b c0 03	 imul	 rax, rax, 3
  0026f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  00274	48 03 c8	 add	 rcx, rax
  00277	48 8b c1	 mov	 rax, rcx
  0027a	b9 04 00 00 00	 mov	 ecx, 4
  0027f	48 6b c9 00	 imul	 rcx, rcx, 0
  00283	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00288	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  0028c	f3 0f 59 04 08	 mulss	 xmm0, DWORD PTR [rax+rcx]
  00291	b8 10 00 00 00	 mov	 eax, 16
  00296	48 6b c0 03	 imul	 rax, rax, 3
  0029a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  0029f	48 03 c8	 add	 rcx, rax
  002a2	48 8b c1	 mov	 rax, rcx
  002a5	b9 04 00 00 00	 mov	 ecx, 4
  002aa	48 6b c9 01	 imul	 rcx, rcx, 1
  002ae	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  002b3	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  002b8	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  002bd	f3 0f 58 c1	 addss	 xmm0, xmm1
  002c1	b8 10 00 00 00	 mov	 eax, 16
  002c6	48 6b c0 03	 imul	 rax, rax, 3
  002ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  002cf	48 03 c8	 add	 rcx, rax
  002d2	48 8b c1	 mov	 rax, rcx
  002d5	b9 04 00 00 00	 mov	 ecx, 4
  002da	48 6b c9 02	 imul	 rcx, rcx, 2
  002de	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  002e3	f3 0f 10 4a 08	 movss	 xmm1, DWORD PTR [rdx+8]
  002e8	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  002ed	f3 0f 58 c1	 addss	 xmm0, xmm1
  002f1	b8 10 00 00 00	 mov	 eax, 16
  002f6	48 6b c0 03	 imul	 rax, rax, 3
  002fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR A$[rsp]
  002ff	48 03 c8	 add	 rcx, rax
  00302	48 8b c1	 mov	 rax, rcx
  00305	b9 04 00 00 00	 mov	 ecx, 4
  0030a	48 6b c9 03	 imul	 rcx, rcx, 3
  0030e	48 8b 54 24 50	 mov	 rdx, QWORD PTR B$[rsp]
  00313	f3 0f 10 4a 0c	 movss	 xmm1, DWORD PTR [rdx+12]
  00318	f3 0f 59 0c 08	 mulss	 xmm1, DWORD PTR [rax+rcx]
  0031d	f3 0f 58 c1	 addss	 xmm0, xmm1
  00321	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 586  :     };
; 587  :     
; 588  :     return(Result);

  00327	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  0032b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00330	48 8b f0	 mov	 rsi, rax
  00333	b9 10 00 00 00	 mov	 ecx, 16
  00338	f3 a4		 rep movsb
  0033a	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 589  : }

  0033f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00344	48 33 cc	 xor	 rcx, rsp
  00347	e8 00 00 00 00	 call	 __security_check_cookie
  0034c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00350	5f		 pop	 rdi
  00351	5e		 pop	 rsi
  00352	c3		 ret	 0
??D@YA?ATv4@@Tmat4@@T0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 64
$T1 = 112
A$ = 120
B$ = 128
??D@YA?ATmat4@@T0@0@Z PROC				; operator*

; 553  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 554  :     mat4 Result =
; 555  :     {
; 556  :         A.m[0][0] * B.m[0][0] + A.m[0][1] * B.m[1][0] + A.m[0][2] * B.m[2][0] + A.m[0][3] * B.m[3][0],

  00024	b8 10 00 00 00	 mov	 eax, 16
  00029	48 6b c0 00	 imul	 rax, rax, 0
  0002d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	48 6b c9 00	 imul	 rcx, rcx, 0
  00041	ba 10 00 00 00	 mov	 edx, 16
  00046	48 6b d2 00	 imul	 rdx, rdx, 0
  0004a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00052	4c 03 c2	 add	 r8, rdx
  00055	49 8b d0	 mov	 rdx, r8
  00058	41 b8 04 00 00
	00		 mov	 r8d, 4
  0005e	4d 6b c0 00	 imul	 r8, r8, 0
  00062	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00067	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0006d	b8 10 00 00 00	 mov	 eax, 16
  00072	48 6b c0 00	 imul	 rax, rax, 0
  00076	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0007b	48 03 c8	 add	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	b9 04 00 00 00	 mov	 ecx, 4
  00086	48 6b c9 01	 imul	 rcx, rcx, 1
  0008a	ba 10 00 00 00	 mov	 edx, 16
  0008f	48 6b d2 01	 imul	 rdx, rdx, 1
  00093	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0009b	4c 03 c2	 add	 r8, rdx
  0009e	49 8b d0	 mov	 rdx, r8
  000a1	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a7	4d 6b c0 00	 imul	 r8, r8, 0
  000ab	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  000b0	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  000b6	f3 0f 58 c1	 addss	 xmm0, xmm1
  000ba	b8 10 00 00 00	 mov	 eax, 16
  000bf	48 6b c0 00	 imul	 rax, rax, 0
  000c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  000c8	48 03 c8	 add	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	b9 04 00 00 00	 mov	 ecx, 4
  000d3	48 6b c9 02	 imul	 rcx, rcx, 2
  000d7	ba 10 00 00 00	 mov	 edx, 16
  000dc	48 6b d2 02	 imul	 rdx, rdx, 2
  000e0	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  000e8	4c 03 c2	 add	 r8, rdx
  000eb	49 8b d0	 mov	 rdx, r8
  000ee	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f4	4d 6b c0 00	 imul	 r8, r8, 0
  000f8	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  000fd	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00103	f3 0f 58 c1	 addss	 xmm0, xmm1
  00107	b8 10 00 00 00	 mov	 eax, 16
  0010c	48 6b c0 00	 imul	 rax, rax, 0
  00110	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00115	48 03 c8	 add	 rcx, rax
  00118	48 8b c1	 mov	 rax, rcx
  0011b	b9 04 00 00 00	 mov	 ecx, 4
  00120	48 6b c9 03	 imul	 rcx, rcx, 3
  00124	ba 10 00 00 00	 mov	 edx, 16
  00129	48 6b d2 03	 imul	 rdx, rdx, 3
  0012d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00135	4c 03 c2	 add	 r8, rdx
  00138	49 8b d0	 mov	 rdx, r8
  0013b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00141	4d 6b c0 00	 imul	 r8, r8, 0
  00145	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0014a	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00150	f3 0f 58 c1	 addss	 xmm0, xmm1
  00154	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 557  :         A.m[0][0] * B.m[0][1] + A.m[0][1] * B.m[1][1] + A.m[0][2] * B.m[2][1] + A.m[0][3] * B.m[3][1],

  00159	b8 10 00 00 00	 mov	 eax, 16
  0015e	48 6b c0 00	 imul	 rax, rax, 0
  00162	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00167	48 03 c8	 add	 rcx, rax
  0016a	48 8b c1	 mov	 rax, rcx
  0016d	b9 04 00 00 00	 mov	 ecx, 4
  00172	48 6b c9 00	 imul	 rcx, rcx, 0
  00176	ba 10 00 00 00	 mov	 edx, 16
  0017b	48 6b d2 00	 imul	 rdx, rdx, 0
  0017f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00187	4c 03 c2	 add	 r8, rdx
  0018a	49 8b d0	 mov	 rdx, r8
  0018d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00193	4d 6b c0 01	 imul	 r8, r8, 1
  00197	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0019c	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  001a2	b8 10 00 00 00	 mov	 eax, 16
  001a7	48 6b c0 00	 imul	 rax, rax, 0
  001ab	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  001b0	48 03 c8	 add	 rcx, rax
  001b3	48 8b c1	 mov	 rax, rcx
  001b6	b9 04 00 00 00	 mov	 ecx, 4
  001bb	48 6b c9 01	 imul	 rcx, rcx, 1
  001bf	ba 10 00 00 00	 mov	 edx, 16
  001c4	48 6b d2 01	 imul	 rdx, rdx, 1
  001c8	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  001d0	4c 03 c2	 add	 r8, rdx
  001d3	49 8b d0	 mov	 rdx, r8
  001d6	41 b8 04 00 00
	00		 mov	 r8d, 4
  001dc	4d 6b c0 01	 imul	 r8, r8, 1
  001e0	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  001e5	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  001eb	f3 0f 58 c1	 addss	 xmm0, xmm1
  001ef	b8 10 00 00 00	 mov	 eax, 16
  001f4	48 6b c0 00	 imul	 rax, rax, 0
  001f8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  001fd	48 03 c8	 add	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	b9 04 00 00 00	 mov	 ecx, 4
  00208	48 6b c9 02	 imul	 rcx, rcx, 2
  0020c	ba 10 00 00 00	 mov	 edx, 16
  00211	48 6b d2 02	 imul	 rdx, rdx, 2
  00215	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0021d	4c 03 c2	 add	 r8, rdx
  00220	49 8b d0	 mov	 rdx, r8
  00223	41 b8 04 00 00
	00		 mov	 r8d, 4
  00229	4d 6b c0 01	 imul	 r8, r8, 1
  0022d	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00232	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00238	f3 0f 58 c1	 addss	 xmm0, xmm1
  0023c	b8 10 00 00 00	 mov	 eax, 16
  00241	48 6b c0 00	 imul	 rax, rax, 0
  00245	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0024a	48 03 c8	 add	 rcx, rax
  0024d	48 8b c1	 mov	 rax, rcx
  00250	b9 04 00 00 00	 mov	 ecx, 4
  00255	48 6b c9 03	 imul	 rcx, rcx, 3
  00259	ba 10 00 00 00	 mov	 edx, 16
  0025e	48 6b d2 03	 imul	 rdx, rdx, 3
  00262	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0026a	4c 03 c2	 add	 r8, rdx
  0026d	49 8b d0	 mov	 rdx, r8
  00270	41 b8 04 00 00
	00		 mov	 r8d, 4
  00276	4d 6b c0 01	 imul	 r8, r8, 1
  0027a	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0027f	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00285	f3 0f 58 c1	 addss	 xmm0, xmm1
  00289	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 558  :         A.m[0][0] * B.m[0][2] + A.m[0][1] * B.m[1][2] + A.m[0][2] * B.m[2][2] + A.m[0][3] * B.m[3][2],

  0028f	b8 10 00 00 00	 mov	 eax, 16
  00294	48 6b c0 00	 imul	 rax, rax, 0
  00298	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0029d	48 03 c8	 add	 rcx, rax
  002a0	48 8b c1	 mov	 rax, rcx
  002a3	b9 04 00 00 00	 mov	 ecx, 4
  002a8	48 6b c9 00	 imul	 rcx, rcx, 0
  002ac	ba 10 00 00 00	 mov	 edx, 16
  002b1	48 6b d2 00	 imul	 rdx, rdx, 0
  002b5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  002bd	4c 03 c2	 add	 r8, rdx
  002c0	49 8b d0	 mov	 rdx, r8
  002c3	41 b8 04 00 00
	00		 mov	 r8d, 4
  002c9	4d 6b c0 02	 imul	 r8, r8, 2
  002cd	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  002d2	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  002d8	b8 10 00 00 00	 mov	 eax, 16
  002dd	48 6b c0 00	 imul	 rax, rax, 0
  002e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  002e6	48 03 c8	 add	 rcx, rax
  002e9	48 8b c1	 mov	 rax, rcx
  002ec	b9 04 00 00 00	 mov	 ecx, 4
  002f1	48 6b c9 01	 imul	 rcx, rcx, 1
  002f5	ba 10 00 00 00	 mov	 edx, 16
  002fa	48 6b d2 01	 imul	 rdx, rdx, 1
  002fe	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00306	4c 03 c2	 add	 r8, rdx
  00309	49 8b d0	 mov	 rdx, r8
  0030c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00312	4d 6b c0 02	 imul	 r8, r8, 2
  00316	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0031b	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00321	f3 0f 58 c1	 addss	 xmm0, xmm1
  00325	b8 10 00 00 00	 mov	 eax, 16
  0032a	48 6b c0 00	 imul	 rax, rax, 0
  0032e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00333	48 03 c8	 add	 rcx, rax
  00336	48 8b c1	 mov	 rax, rcx
  00339	b9 04 00 00 00	 mov	 ecx, 4
  0033e	48 6b c9 02	 imul	 rcx, rcx, 2
  00342	ba 10 00 00 00	 mov	 edx, 16
  00347	48 6b d2 02	 imul	 rdx, rdx, 2
  0034b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00353	4c 03 c2	 add	 r8, rdx
  00356	49 8b d0	 mov	 rdx, r8
  00359	41 b8 04 00 00
	00		 mov	 r8d, 4
  0035f	4d 6b c0 02	 imul	 r8, r8, 2
  00363	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00368	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0036e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00372	b8 10 00 00 00	 mov	 eax, 16
  00377	48 6b c0 00	 imul	 rax, rax, 0
  0037b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00380	48 03 c8	 add	 rcx, rax
  00383	48 8b c1	 mov	 rax, rcx
  00386	b9 04 00 00 00	 mov	 ecx, 4
  0038b	48 6b c9 03	 imul	 rcx, rcx, 3
  0038f	ba 10 00 00 00	 mov	 edx, 16
  00394	48 6b d2 03	 imul	 rdx, rdx, 3
  00398	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  003a0	4c 03 c2	 add	 r8, rdx
  003a3	49 8b d0	 mov	 rdx, r8
  003a6	41 b8 04 00 00
	00		 mov	 r8d, 4
  003ac	4d 6b c0 02	 imul	 r8, r8, 2
  003b0	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  003b5	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  003bb	f3 0f 58 c1	 addss	 xmm0, xmm1
  003bf	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 559  :         A.m[0][0] * B.m[0][3] + A.m[0][1] * B.m[1][3] + A.m[0][2] * B.m[2][3] + A.m[0][3] * B.m[3][3],

  003c5	b8 10 00 00 00	 mov	 eax, 16
  003ca	48 6b c0 00	 imul	 rax, rax, 0
  003ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  003d3	48 03 c8	 add	 rcx, rax
  003d6	48 8b c1	 mov	 rax, rcx
  003d9	b9 04 00 00 00	 mov	 ecx, 4
  003de	48 6b c9 00	 imul	 rcx, rcx, 0
  003e2	ba 10 00 00 00	 mov	 edx, 16
  003e7	48 6b d2 00	 imul	 rdx, rdx, 0
  003eb	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  003f3	4c 03 c2	 add	 r8, rdx
  003f6	49 8b d0	 mov	 rdx, r8
  003f9	41 b8 04 00 00
	00		 mov	 r8d, 4
  003ff	4d 6b c0 03	 imul	 r8, r8, 3
  00403	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00408	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0040e	b8 10 00 00 00	 mov	 eax, 16
  00413	48 6b c0 00	 imul	 rax, rax, 0
  00417	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0041c	48 03 c8	 add	 rcx, rax
  0041f	48 8b c1	 mov	 rax, rcx
  00422	b9 04 00 00 00	 mov	 ecx, 4
  00427	48 6b c9 01	 imul	 rcx, rcx, 1
  0042b	ba 10 00 00 00	 mov	 edx, 16
  00430	48 6b d2 01	 imul	 rdx, rdx, 1
  00434	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0043c	4c 03 c2	 add	 r8, rdx
  0043f	49 8b d0	 mov	 rdx, r8
  00442	41 b8 04 00 00
	00		 mov	 r8d, 4
  00448	4d 6b c0 03	 imul	 r8, r8, 3
  0044c	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00451	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00457	f3 0f 58 c1	 addss	 xmm0, xmm1
  0045b	b8 10 00 00 00	 mov	 eax, 16
  00460	48 6b c0 00	 imul	 rax, rax, 0
  00464	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00469	48 03 c8	 add	 rcx, rax
  0046c	48 8b c1	 mov	 rax, rcx
  0046f	b9 04 00 00 00	 mov	 ecx, 4
  00474	48 6b c9 02	 imul	 rcx, rcx, 2
  00478	ba 10 00 00 00	 mov	 edx, 16
  0047d	48 6b d2 02	 imul	 rdx, rdx, 2
  00481	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00489	4c 03 c2	 add	 r8, rdx
  0048c	49 8b d0	 mov	 rdx, r8
  0048f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00495	4d 6b c0 03	 imul	 r8, r8, 3
  00499	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0049e	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  004a4	f3 0f 58 c1	 addss	 xmm0, xmm1
  004a8	b8 10 00 00 00	 mov	 eax, 16
  004ad	48 6b c0 00	 imul	 rax, rax, 0
  004b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  004b6	48 03 c8	 add	 rcx, rax
  004b9	48 8b c1	 mov	 rax, rcx
  004bc	b9 04 00 00 00	 mov	 ecx, 4
  004c1	48 6b c9 03	 imul	 rcx, rcx, 3
  004c5	ba 10 00 00 00	 mov	 edx, 16
  004ca	48 6b d2 03	 imul	 rdx, rdx, 3
  004ce	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  004d6	4c 03 c2	 add	 r8, rdx
  004d9	49 8b d0	 mov	 rdx, r8
  004dc	41 b8 04 00 00
	00		 mov	 r8d, 4
  004e2	4d 6b c0 03	 imul	 r8, r8, 3
  004e6	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  004eb	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  004f1	f3 0f 58 c1	 addss	 xmm0, xmm1
  004f5	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 560  :         A.m[1][0] * B.m[0][0] + A.m[1][1] * B.m[1][0] + A.m[1][2] * B.m[2][0] + A.m[1][3] * B.m[3][0],

  004fb	b8 10 00 00 00	 mov	 eax, 16
  00500	48 6b c0 01	 imul	 rax, rax, 1
  00504	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00509	48 03 c8	 add	 rcx, rax
  0050c	48 8b c1	 mov	 rax, rcx
  0050f	b9 04 00 00 00	 mov	 ecx, 4
  00514	48 6b c9 00	 imul	 rcx, rcx, 0
  00518	ba 10 00 00 00	 mov	 edx, 16
  0051d	48 6b d2 00	 imul	 rdx, rdx, 0
  00521	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00529	4c 03 c2	 add	 r8, rdx
  0052c	49 8b d0	 mov	 rdx, r8
  0052f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00535	4d 6b c0 00	 imul	 r8, r8, 0
  00539	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0053e	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00544	b8 10 00 00 00	 mov	 eax, 16
  00549	48 6b c0 01	 imul	 rax, rax, 1
  0054d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00552	48 03 c8	 add	 rcx, rax
  00555	48 8b c1	 mov	 rax, rcx
  00558	b9 04 00 00 00	 mov	 ecx, 4
  0055d	48 6b c9 01	 imul	 rcx, rcx, 1
  00561	ba 10 00 00 00	 mov	 edx, 16
  00566	48 6b d2 01	 imul	 rdx, rdx, 1
  0056a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00572	4c 03 c2	 add	 r8, rdx
  00575	49 8b d0	 mov	 rdx, r8
  00578	41 b8 04 00 00
	00		 mov	 r8d, 4
  0057e	4d 6b c0 00	 imul	 r8, r8, 0
  00582	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00587	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0058d	f3 0f 58 c1	 addss	 xmm0, xmm1
  00591	b8 10 00 00 00	 mov	 eax, 16
  00596	48 6b c0 01	 imul	 rax, rax, 1
  0059a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0059f	48 03 c8	 add	 rcx, rax
  005a2	48 8b c1	 mov	 rax, rcx
  005a5	b9 04 00 00 00	 mov	 ecx, 4
  005aa	48 6b c9 02	 imul	 rcx, rcx, 2
  005ae	ba 10 00 00 00	 mov	 edx, 16
  005b3	48 6b d2 02	 imul	 rdx, rdx, 2
  005b7	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  005bf	4c 03 c2	 add	 r8, rdx
  005c2	49 8b d0	 mov	 rdx, r8
  005c5	41 b8 04 00 00
	00		 mov	 r8d, 4
  005cb	4d 6b c0 00	 imul	 r8, r8, 0
  005cf	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  005d4	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  005da	f3 0f 58 c1	 addss	 xmm0, xmm1
  005de	b8 10 00 00 00	 mov	 eax, 16
  005e3	48 6b c0 01	 imul	 rax, rax, 1
  005e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  005ec	48 03 c8	 add	 rcx, rax
  005ef	48 8b c1	 mov	 rax, rcx
  005f2	b9 04 00 00 00	 mov	 ecx, 4
  005f7	48 6b c9 03	 imul	 rcx, rcx, 3
  005fb	ba 10 00 00 00	 mov	 edx, 16
  00600	48 6b d2 03	 imul	 rdx, rdx, 3
  00604	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0060c	4c 03 c2	 add	 r8, rdx
  0060f	49 8b d0	 mov	 rdx, r8
  00612	41 b8 04 00 00
	00		 mov	 r8d, 4
  00618	4d 6b c0 00	 imul	 r8, r8, 0
  0061c	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00621	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00627	f3 0f 58 c1	 addss	 xmm0, xmm1
  0062b	f3 0f 11 44 24
	10		 movss	 DWORD PTR Result$[rsp+16], xmm0

; 561  :         A.m[1][0] * B.m[0][1] + A.m[1][1] * B.m[1][1] + A.m[1][2] * B.m[2][1] + A.m[1][3] * B.m[3][1],

  00631	b8 10 00 00 00	 mov	 eax, 16
  00636	48 6b c0 01	 imul	 rax, rax, 1
  0063a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0063f	48 03 c8	 add	 rcx, rax
  00642	48 8b c1	 mov	 rax, rcx
  00645	b9 04 00 00 00	 mov	 ecx, 4
  0064a	48 6b c9 00	 imul	 rcx, rcx, 0
  0064e	ba 10 00 00 00	 mov	 edx, 16
  00653	48 6b d2 00	 imul	 rdx, rdx, 0
  00657	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0065f	4c 03 c2	 add	 r8, rdx
  00662	49 8b d0	 mov	 rdx, r8
  00665	41 b8 04 00 00
	00		 mov	 r8d, 4
  0066b	4d 6b c0 01	 imul	 r8, r8, 1
  0066f	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00674	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0067a	b8 10 00 00 00	 mov	 eax, 16
  0067f	48 6b c0 01	 imul	 rax, rax, 1
  00683	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00688	48 03 c8	 add	 rcx, rax
  0068b	48 8b c1	 mov	 rax, rcx
  0068e	b9 04 00 00 00	 mov	 ecx, 4
  00693	48 6b c9 01	 imul	 rcx, rcx, 1
  00697	ba 10 00 00 00	 mov	 edx, 16
  0069c	48 6b d2 01	 imul	 rdx, rdx, 1
  006a0	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  006a8	4c 03 c2	 add	 r8, rdx
  006ab	49 8b d0	 mov	 rdx, r8
  006ae	41 b8 04 00 00
	00		 mov	 r8d, 4
  006b4	4d 6b c0 01	 imul	 r8, r8, 1
  006b8	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  006bd	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  006c3	f3 0f 58 c1	 addss	 xmm0, xmm1
  006c7	b8 10 00 00 00	 mov	 eax, 16
  006cc	48 6b c0 01	 imul	 rax, rax, 1
  006d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  006d5	48 03 c8	 add	 rcx, rax
  006d8	48 8b c1	 mov	 rax, rcx
  006db	b9 04 00 00 00	 mov	 ecx, 4
  006e0	48 6b c9 02	 imul	 rcx, rcx, 2
  006e4	ba 10 00 00 00	 mov	 edx, 16
  006e9	48 6b d2 02	 imul	 rdx, rdx, 2
  006ed	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  006f5	4c 03 c2	 add	 r8, rdx
  006f8	49 8b d0	 mov	 rdx, r8
  006fb	41 b8 04 00 00
	00		 mov	 r8d, 4
  00701	4d 6b c0 01	 imul	 r8, r8, 1
  00705	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0070a	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00710	f3 0f 58 c1	 addss	 xmm0, xmm1
  00714	b8 10 00 00 00	 mov	 eax, 16
  00719	48 6b c0 01	 imul	 rax, rax, 1
  0071d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00722	48 03 c8	 add	 rcx, rax
  00725	48 8b c1	 mov	 rax, rcx
  00728	b9 04 00 00 00	 mov	 ecx, 4
  0072d	48 6b c9 03	 imul	 rcx, rcx, 3
  00731	ba 10 00 00 00	 mov	 edx, 16
  00736	48 6b d2 03	 imul	 rdx, rdx, 3
  0073a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00742	4c 03 c2	 add	 r8, rdx
  00745	49 8b d0	 mov	 rdx, r8
  00748	41 b8 04 00 00
	00		 mov	 r8d, 4
  0074e	4d 6b c0 01	 imul	 r8, r8, 1
  00752	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00757	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0075d	f3 0f 58 c1	 addss	 xmm0, xmm1
  00761	f3 0f 11 44 24
	14		 movss	 DWORD PTR Result$[rsp+20], xmm0

; 562  :         A.m[1][0] * B.m[0][2] + A.m[1][1] * B.m[1][2] + A.m[1][2] * B.m[2][2] + A.m[1][3] * B.m[3][2],

  00767	b8 10 00 00 00	 mov	 eax, 16
  0076c	48 6b c0 01	 imul	 rax, rax, 1
  00770	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00775	48 03 c8	 add	 rcx, rax
  00778	48 8b c1	 mov	 rax, rcx
  0077b	b9 04 00 00 00	 mov	 ecx, 4
  00780	48 6b c9 00	 imul	 rcx, rcx, 0
  00784	ba 10 00 00 00	 mov	 edx, 16
  00789	48 6b d2 00	 imul	 rdx, rdx, 0
  0078d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00795	4c 03 c2	 add	 r8, rdx
  00798	49 8b d0	 mov	 rdx, r8
  0079b	41 b8 04 00 00
	00		 mov	 r8d, 4
  007a1	4d 6b c0 02	 imul	 r8, r8, 2
  007a5	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  007aa	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  007b0	b8 10 00 00 00	 mov	 eax, 16
  007b5	48 6b c0 01	 imul	 rax, rax, 1
  007b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  007be	48 03 c8	 add	 rcx, rax
  007c1	48 8b c1	 mov	 rax, rcx
  007c4	b9 04 00 00 00	 mov	 ecx, 4
  007c9	48 6b c9 01	 imul	 rcx, rcx, 1
  007cd	ba 10 00 00 00	 mov	 edx, 16
  007d2	48 6b d2 01	 imul	 rdx, rdx, 1
  007d6	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  007de	4c 03 c2	 add	 r8, rdx
  007e1	49 8b d0	 mov	 rdx, r8
  007e4	41 b8 04 00 00
	00		 mov	 r8d, 4
  007ea	4d 6b c0 02	 imul	 r8, r8, 2
  007ee	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  007f3	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  007f9	f3 0f 58 c1	 addss	 xmm0, xmm1
  007fd	b8 10 00 00 00	 mov	 eax, 16
  00802	48 6b c0 01	 imul	 rax, rax, 1
  00806	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0080b	48 03 c8	 add	 rcx, rax
  0080e	48 8b c1	 mov	 rax, rcx
  00811	b9 04 00 00 00	 mov	 ecx, 4
  00816	48 6b c9 02	 imul	 rcx, rcx, 2
  0081a	ba 10 00 00 00	 mov	 edx, 16
  0081f	48 6b d2 02	 imul	 rdx, rdx, 2
  00823	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0082b	4c 03 c2	 add	 r8, rdx
  0082e	49 8b d0	 mov	 rdx, r8
  00831	41 b8 04 00 00
	00		 mov	 r8d, 4
  00837	4d 6b c0 02	 imul	 r8, r8, 2
  0083b	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00840	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00846	f3 0f 58 c1	 addss	 xmm0, xmm1
  0084a	b8 10 00 00 00	 mov	 eax, 16
  0084f	48 6b c0 01	 imul	 rax, rax, 1
  00853	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00858	48 03 c8	 add	 rcx, rax
  0085b	48 8b c1	 mov	 rax, rcx
  0085e	b9 04 00 00 00	 mov	 ecx, 4
  00863	48 6b c9 03	 imul	 rcx, rcx, 3
  00867	ba 10 00 00 00	 mov	 edx, 16
  0086c	48 6b d2 03	 imul	 rdx, rdx, 3
  00870	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00878	4c 03 c2	 add	 r8, rdx
  0087b	49 8b d0	 mov	 rdx, r8
  0087e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00884	4d 6b c0 02	 imul	 r8, r8, 2
  00888	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0088d	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00893	f3 0f 58 c1	 addss	 xmm0, xmm1
  00897	f3 0f 11 44 24
	18		 movss	 DWORD PTR Result$[rsp+24], xmm0

; 563  :         A.m[1][0] * B.m[0][3] + A.m[1][1] * B.m[1][3] + A.m[1][2] * B.m[2][3] + A.m[1][3] * B.m[3][3],

  0089d	b8 10 00 00 00	 mov	 eax, 16
  008a2	48 6b c0 01	 imul	 rax, rax, 1
  008a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  008ab	48 03 c8	 add	 rcx, rax
  008ae	48 8b c1	 mov	 rax, rcx
  008b1	b9 04 00 00 00	 mov	 ecx, 4
  008b6	48 6b c9 00	 imul	 rcx, rcx, 0
  008ba	ba 10 00 00 00	 mov	 edx, 16
  008bf	48 6b d2 00	 imul	 rdx, rdx, 0
  008c3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  008cb	4c 03 c2	 add	 r8, rdx
  008ce	49 8b d0	 mov	 rdx, r8
  008d1	41 b8 04 00 00
	00		 mov	 r8d, 4
  008d7	4d 6b c0 03	 imul	 r8, r8, 3
  008db	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  008e0	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  008e6	b8 10 00 00 00	 mov	 eax, 16
  008eb	48 6b c0 01	 imul	 rax, rax, 1
  008ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  008f4	48 03 c8	 add	 rcx, rax
  008f7	48 8b c1	 mov	 rax, rcx
  008fa	b9 04 00 00 00	 mov	 ecx, 4
  008ff	48 6b c9 01	 imul	 rcx, rcx, 1
  00903	ba 10 00 00 00	 mov	 edx, 16
  00908	48 6b d2 01	 imul	 rdx, rdx, 1
  0090c	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00914	4c 03 c2	 add	 r8, rdx
  00917	49 8b d0	 mov	 rdx, r8
  0091a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00920	4d 6b c0 03	 imul	 r8, r8, 3
  00924	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00929	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0092f	f3 0f 58 c1	 addss	 xmm0, xmm1
  00933	b8 10 00 00 00	 mov	 eax, 16
  00938	48 6b c0 01	 imul	 rax, rax, 1
  0093c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00941	48 03 c8	 add	 rcx, rax
  00944	48 8b c1	 mov	 rax, rcx
  00947	b9 04 00 00 00	 mov	 ecx, 4
  0094c	48 6b c9 02	 imul	 rcx, rcx, 2
  00950	ba 10 00 00 00	 mov	 edx, 16
  00955	48 6b d2 02	 imul	 rdx, rdx, 2
  00959	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00961	4c 03 c2	 add	 r8, rdx
  00964	49 8b d0	 mov	 rdx, r8
  00967	41 b8 04 00 00
	00		 mov	 r8d, 4
  0096d	4d 6b c0 03	 imul	 r8, r8, 3
  00971	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00976	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0097c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00980	b8 10 00 00 00	 mov	 eax, 16
  00985	48 6b c0 01	 imul	 rax, rax, 1
  00989	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0098e	48 03 c8	 add	 rcx, rax
  00991	48 8b c1	 mov	 rax, rcx
  00994	b9 04 00 00 00	 mov	 ecx, 4
  00999	48 6b c9 03	 imul	 rcx, rcx, 3
  0099d	ba 10 00 00 00	 mov	 edx, 16
  009a2	48 6b d2 03	 imul	 rdx, rdx, 3
  009a6	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  009ae	4c 03 c2	 add	 r8, rdx
  009b1	49 8b d0	 mov	 rdx, r8
  009b4	41 b8 04 00 00
	00		 mov	 r8d, 4
  009ba	4d 6b c0 03	 imul	 r8, r8, 3
  009be	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  009c3	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  009c9	f3 0f 58 c1	 addss	 xmm0, xmm1
  009cd	f3 0f 11 44 24
	1c		 movss	 DWORD PTR Result$[rsp+28], xmm0

; 564  :         A.m[2][0] * B.m[0][0] + A.m[2][1] * B.m[1][0] + A.m[2][2] * B.m[2][0] + A.m[2][3] * B.m[3][0],

  009d3	b8 10 00 00 00	 mov	 eax, 16
  009d8	48 6b c0 02	 imul	 rax, rax, 2
  009dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  009e1	48 03 c8	 add	 rcx, rax
  009e4	48 8b c1	 mov	 rax, rcx
  009e7	b9 04 00 00 00	 mov	 ecx, 4
  009ec	48 6b c9 00	 imul	 rcx, rcx, 0
  009f0	ba 10 00 00 00	 mov	 edx, 16
  009f5	48 6b d2 00	 imul	 rdx, rdx, 0
  009f9	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00a01	4c 03 c2	 add	 r8, rdx
  00a04	49 8b d0	 mov	 rdx, r8
  00a07	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a0d	4d 6b c0 00	 imul	 r8, r8, 0
  00a11	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00a16	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00a1c	b8 10 00 00 00	 mov	 eax, 16
  00a21	48 6b c0 02	 imul	 rax, rax, 2
  00a25	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00a2a	48 03 c8	 add	 rcx, rax
  00a2d	48 8b c1	 mov	 rax, rcx
  00a30	b9 04 00 00 00	 mov	 ecx, 4
  00a35	48 6b c9 01	 imul	 rcx, rcx, 1
  00a39	ba 10 00 00 00	 mov	 edx, 16
  00a3e	48 6b d2 01	 imul	 rdx, rdx, 1
  00a42	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00a4a	4c 03 c2	 add	 r8, rdx
  00a4d	49 8b d0	 mov	 rdx, r8
  00a50	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a56	4d 6b c0 00	 imul	 r8, r8, 0
  00a5a	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00a5f	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00a65	f3 0f 58 c1	 addss	 xmm0, xmm1
  00a69	b8 10 00 00 00	 mov	 eax, 16
  00a6e	48 6b c0 02	 imul	 rax, rax, 2
  00a72	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00a77	48 03 c8	 add	 rcx, rax
  00a7a	48 8b c1	 mov	 rax, rcx
  00a7d	b9 04 00 00 00	 mov	 ecx, 4
  00a82	48 6b c9 02	 imul	 rcx, rcx, 2
  00a86	ba 10 00 00 00	 mov	 edx, 16
  00a8b	48 6b d2 02	 imul	 rdx, rdx, 2
  00a8f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00a97	4c 03 c2	 add	 r8, rdx
  00a9a	49 8b d0	 mov	 rdx, r8
  00a9d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00aa3	4d 6b c0 00	 imul	 r8, r8, 0
  00aa7	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00aac	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00ab2	f3 0f 58 c1	 addss	 xmm0, xmm1
  00ab6	b8 10 00 00 00	 mov	 eax, 16
  00abb	48 6b c0 02	 imul	 rax, rax, 2
  00abf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00ac4	48 03 c8	 add	 rcx, rax
  00ac7	48 8b c1	 mov	 rax, rcx
  00aca	b9 04 00 00 00	 mov	 ecx, 4
  00acf	48 6b c9 03	 imul	 rcx, rcx, 3
  00ad3	ba 10 00 00 00	 mov	 edx, 16
  00ad8	48 6b d2 03	 imul	 rdx, rdx, 3
  00adc	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00ae4	4c 03 c2	 add	 r8, rdx
  00ae7	49 8b d0	 mov	 rdx, r8
  00aea	41 b8 04 00 00
	00		 mov	 r8d, 4
  00af0	4d 6b c0 00	 imul	 r8, r8, 0
  00af4	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00af9	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00aff	f3 0f 58 c1	 addss	 xmm0, xmm1
  00b03	f3 0f 11 44 24
	20		 movss	 DWORD PTR Result$[rsp+32], xmm0

; 565  :         A.m[2][0] * B.m[0][1] + A.m[2][1] * B.m[1][1] + A.m[2][2] * B.m[2][1] + A.m[2][3] * B.m[3][1],

  00b09	b8 10 00 00 00	 mov	 eax, 16
  00b0e	48 6b c0 02	 imul	 rax, rax, 2
  00b12	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00b17	48 03 c8	 add	 rcx, rax
  00b1a	48 8b c1	 mov	 rax, rcx
  00b1d	b9 04 00 00 00	 mov	 ecx, 4
  00b22	48 6b c9 00	 imul	 rcx, rcx, 0
  00b26	ba 10 00 00 00	 mov	 edx, 16
  00b2b	48 6b d2 00	 imul	 rdx, rdx, 0
  00b2f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00b37	4c 03 c2	 add	 r8, rdx
  00b3a	49 8b d0	 mov	 rdx, r8
  00b3d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00b43	4d 6b c0 01	 imul	 r8, r8, 1
  00b47	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00b4c	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00b52	b8 10 00 00 00	 mov	 eax, 16
  00b57	48 6b c0 02	 imul	 rax, rax, 2
  00b5b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00b60	48 03 c8	 add	 rcx, rax
  00b63	48 8b c1	 mov	 rax, rcx
  00b66	b9 04 00 00 00	 mov	 ecx, 4
  00b6b	48 6b c9 01	 imul	 rcx, rcx, 1
  00b6f	ba 10 00 00 00	 mov	 edx, 16
  00b74	48 6b d2 01	 imul	 rdx, rdx, 1
  00b78	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00b80	4c 03 c2	 add	 r8, rdx
  00b83	49 8b d0	 mov	 rdx, r8
  00b86	41 b8 04 00 00
	00		 mov	 r8d, 4
  00b8c	4d 6b c0 01	 imul	 r8, r8, 1
  00b90	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00b95	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00b9b	f3 0f 58 c1	 addss	 xmm0, xmm1
  00b9f	b8 10 00 00 00	 mov	 eax, 16
  00ba4	48 6b c0 02	 imul	 rax, rax, 2
  00ba8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00bad	48 03 c8	 add	 rcx, rax
  00bb0	48 8b c1	 mov	 rax, rcx
  00bb3	b9 04 00 00 00	 mov	 ecx, 4
  00bb8	48 6b c9 02	 imul	 rcx, rcx, 2
  00bbc	ba 10 00 00 00	 mov	 edx, 16
  00bc1	48 6b d2 02	 imul	 rdx, rdx, 2
  00bc5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00bcd	4c 03 c2	 add	 r8, rdx
  00bd0	49 8b d0	 mov	 rdx, r8
  00bd3	41 b8 04 00 00
	00		 mov	 r8d, 4
  00bd9	4d 6b c0 01	 imul	 r8, r8, 1
  00bdd	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00be2	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00be8	f3 0f 58 c1	 addss	 xmm0, xmm1
  00bec	b8 10 00 00 00	 mov	 eax, 16
  00bf1	48 6b c0 02	 imul	 rax, rax, 2
  00bf5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00bfa	48 03 c8	 add	 rcx, rax
  00bfd	48 8b c1	 mov	 rax, rcx
  00c00	b9 04 00 00 00	 mov	 ecx, 4
  00c05	48 6b c9 03	 imul	 rcx, rcx, 3
  00c09	ba 10 00 00 00	 mov	 edx, 16
  00c0e	48 6b d2 03	 imul	 rdx, rdx, 3
  00c12	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00c1a	4c 03 c2	 add	 r8, rdx
  00c1d	49 8b d0	 mov	 rdx, r8
  00c20	41 b8 04 00 00
	00		 mov	 r8d, 4
  00c26	4d 6b c0 01	 imul	 r8, r8, 1
  00c2a	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00c2f	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00c35	f3 0f 58 c1	 addss	 xmm0, xmm1
  00c39	f3 0f 11 44 24
	24		 movss	 DWORD PTR Result$[rsp+36], xmm0

; 566  :         A.m[2][0] * B.m[0][2] + A.m[2][1] * B.m[1][2] + A.m[2][2] * B.m[2][2] + A.m[2][3] * B.m[3][2],

  00c3f	b8 10 00 00 00	 mov	 eax, 16
  00c44	48 6b c0 02	 imul	 rax, rax, 2
  00c48	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00c4d	48 03 c8	 add	 rcx, rax
  00c50	48 8b c1	 mov	 rax, rcx
  00c53	b9 04 00 00 00	 mov	 ecx, 4
  00c58	48 6b c9 00	 imul	 rcx, rcx, 0
  00c5c	ba 10 00 00 00	 mov	 edx, 16
  00c61	48 6b d2 00	 imul	 rdx, rdx, 0
  00c65	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00c6d	4c 03 c2	 add	 r8, rdx
  00c70	49 8b d0	 mov	 rdx, r8
  00c73	41 b8 04 00 00
	00		 mov	 r8d, 4
  00c79	4d 6b c0 02	 imul	 r8, r8, 2
  00c7d	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00c82	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00c88	b8 10 00 00 00	 mov	 eax, 16
  00c8d	48 6b c0 02	 imul	 rax, rax, 2
  00c91	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00c96	48 03 c8	 add	 rcx, rax
  00c99	48 8b c1	 mov	 rax, rcx
  00c9c	b9 04 00 00 00	 mov	 ecx, 4
  00ca1	48 6b c9 01	 imul	 rcx, rcx, 1
  00ca5	ba 10 00 00 00	 mov	 edx, 16
  00caa	48 6b d2 01	 imul	 rdx, rdx, 1
  00cae	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00cb6	4c 03 c2	 add	 r8, rdx
  00cb9	49 8b d0	 mov	 rdx, r8
  00cbc	41 b8 04 00 00
	00		 mov	 r8d, 4
  00cc2	4d 6b c0 02	 imul	 r8, r8, 2
  00cc6	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00ccb	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00cd1	f3 0f 58 c1	 addss	 xmm0, xmm1
  00cd5	b8 10 00 00 00	 mov	 eax, 16
  00cda	48 6b c0 02	 imul	 rax, rax, 2
  00cde	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00ce3	48 03 c8	 add	 rcx, rax
  00ce6	48 8b c1	 mov	 rax, rcx
  00ce9	b9 04 00 00 00	 mov	 ecx, 4
  00cee	48 6b c9 02	 imul	 rcx, rcx, 2
  00cf2	ba 10 00 00 00	 mov	 edx, 16
  00cf7	48 6b d2 02	 imul	 rdx, rdx, 2
  00cfb	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00d03	4c 03 c2	 add	 r8, rdx
  00d06	49 8b d0	 mov	 rdx, r8
  00d09	41 b8 04 00 00
	00		 mov	 r8d, 4
  00d0f	4d 6b c0 02	 imul	 r8, r8, 2
  00d13	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00d18	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00d1e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00d22	b8 10 00 00 00	 mov	 eax, 16
  00d27	48 6b c0 02	 imul	 rax, rax, 2
  00d2b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00d30	48 03 c8	 add	 rcx, rax
  00d33	48 8b c1	 mov	 rax, rcx
  00d36	b9 04 00 00 00	 mov	 ecx, 4
  00d3b	48 6b c9 03	 imul	 rcx, rcx, 3
  00d3f	ba 10 00 00 00	 mov	 edx, 16
  00d44	48 6b d2 03	 imul	 rdx, rdx, 3
  00d48	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00d50	4c 03 c2	 add	 r8, rdx
  00d53	49 8b d0	 mov	 rdx, r8
  00d56	41 b8 04 00 00
	00		 mov	 r8d, 4
  00d5c	4d 6b c0 02	 imul	 r8, r8, 2
  00d60	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00d65	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00d6b	f3 0f 58 c1	 addss	 xmm0, xmm1
  00d6f	f3 0f 11 44 24
	28		 movss	 DWORD PTR Result$[rsp+40], xmm0

; 567  :         A.m[2][0] * B.m[0][3] + A.m[2][1] * B.m[1][3] + A.m[2][2] * B.m[2][3] + A.m[2][3] * B.m[3][3],

  00d75	b8 10 00 00 00	 mov	 eax, 16
  00d7a	48 6b c0 02	 imul	 rax, rax, 2
  00d7e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00d83	48 03 c8	 add	 rcx, rax
  00d86	48 8b c1	 mov	 rax, rcx
  00d89	b9 04 00 00 00	 mov	 ecx, 4
  00d8e	48 6b c9 00	 imul	 rcx, rcx, 0
  00d92	ba 10 00 00 00	 mov	 edx, 16
  00d97	48 6b d2 00	 imul	 rdx, rdx, 0
  00d9b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00da3	4c 03 c2	 add	 r8, rdx
  00da6	49 8b d0	 mov	 rdx, r8
  00da9	41 b8 04 00 00
	00		 mov	 r8d, 4
  00daf	4d 6b c0 03	 imul	 r8, r8, 3
  00db3	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00db8	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00dbe	b8 10 00 00 00	 mov	 eax, 16
  00dc3	48 6b c0 02	 imul	 rax, rax, 2
  00dc7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00dcc	48 03 c8	 add	 rcx, rax
  00dcf	48 8b c1	 mov	 rax, rcx
  00dd2	b9 04 00 00 00	 mov	 ecx, 4
  00dd7	48 6b c9 01	 imul	 rcx, rcx, 1
  00ddb	ba 10 00 00 00	 mov	 edx, 16
  00de0	48 6b d2 01	 imul	 rdx, rdx, 1
  00de4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00dec	4c 03 c2	 add	 r8, rdx
  00def	49 8b d0	 mov	 rdx, r8
  00df2	41 b8 04 00 00
	00		 mov	 r8d, 4
  00df8	4d 6b c0 03	 imul	 r8, r8, 3
  00dfc	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00e01	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00e07	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e0b	b8 10 00 00 00	 mov	 eax, 16
  00e10	48 6b c0 02	 imul	 rax, rax, 2
  00e14	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00e19	48 03 c8	 add	 rcx, rax
  00e1c	48 8b c1	 mov	 rax, rcx
  00e1f	b9 04 00 00 00	 mov	 ecx, 4
  00e24	48 6b c9 02	 imul	 rcx, rcx, 2
  00e28	ba 10 00 00 00	 mov	 edx, 16
  00e2d	48 6b d2 02	 imul	 rdx, rdx, 2
  00e31	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00e39	4c 03 c2	 add	 r8, rdx
  00e3c	49 8b d0	 mov	 rdx, r8
  00e3f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00e45	4d 6b c0 03	 imul	 r8, r8, 3
  00e49	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00e4e	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00e54	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e58	b8 10 00 00 00	 mov	 eax, 16
  00e5d	48 6b c0 02	 imul	 rax, rax, 2
  00e61	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00e66	48 03 c8	 add	 rcx, rax
  00e69	48 8b c1	 mov	 rax, rcx
  00e6c	b9 04 00 00 00	 mov	 ecx, 4
  00e71	48 6b c9 03	 imul	 rcx, rcx, 3
  00e75	ba 10 00 00 00	 mov	 edx, 16
  00e7a	48 6b d2 03	 imul	 rdx, rdx, 3
  00e7e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00e86	4c 03 c2	 add	 r8, rdx
  00e89	49 8b d0	 mov	 rdx, r8
  00e8c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00e92	4d 6b c0 03	 imul	 r8, r8, 3
  00e96	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00e9b	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00ea1	f3 0f 58 c1	 addss	 xmm0, xmm1
  00ea5	f3 0f 11 44 24
	2c		 movss	 DWORD PTR Result$[rsp+44], xmm0

; 568  :         A.m[3][0] * B.m[0][0] + A.m[3][1] * B.m[1][0] + A.m[3][2] * B.m[2][0] + A.m[3][3] * B.m[3][0],

  00eab	b8 10 00 00 00	 mov	 eax, 16
  00eb0	48 6b c0 03	 imul	 rax, rax, 3
  00eb4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00eb9	48 03 c8	 add	 rcx, rax
  00ebc	48 8b c1	 mov	 rax, rcx
  00ebf	b9 04 00 00 00	 mov	 ecx, 4
  00ec4	48 6b c9 00	 imul	 rcx, rcx, 0
  00ec8	ba 10 00 00 00	 mov	 edx, 16
  00ecd	48 6b d2 00	 imul	 rdx, rdx, 0
  00ed1	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00ed9	4c 03 c2	 add	 r8, rdx
  00edc	49 8b d0	 mov	 rdx, r8
  00edf	41 b8 04 00 00
	00		 mov	 r8d, 4
  00ee5	4d 6b c0 00	 imul	 r8, r8, 0
  00ee9	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00eee	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00ef4	b8 10 00 00 00	 mov	 eax, 16
  00ef9	48 6b c0 03	 imul	 rax, rax, 3
  00efd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00f02	48 03 c8	 add	 rcx, rax
  00f05	48 8b c1	 mov	 rax, rcx
  00f08	b9 04 00 00 00	 mov	 ecx, 4
  00f0d	48 6b c9 01	 imul	 rcx, rcx, 1
  00f11	ba 10 00 00 00	 mov	 edx, 16
  00f16	48 6b d2 01	 imul	 rdx, rdx, 1
  00f1a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00f22	4c 03 c2	 add	 r8, rdx
  00f25	49 8b d0	 mov	 rdx, r8
  00f28	41 b8 04 00 00
	00		 mov	 r8d, 4
  00f2e	4d 6b c0 00	 imul	 r8, r8, 0
  00f32	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00f37	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00f3d	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f41	b8 10 00 00 00	 mov	 eax, 16
  00f46	48 6b c0 03	 imul	 rax, rax, 3
  00f4a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00f4f	48 03 c8	 add	 rcx, rax
  00f52	48 8b c1	 mov	 rax, rcx
  00f55	b9 04 00 00 00	 mov	 ecx, 4
  00f5a	48 6b c9 02	 imul	 rcx, rcx, 2
  00f5e	ba 10 00 00 00	 mov	 edx, 16
  00f63	48 6b d2 02	 imul	 rdx, rdx, 2
  00f67	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00f6f	4c 03 c2	 add	 r8, rdx
  00f72	49 8b d0	 mov	 rdx, r8
  00f75	41 b8 04 00 00
	00		 mov	 r8d, 4
  00f7b	4d 6b c0 00	 imul	 r8, r8, 0
  00f7f	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00f84	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00f8a	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f8e	b8 10 00 00 00	 mov	 eax, 16
  00f93	48 6b c0 03	 imul	 rax, rax, 3
  00f97	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00f9c	48 03 c8	 add	 rcx, rax
  00f9f	48 8b c1	 mov	 rax, rcx
  00fa2	b9 04 00 00 00	 mov	 ecx, 4
  00fa7	48 6b c9 03	 imul	 rcx, rcx, 3
  00fab	ba 10 00 00 00	 mov	 edx, 16
  00fb0	48 6b d2 03	 imul	 rdx, rdx, 3
  00fb4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  00fbc	4c 03 c2	 add	 r8, rdx
  00fbf	49 8b d0	 mov	 rdx, r8
  00fc2	41 b8 04 00 00
	00		 mov	 r8d, 4
  00fc8	4d 6b c0 00	 imul	 r8, r8, 0
  00fcc	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00fd1	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00fd7	f3 0f 58 c1	 addss	 xmm0, xmm1
  00fdb	f3 0f 11 44 24
	30		 movss	 DWORD PTR Result$[rsp+48], xmm0

; 569  :         A.m[3][0] * B.m[0][1] + A.m[3][1] * B.m[1][1] + A.m[3][2] * B.m[2][1] + A.m[3][3] * B.m[3][1],

  00fe1	b8 10 00 00 00	 mov	 eax, 16
  00fe6	48 6b c0 03	 imul	 rax, rax, 3
  00fea	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00fef	48 03 c8	 add	 rcx, rax
  00ff2	48 8b c1	 mov	 rax, rcx
  00ff5	b9 04 00 00 00	 mov	 ecx, 4
  00ffa	48 6b c9 00	 imul	 rcx, rcx, 0
  00ffe	ba 10 00 00 00	 mov	 edx, 16
  01003	48 6b d2 00	 imul	 rdx, rdx, 0
  01007	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0100f	4c 03 c2	 add	 r8, rdx
  01012	49 8b d0	 mov	 rdx, r8
  01015	41 b8 04 00 00
	00		 mov	 r8d, 4
  0101b	4d 6b c0 01	 imul	 r8, r8, 1
  0101f	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  01024	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0102a	b8 10 00 00 00	 mov	 eax, 16
  0102f	48 6b c0 03	 imul	 rax, rax, 3
  01033	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  01038	48 03 c8	 add	 rcx, rax
  0103b	48 8b c1	 mov	 rax, rcx
  0103e	b9 04 00 00 00	 mov	 ecx, 4
  01043	48 6b c9 01	 imul	 rcx, rcx, 1
  01047	ba 10 00 00 00	 mov	 edx, 16
  0104c	48 6b d2 01	 imul	 rdx, rdx, 1
  01050	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  01058	4c 03 c2	 add	 r8, rdx
  0105b	49 8b d0	 mov	 rdx, r8
  0105e	41 b8 04 00 00
	00		 mov	 r8d, 4
  01064	4d 6b c0 01	 imul	 r8, r8, 1
  01068	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0106d	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  01073	f3 0f 58 c1	 addss	 xmm0, xmm1
  01077	b8 10 00 00 00	 mov	 eax, 16
  0107c	48 6b c0 03	 imul	 rax, rax, 3
  01080	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  01085	48 03 c8	 add	 rcx, rax
  01088	48 8b c1	 mov	 rax, rcx
  0108b	b9 04 00 00 00	 mov	 ecx, 4
  01090	48 6b c9 02	 imul	 rcx, rcx, 2
  01094	ba 10 00 00 00	 mov	 edx, 16
  01099	48 6b d2 02	 imul	 rdx, rdx, 2
  0109d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  010a5	4c 03 c2	 add	 r8, rdx
  010a8	49 8b d0	 mov	 rdx, r8
  010ab	41 b8 04 00 00
	00		 mov	 r8d, 4
  010b1	4d 6b c0 01	 imul	 r8, r8, 1
  010b5	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  010ba	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  010c0	f3 0f 58 c1	 addss	 xmm0, xmm1
  010c4	b8 10 00 00 00	 mov	 eax, 16
  010c9	48 6b c0 03	 imul	 rax, rax, 3
  010cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  010d2	48 03 c8	 add	 rcx, rax
  010d5	48 8b c1	 mov	 rax, rcx
  010d8	b9 04 00 00 00	 mov	 ecx, 4
  010dd	48 6b c9 03	 imul	 rcx, rcx, 3
  010e1	ba 10 00 00 00	 mov	 edx, 16
  010e6	48 6b d2 03	 imul	 rdx, rdx, 3
  010ea	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  010f2	4c 03 c2	 add	 r8, rdx
  010f5	49 8b d0	 mov	 rdx, r8
  010f8	41 b8 04 00 00
	00		 mov	 r8d, 4
  010fe	4d 6b c0 01	 imul	 r8, r8, 1
  01102	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01107	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0110d	f3 0f 58 c1	 addss	 xmm0, xmm1
  01111	f3 0f 11 44 24
	34		 movss	 DWORD PTR Result$[rsp+52], xmm0

; 570  :         A.m[3][0] * B.m[0][2] + A.m[3][1] * B.m[1][2] + A.m[3][2] * B.m[2][2] + A.m[3][3] * B.m[3][2],

  01117	b8 10 00 00 00	 mov	 eax, 16
  0111c	48 6b c0 03	 imul	 rax, rax, 3
  01120	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  01125	48 03 c8	 add	 rcx, rax
  01128	48 8b c1	 mov	 rax, rcx
  0112b	b9 04 00 00 00	 mov	 ecx, 4
  01130	48 6b c9 00	 imul	 rcx, rcx, 0
  01134	ba 10 00 00 00	 mov	 edx, 16
  01139	48 6b d2 00	 imul	 rdx, rdx, 0
  0113d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  01145	4c 03 c2	 add	 r8, rdx
  01148	49 8b d0	 mov	 rdx, r8
  0114b	41 b8 04 00 00
	00		 mov	 r8d, 4
  01151	4d 6b c0 02	 imul	 r8, r8, 2
  01155	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0115a	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  01160	b8 10 00 00 00	 mov	 eax, 16
  01165	48 6b c0 03	 imul	 rax, rax, 3
  01169	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0116e	48 03 c8	 add	 rcx, rax
  01171	48 8b c1	 mov	 rax, rcx
  01174	b9 04 00 00 00	 mov	 ecx, 4
  01179	48 6b c9 01	 imul	 rcx, rcx, 1
  0117d	ba 10 00 00 00	 mov	 edx, 16
  01182	48 6b d2 01	 imul	 rdx, rdx, 1
  01186	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0118e	4c 03 c2	 add	 r8, rdx
  01191	49 8b d0	 mov	 rdx, r8
  01194	41 b8 04 00 00
	00		 mov	 r8d, 4
  0119a	4d 6b c0 02	 imul	 r8, r8, 2
  0119e	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  011a3	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  011a9	f3 0f 58 c1	 addss	 xmm0, xmm1
  011ad	b8 10 00 00 00	 mov	 eax, 16
  011b2	48 6b c0 03	 imul	 rax, rax, 3
  011b6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  011bb	48 03 c8	 add	 rcx, rax
  011be	48 8b c1	 mov	 rax, rcx
  011c1	b9 04 00 00 00	 mov	 ecx, 4
  011c6	48 6b c9 02	 imul	 rcx, rcx, 2
  011ca	ba 10 00 00 00	 mov	 edx, 16
  011cf	48 6b d2 02	 imul	 rdx, rdx, 2
  011d3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  011db	4c 03 c2	 add	 r8, rdx
  011de	49 8b d0	 mov	 rdx, r8
  011e1	41 b8 04 00 00
	00		 mov	 r8d, 4
  011e7	4d 6b c0 02	 imul	 r8, r8, 2
  011eb	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  011f0	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  011f6	f3 0f 58 c1	 addss	 xmm0, xmm1
  011fa	b8 10 00 00 00	 mov	 eax, 16
  011ff	48 6b c0 03	 imul	 rax, rax, 3
  01203	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  01208	48 03 c8	 add	 rcx, rax
  0120b	48 8b c1	 mov	 rax, rcx
  0120e	b9 04 00 00 00	 mov	 ecx, 4
  01213	48 6b c9 03	 imul	 rcx, rcx, 3
  01217	ba 10 00 00 00	 mov	 edx, 16
  0121c	48 6b d2 03	 imul	 rdx, rdx, 3
  01220	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  01228	4c 03 c2	 add	 r8, rdx
  0122b	49 8b d0	 mov	 rdx, r8
  0122e	41 b8 04 00 00
	00		 mov	 r8d, 4
  01234	4d 6b c0 02	 imul	 r8, r8, 2
  01238	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0123d	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  01243	f3 0f 58 c1	 addss	 xmm0, xmm1
  01247	f3 0f 11 44 24
	38		 movss	 DWORD PTR Result$[rsp+56], xmm0

; 571  :         A.m[3][0] * B.m[0][3] + A.m[3][1] * B.m[1][3] + A.m[3][2] * B.m[2][3] + A.m[3][3] * B.m[3][3],

  0124d	b8 10 00 00 00	 mov	 eax, 16
  01252	48 6b c0 03	 imul	 rax, rax, 3
  01256	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0125b	48 03 c8	 add	 rcx, rax
  0125e	48 8b c1	 mov	 rax, rcx
  01261	b9 04 00 00 00	 mov	 ecx, 4
  01266	48 6b c9 00	 imul	 rcx, rcx, 0
  0126a	ba 10 00 00 00	 mov	 edx, 16
  0126f	48 6b d2 00	 imul	 rdx, rdx, 0
  01273	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0127b	4c 03 c2	 add	 r8, rdx
  0127e	49 8b d0	 mov	 rdx, r8
  01281	41 b8 04 00 00
	00		 mov	 r8d, 4
  01287	4d 6b c0 03	 imul	 r8, r8, 3
  0128b	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  01290	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  01296	b8 10 00 00 00	 mov	 eax, 16
  0129b	48 6b c0 03	 imul	 rax, rax, 3
  0129f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  012a4	48 03 c8	 add	 rcx, rax
  012a7	48 8b c1	 mov	 rax, rcx
  012aa	b9 04 00 00 00	 mov	 ecx, 4
  012af	48 6b c9 01	 imul	 rcx, rcx, 1
  012b3	ba 10 00 00 00	 mov	 edx, 16
  012b8	48 6b d2 01	 imul	 rdx, rdx, 1
  012bc	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  012c4	4c 03 c2	 add	 r8, rdx
  012c7	49 8b d0	 mov	 rdx, r8
  012ca	41 b8 04 00 00
	00		 mov	 r8d, 4
  012d0	4d 6b c0 03	 imul	 r8, r8, 3
  012d4	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  012d9	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  012df	f3 0f 58 c1	 addss	 xmm0, xmm1
  012e3	b8 10 00 00 00	 mov	 eax, 16
  012e8	48 6b c0 03	 imul	 rax, rax, 3
  012ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  012f1	48 03 c8	 add	 rcx, rax
  012f4	48 8b c1	 mov	 rax, rcx
  012f7	b9 04 00 00 00	 mov	 ecx, 4
  012fc	48 6b c9 02	 imul	 rcx, rcx, 2
  01300	ba 10 00 00 00	 mov	 edx, 16
  01305	48 6b d2 02	 imul	 rdx, rdx, 2
  01309	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  01311	4c 03 c2	 add	 r8, rdx
  01314	49 8b d0	 mov	 rdx, r8
  01317	41 b8 04 00 00
	00		 mov	 r8d, 4
  0131d	4d 6b c0 03	 imul	 r8, r8, 3
  01321	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01326	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0132c	f3 0f 58 c1	 addss	 xmm0, xmm1
  01330	b8 10 00 00 00	 mov	 eax, 16
  01335	48 6b c0 03	 imul	 rax, rax, 3
  01339	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0133e	48 03 c8	 add	 rcx, rax
  01341	48 8b c1	 mov	 rax, rcx
  01344	b9 04 00 00 00	 mov	 ecx, 4
  01349	48 6b c9 03	 imul	 rcx, rcx, 3
  0134d	ba 10 00 00 00	 mov	 edx, 16
  01352	48 6b d2 03	 imul	 rdx, rdx, 3
  01356	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR B$[rsp]
  0135e	4c 03 c2	 add	 r8, rdx
  01361	49 8b d0	 mov	 rdx, r8
  01364	41 b8 04 00 00
	00		 mov	 r8d, 4
  0136a	4d 6b c0 03	 imul	 r8, r8, 3
  0136e	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01373	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  01379	f3 0f 58 c1	 addss	 xmm0, xmm1
  0137d	f3 0f 11 44 24
	3c		 movss	 DWORD PTR Result$[rsp+60], xmm0

; 572  :     };
; 573  :     
; 574  :     return(Result);

  01383	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  01387	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T1[rsp]
  0138c	48 8b f0	 mov	 rsi, rax
  0138f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  01394	f3 a4		 rep movsb
  01396	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]

; 575  : }

  0139b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  013a0	48 33 cc	 xor	 rcx, rsp
  013a3	e8 00 00 00 00	 call	 __security_check_cookie
  013a8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  013ac	5f		 pop	 rdi
  013ad	5e		 pop	 rsi
  013ae	c3		 ret	 0
??D@YA?ATmat4@@T0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Idet$ = 0
C$ = 8
S$ = 32
__$ArrayPad$ = 56
Result$ = 80
A$ = 88
?Mat4Inverse@@YAXPEATmat4@@0@Z PROC			; Mat4Inverse

; 511  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 512  :     f32 S[6];
; 513  :     S[0] = A->m[0][0]*A->m[1][1] - A->m[1][0]*A->m[0][1];

  0001d	b8 10 00 00 00	 mov	 eax, 16
  00022	48 6b c0 00	 imul	 rax, rax, 0
  00026	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0002b	48 03 c8	 add	 rcx, rax
  0002e	48 8b c1	 mov	 rax, rcx
  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	48 6b c9 00	 imul	 rcx, rcx, 0
  0003a	ba 10 00 00 00	 mov	 edx, 16
  0003f	48 6b d2 01	 imul	 rdx, rdx, 1
  00043	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00048	4c 03 c2	 add	 r8, rdx
  0004b	49 8b d0	 mov	 rdx, r8
  0004e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00054	4d 6b c0 01	 imul	 r8, r8, 1
  00058	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0005d	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00063	b8 10 00 00 00	 mov	 eax, 16
  00068	48 6b c0 01	 imul	 rax, rax, 1
  0006c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00071	48 03 c8	 add	 rcx, rax
  00074	48 8b c1	 mov	 rax, rcx
  00077	b9 04 00 00 00	 mov	 ecx, 4
  0007c	48 6b c9 00	 imul	 rcx, rcx, 0
  00080	ba 10 00 00 00	 mov	 edx, 16
  00085	48 6b d2 00	 imul	 rdx, rdx, 0
  00089	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  0008e	4c 03 c2	 add	 r8, rdx
  00091	49 8b d0	 mov	 rdx, r8
  00094	41 b8 04 00 00
	00		 mov	 r8d, 4
  0009a	4d 6b c0 01	 imul	 r8, r8, 1
  0009e	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  000a3	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  000a9	f3 0f 5c c1	 subss	 xmm0, xmm1
  000ad	b8 04 00 00 00	 mov	 eax, 4
  000b2	48 6b c0 00	 imul	 rax, rax, 0
  000b6	f3 0f 11 44 04
	20		 movss	 DWORD PTR S$[rsp+rax], xmm0

; 514  :     S[1] = A->m[0][0]*A->m[1][2] - A->m[1][0]*A->m[0][2];

  000bc	b8 10 00 00 00	 mov	 eax, 16
  000c1	48 6b c0 00	 imul	 rax, rax, 0
  000c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  000ca	48 03 c8	 add	 rcx, rax
  000cd	48 8b c1	 mov	 rax, rcx
  000d0	b9 04 00 00 00	 mov	 ecx, 4
  000d5	48 6b c9 00	 imul	 rcx, rcx, 0
  000d9	ba 10 00 00 00	 mov	 edx, 16
  000de	48 6b d2 01	 imul	 rdx, rdx, 1
  000e2	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  000e7	4c 03 c2	 add	 r8, rdx
  000ea	49 8b d0	 mov	 rdx, r8
  000ed	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f3	4d 6b c0 02	 imul	 r8, r8, 2
  000f7	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  000fc	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00102	b8 10 00 00 00	 mov	 eax, 16
  00107	48 6b c0 01	 imul	 rax, rax, 1
  0010b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00110	48 03 c8	 add	 rcx, rax
  00113	48 8b c1	 mov	 rax, rcx
  00116	b9 04 00 00 00	 mov	 ecx, 4
  0011b	48 6b c9 00	 imul	 rcx, rcx, 0
  0011f	ba 10 00 00 00	 mov	 edx, 16
  00124	48 6b d2 00	 imul	 rdx, rdx, 0
  00128	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  0012d	4c 03 c2	 add	 r8, rdx
  00130	49 8b d0	 mov	 rdx, r8
  00133	41 b8 04 00 00
	00		 mov	 r8d, 4
  00139	4d 6b c0 02	 imul	 r8, r8, 2
  0013d	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00142	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00148	f3 0f 5c c1	 subss	 xmm0, xmm1
  0014c	b8 04 00 00 00	 mov	 eax, 4
  00151	48 6b c0 01	 imul	 rax, rax, 1
  00155	f3 0f 11 44 04
	20		 movss	 DWORD PTR S$[rsp+rax], xmm0

; 515  :     S[2] = A->m[0][0]*A->m[1][3] - A->m[1][0]*A->m[0][3];

  0015b	b8 10 00 00 00	 mov	 eax, 16
  00160	48 6b c0 00	 imul	 rax, rax, 0
  00164	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00169	48 03 c8	 add	 rcx, rax
  0016c	48 8b c1	 mov	 rax, rcx
  0016f	b9 04 00 00 00	 mov	 ecx, 4
  00174	48 6b c9 00	 imul	 rcx, rcx, 0
  00178	ba 10 00 00 00	 mov	 edx, 16
  0017d	48 6b d2 01	 imul	 rdx, rdx, 1
  00181	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00186	4c 03 c2	 add	 r8, rdx
  00189	49 8b d0	 mov	 rdx, r8
  0018c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00192	4d 6b c0 03	 imul	 r8, r8, 3
  00196	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0019b	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  001a1	b8 10 00 00 00	 mov	 eax, 16
  001a6	48 6b c0 01	 imul	 rax, rax, 1
  001aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  001af	48 03 c8	 add	 rcx, rax
  001b2	48 8b c1	 mov	 rax, rcx
  001b5	b9 04 00 00 00	 mov	 ecx, 4
  001ba	48 6b c9 00	 imul	 rcx, rcx, 0
  001be	ba 10 00 00 00	 mov	 edx, 16
  001c3	48 6b d2 00	 imul	 rdx, rdx, 0
  001c7	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  001cc	4c 03 c2	 add	 r8, rdx
  001cf	49 8b d0	 mov	 rdx, r8
  001d2	41 b8 04 00 00
	00		 mov	 r8d, 4
  001d8	4d 6b c0 03	 imul	 r8, r8, 3
  001dc	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  001e1	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  001e7	f3 0f 5c c1	 subss	 xmm0, xmm1
  001eb	b8 04 00 00 00	 mov	 eax, 4
  001f0	48 6b c0 02	 imul	 rax, rax, 2
  001f4	f3 0f 11 44 04
	20		 movss	 DWORD PTR S$[rsp+rax], xmm0

; 516  :     S[3] = A->m[0][1]*A->m[1][2] - A->m[1][1]*A->m[0][2];

  001fa	b8 10 00 00 00	 mov	 eax, 16
  001ff	48 6b c0 00	 imul	 rax, rax, 0
  00203	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00208	48 03 c8	 add	 rcx, rax
  0020b	48 8b c1	 mov	 rax, rcx
  0020e	b9 04 00 00 00	 mov	 ecx, 4
  00213	48 6b c9 01	 imul	 rcx, rcx, 1
  00217	ba 10 00 00 00	 mov	 edx, 16
  0021c	48 6b d2 01	 imul	 rdx, rdx, 1
  00220	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00225	4c 03 c2	 add	 r8, rdx
  00228	49 8b d0	 mov	 rdx, r8
  0022b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00231	4d 6b c0 02	 imul	 r8, r8, 2
  00235	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0023a	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00240	b8 10 00 00 00	 mov	 eax, 16
  00245	48 6b c0 01	 imul	 rax, rax, 1
  00249	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0024e	48 03 c8	 add	 rcx, rax
  00251	48 8b c1	 mov	 rax, rcx
  00254	b9 04 00 00 00	 mov	 ecx, 4
  00259	48 6b c9 01	 imul	 rcx, rcx, 1
  0025d	ba 10 00 00 00	 mov	 edx, 16
  00262	48 6b d2 00	 imul	 rdx, rdx, 0
  00266	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  0026b	4c 03 c2	 add	 r8, rdx
  0026e	49 8b d0	 mov	 rdx, r8
  00271	41 b8 04 00 00
	00		 mov	 r8d, 4
  00277	4d 6b c0 02	 imul	 r8, r8, 2
  0027b	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00280	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00286	f3 0f 5c c1	 subss	 xmm0, xmm1
  0028a	b8 04 00 00 00	 mov	 eax, 4
  0028f	48 6b c0 03	 imul	 rax, rax, 3
  00293	f3 0f 11 44 04
	20		 movss	 DWORD PTR S$[rsp+rax], xmm0

; 517  :     S[4] = A->m[0][1]*A->m[1][3] - A->m[1][1]*A->m[0][3];

  00299	b8 10 00 00 00	 mov	 eax, 16
  0029e	48 6b c0 00	 imul	 rax, rax, 0
  002a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  002a7	48 03 c8	 add	 rcx, rax
  002aa	48 8b c1	 mov	 rax, rcx
  002ad	b9 04 00 00 00	 mov	 ecx, 4
  002b2	48 6b c9 01	 imul	 rcx, rcx, 1
  002b6	ba 10 00 00 00	 mov	 edx, 16
  002bb	48 6b d2 01	 imul	 rdx, rdx, 1
  002bf	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  002c4	4c 03 c2	 add	 r8, rdx
  002c7	49 8b d0	 mov	 rdx, r8
  002ca	41 b8 04 00 00
	00		 mov	 r8d, 4
  002d0	4d 6b c0 03	 imul	 r8, r8, 3
  002d4	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  002d9	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  002df	b8 10 00 00 00	 mov	 eax, 16
  002e4	48 6b c0 01	 imul	 rax, rax, 1
  002e8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  002ed	48 03 c8	 add	 rcx, rax
  002f0	48 8b c1	 mov	 rax, rcx
  002f3	b9 04 00 00 00	 mov	 ecx, 4
  002f8	48 6b c9 01	 imul	 rcx, rcx, 1
  002fc	ba 10 00 00 00	 mov	 edx, 16
  00301	48 6b d2 00	 imul	 rdx, rdx, 0
  00305	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  0030a	4c 03 c2	 add	 r8, rdx
  0030d	49 8b d0	 mov	 rdx, r8
  00310	41 b8 04 00 00
	00		 mov	 r8d, 4
  00316	4d 6b c0 03	 imul	 r8, r8, 3
  0031a	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0031f	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00325	f3 0f 5c c1	 subss	 xmm0, xmm1
  00329	b8 04 00 00 00	 mov	 eax, 4
  0032e	48 6b c0 04	 imul	 rax, rax, 4
  00332	f3 0f 11 44 04
	20		 movss	 DWORD PTR S$[rsp+rax], xmm0

; 518  :     S[5] = A->m[0][2]*A->m[1][3] - A->m[1][2]*A->m[0][3];

  00338	b8 10 00 00 00	 mov	 eax, 16
  0033d	48 6b c0 00	 imul	 rax, rax, 0
  00341	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00346	48 03 c8	 add	 rcx, rax
  00349	48 8b c1	 mov	 rax, rcx
  0034c	b9 04 00 00 00	 mov	 ecx, 4
  00351	48 6b c9 02	 imul	 rcx, rcx, 2
  00355	ba 10 00 00 00	 mov	 edx, 16
  0035a	48 6b d2 01	 imul	 rdx, rdx, 1
  0035e	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00363	4c 03 c2	 add	 r8, rdx
  00366	49 8b d0	 mov	 rdx, r8
  00369	41 b8 04 00 00
	00		 mov	 r8d, 4
  0036f	4d 6b c0 03	 imul	 r8, r8, 3
  00373	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00378	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0037e	b8 10 00 00 00	 mov	 eax, 16
  00383	48 6b c0 01	 imul	 rax, rax, 1
  00387	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0038c	48 03 c8	 add	 rcx, rax
  0038f	48 8b c1	 mov	 rax, rcx
  00392	b9 04 00 00 00	 mov	 ecx, 4
  00397	48 6b c9 02	 imul	 rcx, rcx, 2
  0039b	ba 10 00 00 00	 mov	 edx, 16
  003a0	48 6b d2 00	 imul	 rdx, rdx, 0
  003a4	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  003a9	4c 03 c2	 add	 r8, rdx
  003ac	49 8b d0	 mov	 rdx, r8
  003af	41 b8 04 00 00
	00		 mov	 r8d, 4
  003b5	4d 6b c0 03	 imul	 r8, r8, 3
  003b9	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  003be	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  003c4	f3 0f 5c c1	 subss	 xmm0, xmm1
  003c8	b8 04 00 00 00	 mov	 eax, 4
  003cd	48 6b c0 05	 imul	 rax, rax, 5
  003d1	f3 0f 11 44 04
	20		 movss	 DWORD PTR S$[rsp+rax], xmm0

; 519  :     
; 520  :     f32 C[6];
; 521  :     C[0] = A->m[2][0]*A->m[3][1] - A->m[3][0]*A->m[2][1];

  003d7	b8 10 00 00 00	 mov	 eax, 16
  003dc	48 6b c0 02	 imul	 rax, rax, 2
  003e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  003e5	48 03 c8	 add	 rcx, rax
  003e8	48 8b c1	 mov	 rax, rcx
  003eb	b9 04 00 00 00	 mov	 ecx, 4
  003f0	48 6b c9 00	 imul	 rcx, rcx, 0
  003f4	ba 10 00 00 00	 mov	 edx, 16
  003f9	48 6b d2 03	 imul	 rdx, rdx, 3
  003fd	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00402	4c 03 c2	 add	 r8, rdx
  00405	49 8b d0	 mov	 rdx, r8
  00408	41 b8 04 00 00
	00		 mov	 r8d, 4
  0040e	4d 6b c0 01	 imul	 r8, r8, 1
  00412	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00417	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0041d	b8 10 00 00 00	 mov	 eax, 16
  00422	48 6b c0 03	 imul	 rax, rax, 3
  00426	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0042b	48 03 c8	 add	 rcx, rax
  0042e	48 8b c1	 mov	 rax, rcx
  00431	b9 04 00 00 00	 mov	 ecx, 4
  00436	48 6b c9 00	 imul	 rcx, rcx, 0
  0043a	ba 10 00 00 00	 mov	 edx, 16
  0043f	48 6b d2 02	 imul	 rdx, rdx, 2
  00443	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00448	4c 03 c2	 add	 r8, rdx
  0044b	49 8b d0	 mov	 rdx, r8
  0044e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00454	4d 6b c0 01	 imul	 r8, r8, 1
  00458	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0045d	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00463	f3 0f 5c c1	 subss	 xmm0, xmm1
  00467	b8 04 00 00 00	 mov	 eax, 4
  0046c	48 6b c0 00	 imul	 rax, rax, 0
  00470	f3 0f 11 44 04
	08		 movss	 DWORD PTR C$[rsp+rax], xmm0

; 522  :     C[1] = A->m[2][0]*A->m[3][2] - A->m[3][0]*A->m[2][2];

  00476	b8 10 00 00 00	 mov	 eax, 16
  0047b	48 6b c0 02	 imul	 rax, rax, 2
  0047f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00484	48 03 c8	 add	 rcx, rax
  00487	48 8b c1	 mov	 rax, rcx
  0048a	b9 04 00 00 00	 mov	 ecx, 4
  0048f	48 6b c9 00	 imul	 rcx, rcx, 0
  00493	ba 10 00 00 00	 mov	 edx, 16
  00498	48 6b d2 03	 imul	 rdx, rdx, 3
  0049c	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  004a1	4c 03 c2	 add	 r8, rdx
  004a4	49 8b d0	 mov	 rdx, r8
  004a7	41 b8 04 00 00
	00		 mov	 r8d, 4
  004ad	4d 6b c0 02	 imul	 r8, r8, 2
  004b1	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  004b6	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  004bc	b8 10 00 00 00	 mov	 eax, 16
  004c1	48 6b c0 03	 imul	 rax, rax, 3
  004c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  004ca	48 03 c8	 add	 rcx, rax
  004cd	48 8b c1	 mov	 rax, rcx
  004d0	b9 04 00 00 00	 mov	 ecx, 4
  004d5	48 6b c9 00	 imul	 rcx, rcx, 0
  004d9	ba 10 00 00 00	 mov	 edx, 16
  004de	48 6b d2 02	 imul	 rdx, rdx, 2
  004e2	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  004e7	4c 03 c2	 add	 r8, rdx
  004ea	49 8b d0	 mov	 rdx, r8
  004ed	41 b8 04 00 00
	00		 mov	 r8d, 4
  004f3	4d 6b c0 02	 imul	 r8, r8, 2
  004f7	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  004fc	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00502	f3 0f 5c c1	 subss	 xmm0, xmm1
  00506	b8 04 00 00 00	 mov	 eax, 4
  0050b	48 6b c0 01	 imul	 rax, rax, 1
  0050f	f3 0f 11 44 04
	08		 movss	 DWORD PTR C$[rsp+rax], xmm0

; 523  :     C[2] = A->m[2][0]*A->m[3][3] - A->m[3][0]*A->m[2][3];

  00515	b8 10 00 00 00	 mov	 eax, 16
  0051a	48 6b c0 02	 imul	 rax, rax, 2
  0051e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00523	48 03 c8	 add	 rcx, rax
  00526	48 8b c1	 mov	 rax, rcx
  00529	b9 04 00 00 00	 mov	 ecx, 4
  0052e	48 6b c9 00	 imul	 rcx, rcx, 0
  00532	ba 10 00 00 00	 mov	 edx, 16
  00537	48 6b d2 03	 imul	 rdx, rdx, 3
  0053b	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00540	4c 03 c2	 add	 r8, rdx
  00543	49 8b d0	 mov	 rdx, r8
  00546	41 b8 04 00 00
	00		 mov	 r8d, 4
  0054c	4d 6b c0 03	 imul	 r8, r8, 3
  00550	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00555	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  0055b	b8 10 00 00 00	 mov	 eax, 16
  00560	48 6b c0 03	 imul	 rax, rax, 3
  00564	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00569	48 03 c8	 add	 rcx, rax
  0056c	48 8b c1	 mov	 rax, rcx
  0056f	b9 04 00 00 00	 mov	 ecx, 4
  00574	48 6b c9 00	 imul	 rcx, rcx, 0
  00578	ba 10 00 00 00	 mov	 edx, 16
  0057d	48 6b d2 02	 imul	 rdx, rdx, 2
  00581	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00586	4c 03 c2	 add	 r8, rdx
  00589	49 8b d0	 mov	 rdx, r8
  0058c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00592	4d 6b c0 03	 imul	 r8, r8, 3
  00596	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0059b	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  005a1	f3 0f 5c c1	 subss	 xmm0, xmm1
  005a5	b8 04 00 00 00	 mov	 eax, 4
  005aa	48 6b c0 02	 imul	 rax, rax, 2
  005ae	f3 0f 11 44 04
	08		 movss	 DWORD PTR C$[rsp+rax], xmm0

; 524  :     C[3] = A->m[2][1]*A->m[3][2] - A->m[3][1]*A->m[2][2];

  005b4	b8 10 00 00 00	 mov	 eax, 16
  005b9	48 6b c0 02	 imul	 rax, rax, 2
  005bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  005c2	48 03 c8	 add	 rcx, rax
  005c5	48 8b c1	 mov	 rax, rcx
  005c8	b9 04 00 00 00	 mov	 ecx, 4
  005cd	48 6b c9 01	 imul	 rcx, rcx, 1
  005d1	ba 10 00 00 00	 mov	 edx, 16
  005d6	48 6b d2 03	 imul	 rdx, rdx, 3
  005da	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  005df	4c 03 c2	 add	 r8, rdx
  005e2	49 8b d0	 mov	 rdx, r8
  005e5	41 b8 04 00 00
	00		 mov	 r8d, 4
  005eb	4d 6b c0 02	 imul	 r8, r8, 2
  005ef	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  005f4	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  005fa	b8 10 00 00 00	 mov	 eax, 16
  005ff	48 6b c0 03	 imul	 rax, rax, 3
  00603	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00608	48 03 c8	 add	 rcx, rax
  0060b	48 8b c1	 mov	 rax, rcx
  0060e	b9 04 00 00 00	 mov	 ecx, 4
  00613	48 6b c9 01	 imul	 rcx, rcx, 1
  00617	ba 10 00 00 00	 mov	 edx, 16
  0061c	48 6b d2 02	 imul	 rdx, rdx, 2
  00620	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00625	4c 03 c2	 add	 r8, rdx
  00628	49 8b d0	 mov	 rdx, r8
  0062b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00631	4d 6b c0 02	 imul	 r8, r8, 2
  00635	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0063a	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  00640	f3 0f 5c c1	 subss	 xmm0, xmm1
  00644	b8 04 00 00 00	 mov	 eax, 4
  00649	48 6b c0 03	 imul	 rax, rax, 3
  0064d	f3 0f 11 44 04
	08		 movss	 DWORD PTR C$[rsp+rax], xmm0

; 525  :     C[4] = A->m[2][1]*A->m[3][3] - A->m[3][1]*A->m[2][3];

  00653	b8 10 00 00 00	 mov	 eax, 16
  00658	48 6b c0 02	 imul	 rax, rax, 2
  0065c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00661	48 03 c8	 add	 rcx, rax
  00664	48 8b c1	 mov	 rax, rcx
  00667	b9 04 00 00 00	 mov	 ecx, 4
  0066c	48 6b c9 01	 imul	 rcx, rcx, 1
  00670	ba 10 00 00 00	 mov	 edx, 16
  00675	48 6b d2 03	 imul	 rdx, rdx, 3
  00679	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  0067e	4c 03 c2	 add	 r8, rdx
  00681	49 8b d0	 mov	 rdx, r8
  00684	41 b8 04 00 00
	00		 mov	 r8d, 4
  0068a	4d 6b c0 03	 imul	 r8, r8, 3
  0068e	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00693	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00699	b8 10 00 00 00	 mov	 eax, 16
  0069e	48 6b c0 03	 imul	 rax, rax, 3
  006a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  006a7	48 03 c8	 add	 rcx, rax
  006aa	48 8b c1	 mov	 rax, rcx
  006ad	b9 04 00 00 00	 mov	 ecx, 4
  006b2	48 6b c9 01	 imul	 rcx, rcx, 1
  006b6	ba 10 00 00 00	 mov	 edx, 16
  006bb	48 6b d2 02	 imul	 rdx, rdx, 2
  006bf	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  006c4	4c 03 c2	 add	 r8, rdx
  006c7	49 8b d0	 mov	 rdx, r8
  006ca	41 b8 04 00 00
	00		 mov	 r8d, 4
  006d0	4d 6b c0 03	 imul	 r8, r8, 3
  006d4	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  006d9	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  006df	f3 0f 5c c1	 subss	 xmm0, xmm1
  006e3	b8 04 00 00 00	 mov	 eax, 4
  006e8	48 6b c0 04	 imul	 rax, rax, 4
  006ec	f3 0f 11 44 04
	08		 movss	 DWORD PTR C$[rsp+rax], xmm0

; 526  :     C[5] = A->m[2][2]*A->m[3][3] - A->m[3][2]*A->m[2][3];

  006f2	b8 10 00 00 00	 mov	 eax, 16
  006f7	48 6b c0 02	 imul	 rax, rax, 2
  006fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00700	48 03 c8	 add	 rcx, rax
  00703	48 8b c1	 mov	 rax, rcx
  00706	b9 04 00 00 00	 mov	 ecx, 4
  0070b	48 6b c9 02	 imul	 rcx, rcx, 2
  0070f	ba 10 00 00 00	 mov	 edx, 16
  00714	48 6b d2 03	 imul	 rdx, rdx, 3
  00718	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  0071d	4c 03 c2	 add	 r8, rdx
  00720	49 8b d0	 mov	 rdx, r8
  00723	41 b8 04 00 00
	00		 mov	 r8d, 4
  00729	4d 6b c0 03	 imul	 r8, r8, 3
  0072d	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00732	f3 42 0f 59 04
	02		 mulss	 xmm0, DWORD PTR [rdx+r8]
  00738	b8 10 00 00 00	 mov	 eax, 16
  0073d	48 6b c0 03	 imul	 rax, rax, 3
  00741	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00746	48 03 c8	 add	 rcx, rax
  00749	48 8b c1	 mov	 rax, rcx
  0074c	b9 04 00 00 00	 mov	 ecx, 4
  00751	48 6b c9 02	 imul	 rcx, rcx, 2
  00755	ba 10 00 00 00	 mov	 edx, 16
  0075a	48 6b d2 02	 imul	 rdx, rdx, 2
  0075e	4c 8b 44 24 58	 mov	 r8, QWORD PTR A$[rsp]
  00763	4c 03 c2	 add	 r8, rdx
  00766	49 8b d0	 mov	 rdx, r8
  00769	41 b8 04 00 00
	00		 mov	 r8d, 4
  0076f	4d 6b c0 03	 imul	 r8, r8, 3
  00773	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00778	f3 42 0f 59 0c
	02		 mulss	 xmm1, DWORD PTR [rdx+r8]
  0077e	f3 0f 5c c1	 subss	 xmm0, xmm1
  00782	b8 04 00 00 00	 mov	 eax, 4
  00787	48 6b c0 05	 imul	 rax, rax, 5
  0078b	f3 0f 11 44 04
	08		 movss	 DWORD PTR C$[rsp+rax], xmm0

; 527  :     
; 528  :     f32 Idet = 1.0f/(S[0]*C[5] - S[1]*C[4] + S[2]*C[3] + S[3]*C[2] - S[4]*C[1] + S[5]*C[0]);

  00791	b8 04 00 00 00	 mov	 eax, 4
  00796	48 6b c0 00	 imul	 rax, rax, 0
  0079a	b9 04 00 00 00	 mov	 ecx, 4
  0079f	48 6b c9 05	 imul	 rcx, rcx, 5
  007a3	f3 0f 10 44 04
	20		 movss	 xmm0, DWORD PTR S$[rsp+rax]
  007a9	f3 0f 59 44 0c
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rcx]
  007af	b8 04 00 00 00	 mov	 eax, 4
  007b4	48 6b c0 01	 imul	 rax, rax, 1
  007b8	b9 04 00 00 00	 mov	 ecx, 4
  007bd	48 6b c9 04	 imul	 rcx, rcx, 4
  007c1	f3 0f 10 4c 04
	20		 movss	 xmm1, DWORD PTR S$[rsp+rax]
  007c7	f3 0f 59 4c 0c
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rcx]
  007cd	f3 0f 5c c1	 subss	 xmm0, xmm1
  007d1	b8 04 00 00 00	 mov	 eax, 4
  007d6	48 6b c0 02	 imul	 rax, rax, 2
  007da	b9 04 00 00 00	 mov	 ecx, 4
  007df	48 6b c9 03	 imul	 rcx, rcx, 3
  007e3	f3 0f 10 4c 04
	20		 movss	 xmm1, DWORD PTR S$[rsp+rax]
  007e9	f3 0f 59 4c 0c
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rcx]
  007ef	f3 0f 58 c1	 addss	 xmm0, xmm1
  007f3	b8 04 00 00 00	 mov	 eax, 4
  007f8	48 6b c0 03	 imul	 rax, rax, 3
  007fc	b9 04 00 00 00	 mov	 ecx, 4
  00801	48 6b c9 02	 imul	 rcx, rcx, 2
  00805	f3 0f 10 4c 04
	20		 movss	 xmm1, DWORD PTR S$[rsp+rax]
  0080b	f3 0f 59 4c 0c
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rcx]
  00811	f3 0f 58 c1	 addss	 xmm0, xmm1
  00815	b8 04 00 00 00	 mov	 eax, 4
  0081a	48 6b c0 04	 imul	 rax, rax, 4
  0081e	b9 04 00 00 00	 mov	 ecx, 4
  00823	48 6b c9 01	 imul	 rcx, rcx, 1
  00827	f3 0f 10 4c 04
	20		 movss	 xmm1, DWORD PTR S$[rsp+rax]
  0082d	f3 0f 59 4c 0c
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rcx]
  00833	f3 0f 5c c1	 subss	 xmm0, xmm1
  00837	b8 04 00 00 00	 mov	 eax, 4
  0083c	48 6b c0 05	 imul	 rax, rax, 5
  00840	b9 04 00 00 00	 mov	 ecx, 4
  00845	48 6b c9 00	 imul	 rcx, rcx, 0
  00849	f3 0f 10 4c 04
	20		 movss	 xmm1, DWORD PTR S$[rsp+rax]
  0084f	f3 0f 59 4c 0c
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rcx]
  00855	f3 0f 58 c1	 addss	 xmm0, xmm1
  00859	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00861	f3 0f 5e c8	 divss	 xmm1, xmm0
  00865	0f 28 c1	 movaps	 xmm0, xmm1
  00868	f3 0f 11 04 24	 movss	 DWORD PTR Idet$[rsp], xmm0

; 529  :     
; 530  :     Result->m[0][0] = ( A->m[1][1]*C[5] - A->m[1][2]*C[4] + A->m[1][3]*C[3])*Idet;

  0086d	b8 10 00 00 00	 mov	 eax, 16
  00872	48 6b c0 01	 imul	 rax, rax, 1
  00876	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0087b	48 03 c8	 add	 rcx, rax
  0087e	48 8b c1	 mov	 rax, rcx
  00881	b9 04 00 00 00	 mov	 ecx, 4
  00886	48 6b c9 01	 imul	 rcx, rcx, 1
  0088a	ba 04 00 00 00	 mov	 edx, 4
  0088f	48 6b d2 05	 imul	 rdx, rdx, 5
  00893	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00898	f3 0f 59 44 14
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rdx]
  0089e	b8 10 00 00 00	 mov	 eax, 16
  008a3	48 6b c0 01	 imul	 rax, rax, 1
  008a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  008ac	48 03 c8	 add	 rcx, rax
  008af	48 8b c1	 mov	 rax, rcx
  008b2	b9 04 00 00 00	 mov	 ecx, 4
  008b7	48 6b c9 02	 imul	 rcx, rcx, 2
  008bb	ba 04 00 00 00	 mov	 edx, 4
  008c0	48 6b d2 04	 imul	 rdx, rdx, 4
  008c4	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  008c9	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  008cf	f3 0f 5c c1	 subss	 xmm0, xmm1
  008d3	b8 10 00 00 00	 mov	 eax, 16
  008d8	48 6b c0 01	 imul	 rax, rax, 1
  008dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  008e1	48 03 c8	 add	 rcx, rax
  008e4	48 8b c1	 mov	 rax, rcx
  008e7	b9 04 00 00 00	 mov	 ecx, 4
  008ec	48 6b c9 03	 imul	 rcx, rcx, 3
  008f0	ba 04 00 00 00	 mov	 edx, 4
  008f5	48 6b d2 03	 imul	 rdx, rdx, 3
  008f9	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  008fe	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00904	f3 0f 58 c1	 addss	 xmm0, xmm1
  00908	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  0090d	b8 10 00 00 00	 mov	 eax, 16
  00912	48 6b c0 00	 imul	 rax, rax, 0
  00916	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  0091b	48 03 c8	 add	 rcx, rax
  0091e	48 8b c1	 mov	 rax, rcx
  00921	b9 04 00 00 00	 mov	 ecx, 4
  00926	48 6b c9 00	 imul	 rcx, rcx, 0
  0092a	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 531  :     Result->m[0][1] = (-A->m[0][1]*C[5] + A->m[0][2]*C[4] - A->m[0][3]*C[3])*Idet;

  0092f	b8 10 00 00 00	 mov	 eax, 16
  00934	48 6b c0 00	 imul	 rax, rax, 0
  00938	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0093d	48 03 c8	 add	 rcx, rax
  00940	48 8b c1	 mov	 rax, rcx
  00943	b9 04 00 00 00	 mov	 ecx, 4
  00948	48 6b c9 01	 imul	 rcx, rcx, 1
  0094c	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00951	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00958	b8 04 00 00 00	 mov	 eax, 4
  0095d	48 6b c0 05	 imul	 rax, rax, 5
  00961	f3 0f 59 44 04
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rax]
  00967	b8 10 00 00 00	 mov	 eax, 16
  0096c	48 6b c0 00	 imul	 rax, rax, 0
  00970	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00975	48 03 c8	 add	 rcx, rax
  00978	48 8b c1	 mov	 rax, rcx
  0097b	b9 04 00 00 00	 mov	 ecx, 4
  00980	48 6b c9 02	 imul	 rcx, rcx, 2
  00984	ba 04 00 00 00	 mov	 edx, 4
  00989	48 6b d2 04	 imul	 rdx, rdx, 4
  0098d	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00992	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00998	f3 0f 58 c1	 addss	 xmm0, xmm1
  0099c	b8 10 00 00 00	 mov	 eax, 16
  009a1	48 6b c0 00	 imul	 rax, rax, 0
  009a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  009aa	48 03 c8	 add	 rcx, rax
  009ad	48 8b c1	 mov	 rax, rcx
  009b0	b9 04 00 00 00	 mov	 ecx, 4
  009b5	48 6b c9 03	 imul	 rcx, rcx, 3
  009b9	ba 04 00 00 00	 mov	 edx, 4
  009be	48 6b d2 03	 imul	 rdx, rdx, 3
  009c2	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  009c7	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  009cd	f3 0f 5c c1	 subss	 xmm0, xmm1
  009d1	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  009d6	b8 10 00 00 00	 mov	 eax, 16
  009db	48 6b c0 00	 imul	 rax, rax, 0
  009df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  009e4	48 03 c8	 add	 rcx, rax
  009e7	48 8b c1	 mov	 rax, rcx
  009ea	b9 04 00 00 00	 mov	 ecx, 4
  009ef	48 6b c9 01	 imul	 rcx, rcx, 1
  009f3	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 532  :     Result->m[0][2] = ( A->m[3][1]*S[5] - A->m[3][2]*S[4] + A->m[3][3]*S[3])*Idet;

  009f8	b8 10 00 00 00	 mov	 eax, 16
  009fd	48 6b c0 03	 imul	 rax, rax, 3
  00a01	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00a06	48 03 c8	 add	 rcx, rax
  00a09	48 8b c1	 mov	 rax, rcx
  00a0c	b9 04 00 00 00	 mov	 ecx, 4
  00a11	48 6b c9 01	 imul	 rcx, rcx, 1
  00a15	ba 04 00 00 00	 mov	 edx, 4
  00a1a	48 6b d2 05	 imul	 rdx, rdx, 5
  00a1e	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00a23	f3 0f 59 44 14
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rdx]
  00a29	b8 10 00 00 00	 mov	 eax, 16
  00a2e	48 6b c0 03	 imul	 rax, rax, 3
  00a32	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00a37	48 03 c8	 add	 rcx, rax
  00a3a	48 8b c1	 mov	 rax, rcx
  00a3d	b9 04 00 00 00	 mov	 ecx, 4
  00a42	48 6b c9 02	 imul	 rcx, rcx, 2
  00a46	ba 04 00 00 00	 mov	 edx, 4
  00a4b	48 6b d2 04	 imul	 rdx, rdx, 4
  00a4f	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00a54	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00a5a	f3 0f 5c c1	 subss	 xmm0, xmm1
  00a5e	b8 10 00 00 00	 mov	 eax, 16
  00a63	48 6b c0 03	 imul	 rax, rax, 3
  00a67	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00a6c	48 03 c8	 add	 rcx, rax
  00a6f	48 8b c1	 mov	 rax, rcx
  00a72	b9 04 00 00 00	 mov	 ecx, 4
  00a77	48 6b c9 03	 imul	 rcx, rcx, 3
  00a7b	ba 04 00 00 00	 mov	 edx, 4
  00a80	48 6b d2 03	 imul	 rdx, rdx, 3
  00a84	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00a89	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00a8f	f3 0f 58 c1	 addss	 xmm0, xmm1
  00a93	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00a98	b8 10 00 00 00	 mov	 eax, 16
  00a9d	48 6b c0 00	 imul	 rax, rax, 0
  00aa1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00aa6	48 03 c8	 add	 rcx, rax
  00aa9	48 8b c1	 mov	 rax, rcx
  00aac	b9 04 00 00 00	 mov	 ecx, 4
  00ab1	48 6b c9 02	 imul	 rcx, rcx, 2
  00ab5	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 533  :     Result->m[0][3] = (-A->m[2][1]*S[5] + A->m[2][2]*S[4] - A->m[2][3]*S[3])*Idet;

  00aba	b8 10 00 00 00	 mov	 eax, 16
  00abf	48 6b c0 02	 imul	 rax, rax, 2
  00ac3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00ac8	48 03 c8	 add	 rcx, rax
  00acb	48 8b c1	 mov	 rax, rcx
  00ace	b9 04 00 00 00	 mov	 ecx, 4
  00ad3	48 6b c9 01	 imul	 rcx, rcx, 1
  00ad7	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00adc	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00ae3	b8 04 00 00 00	 mov	 eax, 4
  00ae8	48 6b c0 05	 imul	 rax, rax, 5
  00aec	f3 0f 59 44 04
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rax]
  00af2	b8 10 00 00 00	 mov	 eax, 16
  00af7	48 6b c0 02	 imul	 rax, rax, 2
  00afb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00b00	48 03 c8	 add	 rcx, rax
  00b03	48 8b c1	 mov	 rax, rcx
  00b06	b9 04 00 00 00	 mov	 ecx, 4
  00b0b	48 6b c9 02	 imul	 rcx, rcx, 2
  00b0f	ba 04 00 00 00	 mov	 edx, 4
  00b14	48 6b d2 04	 imul	 rdx, rdx, 4
  00b18	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00b1d	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00b23	f3 0f 58 c1	 addss	 xmm0, xmm1
  00b27	b8 10 00 00 00	 mov	 eax, 16
  00b2c	48 6b c0 02	 imul	 rax, rax, 2
  00b30	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00b35	48 03 c8	 add	 rcx, rax
  00b38	48 8b c1	 mov	 rax, rcx
  00b3b	b9 04 00 00 00	 mov	 ecx, 4
  00b40	48 6b c9 03	 imul	 rcx, rcx, 3
  00b44	ba 04 00 00 00	 mov	 edx, 4
  00b49	48 6b d2 03	 imul	 rdx, rdx, 3
  00b4d	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00b52	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00b58	f3 0f 5c c1	 subss	 xmm0, xmm1
  00b5c	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00b61	b8 10 00 00 00	 mov	 eax, 16
  00b66	48 6b c0 00	 imul	 rax, rax, 0
  00b6a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00b6f	48 03 c8	 add	 rcx, rax
  00b72	48 8b c1	 mov	 rax, rcx
  00b75	b9 04 00 00 00	 mov	 ecx, 4
  00b7a	48 6b c9 03	 imul	 rcx, rcx, 3
  00b7e	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 534  :     
; 535  :     Result->m[1][0] = (-A->m[1][0]*C[5] + A->m[1][2]*C[2] - A->m[1][3]*C[1])*Idet;

  00b83	b8 10 00 00 00	 mov	 eax, 16
  00b88	48 6b c0 01	 imul	 rax, rax, 1
  00b8c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00b91	48 03 c8	 add	 rcx, rax
  00b94	48 8b c1	 mov	 rax, rcx
  00b97	b9 04 00 00 00	 mov	 ecx, 4
  00b9c	48 6b c9 00	 imul	 rcx, rcx, 0
  00ba0	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00ba5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00bac	b8 04 00 00 00	 mov	 eax, 4
  00bb1	48 6b c0 05	 imul	 rax, rax, 5
  00bb5	f3 0f 59 44 04
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rax]
  00bbb	b8 10 00 00 00	 mov	 eax, 16
  00bc0	48 6b c0 01	 imul	 rax, rax, 1
  00bc4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00bc9	48 03 c8	 add	 rcx, rax
  00bcc	48 8b c1	 mov	 rax, rcx
  00bcf	b9 04 00 00 00	 mov	 ecx, 4
  00bd4	48 6b c9 02	 imul	 rcx, rcx, 2
  00bd8	ba 04 00 00 00	 mov	 edx, 4
  00bdd	48 6b d2 02	 imul	 rdx, rdx, 2
  00be1	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00be6	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00bec	f3 0f 58 c1	 addss	 xmm0, xmm1
  00bf0	b8 10 00 00 00	 mov	 eax, 16
  00bf5	48 6b c0 01	 imul	 rax, rax, 1
  00bf9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00bfe	48 03 c8	 add	 rcx, rax
  00c01	48 8b c1	 mov	 rax, rcx
  00c04	b9 04 00 00 00	 mov	 ecx, 4
  00c09	48 6b c9 03	 imul	 rcx, rcx, 3
  00c0d	ba 04 00 00 00	 mov	 edx, 4
  00c12	48 6b d2 01	 imul	 rdx, rdx, 1
  00c16	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00c1b	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00c21	f3 0f 5c c1	 subss	 xmm0, xmm1
  00c25	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00c2a	b8 10 00 00 00	 mov	 eax, 16
  00c2f	48 6b c0 01	 imul	 rax, rax, 1
  00c33	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00c38	48 03 c8	 add	 rcx, rax
  00c3b	48 8b c1	 mov	 rax, rcx
  00c3e	b9 04 00 00 00	 mov	 ecx, 4
  00c43	48 6b c9 00	 imul	 rcx, rcx, 0
  00c47	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 536  :     Result->m[1][1] = ( A->m[0][0]*C[5] - A->m[0][2]*C[2] + A->m[0][3]*C[1])*Idet;

  00c4c	b8 10 00 00 00	 mov	 eax, 16
  00c51	48 6b c0 00	 imul	 rax, rax, 0
  00c55	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00c5a	48 03 c8	 add	 rcx, rax
  00c5d	48 8b c1	 mov	 rax, rcx
  00c60	b9 04 00 00 00	 mov	 ecx, 4
  00c65	48 6b c9 00	 imul	 rcx, rcx, 0
  00c69	ba 04 00 00 00	 mov	 edx, 4
  00c6e	48 6b d2 05	 imul	 rdx, rdx, 5
  00c72	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00c77	f3 0f 59 44 14
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rdx]
  00c7d	b8 10 00 00 00	 mov	 eax, 16
  00c82	48 6b c0 00	 imul	 rax, rax, 0
  00c86	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00c8b	48 03 c8	 add	 rcx, rax
  00c8e	48 8b c1	 mov	 rax, rcx
  00c91	b9 04 00 00 00	 mov	 ecx, 4
  00c96	48 6b c9 02	 imul	 rcx, rcx, 2
  00c9a	ba 04 00 00 00	 mov	 edx, 4
  00c9f	48 6b d2 02	 imul	 rdx, rdx, 2
  00ca3	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00ca8	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00cae	f3 0f 5c c1	 subss	 xmm0, xmm1
  00cb2	b8 10 00 00 00	 mov	 eax, 16
  00cb7	48 6b c0 00	 imul	 rax, rax, 0
  00cbb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00cc0	48 03 c8	 add	 rcx, rax
  00cc3	48 8b c1	 mov	 rax, rcx
  00cc6	b9 04 00 00 00	 mov	 ecx, 4
  00ccb	48 6b c9 03	 imul	 rcx, rcx, 3
  00ccf	ba 04 00 00 00	 mov	 edx, 4
  00cd4	48 6b d2 01	 imul	 rdx, rdx, 1
  00cd8	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00cdd	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00ce3	f3 0f 58 c1	 addss	 xmm0, xmm1
  00ce7	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00cec	b8 10 00 00 00	 mov	 eax, 16
  00cf1	48 6b c0 01	 imul	 rax, rax, 1
  00cf5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00cfa	48 03 c8	 add	 rcx, rax
  00cfd	48 8b c1	 mov	 rax, rcx
  00d00	b9 04 00 00 00	 mov	 ecx, 4
  00d05	48 6b c9 01	 imul	 rcx, rcx, 1
  00d09	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 537  :     Result->m[1][2] = (-A->m[3][0]*S[5] + A->m[3][2]*S[2] - A->m[3][3]*S[1])*Idet;

  00d0e	b8 10 00 00 00	 mov	 eax, 16
  00d13	48 6b c0 03	 imul	 rax, rax, 3
  00d17	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00d1c	48 03 c8	 add	 rcx, rax
  00d1f	48 8b c1	 mov	 rax, rcx
  00d22	b9 04 00 00 00	 mov	 ecx, 4
  00d27	48 6b c9 00	 imul	 rcx, rcx, 0
  00d2b	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00d30	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00d37	b8 04 00 00 00	 mov	 eax, 4
  00d3c	48 6b c0 05	 imul	 rax, rax, 5
  00d40	f3 0f 59 44 04
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rax]
  00d46	b8 10 00 00 00	 mov	 eax, 16
  00d4b	48 6b c0 03	 imul	 rax, rax, 3
  00d4f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00d54	48 03 c8	 add	 rcx, rax
  00d57	48 8b c1	 mov	 rax, rcx
  00d5a	b9 04 00 00 00	 mov	 ecx, 4
  00d5f	48 6b c9 02	 imul	 rcx, rcx, 2
  00d63	ba 04 00 00 00	 mov	 edx, 4
  00d68	48 6b d2 02	 imul	 rdx, rdx, 2
  00d6c	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00d71	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00d77	f3 0f 58 c1	 addss	 xmm0, xmm1
  00d7b	b8 10 00 00 00	 mov	 eax, 16
  00d80	48 6b c0 03	 imul	 rax, rax, 3
  00d84	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00d89	48 03 c8	 add	 rcx, rax
  00d8c	48 8b c1	 mov	 rax, rcx
  00d8f	b9 04 00 00 00	 mov	 ecx, 4
  00d94	48 6b c9 03	 imul	 rcx, rcx, 3
  00d98	ba 04 00 00 00	 mov	 edx, 4
  00d9d	48 6b d2 01	 imul	 rdx, rdx, 1
  00da1	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00da6	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00dac	f3 0f 5c c1	 subss	 xmm0, xmm1
  00db0	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00db5	b8 10 00 00 00	 mov	 eax, 16
  00dba	48 6b c0 01	 imul	 rax, rax, 1
  00dbe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00dc3	48 03 c8	 add	 rcx, rax
  00dc6	48 8b c1	 mov	 rax, rcx
  00dc9	b9 04 00 00 00	 mov	 ecx, 4
  00dce	48 6b c9 02	 imul	 rcx, rcx, 2
  00dd2	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 538  :     Result->m[1][3] = ( A->m[2][0]*S[5] - A->m[2][2]*S[2] + A->m[2][3]*S[1])*Idet;

  00dd7	b8 10 00 00 00	 mov	 eax, 16
  00ddc	48 6b c0 02	 imul	 rax, rax, 2
  00de0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00de5	48 03 c8	 add	 rcx, rax
  00de8	48 8b c1	 mov	 rax, rcx
  00deb	b9 04 00 00 00	 mov	 ecx, 4
  00df0	48 6b c9 00	 imul	 rcx, rcx, 0
  00df4	ba 04 00 00 00	 mov	 edx, 4
  00df9	48 6b d2 05	 imul	 rdx, rdx, 5
  00dfd	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00e02	f3 0f 59 44 14
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rdx]
  00e08	b8 10 00 00 00	 mov	 eax, 16
  00e0d	48 6b c0 02	 imul	 rax, rax, 2
  00e11	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00e16	48 03 c8	 add	 rcx, rax
  00e19	48 8b c1	 mov	 rax, rcx
  00e1c	b9 04 00 00 00	 mov	 ecx, 4
  00e21	48 6b c9 02	 imul	 rcx, rcx, 2
  00e25	ba 04 00 00 00	 mov	 edx, 4
  00e2a	48 6b d2 02	 imul	 rdx, rdx, 2
  00e2e	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00e33	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00e39	f3 0f 5c c1	 subss	 xmm0, xmm1
  00e3d	b8 10 00 00 00	 mov	 eax, 16
  00e42	48 6b c0 02	 imul	 rax, rax, 2
  00e46	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00e4b	48 03 c8	 add	 rcx, rax
  00e4e	48 8b c1	 mov	 rax, rcx
  00e51	b9 04 00 00 00	 mov	 ecx, 4
  00e56	48 6b c9 03	 imul	 rcx, rcx, 3
  00e5a	ba 04 00 00 00	 mov	 edx, 4
  00e5f	48 6b d2 01	 imul	 rdx, rdx, 1
  00e63	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00e68	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  00e6e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e72	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00e77	b8 10 00 00 00	 mov	 eax, 16
  00e7c	48 6b c0 01	 imul	 rax, rax, 1
  00e80	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00e85	48 03 c8	 add	 rcx, rax
  00e88	48 8b c1	 mov	 rax, rcx
  00e8b	b9 04 00 00 00	 mov	 ecx, 4
  00e90	48 6b c9 03	 imul	 rcx, rcx, 3
  00e94	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 539  :     
; 540  :     Result->m[2][0] = ( A->m[1][0]*C[4] - A->m[1][1]*C[2] + A->m[1][3]*C[0])*Idet;

  00e99	b8 10 00 00 00	 mov	 eax, 16
  00e9e	48 6b c0 01	 imul	 rax, rax, 1
  00ea2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00ea7	48 03 c8	 add	 rcx, rax
  00eaa	48 8b c1	 mov	 rax, rcx
  00ead	b9 04 00 00 00	 mov	 ecx, 4
  00eb2	48 6b c9 00	 imul	 rcx, rcx, 0
  00eb6	ba 04 00 00 00	 mov	 edx, 4
  00ebb	48 6b d2 04	 imul	 rdx, rdx, 4
  00ebf	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00ec4	f3 0f 59 44 14
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rdx]
  00eca	b8 10 00 00 00	 mov	 eax, 16
  00ecf	48 6b c0 01	 imul	 rax, rax, 1
  00ed3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00ed8	48 03 c8	 add	 rcx, rax
  00edb	48 8b c1	 mov	 rax, rcx
  00ede	b9 04 00 00 00	 mov	 ecx, 4
  00ee3	48 6b c9 01	 imul	 rcx, rcx, 1
  00ee7	ba 04 00 00 00	 mov	 edx, 4
  00eec	48 6b d2 02	 imul	 rdx, rdx, 2
  00ef0	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00ef5	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00efb	f3 0f 5c c1	 subss	 xmm0, xmm1
  00eff	b8 10 00 00 00	 mov	 eax, 16
  00f04	48 6b c0 01	 imul	 rax, rax, 1
  00f08	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00f0d	48 03 c8	 add	 rcx, rax
  00f10	48 8b c1	 mov	 rax, rcx
  00f13	b9 04 00 00 00	 mov	 ecx, 4
  00f18	48 6b c9 03	 imul	 rcx, rcx, 3
  00f1c	ba 04 00 00 00	 mov	 edx, 4
  00f21	48 6b d2 00	 imul	 rdx, rdx, 0
  00f25	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00f2a	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00f30	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f34	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  00f39	b8 10 00 00 00	 mov	 eax, 16
  00f3e	48 6b c0 02	 imul	 rax, rax, 2
  00f42	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  00f47	48 03 c8	 add	 rcx, rax
  00f4a	48 8b c1	 mov	 rax, rcx
  00f4d	b9 04 00 00 00	 mov	 ecx, 4
  00f52	48 6b c9 00	 imul	 rcx, rcx, 0
  00f56	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 541  :     Result->m[2][1] = (-A->m[0][0]*C[4] + A->m[0][1]*C[2] - A->m[0][3]*C[0])*Idet;

  00f5b	b8 10 00 00 00	 mov	 eax, 16
  00f60	48 6b c0 00	 imul	 rax, rax, 0
  00f64	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00f69	48 03 c8	 add	 rcx, rax
  00f6c	48 8b c1	 mov	 rax, rcx
  00f6f	b9 04 00 00 00	 mov	 ecx, 4
  00f74	48 6b c9 00	 imul	 rcx, rcx, 0
  00f78	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00f7d	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00f84	b8 04 00 00 00	 mov	 eax, 4
  00f89	48 6b c0 04	 imul	 rax, rax, 4
  00f8d	f3 0f 59 44 04
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rax]
  00f93	b8 10 00 00 00	 mov	 eax, 16
  00f98	48 6b c0 00	 imul	 rax, rax, 0
  00f9c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00fa1	48 03 c8	 add	 rcx, rax
  00fa4	48 8b c1	 mov	 rax, rcx
  00fa7	b9 04 00 00 00	 mov	 ecx, 4
  00fac	48 6b c9 01	 imul	 rcx, rcx, 1
  00fb0	ba 04 00 00 00	 mov	 edx, 4
  00fb5	48 6b d2 02	 imul	 rdx, rdx, 2
  00fb9	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00fbe	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00fc4	f3 0f 58 c1	 addss	 xmm0, xmm1
  00fc8	b8 10 00 00 00	 mov	 eax, 16
  00fcd	48 6b c0 00	 imul	 rax, rax, 0
  00fd1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00fd6	48 03 c8	 add	 rcx, rax
  00fd9	48 8b c1	 mov	 rax, rcx
  00fdc	b9 04 00 00 00	 mov	 ecx, 4
  00fe1	48 6b c9 03	 imul	 rcx, rcx, 3
  00fe5	ba 04 00 00 00	 mov	 edx, 4
  00fea	48 6b d2 00	 imul	 rdx, rdx, 0
  00fee	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  00ff3	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  00ff9	f3 0f 5c c1	 subss	 xmm0, xmm1
  00ffd	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  01002	b8 10 00 00 00	 mov	 eax, 16
  01007	48 6b c0 02	 imul	 rax, rax, 2
  0100b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  01010	48 03 c8	 add	 rcx, rax
  01013	48 8b c1	 mov	 rax, rcx
  01016	b9 04 00 00 00	 mov	 ecx, 4
  0101b	48 6b c9 01	 imul	 rcx, rcx, 1
  0101f	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 542  :     Result->m[2][2] = ( A->m[3][0]*S[4] - A->m[3][1]*S[2] + A->m[3][3]*S[0])*Idet;

  01024	b8 10 00 00 00	 mov	 eax, 16
  01029	48 6b c0 03	 imul	 rax, rax, 3
  0102d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01032	48 03 c8	 add	 rcx, rax
  01035	48 8b c1	 mov	 rax, rcx
  01038	b9 04 00 00 00	 mov	 ecx, 4
  0103d	48 6b c9 00	 imul	 rcx, rcx, 0
  01041	ba 04 00 00 00	 mov	 edx, 4
  01046	48 6b d2 04	 imul	 rdx, rdx, 4
  0104a	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0104f	f3 0f 59 44 14
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rdx]
  01055	b8 10 00 00 00	 mov	 eax, 16
  0105a	48 6b c0 03	 imul	 rax, rax, 3
  0105e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01063	48 03 c8	 add	 rcx, rax
  01066	48 8b c1	 mov	 rax, rcx
  01069	b9 04 00 00 00	 mov	 ecx, 4
  0106e	48 6b c9 01	 imul	 rcx, rcx, 1
  01072	ba 04 00 00 00	 mov	 edx, 4
  01077	48 6b d2 02	 imul	 rdx, rdx, 2
  0107b	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01080	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  01086	f3 0f 5c c1	 subss	 xmm0, xmm1
  0108a	b8 10 00 00 00	 mov	 eax, 16
  0108f	48 6b c0 03	 imul	 rax, rax, 3
  01093	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01098	48 03 c8	 add	 rcx, rax
  0109b	48 8b c1	 mov	 rax, rcx
  0109e	b9 04 00 00 00	 mov	 ecx, 4
  010a3	48 6b c9 03	 imul	 rcx, rcx, 3
  010a7	ba 04 00 00 00	 mov	 edx, 4
  010ac	48 6b d2 00	 imul	 rdx, rdx, 0
  010b0	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  010b5	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  010bb	f3 0f 58 c1	 addss	 xmm0, xmm1
  010bf	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  010c4	b8 10 00 00 00	 mov	 eax, 16
  010c9	48 6b c0 02	 imul	 rax, rax, 2
  010cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  010d2	48 03 c8	 add	 rcx, rax
  010d5	48 8b c1	 mov	 rax, rcx
  010d8	b9 04 00 00 00	 mov	 ecx, 4
  010dd	48 6b c9 02	 imul	 rcx, rcx, 2
  010e1	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 543  :     Result->m[2][3] = (-A->m[2][0]*S[4] + A->m[2][1]*S[2] - A->m[2][3]*S[0])*Idet;

  010e6	b8 10 00 00 00	 mov	 eax, 16
  010eb	48 6b c0 02	 imul	 rax, rax, 2
  010ef	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  010f4	48 03 c8	 add	 rcx, rax
  010f7	48 8b c1	 mov	 rax, rcx
  010fa	b9 04 00 00 00	 mov	 ecx, 4
  010ff	48 6b c9 00	 imul	 rcx, rcx, 0
  01103	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  01108	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0110f	b8 04 00 00 00	 mov	 eax, 4
  01114	48 6b c0 04	 imul	 rax, rax, 4
  01118	f3 0f 59 44 04
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rax]
  0111e	b8 10 00 00 00	 mov	 eax, 16
  01123	48 6b c0 02	 imul	 rax, rax, 2
  01127	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0112c	48 03 c8	 add	 rcx, rax
  0112f	48 8b c1	 mov	 rax, rcx
  01132	b9 04 00 00 00	 mov	 ecx, 4
  01137	48 6b c9 01	 imul	 rcx, rcx, 1
  0113b	ba 04 00 00 00	 mov	 edx, 4
  01140	48 6b d2 02	 imul	 rdx, rdx, 2
  01144	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01149	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  0114f	f3 0f 58 c1	 addss	 xmm0, xmm1
  01153	b8 10 00 00 00	 mov	 eax, 16
  01158	48 6b c0 02	 imul	 rax, rax, 2
  0115c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01161	48 03 c8	 add	 rcx, rax
  01164	48 8b c1	 mov	 rax, rcx
  01167	b9 04 00 00 00	 mov	 ecx, 4
  0116c	48 6b c9 03	 imul	 rcx, rcx, 3
  01170	ba 04 00 00 00	 mov	 edx, 4
  01175	48 6b d2 00	 imul	 rdx, rdx, 0
  01179	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0117e	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  01184	f3 0f 5c c1	 subss	 xmm0, xmm1
  01188	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  0118d	b8 10 00 00 00	 mov	 eax, 16
  01192	48 6b c0 02	 imul	 rax, rax, 2
  01196	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  0119b	48 03 c8	 add	 rcx, rax
  0119e	48 8b c1	 mov	 rax, rcx
  011a1	b9 04 00 00 00	 mov	 ecx, 4
  011a6	48 6b c9 03	 imul	 rcx, rcx, 3
  011aa	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 544  :     
; 545  :     Result->m[3][0] = (-A->m[1][0]*C[3] + A->m[1][1]*C[1] - A->m[1][2]*C[0])*Idet;

  011af	b8 10 00 00 00	 mov	 eax, 16
  011b4	48 6b c0 01	 imul	 rax, rax, 1
  011b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  011bd	48 03 c8	 add	 rcx, rax
  011c0	48 8b c1	 mov	 rax, rcx
  011c3	b9 04 00 00 00	 mov	 ecx, 4
  011c8	48 6b c9 00	 imul	 rcx, rcx, 0
  011cc	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  011d1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  011d8	b8 04 00 00 00	 mov	 eax, 4
  011dd	48 6b c0 03	 imul	 rax, rax, 3
  011e1	f3 0f 59 44 04
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rax]
  011e7	b8 10 00 00 00	 mov	 eax, 16
  011ec	48 6b c0 01	 imul	 rax, rax, 1
  011f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  011f5	48 03 c8	 add	 rcx, rax
  011f8	48 8b c1	 mov	 rax, rcx
  011fb	b9 04 00 00 00	 mov	 ecx, 4
  01200	48 6b c9 01	 imul	 rcx, rcx, 1
  01204	ba 04 00 00 00	 mov	 edx, 4
  01209	48 6b d2 01	 imul	 rdx, rdx, 1
  0120d	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01212	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  01218	f3 0f 58 c1	 addss	 xmm0, xmm1
  0121c	b8 10 00 00 00	 mov	 eax, 16
  01221	48 6b c0 01	 imul	 rax, rax, 1
  01225	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0122a	48 03 c8	 add	 rcx, rax
  0122d	48 8b c1	 mov	 rax, rcx
  01230	b9 04 00 00 00	 mov	 ecx, 4
  01235	48 6b c9 02	 imul	 rcx, rcx, 2
  01239	ba 04 00 00 00	 mov	 edx, 4
  0123e	48 6b d2 00	 imul	 rdx, rdx, 0
  01242	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01247	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  0124d	f3 0f 5c c1	 subss	 xmm0, xmm1
  01251	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  01256	b8 10 00 00 00	 mov	 eax, 16
  0125b	48 6b c0 03	 imul	 rax, rax, 3
  0125f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  01264	48 03 c8	 add	 rcx, rax
  01267	48 8b c1	 mov	 rax, rcx
  0126a	b9 04 00 00 00	 mov	 ecx, 4
  0126f	48 6b c9 00	 imul	 rcx, rcx, 0
  01273	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 546  :     Result->m[3][1] = ( A->m[0][0]*C[3] - A->m[0][1]*C[1] + A->m[0][2]*C[0])*Idet;

  01278	b8 10 00 00 00	 mov	 eax, 16
  0127d	48 6b c0 00	 imul	 rax, rax, 0
  01281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01286	48 03 c8	 add	 rcx, rax
  01289	48 8b c1	 mov	 rax, rcx
  0128c	b9 04 00 00 00	 mov	 ecx, 4
  01291	48 6b c9 00	 imul	 rcx, rcx, 0
  01295	ba 04 00 00 00	 mov	 edx, 4
  0129a	48 6b d2 03	 imul	 rdx, rdx, 3
  0129e	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  012a3	f3 0f 59 44 14
	08		 mulss	 xmm0, DWORD PTR C$[rsp+rdx]
  012a9	b8 10 00 00 00	 mov	 eax, 16
  012ae	48 6b c0 00	 imul	 rax, rax, 0
  012b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  012b7	48 03 c8	 add	 rcx, rax
  012ba	48 8b c1	 mov	 rax, rcx
  012bd	b9 04 00 00 00	 mov	 ecx, 4
  012c2	48 6b c9 01	 imul	 rcx, rcx, 1
  012c6	ba 04 00 00 00	 mov	 edx, 4
  012cb	48 6b d2 01	 imul	 rdx, rdx, 1
  012cf	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  012d4	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  012da	f3 0f 5c c1	 subss	 xmm0, xmm1
  012de	b8 10 00 00 00	 mov	 eax, 16
  012e3	48 6b c0 00	 imul	 rax, rax, 0
  012e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  012ec	48 03 c8	 add	 rcx, rax
  012ef	48 8b c1	 mov	 rax, rcx
  012f2	b9 04 00 00 00	 mov	 ecx, 4
  012f7	48 6b c9 02	 imul	 rcx, rcx, 2
  012fb	ba 04 00 00 00	 mov	 edx, 4
  01300	48 6b d2 00	 imul	 rdx, rdx, 0
  01304	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01309	f3 0f 59 4c 14
	08		 mulss	 xmm1, DWORD PTR C$[rsp+rdx]
  0130f	f3 0f 58 c1	 addss	 xmm0, xmm1
  01313	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  01318	b8 10 00 00 00	 mov	 eax, 16
  0131d	48 6b c0 03	 imul	 rax, rax, 3
  01321	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  01326	48 03 c8	 add	 rcx, rax
  01329	48 8b c1	 mov	 rax, rcx
  0132c	b9 04 00 00 00	 mov	 ecx, 4
  01331	48 6b c9 01	 imul	 rcx, rcx, 1
  01335	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 547  :     Result->m[3][2] = (-A->m[3][0]*S[3] + A->m[3][1]*S[1] - A->m[3][2]*S[0])*Idet;

  0133a	b8 10 00 00 00	 mov	 eax, 16
  0133f	48 6b c0 03	 imul	 rax, rax, 3
  01343	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01348	48 03 c8	 add	 rcx, rax
  0134b	48 8b c1	 mov	 rax, rcx
  0134e	b9 04 00 00 00	 mov	 ecx, 4
  01353	48 6b c9 00	 imul	 rcx, rcx, 0
  01357	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0135c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  01363	b8 04 00 00 00	 mov	 eax, 4
  01368	48 6b c0 03	 imul	 rax, rax, 3
  0136c	f3 0f 59 44 04
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rax]
  01372	b8 10 00 00 00	 mov	 eax, 16
  01377	48 6b c0 03	 imul	 rax, rax, 3
  0137b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01380	48 03 c8	 add	 rcx, rax
  01383	48 8b c1	 mov	 rax, rcx
  01386	b9 04 00 00 00	 mov	 ecx, 4
  0138b	48 6b c9 01	 imul	 rcx, rcx, 1
  0138f	ba 04 00 00 00	 mov	 edx, 4
  01394	48 6b d2 01	 imul	 rdx, rdx, 1
  01398	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0139d	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  013a3	f3 0f 58 c1	 addss	 xmm0, xmm1
  013a7	b8 10 00 00 00	 mov	 eax, 16
  013ac	48 6b c0 03	 imul	 rax, rax, 3
  013b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  013b5	48 03 c8	 add	 rcx, rax
  013b8	48 8b c1	 mov	 rax, rcx
  013bb	b9 04 00 00 00	 mov	 ecx, 4
  013c0	48 6b c9 02	 imul	 rcx, rcx, 2
  013c4	ba 04 00 00 00	 mov	 edx, 4
  013c9	48 6b d2 00	 imul	 rdx, rdx, 0
  013cd	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  013d2	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  013d8	f3 0f 5c c1	 subss	 xmm0, xmm1
  013dc	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  013e1	b8 10 00 00 00	 mov	 eax, 16
  013e6	48 6b c0 03	 imul	 rax, rax, 3
  013ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  013ef	48 03 c8	 add	 rcx, rax
  013f2	48 8b c1	 mov	 rax, rcx
  013f5	b9 04 00 00 00	 mov	 ecx, 4
  013fa	48 6b c9 02	 imul	 rcx, rcx, 2
  013fe	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 548  :     Result->m[3][3] = ( A->m[2][0]*S[3] - A->m[2][1]*S[1] + A->m[2][2]*S[0])*Idet;

  01403	b8 10 00 00 00	 mov	 eax, 16
  01408	48 6b c0 02	 imul	 rax, rax, 2
  0140c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01411	48 03 c8	 add	 rcx, rax
  01414	48 8b c1	 mov	 rax, rcx
  01417	b9 04 00 00 00	 mov	 ecx, 4
  0141c	48 6b c9 00	 imul	 rcx, rcx, 0
  01420	ba 04 00 00 00	 mov	 edx, 4
  01425	48 6b d2 03	 imul	 rdx, rdx, 3
  01429	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  0142e	f3 0f 59 44 14
	20		 mulss	 xmm0, DWORD PTR S$[rsp+rdx]
  01434	b8 10 00 00 00	 mov	 eax, 16
  01439	48 6b c0 02	 imul	 rax, rax, 2
  0143d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01442	48 03 c8	 add	 rcx, rax
  01445	48 8b c1	 mov	 rax, rcx
  01448	b9 04 00 00 00	 mov	 ecx, 4
  0144d	48 6b c9 01	 imul	 rcx, rcx, 1
  01451	ba 04 00 00 00	 mov	 edx, 4
  01456	48 6b d2 01	 imul	 rdx, rdx, 1
  0145a	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  0145f	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  01465	f3 0f 5c c1	 subss	 xmm0, xmm1
  01469	b8 10 00 00 00	 mov	 eax, 16
  0146e	48 6b c0 02	 imul	 rax, rax, 2
  01472	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  01477	48 03 c8	 add	 rcx, rax
  0147a	48 8b c1	 mov	 rax, rcx
  0147d	b9 04 00 00 00	 mov	 ecx, 4
  01482	48 6b c9 02	 imul	 rcx, rcx, 2
  01486	ba 04 00 00 00	 mov	 edx, 4
  0148b	48 6b d2 00	 imul	 rdx, rdx, 0
  0148f	f3 0f 10 0c 08	 movss	 xmm1, DWORD PTR [rax+rcx]
  01494	f3 0f 59 4c 14
	20		 mulss	 xmm1, DWORD PTR S$[rsp+rdx]
  0149a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0149e	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR Idet$[rsp]
  014a3	b8 10 00 00 00	 mov	 eax, 16
  014a8	48 6b c0 03	 imul	 rax, rax, 3
  014ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Result$[rsp]
  014b1	48 03 c8	 add	 rcx, rax
  014b4	48 8b c1	 mov	 rax, rcx
  014b7	b9 04 00 00 00	 mov	 ecx, 4
  014bc	48 6b c9 03	 imul	 rcx, rcx, 3
  014c0	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 549  : }

  014c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  014ca	48 33 cc	 xor	 rcx, rsp
  014cd	e8 00 00 00 00	 call	 __security_check_cookie
  014d2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  014d6	c3		 ret	 0
?Mat4Inverse@@YAXPEATmat4@@0@Z ENDP			; Mat4Inverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Mat$ = 0
__$ArrayPad$ = 64
Result$ = 112
A$ = 120
?Mat4Transpose@@YAXPEATmat4@@0@Z PROC			; Mat4Transpose

; 497  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 498  :     mat4 Mat =
; 499  :     {
; 500  :         A->e[0].x, A->e[1].x, A->e[2].x, A->e[3].x,

  0001f	b8 10 00 00 00	 mov	 eax, 16
  00024	48 6b c0 00	 imul	 rax, rax, 0
  00028	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0002d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR Mat$[rsp], xmm0
  00037	b8 10 00 00 00	 mov	 eax, 16
  0003c	48 6b c0 01	 imul	 rax, rax, 1
  00040	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00045	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  0004a	f3 0f 11 44 24
	04		 movss	 DWORD PTR Mat$[rsp+4], xmm0
  00050	b8 10 00 00 00	 mov	 eax, 16
  00055	48 6b c0 02	 imul	 rax, rax, 2
  00059	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0005e	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  00063	f3 0f 11 44 24
	08		 movss	 DWORD PTR Mat$[rsp+8], xmm0
  00069	b8 10 00 00 00	 mov	 eax, 16
  0006e	48 6b c0 03	 imul	 rax, rax, 3
  00072	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00077	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  0007c	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Mat$[rsp+12], xmm0

; 501  :         A->e[0].y, A->e[1].y, A->e[2].y, A->e[3].y,

  00082	b8 10 00 00 00	 mov	 eax, 16
  00087	48 6b c0 00	 imul	 rax, rax, 0
  0008b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00090	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  00096	f3 0f 11 44 24
	10		 movss	 DWORD PTR Mat$[rsp+16], xmm0
  0009c	b8 10 00 00 00	 mov	 eax, 16
  000a1	48 6b c0 01	 imul	 rax, rax, 1
  000a5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  000aa	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  000b0	f3 0f 11 44 24
	14		 movss	 DWORD PTR Mat$[rsp+20], xmm0
  000b6	b8 10 00 00 00	 mov	 eax, 16
  000bb	48 6b c0 02	 imul	 rax, rax, 2
  000bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  000c4	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  000ca	f3 0f 11 44 24
	18		 movss	 DWORD PTR Mat$[rsp+24], xmm0
  000d0	b8 10 00 00 00	 mov	 eax, 16
  000d5	48 6b c0 03	 imul	 rax, rax, 3
  000d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  000de	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  000e4	f3 0f 11 44 24
	1c		 movss	 DWORD PTR Mat$[rsp+28], xmm0

; 502  :         A->e[0].z, A->e[1].z, A->e[2].z, A->e[3].z,

  000ea	b8 10 00 00 00	 mov	 eax, 16
  000ef	48 6b c0 00	 imul	 rax, rax, 0
  000f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  000f8	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  000fe	f3 0f 11 44 24
	20		 movss	 DWORD PTR Mat$[rsp+32], xmm0
  00104	b8 10 00 00 00	 mov	 eax, 16
  00109	48 6b c0 01	 imul	 rax, rax, 1
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00112	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  00118	f3 0f 11 44 24
	24		 movss	 DWORD PTR Mat$[rsp+36], xmm0
  0011e	b8 10 00 00 00	 mov	 eax, 16
  00123	48 6b c0 02	 imul	 rax, rax, 2
  00127	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0012c	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  00132	f3 0f 11 44 24
	28		 movss	 DWORD PTR Mat$[rsp+40], xmm0
  00138	b8 10 00 00 00	 mov	 eax, 16
  0013d	48 6b c0 03	 imul	 rax, rax, 3
  00141	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00146	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  0014c	f3 0f 11 44 24
	2c		 movss	 DWORD PTR Mat$[rsp+44], xmm0

; 503  :         A->e[0].w, A->e[1].w, A->e[2].w, A->e[3].w

  00152	b8 10 00 00 00	 mov	 eax, 16
  00157	48 6b c0 00	 imul	 rax, rax, 0
  0015b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00160	f3 0f 10 44 01
	0c		 movss	 xmm0, DWORD PTR [rcx+rax+12]
  00166	f3 0f 11 44 24
	30		 movss	 DWORD PTR Mat$[rsp+48], xmm0
  0016c	b8 10 00 00 00	 mov	 eax, 16
  00171	48 6b c0 01	 imul	 rax, rax, 1
  00175	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  0017a	f3 0f 10 44 01
	0c		 movss	 xmm0, DWORD PTR [rcx+rax+12]
  00180	f3 0f 11 44 24
	34		 movss	 DWORD PTR Mat$[rsp+52], xmm0
  00186	b8 10 00 00 00	 mov	 eax, 16
  0018b	48 6b c0 02	 imul	 rax, rax, 2
  0018f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  00194	f3 0f 10 44 01
	0c		 movss	 xmm0, DWORD PTR [rcx+rax+12]
  0019a	f3 0f 11 44 24
	38		 movss	 DWORD PTR Mat$[rsp+56], xmm0
  001a0	b8 10 00 00 00	 mov	 eax, 16
  001a5	48 6b c0 03	 imul	 rax, rax, 3
  001a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR A$[rsp]
  001ae	f3 0f 10 44 01
	0c		 movss	 xmm0, DWORD PTR [rcx+rax+12]
  001b4	f3 0f 11 44 24
	3c		 movss	 DWORD PTR Mat$[rsp+60], xmm0

; 504  :     };
; 505  :     
; 506  :     *Result = Mat;

  001ba	48 8d 04 24	 lea	 rax, QWORD PTR Mat$[rsp]
  001be	48 8b 7c 24 70	 mov	 rdi, QWORD PTR Result$[rsp]
  001c3	48 8b f0	 mov	 rsi, rax
  001c6	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001cb	f3 a4		 rep movsb

; 507  : }

  001cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d2	48 33 cc	 xor	 rcx, rsp
  001d5	e8 00 00 00 00	 call	 __security_check_cookie
  001da	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001de	5f		 pop	 rdi
  001df	5e		 pop	 rsi
  001e0	c3		 ret	 0
?Mat4Transpose@@YAXPEATmat4@@0@Z ENDP			; Mat4Transpose
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 64
$T1 = 112
?Mat4Identity@@YA?ATmat4@@XZ PROC			; Mat4Identity

; 483  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 484  :     mat4 Result =
; 485  :     {
; 486  :         1.0f, 0.0f, 0.0f, 0.0f,

  0001a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00022	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0
  00039	0f 57 c0	 xorps	 xmm0, xmm0
  0003c	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 487  :         0.0f, 1.0f, 0.0f, 0.0f,

  00042	0f 57 c0	 xorps	 xmm0, xmm0
  00045	f3 0f 11 44 24
	10		 movss	 DWORD PTR Result$[rsp+16], xmm0
  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00053	f3 0f 11 44 24
	14		 movss	 DWORD PTR Result$[rsp+20], xmm0
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 44 24
	18		 movss	 DWORD PTR Result$[rsp+24], xmm0
  00062	0f 57 c0	 xorps	 xmm0, xmm0
  00065	f3 0f 11 44 24
	1c		 movss	 DWORD PTR Result$[rsp+28], xmm0

; 488  :         0.0f, 0.0f, 1.0f, 0.0f,

  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	f3 0f 11 44 24
	20		 movss	 DWORD PTR Result$[rsp+32], xmm0
  00074	0f 57 c0	 xorps	 xmm0, xmm0
  00077	f3 0f 11 44 24
	24		 movss	 DWORD PTR Result$[rsp+36], xmm0
  0007d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00085	f3 0f 11 44 24
	28		 movss	 DWORD PTR Result$[rsp+40], xmm0
  0008b	0f 57 c0	 xorps	 xmm0, xmm0
  0008e	f3 0f 11 44 24
	2c		 movss	 DWORD PTR Result$[rsp+44], xmm0

; 489  :         0.0f, 0.0f, 0.0f, 1.0f

  00094	0f 57 c0	 xorps	 xmm0, xmm0
  00097	f3 0f 11 44 24
	30		 movss	 DWORD PTR Result$[rsp+48], xmm0
  0009d	0f 57 c0	 xorps	 xmm0, xmm0
  000a0	f3 0f 11 44 24
	34		 movss	 DWORD PTR Result$[rsp+52], xmm0
  000a6	0f 57 c0	 xorps	 xmm0, xmm0
  000a9	f3 0f 11 44 24
	38		 movss	 DWORD PTR Result$[rsp+56], xmm0
  000af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b7	f3 0f 11 44 24
	3c		 movss	 DWORD PTR Result$[rsp+60], xmm0

; 490  :     };
; 491  :     
; 492  :     return(Result);

  000bd	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  000c1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T1[rsp]
  000c6	48 8b f0	 mov	 rsi, rax
  000c9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000ce	f3 a4		 rep movsb
  000d0	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]

; 493  : }

  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e6	5f		 pop	 rdi
  000e7	5e		 pop	 rsi
  000e8	c3		 ret	 0
?Mat4Identity@@YA?ATmat4@@XZ ENDP			; Mat4Identity
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 40
$T1 = 80
A$ = 88
?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z PROC		; Mat3FromMat4

; 466  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 467  :     mat3 Result =
; 468  :     {
; 469  :         A->e[0].x, A->e[0].y, A->e[0].z,

  0001f	b8 10 00 00 00	 mov	 eax, 16
  00024	48 6b c0 00	 imul	 rax, rax, 0
  00028	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0002d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00037	b8 10 00 00 00	 mov	 eax, 16
  0003c	48 6b c0 00	 imul	 rax, rax, 0
  00040	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00045	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  0004b	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  00051	b8 10 00 00 00	 mov	 eax, 16
  00056	48 6b c0 00	 imul	 rax, rax, 0
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  0005f	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  00065	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 470  :         A->e[1].x, A->e[1].y, A->e[1].z,

  0006b	b8 10 00 00 00	 mov	 eax, 16
  00070	48 6b c0 01	 imul	 rax, rax, 1
  00074	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00079	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  0007e	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0
  00084	b8 10 00 00 00	 mov	 eax, 16
  00089	48 6b c0 01	 imul	 rax, rax, 1
  0008d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  00092	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  00098	f3 0f 11 44 24
	10		 movss	 DWORD PTR Result$[rsp+16], xmm0
  0009e	b8 10 00 00 00	 mov	 eax, 16
  000a3	48 6b c0 01	 imul	 rax, rax, 1
  000a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  000ac	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  000b2	f3 0f 11 44 24
	14		 movss	 DWORD PTR Result$[rsp+20], xmm0

; 471  :         A->e[2].x, A->e[2].y, A->e[2].z,

  000b8	b8 10 00 00 00	 mov	 eax, 16
  000bd	48 6b c0 02	 imul	 rax, rax, 2
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  000c6	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [rcx+rax]
  000cb	f3 0f 11 44 24
	18		 movss	 DWORD PTR Result$[rsp+24], xmm0
  000d1	b8 10 00 00 00	 mov	 eax, 16
  000d6	48 6b c0 02	 imul	 rax, rax, 2
  000da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  000df	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [rcx+rax+4]
  000e5	f3 0f 11 44 24
	1c		 movss	 DWORD PTR Result$[rsp+28], xmm0
  000eb	b8 10 00 00 00	 mov	 eax, 16
  000f0	48 6b c0 02	 imul	 rax, rax, 2
  000f4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR A$[rsp]
  000f9	f3 0f 10 44 01
	08		 movss	 xmm0, DWORD PTR [rcx+rax+8]
  000ff	f3 0f 11 44 24
	20		 movss	 DWORD PTR Result$[rsp+32], xmm0

; 472  :     };
; 473  :     
; 474  :     return(Result);

  00105	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00109	48 8b 7c 24 50	 mov	 rdi, QWORD PTR $T1[rsp]
  0010e	48 8b f0	 mov	 rsi, rax
  00111	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00116	f3 a4		 rep movsb
  00118	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]

; 475  : }

  0011d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00122	48 33 cc	 xor	 rcx, rsp
  00125	e8 00 00 00 00	 call	 __security_check_cookie
  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	5f		 pop	 rdi
  0012f	5e		 pop	 rsi
  00130	c3		 ret	 0
?Mat3FromMat4@@YA?ATmat3@@PEATmat4@@@Z ENDP		; Mat3FromMat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
__$ArrayPad$ = 96
A$ = 144
B$ = 152
??X@YAAEATv4@@AEAT0@T0@@Z PROC				; operator*=

; 435  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 436  :     A = A*B;

  0001f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR B$[rsp]
  0002f	b9 10 00 00 00	 mov	 ecx, 16
  00034	f3 a4		 rep movsb
  00036	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00046	b9 10 00 00 00	 mov	 ecx, 16
  0004b	f3 a4		 rep movsb
  0004d	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00052	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00057	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0005c	e8 00 00 00 00	 call	 ??D@YA?ATv4@@T0@0@Z	; operator*
  00061	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  00066	48 8b f9	 mov	 rdi, rcx
  00069	48 8b f0	 mov	 rsi, rax
  0006c	b9 10 00 00 00	 mov	 ecx, 16
  00071	f3 a4		 rep movsb
  00073	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  00078	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR A$[rsp]
  00080	48 8b f0	 mov	 rsi, rax
  00083	b9 10 00 00 00	 mov	 ecx, 16
  00088	f3 a4		 rep movsb

; 437  :     return(A);

  0008a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR A$[rsp]

; 438  : }

  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00097	48 33 cc	 xor	 rcx, rsp
  0009a	e8 00 00 00 00	 call	 __security_check_cookie
  0009f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a3	5f		 pop	 rdi
  000a4	5e		 pop	 rsi
  000a5	c3		 ret	 0
??X@YAAEATv4@@AEAT0@T0@@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??D@YA?ATv4@@T0@M@Z PROC				; operator*

; 411  : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 412  :     v4 Result;
; 413  :     Result.x = A.x*B;

  00025	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0002a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0002e	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 414  :     Result.y = A.y*B;

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0003e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00043	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  00049	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 415  :     Result.z = A.z*B;

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00054	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00059	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  0005f	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 416  :     Result.w = A.w*B;

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0006a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0006f	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  00075	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 417  :     
; 418  :     return(Result);

  0007b	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  0007f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00084	48 8b f0	 mov	 rsi, rax
  00087	b9 10 00 00 00	 mov	 ecx, 16
  0008c	f3 a4		 rep movsb
  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 419  : }

  00093	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00098	48 33 cc	 xor	 rcx, rsp
  0009b	e8 00 00 00 00	 call	 __security_check_cookie
  000a0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a4	5f		 pop	 rdi
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
??D@YA?ATv4@@T0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??D@YA?ATv4@@T0@0@Z PROC				; operator*

; 398  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 399  :     v4 Result;
; 400  :     
; 401  :     Result.x = A.x*B.x;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 402  :     Result.y = A.y*B.y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 403  :     Result.z = A.z*B.z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 404  :     Result.w = A.w*B.w;

  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00079	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0007e	f3 0f 59 41 0c	 mulss	 xmm0, DWORD PTR [rcx+12]
  00083	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 405  :     
; 406  :     return(Result);

  00089	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  0008d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00092	48 8b f0	 mov	 rsi, rax
  00095	b9 10 00 00 00	 mov	 ecx, 16
  0009a	f3 a4		 rep movsb
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 407  : }

  000a1	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a6	48 33 cc	 xor	 rcx, rsp
  000a9	e8 00 00 00 00	 call	 __security_check_cookie
  000ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b2	5f		 pop	 rdi
  000b3	5e		 pop	 rsi
  000b4	c3		 ret	 0
??D@YA?ATv4@@T0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??H@YA?ATv4@@T0@0@Z PROC				; operator+

; 385  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 386  :     v4 Result;
; 387  :     
; 388  :     Result.x = A.x + B.x;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 58 01	 addss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 389  :     Result.y = A.y + B.y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 390  :     Result.z = A.z + B.z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 391  :     Result.w = A.w + B.w;

  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00079	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  0007e	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [rcx+12]
  00083	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 392  :     
; 393  :     return(Result);

  00089	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  0008d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00092	48 8b f0	 mov	 rsi, rax
  00095	b9 10 00 00 00	 mov	 ecx, 16
  0009a	f3 a4		 rep movsb
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 394  : }

  000a1	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a6	48 33 cc	 xor	 rcx, rsp
  000a9	e8 00 00 00 00	 call	 __security_check_cookie
  000ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b2	5f		 pop	 rdi
  000b3	5e		 pop	 rsi
  000b4	c3		 ret	 0
??H@YA?ATv4@@T0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
?V4@@YA?ATv4@@Tv3@@M@Z PROC				; V4

; 377  : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 378  :     v4 Result = { A.x, A.y, A.z, B };

  00025	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0002a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00038	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0003d	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  00043	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00048	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  0004d	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0
  00053	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR B$[rsp]
  00059	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 379  :     
; 380  :     return(Result);

  0005f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00063	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00068	48 8b f0	 mov	 rsi, rax
  0006b	b9 10 00 00 00	 mov	 ecx, 16
  00070	f3 a4		 rep movsb
  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 381  : }

  00077	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	5f		 pop	 rdi
  00089	5e		 pop	 rsi
  0008a	c3		 ret	 0
?V4@@YA?ATv4@@Tv3@@M@Z ENDP				; V4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
X$ = 72
Y$ = 80
Z$ = 88
W$ = 96
?V4@@YA?ATv4@@MMMM@Z PROC				; V4

; 369  : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	56		 push	 rsi
  00018	57		 push	 rdi
  00019	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  :     v4 Result = { X, Y, Z, W };

  0002c	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR X$[rsp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00037	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR Y$[rsp]
  0003d	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  00043	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR Z$[rsp]
  00049	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0
  0004f	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR W$[rsp]
  00055	f3 0f 11 44 24
	0c		 movss	 DWORD PTR Result$[rsp+12], xmm0

; 371  :     
; 372  :     return(Result);

  0005b	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  0005f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00064	48 8b f0	 mov	 rsi, rax
  00067	b9 10 00 00 00	 mov	 ecx, 16
  0006c	f3 a4		 rep movsb
  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 373  : }

  00073	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00078	48 33 cc	 xor	 rcx, rsp
  0007b	e8 00 00 00 00	 call	 __security_check_cookie
  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	5f		 pop	 rdi
  00085	5e		 pop	 rsi
  00086	c3		 ret	 0
?V4@@YA?ATv4@@MMMM@Z ENDP				; V4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
tv64 = 32
tv77 = 36
$T1 = 48
$T2 = 64
Direction$ = 80
$T3 = 96
__$ArrayPad$ = 112
$T4 = 160
Euler$ = 168
?V3EulerToRotation@@YA?ATv3@@T1@@Z PROC			; V3EulerToRotation

; 351  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 352  :     v3 Direction;
; 353  :     Direction.Pitch = (Cos(Euler.Yaw*DEG_TO_RAD) *

  00022	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR Euler$[rsp]
  0002a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0002f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00037	e8 00 00 00 00	 call	 ?Cos@@YAMM@Z		; Cos
  0003c	f3 0f 11 44 24
	20		 movss	 DWORD PTR tv64[rsp], xmm0
  00042	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR Euler$[rsp]
  0004a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  0004e	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3c8efa35
  00056	0f 28 c1	 movaps	 xmm0, xmm1
  00059	e8 00 00 00 00	 call	 ?Cos@@YAMM@Z		; Cos
  0005e	f3 0f 10 4c 24
	20		 movss	 xmm1, DWORD PTR tv64[rsp]
  00064	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00068	0f 28 c1	 movaps	 xmm0, xmm1
  0006b	f3 0f 11 44 24
	50		 movss	 DWORD PTR Direction$[rsp], xmm0

; 354  :                        Cos(Euler.Pitch*DEG_TO_RAD));
; 355  :     Direction.Yaw = Sin(Euler.Pitch*DEG_TO_RAD);

  00071	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR Euler$[rsp]
  00079	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0007d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00085	e8 00 00 00 00	 call	 ?Sin@@YAMM@Z		; Sin
  0008a	f3 0f 11 44 24
	54		 movss	 DWORD PTR Direction$[rsp+4], xmm0

; 356  :     Direction.Roll = (Sin(Euler.Yaw*DEG_TO_RAD) *

  00090	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR Euler$[rsp]
  00098	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0009d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  000a5	e8 00 00 00 00	 call	 ?Sin@@YAMM@Z		; Sin
  000aa	f3 0f 11 44 24
	24		 movss	 DWORD PTR tv77[rsp], xmm0
  000b0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR Euler$[rsp]
  000b8	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  000bc	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3c8efa35
  000c4	0f 28 c1	 movaps	 xmm0, xmm1
  000c7	e8 00 00 00 00	 call	 ?Cos@@YAMM@Z		; Cos
  000cc	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR tv77[rsp]
  000d2	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000d6	0f 28 c1	 movaps	 xmm0, xmm1
  000d9	f3 0f 11 44 24
	58		 movss	 DWORD PTR Direction$[rsp+8], xmm0

; 357  :                       Cos(Euler.Pitch*DEG_TO_RAD));
; 358  :     Direction = V3Normalize(Direction);

  000df	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  000e4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR Direction$[rsp]
  000e9	48 8b f8	 mov	 rdi, rax
  000ec	48 8b f1	 mov	 rsi, rcx
  000ef	b9 0c 00 00 00	 mov	 ecx, 12
  000f4	f3 a4		 rep movsb
  000f6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00100	e8 00 00 00 00	 call	 ?V3Normalize@@YA?ATv3@@T1@@Z ; V3Normalize
  00105	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  0010a	48 8b f9	 mov	 rdi, rcx
  0010d	48 8b f0	 mov	 rsi, rax
  00110	b9 0c 00 00 00	 mov	 ecx, 12
  00115	f3 a4		 rep movsb
  00117	48 8d 44 24 50	 lea	 rax, QWORD PTR Direction$[rsp]
  0011c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  00121	48 8b f8	 mov	 rdi, rax
  00124	48 8b f1	 mov	 rsi, rcx
  00127	b9 0c 00 00 00	 mov	 ecx, 12
  0012c	f3 a4		 rep movsb

; 359  :     
; 360  :     return(Direction);

  0012e	48 8d 44 24 50	 lea	 rax, QWORD PTR Direction$[rsp]
  00133	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR $T4[rsp]
  0013b	48 8b f0	 mov	 rsi, rax
  0013e	b9 0c 00 00 00	 mov	 ecx, 12
  00143	f3 a4		 rep movsb
  00145	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]

; 361  : }

  0014d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00152	48 33 cc	 xor	 rcx, rsp
  00155	e8 00 00 00 00	 call	 __security_check_cookie
  0015a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00161	5f		 pop	 rdi
  00162	5e		 pop	 rsi
  00163	c3		 ret	 0
?V3EulerToRotation@@YA?ATv3@@T1@@Z ENDP			; V3EulerToRotation
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
K$ = 32
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
Result$ = 112
__$ArrayPad$ = 128
$T5 = 176
A$ = 184
?V3Normalize@@YA?ATv3@@T1@@Z PROC			; V3Normalize

; 342  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 343  :     f32 K = 1.0f / V3Length(A);

  00025	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0002a	48 8b f8	 mov	 rdi, rax
  0002d	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00035	b9 0c 00 00 00	 mov	 ecx, 12
  0003a	f3 a4		 rep movsb
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00041	e8 00 00 00 00	 call	 ?V3Length@@YAMTv3@@@Z	; V3Length
  00046	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0004e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00052	0f 28 c1	 movaps	 xmm0, xmm1
  00055	f3 0f 11 44 24
	20		 movss	 DWORD PTR K$[rsp], xmm0

; 344  :     
; 345  :     v3 Result = A*K;

  0005b	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00060	48 8b f8	 mov	 rdi, rax
  00063	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  0006b	b9 0c 00 00 00	 mov	 ecx, 12
  00070	f3 a4		 rep movsb
  00072	f3 0f 10 54 24
	20		 movss	 xmm2, DWORD PTR K$[rsp]
  00078	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  0007d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  00082	e8 00 00 00 00	 call	 ??D@YA?ATv3@@T0@M@Z	; operator*
  00087	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b f0	 mov	 rsi, rax
  00092	b9 0c 00 00 00	 mov	 ecx, 12
  00097	f3 a4		 rep movsb
  00099	48 8d 44 24 70	 lea	 rax, QWORD PTR Result$[rsp]
  0009e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T4[rsp]
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	48 8b f1	 mov	 rsi, rcx
  000a9	b9 0c 00 00 00	 mov	 ecx, 12
  000ae	f3 a4		 rep movsb

; 346  :     return(Result);

  000b0	48 8d 44 24 70	 lea	 rax, QWORD PTR Result$[rsp]
  000b5	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR $T5[rsp]
  000bd	48 8b f0	 mov	 rsi, rax
  000c0	b9 0c 00 00 00	 mov	 ecx, 12
  000c5	f3 a4		 rep movsb
  000c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]

; 347  : }

  000cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d7	48 33 cc	 xor	 rcx, rsp
  000da	e8 00 00 00 00	 call	 __security_check_cookie
  000df	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000e6	5f		 pop	 rdi
  000e7	5e		 pop	 rsi
  000e8	c3		 ret	 0
?V3Normalize@@YA?ATv3@@T1@@Z ENDP			; V3Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
A$ = 96
?V3Length@@YAMTv3@@@Z PROC				; V3Length

; 336  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 337  :     return(Sqrt(V3MultiplyDot(A, A)));

  0000b	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00010	48 8b f8	 mov	 rdi, rax
  00013	48 8b 74 24 60	 mov	 rsi, QWORD PTR A$[rsp]
  00018	b9 0c 00 00 00	 mov	 ecx, 12
  0001d	f3 a4		 rep movsb
  0001f	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 8b 74 24 60	 mov	 rsi, QWORD PTR A$[rsp]
  0002c	b9 0c 00 00 00	 mov	 ecx, 12
  00031	f3 a4		 rep movsb
  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00038	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0003d	e8 00 00 00 00	 call	 ?V3MultiplyDot@@YAMTv3@@0@Z ; V3MultiplyDot
  00042	e8 00 00 00 00	 call	 ?Sqrt@@YAMM@Z		; Sqrt

; 338  : }

  00047	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004b	5f		 pop	 rdi
  0004c	5e		 pop	 rsi
  0004d	c3		 ret	 0
?V3Length@@YAMTv3@@@Z ENDP				; V3Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
A$ = 32
B$ = 40
?V3MultiplyDot@@YAMTv3@@0@Z PROC			; V3MultiplyDot

; 328  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 329  :     f32 Result = A.x*B.x + A.y*B.y + A.z*B.z;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR A$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR B$[rsp]
  00018	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0001c	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR A$[rsp]
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR B$[rsp]
  0002a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  0002f	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [rcx+4]
  00034	f3 0f 58 c1	 addss	 xmm0, xmm1
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR A$[rsp]
  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR B$[rsp]
  00042	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00047	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [rcx+8]
  0004c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00050	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 330  :     
; 331  :     return(Result);

  00055	f3 0f 10 04 24	 movss	 xmm0, DWORD PTR Result$[rsp]

; 332  : }

  0005a	48 83 c4 18	 add	 rsp, 24
  0005e	c3		 ret	 0
?V3MultiplyDot@@YAMTv3@@0@Z ENDP			; V3MultiplyDot
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??D@YA?ATv3@@T0@M@Z PROC				; operator*

; 297  : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 298  :     v3 Result;
; 299  :     
; 300  :     Result.x = A.x*B;

  00025	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0002a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0002e	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 301  :     Result.y = A.y*B;

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0003e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00043	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  00049	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 302  :     Result.z = A.z*B;

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00054	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00059	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR B$[rsp]
  0005f	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 303  :     
; 304  :     return(Result);

  00065	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00069	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  0006e	48 8b f0	 mov	 rsi, rax
  00071	b9 0c 00 00 00	 mov	 ecx, 12
  00076	f3 a4		 rep movsb
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 305  : }

  0007d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00082	48 33 cc	 xor	 rcx, rsp
  00085	e8 00 00 00 00	 call	 __security_check_cookie
  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	5f		 pop	 rdi
  0008f	5e		 pop	 rsi
  00090	c3		 ret	 0
??D@YA?ATv3@@T0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
__$ArrayPad$ = 96
A$ = 144
B$ = 152
??X@YAAEATv3@@AEAT0@T0@@Z PROC				; operator*=

; 290  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 291  :     A = A*B;

  0001f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR B$[rsp]
  0002f	b9 0c 00 00 00	 mov	 ecx, 12
  00034	f3 a4		 rep movsb
  00036	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00046	b9 0c 00 00 00	 mov	 ecx, 12
  0004b	f3 a4		 rep movsb
  0004d	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00052	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00057	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0005c	e8 00 00 00 00	 call	 ??D@YA?ATv3@@T0@0@Z	; operator*
  00061	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  00066	48 8b f9	 mov	 rdi, rcx
  00069	48 8b f0	 mov	 rsi, rax
  0006c	b9 0c 00 00 00	 mov	 ecx, 12
  00071	f3 a4		 rep movsb
  00073	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  00078	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR A$[rsp]
  00080	48 8b f0	 mov	 rsi, rax
  00083	b9 0c 00 00 00	 mov	 ecx, 12
  00088	f3 a4		 rep movsb

; 292  :     return(A);

  0008a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR A$[rsp]

; 293  : }

  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00097	48 33 cc	 xor	 rcx, rsp
  0009a	e8 00 00 00 00	 call	 __security_check_cookie
  0009f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a3	5f		 pop	 rdi
  000a4	5e		 pop	 rsi
  000a5	c3		 ret	 0
??X@YAAEATv3@@AEAT0@T0@@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??D@YA?ATv3@@T0@0@Z PROC				; operator*

; 278  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 279  :     v3 Result;
; 280  :     
; 281  :     Result.x = A.x*B.x;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 282  :     Result.y = A.y*B.y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 283  :     Result.z = A.z*B.z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 284  :     
; 285  :     return(Result);

  0006f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00073	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00078	48 8b f0	 mov	 rsi, rax
  0007b	b9 0c 00 00 00	 mov	 ecx, 12
  00080	f3 a4		 rep movsb
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 286  : }

  00087	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	5f		 pop	 rdi
  00099	5e		 pop	 rsi
  0009a	c3		 ret	 0
??D@YA?ATv3@@T0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??G@YA?ATv3@@T0@0@Z PROC				; operator-

; 266  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 267  :     v3 Result;
; 268  :     
; 269  :     Result.x = A.x - B.x;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 270  :     Result.y = A.y - B.y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 271  :     Result.z = A.z - B.z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 272  :     
; 273  :     return(Result);

  0006f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00073	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00078	48 8b f0	 mov	 rsi, rax
  0007b	b9 0c 00 00 00	 mov	 ecx, 12
  00080	f3 a4		 rep movsb
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 274  : }

  00087	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	5f		 pop	 rdi
  00099	5e		 pop	 rsi
  0009a	c3		 ret	 0
??G@YA?ATv3@@T0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
__$ArrayPad$ = 96
A$ = 144
B$ = 152
??Y@YAAEATv3@@AEAT0@T0@@Z PROC				; operator+=

; 259  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 260  :     A = A + B;

  0001f	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR B$[rsp]
  0002f	b9 0c 00 00 00	 mov	 ecx, 12
  00034	f3 a4		 rep movsb
  00036	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00046	b9 0c 00 00 00	 mov	 ecx, 12
  0004b	f3 a4		 rep movsb
  0004d	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00052	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  00057	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0005c	e8 00 00 00 00	 call	 ??H@YA?ATv3@@T0@0@Z	; operator+
  00061	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  00066	48 8b f9	 mov	 rdi, rcx
  00069	48 8b f0	 mov	 rsi, rax
  0006c	b9 0c 00 00 00	 mov	 ecx, 12
  00071	f3 a4		 rep movsb
  00073	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  00078	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR A$[rsp]
  00080	48 8b f0	 mov	 rsi, rax
  00083	b9 0c 00 00 00	 mov	 ecx, 12
  00088	f3 a4		 rep movsb

; 261  :     return(A);

  0008a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR A$[rsp]

; 262  : }

  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00097	48 33 cc	 xor	 rcx, rsp
  0009a	e8 00 00 00 00	 call	 __security_check_cookie
  0009f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a3	5f		 pop	 rdi
  000a4	5e		 pop	 rsi
  000a5	c3		 ret	 0
??Y@YAAEATv3@@AEAT0@T0@@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
??H@YA?ATv3@@T0@0@Z PROC				; operator+

; 247  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 248  :     v3 Result;
; 249  :     
; 250  :     Result.x = A.x + B.x;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 58 01	 addss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 251  :     Result.y = A.y + B.y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 252  :     Result.z = A.z + B.z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 253  :     
; 254  :     return(Result);

  0006f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00073	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00078	48 8b f0	 mov	 rsi, rax
  0007b	b9 0c 00 00 00	 mov	 ecx, 12
  00080	f3 a4		 rep movsb
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 255  : }

  00087	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	5f		 pop	 rdi
  00099	5e		 pop	 rsi
  0009a	c3		 ret	 0
??H@YA?ATv3@@T0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
?V3@@YA?ATv3@@Tv4@@@Z PROC				; V3

; 240  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 241  :     v3 Result = { A.x, A.y, A.z };

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00024	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00028	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  0002d	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00032	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00037	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00042	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00047	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 242  :     return(Result);

  0004d	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00051	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00056	48 8b f0	 mov	 rsi, rax
  00059	b9 0c 00 00 00	 mov	 ecx, 12
  0005e	f3 a4		 rep movsb
  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 243  : }

  00065	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006a	48 33 cc	 xor	 rcx, rsp
  0006d	e8 00 00 00 00	 call	 __security_check_cookie
  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	5f		 pop	 rdi
  00077	5e		 pop	 rsi
  00078	c3		 ret	 0
?V3@@YA?ATv3@@Tv4@@@Z ENDP				; V3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
?V3@@YA?ATv3@@Tv2@@M@Z PROC				; V3

; 233  : {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 234  :     v3 Result = { A.x, A.y, B };

  00025	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR A$[rsp]
  0002b	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00030	f3 0f 10 44 24
	4c		 movss	 xmm0, DWORD PTR A$[rsp+4]
  00036	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  0003c	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR B$[rsp]
  00042	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 235  :     return(Result);

  00048	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  0004c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00051	48 8b f0	 mov	 rsi, rax
  00054	b9 0c 00 00 00	 mov	 ecx, 12
  00059	f3 a4		 rep movsb
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 236  : }

  00060	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00065	48 33 cc	 xor	 rcx, rsp
  00068	e8 00 00 00 00	 call	 __security_check_cookie
  0006d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00071	5f		 pop	 rdi
  00072	5e		 pop	 rsi
  00073	c3		 ret	 0
?V3@@YA?ATv3@@Tv2@@M@Z ENDP				; V3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
X$ = 72
Y$ = 80
Z$ = 88
?V3@@YA?ATv3@@MMM@Z PROC				; V3

; 225  : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	56		 push	 rsi
  00018	57		 push	 rdi
  00019	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 226  :     v3 Result = { X, Y, Z };

  0002c	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR X$[rsp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00037	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR Y$[rsp]
  0003d	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0
  00043	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR Z$[rsp]
  00049	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 227  :     
; 228  :     return(Result);

  0004f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00053	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00058	48 8b f0	 mov	 rsi, rax
  0005b	b9 0c 00 00 00	 mov	 ecx, 12
  00060	f3 a4		 rep movsb
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 229  : }

  00067	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00078	5f		 pop	 rdi
  00079	5e		 pop	 rsi
  0007a	c3		 ret	 0
?V3@@YA?ATv3@@MMM@Z ENDP				; V3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
A$ = 72
B$ = 80
?V3Cross@@YA?ATv3@@T1@0@Z PROC				; V3Cross

; 161  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 162  :     v3 Result;
; 163  :     
; 164  :     Result.x = A.y*B.z - A.z*B.y;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00033	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00042	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00047	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [rcx+4]
  0004c	f3 0f 5c c1	 subss	 xmm0, xmm1
  00050	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 165  :     Result.y = A.z*B.x - A.x*B.z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  00072	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  00076	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [rcx+8]
  0007b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0007f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 166  :     Result.z = A.x*B.y + A.y*B.x;

  00085	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  0008f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00093	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  00098	48 8b 44 24 48	 mov	 rax, QWORD PTR A$[rsp]
  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR B$[rsp]
  000a2	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  000a7	f3 0f 59 09	 mulss	 xmm1, DWORD PTR [rcx]
  000ab	f3 0f 58 c1	 addss	 xmm0, xmm1
  000af	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 167  :     
; 168  :     return(Result);

  000b5	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  000b9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  000be	48 8b f0	 mov	 rsi, rax
  000c1	b9 0c 00 00 00	 mov	 ecx, 12
  000c6	f3 a4		 rep movsb
  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 169  : }

  000cd	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d2	48 33 cc	 xor	 rcx, rsp
  000d5	e8 00 00 00 00	 call	 __security_check_cookie
  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	5f		 pop	 rdi
  000df	5e		 pop	 rsi
  000e0	c3		 ret	 0
?V3Cross@@YA?ATv3@@T1@0@Z ENDP				; V3Cross
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Length$ = 32
K$ = 36
$T1 = 40
Result$ = 48
__$ArrayPad$ = 56
A$ = 80
?V2Normalize@@YA?ATv2@@T1@@Z PROC			; V2Normalize

; 142  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 143  :     f32 Length = V2Length(A);

  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR A$[rsp]
  0001d	e8 00 00 00 00	 call	 ?V2Length@@YAMTv2@@@Z	; V2Length
  00022	f3 0f 11 44 24
	20		 movss	 DWORD PTR Length$[rsp], xmm0

; 144  :     
; 145  :     f32 K = 0.0f;

  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	f3 0f 11 44 24
	24		 movss	 DWORD PTR K$[rsp], xmm0

; 146  :     if(Length)

  00031	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Length$[rsp]
  00037	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0003e	7a 02		 jp	 SHORT $LN4@V2Normaliz
  00040	74 14		 je	 SHORT $LN2@V2Normaliz
$LN4@V2Normaliz:

; 147  :     {
; 148  :         K = 1.0f / Length;

  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004a	f3 0f 5e 44 24
	20		 divss	 xmm0, DWORD PTR Length$[rsp]
  00050	f3 0f 11 44 24
	24		 movss	 DWORD PTR K$[rsp], xmm0
$LN2@V2Normaliz:

; 149  :     }
; 150  :     
; 151  :     v2 Result = A*K;

  00056	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR K$[rsp]
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR A$[rsp]
  00061	e8 00 00 00 00	 call	 ??D@YA?ATv2@@T0@M@Z	; operator*
  00066	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00070	48 89 44 24 30	 mov	 QWORD PTR Result$[rsp], rax

; 152  :     return(Result);

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR Result$[rsp]

; 153  : }

  0007a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007f	48 33 cc	 xor	 rcx, rsp
  00082	e8 00 00 00 00	 call	 __security_check_cookie
  00087	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008b	c3		 ret	 0
?V2Normalize@@YA?ATv2@@T1@@Z ENDP			; V2Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 32
A$ = 64
?V2Length@@YAMTv2@@@Z PROC				; V2Length

; 130  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 131  :     f32 Result = V2MultiplyDot(A, A);

  00009	48 8b 54 24 40	 mov	 rdx, QWORD PTR A$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR A$[rsp]
  00013	e8 00 00 00 00	 call	 ?V2MultiplyDot@@YAMTv2@@0@Z ; V2MultiplyDot
  00018	f3 0f 11 44 24
	20		 movss	 DWORD PTR Result$[rsp], xmm0

; 132  :     if(Result)

  0001e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Result$[rsp]
  00024	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0002b	7a 02		 jp	 SHORT $LN4@V2Length
  0002d	74 11		 je	 SHORT $LN2@V2Length
$LN4@V2Length:

; 133  :     {
; 134  :         Result = Sqrt(Result);

  0002f	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Result$[rsp]
  00035	e8 00 00 00 00	 call	 ?Sqrt@@YAMM@Z		; Sqrt
  0003a	f3 0f 11 44 24
	20		 movss	 DWORD PTR Result$[rsp], xmm0
$LN2@V2Length:

; 135  :     }
; 136  :     
; 137  :     return(Result);

  00040	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Result$[rsp]

; 138  : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
?V2Length@@YAMTv2@@@Z ENDP				; V2Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
A$ = 32
B$ = 40
?V2MultiplyDot@@YAMTv2@@0@Z PROC			; V2MultiplyDot

; 122  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 123  :     f32 Result = A.x*B.x + A.y*B.y;

  0000e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR A$[rsp]
  00014	f3 0f 59 44 24
	28		 mulss	 xmm0, DWORD PTR B$[rsp]
  0001a	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR A$[rsp+4]
  00020	f3 0f 59 4c 24
	2c		 mulss	 xmm1, DWORD PTR B$[rsp+4]
  00026	f3 0f 58 c1	 addss	 xmm0, xmm1
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 124  :     
; 125  :     return(Result);

  0002f	f3 0f 10 04 24	 movss	 xmm0, DWORD PTR Result$[rsp]

; 126  : }

  00034	48 83 c4 18	 add	 rsp, 24
  00038	c3		 ret	 0
?V2MultiplyDot@@YAMTv2@@0@Z ENDP			; V2MultiplyDot
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
A$ = 8
B$ = 16
??_0@YAAEATv2@@AEAT0@M@Z PROC				; operator/=

; 114  : {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 115  :     A.x /= B;

  0000b	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  00010	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00014	f3 0f 5e 44 24
	10		 divss	 xmm0, DWORD PTR B$[rsp]
  0001a	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  0001f	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 116  :     A.y /= B;

  00023	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  00028	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0002d	f3 0f 5e 44 24
	10		 divss	 xmm0, DWORD PTR B$[rsp]
  00033	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  00038	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 117  :     return(A);

  0003d	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]

; 118  : }

  00042	c3		 ret	 0
??_0@YAAEATv2@@AEAT0@M@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
A$ = 32
B$ = 40
??K@YA?ATv2@@T0@M@Z PROC				; operator/

; 92   : {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	48 83 ec 18	 sub	 rsp, 24
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 93   :     v2 Result;
; 94   :     
; 95   :     Result.x = A.x/B;

  0001e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR A$[rsp]
  00024	f3 0f 5e 44 24
	28		 divss	 xmm0, DWORD PTR B$[rsp]
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 96   :     Result.y = A.y/B;

  0002f	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR A$[rsp+4]
  00035	f3 0f 5e 44 24
	28		 divss	 xmm0, DWORD PTR B$[rsp]
  0003b	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 97   :     
; 98   :     return(Result);

  00041	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 99   : }

  00045	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004a	48 33 cc	 xor	 rcx, rsp
  0004d	e8 00 00 00 00	 call	 __security_check_cookie
  00052	48 83 c4 18	 add	 rsp, 24
  00056	c3		 ret	 0
??K@YA?ATv2@@T0@M@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
$T1 = 32
__$ArrayPad$ = 40
A$ = 64
B$ = 72
??X@YAAEATv2@@AEAT0@M@Z PROC				; operator*=

; 85   : {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 86   :     A = A*B;

  0001e	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR B$[rsp]
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR A$[rsp]
  00029	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002c	e8 00 00 00 00	 call	 ??D@YA?ATv2@@T0@M@Z	; operator*
  00031	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR A$[rsp]
  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 87   :     return(A);

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR A$[rsp]

; 88   : }

  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004d	48 33 cc	 xor	 rcx, rsp
  00050	e8 00 00 00 00	 call	 __security_check_cookie
  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
??X@YAAEATv2@@AEAT0@M@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
A$ = 32
B$ = 40
??D@YA?ATv2@@T0@M@Z PROC				; operator*

; 63   : {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	48 83 ec 18	 sub	 rsp, 24
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 64   :     v2 Result;
; 65   :     
; 66   :     Result.x = A.x*B;

  0001e	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR A$[rsp]
  00024	f3 0f 59 44 24
	28		 mulss	 xmm0, DWORD PTR B$[rsp]
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 67   :     Result.y = A.y*B;

  0002f	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR A$[rsp+4]
  00035	f3 0f 59 44 24
	28		 mulss	 xmm0, DWORD PTR B$[rsp]
  0003b	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 68   :     
; 69   :     return(Result);

  00041	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 70   : }

  00045	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004a	48 33 cc	 xor	 rcx, rsp
  0004d	e8 00 00 00 00	 call	 __security_check_cookie
  00052	48 83 c4 18	 add	 rsp, 24
  00056	c3		 ret	 0
??D@YA?ATv2@@T0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
A$ = 32
B$ = 40
??D@YA?ATv2@@T0@0@Z PROC				; operator*

; 45   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 46   :     v2 Result;
; 47   :     
; 48   :     Result.x = A.x*B.x;

  0001d	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR A$[rsp]
  00023	f3 0f 59 44 24
	28		 mulss	 xmm0, DWORD PTR B$[rsp]
  00029	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 49   :     Result.y = A.y*B.y;

  0002e	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR A$[rsp+4]
  00034	f3 0f 59 44 24
	2c		 mulss	 xmm0, DWORD PTR B$[rsp+4]
  0003a	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 50   :     
; 51   :     return(Result);

  00040	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 52   : }

  00044	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00049	48 33 cc	 xor	 rcx, rsp
  0004c	e8 00 00 00 00	 call	 __security_check_cookie
  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
??D@YA?ATv2@@T0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
A$ = 8
B$ = 16
??Y@YAAEATv2@@AEAT0@T0@@Z PROC				; operator+=

; 37   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 38   :     A.x += B.x;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00013	f3 0f 58 44 24
	10		 addss	 xmm0, DWORD PTR B$[rsp]
  00019	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  0001e	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 39   :     A.y += B.y;

  00022	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  00027	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0002c	f3 0f 58 44 24
	14		 addss	 xmm0, DWORD PTR B$[rsp+4]
  00032	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]
  00037	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0

; 40   :     return(A);

  0003c	48 8b 44 24 08	 mov	 rax, QWORD PTR A$[rsp]

; 41   : }

  00041	c3		 ret	 0
??Y@YAAEATv2@@AEAT0@T0@@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
A$ = 32
B$ = 40
??H@YA?ATv2@@T0@0@Z PROC				; operator+

; 26   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 27   :     v2 Result;
; 28   :     
; 29   :     Result.x = A.x + B.x;

  0001d	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR A$[rsp]
  00023	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR B$[rsp]
  00029	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 30   :     Result.y = A.y + B.y;

  0002e	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR A$[rsp+4]
  00034	f3 0f 58 44 24
	2c		 addss	 xmm0, DWORD PTR B$[rsp+4]
  0003a	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 31   :     
; 32   :     return(Result);

  00040	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 33   : }

  00044	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00049	48 33 cc	 xor	 rcx, rsp
  0004c	e8 00 00 00 00	 call	 __security_check_cookie
  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
??H@YA?ATv2@@T0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
X$ = 32
Y$ = 40
?V2@@YA?ATv2@@HH@Z PROC					; V2

; 18   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 19   :     v2 Result = {(f32)X, (f32)Y};

  0001b	f3 0f 2a 44 24
	20		 cvtsi2ss xmm0, DWORD PTR X$[rsp]
  00021	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00026	f3 0f 2a 44 24
	28		 cvtsi2ss xmm0, DWORD PTR Y$[rsp]
  0002c	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 20   :     
; 21   :     return(Result);

  00032	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 22   : }

  00036	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003b	48 33 cc	 xor	 rcx, rsp
  0003e	e8 00 00 00 00	 call	 __security_check_cookie
  00043	48 83 c4 18	 add	 rsp, 24
  00047	c3		 ret	 0
?V2@@YA?ATv2@@HH@Z ENDP					; V2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_math.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
X$ = 32
Y$ = 40
?V2@@YA?ATv2@@MM@Z PROC					; V2

; 10   : {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000c	48 83 ec 18	 sub	 rsp, 24
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 11   :     v2 Result = {X, Y};

  0001f	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR X$[rsp]
  00025	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  0002a	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR Y$[rsp]
  00030	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 12   :     
; 13   :     return(Result);

  00036	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 14   : }

  0003a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003f	48 33 cc	 xor	 rcx, rsp
  00042	e8 00 00 00 00	 call	 __security_check_cookie
  00047	48 83 c4 18	 add	 rsp, 24
  0004b	c3		 ret	 0
?V2@@YA?ATv2@@MM@Z ENDP					; V2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_intrinsics.h
_TEXT	SEGMENT
Value$ = 8
?Abs@@YAMM@Z PROC					; Abs

; 46   : {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0

; 47   :     return((f32)(fabs(Value)));

  00006	f3 0f 5a 44 24
	08		 cvtss2sd xmm0, DWORD PTR Value$[rsp]
  0000c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0

; 48   : }

  00017	c3		 ret	 0
?Abs@@YAMM@Z ENDP					; Abs
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_intrinsics.h
_TEXT	SEGMENT
Value$ = 48
?Sqrt@@YAMM@Z PROC					; Sqrt

; 40   : {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 41   :     return(sqrtf(Value));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Value$[rsp]
  00010	e8 00 00 00 00	 call	 sqrtf

; 42   : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
?Sqrt@@YAMM@Z ENDP					; Sqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_intrinsics.h
_TEXT	SEGMENT
Value$ = 48
?Tan@@YAMM@Z PROC					; Tan

; 34   : {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 35   :     return(tanf(Value));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Value$[rsp]
  00010	e8 00 00 00 00	 call	 tanf

; 36   : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
?Tan@@YAMM@Z ENDP					; Tan
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_intrinsics.h
_TEXT	SEGMENT
Value$ = 48
?Cos@@YAMM@Z PROC					; Cos

; 28   : {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 29   :     return(cosf(Value));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Value$[rsp]
  00010	e8 00 00 00 00	 call	 cosf

; 30   : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
?Cos@@YAMM@Z ENDP					; Cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_intrinsics.h
_TEXT	SEGMENT
Value$ = 48
?Sin@@YAMM@Z PROC					; Sin

; 22   : {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   :     return(sinf(Value));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Value$[rsp]
  00010	e8 00 00 00 00	 call	 sinf

; 24   : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
?Sin@@YAMM@Z ENDP					; Sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_platform.h
_TEXT	SEGMENT
WindowFlags$ = 8
WindowDimension$ = 16
Memory$ = 24
GameInput$ = 32
DeltaTime$ = 40
GameUpdateAndRenderStub PROC

; 343  :     {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 344  :         return(false);

  00013	33 c0		 xor	 eax, eax

; 345  :     }

  00015	c3		 ret	 0
GameUpdateAndRenderStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_platform.h
_TEXT	SEGMENT
Result$ = 0
Arena$ = 32
Size$ = 40
PushSize PROC

; 207  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 208  :         void *Result = 0;

  0000e	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR Result$[rsp], 0

; 209  :         if(Arena->Size >= Arena->Used + Size)

  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR Arena$[rsp]
  0001b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0001f	48 03 44 24 28	 add	 rax, QWORD PTR Size$[rsp]
  00024	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Arena$[rsp]
  00029	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  0002d	72 2c		 jb	 SHORT $LN2@PushSize

; 210  :         {
; 211  :             Result = Arena->Memory + Arena->Used;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR Arena$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Arena$[rsp]
  0003c	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00040	48 89 04 24	 mov	 QWORD PTR Result$[rsp], rax

; 212  :             Arena->Used += Size;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR Arena$[rsp]
  00049	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0004d	48 03 44 24 28	 add	 rax, QWORD PTR Size$[rsp]
  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR Arena$[rsp]
  00057	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN2@PushSize:

; 213  :         }
; 214  :         
; 215  :         return(Result);

  0005b	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 216  :     }

  0005f	48 83 c4 18	 add	 rsp, 24
  00063	c3		 ret	 0
PushSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\new-horizons\code\horizons_platform.h
_TEXT	SEGMENT
Arena$ = 8
BackingBuffer$ = 16
Size$ = 24
InitializeArena PROC

; 197  :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 198  :         Arena->Memory = BackingBuffer;

  0000f	48 8b 44 24 08	 mov	 rax, QWORD PTR Arena$[rsp]
  00014	48 8b 4c 24 10	 mov	 rcx, QWORD PTR BackingBuffer$[rsp]
  00019	48 89 08	 mov	 QWORD PTR [rax], rcx

; 199  :         Arena->Size = Size;

  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR Arena$[rsp]
  00021	48 8b 4c 24 18	 mov	 rcx, QWORD PTR Size$[rsp]
  00026	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 200  :         Arena->Used = 0;

  0002a	48 8b 44 24 08	 mov	 rax, QWORD PTR Arena$[rsp]
  0002f	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 201  :     }

  00037	c3		 ret	 0
InitializeArena ENDP
_TEXT	ENDS
END
